<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">我的笔记库</a></li><li class="chapter-item expanded affix "><li class="part-title"></li><li class="chapter-item expanded "><a href="nodejs/index.html"><strong aria-hidden="true">1.</strong> nodejs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="nodejs/fakeJS.html"><strong aria-hidden="true">1.1.</strong> fakeJS</a></li><li class="chapter-item expanded "><a href="nodejs/nodejs事件循环.html"><strong aria-hidden="true">1.2.</strong> nodejs事件循环</a></li><li class="chapter-item expanded "><a href="nodejs/入门.html"><strong aria-hidden="true">1.3.</strong> 入门</a></li><li class="chapter-item expanded "><a href="nodejs/包管理.html"><strong aria-hidden="true">1.4.</strong> 包管理</a></li><li class="chapter-item expanded "><a href="nodejs/定时器.html"><strong aria-hidden="true">1.5.</strong> 定时器</a></li><li class="chapter-item expanded "><a href="nodejs/异步编程.html"><strong aria-hidden="true">1.6.</strong> 异步编程</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.7.</strong> packageInfo参数解析</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="nodejs/packageInfo参数解析/1.scripts.html"><strong aria-hidden="true">1.7.1.</strong> scripts</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Element-UI</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Element-UI/Switch开关.html"><strong aria-hidden="true">2.1.</strong> Switch开关</a></li><li class="chapter-item expanded "><a href="Element-UI/Tree树形控件.html"><strong aria-hidden="true">2.2.</strong> Tree树形控件</a></li><li class="chapter-item expanded "><a href="Element-UI/backtop.html"><strong aria-hidden="true">2.3.</strong> backtop</a></li><li class="chapter-item expanded "><a href="Element-UI/card卡片.html"><strong aria-hidden="true">2.4.</strong> card卡片</a></li><li class="chapter-item expanded "><a href="Element-UI/form表单.html"><strong aria-hidden="true">2.5.</strong> form表单</a></li><li class="chapter-item expanded "><a href="Element-UI/image图片.html"><strong aria-hidden="true">2.6.</strong> image图片</a></li><li class="chapter-item expanded "><a href="Element-UI/navigation-Breadcrumb面包屑.html"><strong aria-hidden="true">2.7.</strong> navigation-Breadcrumb面包屑</a></li><li class="chapter-item expanded "><a href="Element-UI/navigation-dropdown.html"><strong aria-hidden="true">2.8.</strong> navigation-dropdown</a></li><li class="chapter-item expanded "><a href="Element-UI/navigation-navmenu.html"><strong aria-hidden="true">2.9.</strong> navigation-navmenu</a></li><li class="chapter-item expanded "><a href="Element-UI/navigation-steps.html"><strong aria-hidden="true">2.10.</strong> navigation-steps</a></li><li class="chapter-item expanded "><a href="Element-UI/navigation-标签页.html"><strong aria-hidden="true">2.11.</strong> navigation-标签页</a></li><li class="chapter-item expanded "><a href="Element-UI/navigation-页头.html"><strong aria-hidden="true">2.12.</strong> navigation-页头</a></li><li class="chapter-item expanded "><a href="Element-UI/notice-Notification.html"><strong aria-hidden="true">2.13.</strong> notice-Notification</a></li><li class="chapter-item expanded "><a href="Element-UI/notice-alert.html"><strong aria-hidden="true">2.14.</strong> notice-alert</a></li><li class="chapter-item expanded "><a href="Element-UI/notice-loading.html"><strong aria-hidden="true">2.15.</strong> notice-loading</a></li><li class="chapter-item expanded "><a href="Element-UI/notice-message-box.html"><strong aria-hidden="true">2.16.</strong> notice-message-box</a></li><li class="chapter-item expanded "><a href="Element-UI/notice-message提示.html"><strong aria-hidden="true">2.17.</strong> notice-message提示</a></li><li class="chapter-item expanded "><a href="Element-UI/popConfirm.html"><strong aria-hidden="true">2.18.</strong> popConfirm</a></li><li class="chapter-item expanded "><a href="Element-UI/popOver弹出框.html"><strong aria-hidden="true">2.19.</strong> popOver弹出框</a></li><li class="chapter-item expanded "><a href="Element-UI/slider滑块.html"><strong aria-hidden="true">2.20.</strong> slider滑块</a></li><li class="chapter-item expanded "><a href="Element-UI/timeline.html"><strong aria-hidden="true">2.21.</strong> timeline</a></li><li class="chapter-item expanded "><a href="Element-UI/tooltip.html"><strong aria-hidden="true">2.22.</strong> tooltip</a></li><li class="chapter-item expanded "><a href="Element-UI/transfer穿梭框.html"><strong aria-hidden="true">2.23.</strong> transfer穿梭框</a></li><li class="chapter-item expanded "><a href="Element-UI/上传.html"><strong aria-hidden="true">2.24.</strong> 上传</a></li><li class="chapter-item expanded "><a href="Element-UI/入门.html"><strong aria-hidden="true">2.25.</strong> 入门</a></li><li class="chapter-item expanded "><a href="Element-UI/分割线.html"><strong aria-hidden="true">2.26.</strong> 分割线</a></li><li class="chapter-item expanded "><a href="Element-UI/分页.html"><strong aria-hidden="true">2.27.</strong> 分页</a></li><li class="chapter-item expanded "><a href="Element-UI/基础组件.html"><strong aria-hidden="true">2.28.</strong> 基础组件</a></li><li class="chapter-item expanded "><a href="Element-UI/头像.html"><strong aria-hidden="true">2.29.</strong> 头像</a></li><li class="chapter-item expanded "><a href="Element-UI/对话框.html"><strong aria-hidden="true">2.30.</strong> 对话框</a></li><li class="chapter-item expanded "><a href="Element-UI/常见input输入.html"><strong aria-hidden="true">2.31.</strong> 常见input输入</a></li><li class="chapter-item expanded "><a href="Element-UI/折叠面板.html"><strong aria-hidden="true">2.32.</strong> 折叠面板</a></li><li class="chapter-item expanded "><a href="Element-UI/抽屉.html"><strong aria-hidden="true">2.33.</strong> 抽屉</a></li><li class="chapter-item expanded "><a href="Element-UI/无限滚动.html"><strong aria-hidden="true">2.34.</strong> 无限滚动</a></li><li class="chapter-item expanded "><a href="Element-UI/日历.html"><strong aria-hidden="true">2.35.</strong> 日历</a></li><li class="chapter-item expanded "><a href="Element-UI/时间日期选择.html"><strong aria-hidden="true">2.36.</strong> 时间日期选择</a></li><li class="chapter-item expanded "><a href="Element-UI/标签.html"><strong aria-hidden="true">2.37.</strong> 标签</a></li><li class="chapter-item expanded "><a href="Element-UI/标记与提示.html"><strong aria-hidden="true">2.38.</strong> 标记与提示</a></li><li class="chapter-item expanded "><a href="Element-UI/级联选择器.html"><strong aria-hidden="true">2.39.</strong> 级联选择器</a></li><li class="chapter-item expanded "><a href="Element-UI/表格.html"><strong aria-hidden="true">2.40.</strong> 表格</a></li><li class="chapter-item expanded "><a href="Element-UI/评分.html"><strong aria-hidden="true">2.41.</strong> 评分</a></li><li class="chapter-item expanded "><a href="Element-UI/走马灯.html"><strong aria-hidden="true">2.42.</strong> 走马灯</a></li><li class="chapter-item expanded "><a href="Element-UI/进度条.html"><strong aria-hidden="true">2.43.</strong> 进度条</a></li><li class="chapter-item expanded "><a href="Element-UI/颜色选择器.html"><strong aria-hidden="true">2.44.</strong> 颜色选择器</a></li></ol></li><li class="chapter-item expanded "><a href="Html5/index.html"><strong aria-hidden="true">3.</strong> Html5</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Html5/CSS3.html"><strong aria-hidden="true">3.1.</strong> CSS3</a></li><li class="chapter-item expanded "><a href="Html5/H5canvas图形绘制.html"><strong aria-hidden="true">3.2.</strong> H5canvas图形绘制</a></li><li class="chapter-item expanded "><a href="Html5/HTML5.html"><strong aria-hidden="true">3.3.</strong> HTML5</a></li><li class="chapter-item expanded "><a href="Html5/HTML5的结构.html"><strong aria-hidden="true">3.4.</strong> HTML5的结构</a></li><li class="chapter-item expanded "><a href="Html5/HTML5表单.html"><strong aria-hidden="true">3.5.</strong> HTML5表单</a></li><li class="chapter-item expanded "><a href="Html5/WebWorkers.html"><strong aria-hidden="true">3.6.</strong> WebWorkers</a></li><li class="chapter-item expanded "><a href="Html5/多媒体播放.html"><strong aria-hidden="true">3.7.</strong> 多媒体播放</a></li><li class="chapter-item expanded "><a href="Html5/本地存储.html"><strong aria-hidden="true">3.8.</strong> 本地存储</a></li><li class="chapter-item expanded "><a href="Html5/离线应用程序.html"><strong aria-hidden="true">3.9.</strong> 离线应用程序</a></li><li class="chapter-item expanded "><a href="Html5/获取地址位置信息.html"><strong aria-hidden="true">3.10.</strong> 获取地址位置信息</a></li><li class="chapter-item expanded "><a href="Html5/通信API.html"><strong aria-hidden="true">3.11.</strong> 通信API</a></li></ol></li><li class="chapter-item expanded "><a href="css/index.html"><strong aria-hidden="true">4.</strong> css</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="css/BFC.html"><strong aria-hidden="true">4.1.</strong> BFC</a></li><li class="chapter-item expanded "><a href="css/CSS选择器.html"><strong aria-hidden="true">4.2.</strong> CSS选择器</a></li><li class="chapter-item expanded "><a href="css/内联元素垂直居中的方式.html"><strong aria-hidden="true">4.3.</strong> 内联元素垂直居中的方式</a></li><li class="chapter-item expanded "><a href="css/基本视觉格式化.html"><strong aria-hidden="true">4.4.</strong> 基本视觉格式化</a></li><li class="chapter-item expanded "><a href="css/基本视觉格式化-1.html"><strong aria-hidden="true">4.5.</strong> 基本视觉格式化-1</a></li><li class="chapter-item expanded "><a href="css/弹性布局.html"><strong aria-hidden="true">4.6.</strong> 弹性布局</a></li><li class="chapter-item expanded "><a href="css/结构与层叠.html"><strong aria-hidden="true">4.7.</strong> 结构与层叠</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> CSS布局方式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="css/CSS布局方式/flex布局.html"><strong aria-hidden="true">4.8.1.</strong> flex布局</a></li><li class="chapter-item expanded "><a href="css/CSS布局方式/两栏布局.html"><strong aria-hidden="true">4.8.2.</strong> 两栏布局</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.9.</strong> CSS样式详解</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="css/CSS样式详解/Grid布局.html"><strong aria-hidden="true">4.9.1.</strong> Grid布局</a></li><li class="chapter-item expanded "><a href="css/CSS样式详解/flex布局.html"><strong aria-hidden="true">4.9.2.</strong> flex布局</a></li><li class="chapter-item expanded "><a href="css/CSS样式详解/定位.html"><strong aria-hidden="true">4.9.3.</strong> 定位</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="vue/index.html"><strong aria-hidden="true">5.</strong> vue</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vue/class与style的绑定.html"><strong aria-hidden="true">5.1.</strong> class与style的绑定</a></li><li class="chapter-item expanded "><a href="vue/事件处理.html"><strong aria-hidden="true">5.2.</strong> 事件处理</a></li><li class="chapter-item expanded "><a href="vue/列表渲染.html"><strong aria-hidden="true">5.3.</strong> 列表渲染</a></li><li class="chapter-item expanded "><a href="vue/条件渲染.html"><strong aria-hidden="true">5.4.</strong> 条件渲染</a></li><li class="chapter-item expanded "><a href="vue/模板语法.html"><strong aria-hidden="true">5.5.</strong> 模板语法</a></li><li class="chapter-item expanded "><a href="vue/组件.html"><strong aria-hidden="true">5.6.</strong> 组件</a></li><li class="chapter-item expanded "><a href="vue/表单输入绑定.html"><strong aria-hidden="true">5.7.</strong> 表单输入绑定</a></li><li class="chapter-item expanded "><a href="vue/计算属性和侦听器.html"><strong aria-hidden="true">5.8.</strong> 计算属性和侦听器</a></li></ol></li><li class="chapter-item expanded "><a href="quasar/index.html"><strong aria-hidden="true">6.</strong> quasar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quasar/quasarCli.html"><strong aria-hidden="true">6.1.</strong> quasarCli</a></li><li class="chapter-item expanded "><a href="quasar/quasar选项和辅助.html"><strong aria-hidden="true">6.2.</strong> quasar选项和辅助</a></li><li class="chapter-item expanded "><a href="quasar/vue组件.html"><strong aria-hidden="true">6.3.</strong> vue组件</a></li><li class="chapter-item expanded "><a href="quasar/布局.html"><strong aria-hidden="true">6.4.</strong> 布局</a></li><li class="chapter-item expanded "><a href="quasar/网格布局.html"><strong aria-hidden="true">6.5.</strong> 网格布局</a></li><li class="chapter-item expanded "><a href="quasar/风格和特性.html"><strong aria-hidden="true">6.6.</strong> 风格和特性</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.7.</strong> 组件</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="quasar/组件/q-dialog.html"><strong aria-hidden="true">6.7.1.</strong> q-dialog</a></li><li class="chapter-item expanded "><a href="quasar/组件/q-expansion-item.html"><strong aria-hidden="true">6.7.2.</strong> q-expansion-item</a></li><li class="chapter-item expanded "><a href="quasar/组件/q-page-sticky.html"><strong aria-hidden="true">6.7.3.</strong> q-page-sticky</a></li><li class="chapter-item expanded "><a href="quasar/组件/q-tabs.html"><strong aria-hidden="true">6.7.4.</strong> q-tabs</a></li><li class="chapter-item expanded "><a href="quasar/组件/q-toolbar.html"><strong aria-hidden="true">6.7.5.</strong> q-toolbar</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> HTTP</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="HTTP/Content-Disposition.html"><strong aria-hidden="true">7.1.</strong> Content-Disposition</a></li><li class="chapter-item expanded "><a href="HTTP/Cookie.html"><strong aria-hidden="true">7.2.</strong> Cookie</a></li><li class="chapter-item expanded "><a href="HTTP/HTTP缓存.html"><strong aria-hidden="true">7.3.</strong> HTTP缓存</a></li><li class="chapter-item expanded "><a href="HTTP/HTTP访问控制.html"><strong aria-hidden="true">7.4.</strong> HTTP访问控制</a></li><li class="chapter-item expanded "><a href="HTTP/Http响应码.html"><strong aria-hidden="true">7.5.</strong> Http响应码</a></li><li class="chapter-item expanded "><a href="HTTP/MIME.html"><strong aria-hidden="true">7.6.</strong> MIME</a></li><li class="chapter-item expanded "><a href="HTTP/http头.html"><strong aria-hidden="true">7.7.</strong> http头</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> ECMAScript</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ECMAScript/ECMAScript6简介.html"><strong aria-hidden="true">8.1.</strong> ECMAScript6简介</a></li><li class="chapter-item expanded "><a href="ECMAScript/Set-Map数据结构.html"><strong aria-hidden="true">8.2.</strong> Set-Map数据结构</a></li><li class="chapter-item expanded "><a href="ECMAScript/async函数.html"><strong aria-hidden="true">8.3.</strong> async函数</a></li><li class="chapter-item expanded "><a href="ECMAScript/generate函数.html"><strong aria-hidden="true">8.4.</strong> generate函数</a></li><li class="chapter-item expanded "><a href="ECMAScript/let与const命令.html"><strong aria-hidden="true">8.5.</strong> let与const命令</a></li><li class="chapter-item expanded "><a href="ECMAScript/proxy.html"><strong aria-hidden="true">8.6.</strong> proxy</a></li><li class="chapter-item expanded "><a href="ECMAScript/symbol.html"><strong aria-hidden="true">8.7.</strong> symbol</a></li><li class="chapter-item expanded "><a href="ECMAScript/函数.html"><strong aria-hidden="true">8.8.</strong> 函数</a></li><li class="chapter-item expanded "><a href="ECMAScript/字符串-正则-数值.html"><strong aria-hidden="true">8.9.</strong> 字符串-正则-数值</a></li><li class="chapter-item expanded "><a href="ECMAScript/对象.html"><strong aria-hidden="true">8.10.</strong> 对象</a></li><li class="chapter-item expanded "><a href="ECMAScript/数组.html"><strong aria-hidden="true">8.11.</strong> 数组</a></li></ol></li><li class="chapter-item expanded "><a href="reactor/index.html"><strong aria-hidden="true">9.</strong> reactor</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reactor/1.搭建TS-Reactor环境.html"><strong aria-hidden="true">9.1.</strong> 搭建TS-Reactor环境</a></li><li class="chapter-item expanded "><a href="reactor/2.jsx.html"><strong aria-hidden="true">9.2.</strong> jsx</a></li><li class="chapter-item expanded "><a href="reactor/3.元素渲染.html"><strong aria-hidden="true">9.3.</strong> 元素渲染</a></li><li class="chapter-item expanded "><a href="reactor/4.组件与模块&Props.html"><strong aria-hidden="true">9.4.</strong> 组件与模块&Props</a></li><li class="chapter-item expanded "><a href="reactor/5.State生命周期.html"><strong aria-hidden="true">9.5.</strong> State生命周期</a></li><li class="chapter-item expanded "><a href="reactor/6.事件处理.html"><strong aria-hidden="true">9.6.</strong> 事件处理</a></li><li class="chapter-item expanded "><a href="reactor/7.条件渲染.html"><strong aria-hidden="true">9.7.</strong> 条件渲染</a></li><li class="chapter-item expanded "><a href="reactor/8.列表.html"><strong aria-hidden="true">9.8.</strong> 列表</a></li><li class="chapter-item expanded "><a href="reactor/9.表单.html"><strong aria-hidden="true">9.9.</strong> 表单</a></li><li class="chapter-item expanded "><a href="reactor/10.组合与继承.html"><strong aria-hidden="true">9.10.</strong> 组合与继承</a></li><li class="chapter-item expanded "><a href="reactor/11.React最佳实践.html"><strong aria-hidden="true">9.11.</strong> React最佳实践</a></li><li class="chapter-item expanded "><a href="reactor/高级特性/index.html"><strong aria-hidden="true">9.12.</strong> 高级特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reactor/高级特性/Refs转发.html"><strong aria-hidden="true">9.12.1.</strong> Refs转发</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="我的笔记库"><a class="header" href="#我的笔记库">我的笔记库</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<ol>
<li>
<p>Node.js 是一个开源和跨平台的 JavaScript 运行时环境。 它几乎是任何类型项目的流行工具！</p>
</li>
<li>
<p>Node.js 在浏览器之外运行 V8 JavaScript 引擎（Google Chrome 的内核）。 这使得 Node.js 的性能非常好。</p>
</li>
<li>
<p>Node.js 应用程序在单个进程中运行，无需为每个请求创建新的线程</p>
</li>
<li>
<p>Node.js 在其标准库中提供了一组异步的 I/O 原语，以防止 JavaScript 代码阻塞</p>
</li>
<li>
<p>通常，Node.js 中的库是使用非阻塞范式编写的，使得阻塞行为成为异常而不是常态。</p>
</li>
</ol>
<p>当 Node.js 执行 I/O 操作时（比如从网络读取、访问数据库或文件系统），Node.js 将在响应返回时恢复操作（而不是阻塞线程和浪费 CPU 周期等待）。</p>
<p>这允许 Node.js 使用单个服务器处理数千个并发连接，而不会引入管理线程并发（这可能是错误的重要来源）的负担。</p>
<h2 id="nodejs-应用程序的示例"><a class="header" href="#nodejs-应用程序的示例">Node.js 应用程序的示例</a></h2>
<pre><code class="language-js">JScopyconst http = require('http')
const hostname = '127.0.0.1'const port = 3000
const server = http.createServer((req, res) =&gt; {  res.statusCode = 200  res.setHeader('Content-Type', 'text/plain')
 res.end('Hello World\n')}
                                )
server.listen(port, hostname, () =&gt; {  console.log(`Server running at http://${hostname}:${port}/`)})
</code></pre>
<p>要运行此代码片段，则将其另存为 <code>server.js</code> 文件并在终端中运行 <code>node server.js</code>。</p>
<ol>
<li>此代码首先引入 Node.js <a href="http://nodejs.cn/api/http.html"><code>http</code> 模块</a>。</li>
<li><code>http</code> 的 <code>createServer()</code> 方法创建新的 HTTP 服务器并返回。</li>
<li>服务器设置为监听指定的端口和主机名。 当服务器准备好时，则回调函数被调用，在此示例中会通知我们服务器正在运行。</li>
<li>每当接收到新请求时，都会调用 <a href="http://nodejs.cn/api/http.html#http_event_request"><code>request</code> 事件</a>，其提供两个对象：请求（<a href="http://nodejs.cn/api/http.html#http_class_http_incomingmessage"><code>http.IncomingMessage</code></a> 对象）和响应（<a href="http://nodejs.cn/api/http.html#http_class_http_serverresponse"><code>http.ServerResponse</code></a> 对象）。</li>
<li>每当接收到新请求时，都会调用 <a href="http://nodejs.cn/api/http.html#http_event_request"><code>request</code> 事件</a>，其提供两个对象：请求（<a href="http://nodejs.cn/api/http.html#http_class_http_incomingmessage"><code>http.IncomingMessage</code></a> 对象）和响应（<a href="http://nodejs.cn/api/http.html#http_class_http_serverresponse"><code>http.ServerResponse</code></a> 对象）。</li>
</ol>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>使用 NVM 动态切换 nodejs版本</p>
<p><a href="https://github.com/coreybutler/nvm-windows/releases">windows版本</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<pre><code class="language-shell">yarn add @faker-js/faker -D
</code></pre>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;esModuleInterop&quot;: true,
    &quot;moduleResolution&quot;: &quot;Node&quot;
  }
}
</code></pre>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p>An in-depth overview of the API methods is available in the documentation. The API covers the following modules:</p>
<table><thead><tr><th>Module</th><th>Example</th><th>Output</th></tr></thead><tbody>
<tr><td>Address</td><td><code>faker.address.city()</code></td><td>Lake Raoulfort</td></tr>
<tr><td>Animal</td><td><code>faker.animal.type()</code></td><td>Dog, cat, snake, bear, lion, etc.</td></tr>
<tr><td>Commerce</td><td><code>faker.commerce.product()</code></td><td>Polo t-shirt</td></tr>
<tr><td>Company</td><td><code>faker.company.companyName()</code></td><td>Zboncak and Sons</td></tr>
<tr><td>Database</td><td><code>faker.database.engine()</code></td><td>MyISAM</td></tr>
<tr><td>Datatype</td><td><code>faker.datatype.uuid()</code></td><td>1oijf8-3iuhiu-21jddj-1092jf</td></tr>
<tr><td>Date</td><td><code>faker.date.past()</code></td><td>Sat Oct 20 2018 04:19:38 GMT-0700 (Pacific Daylight Time)</td></tr>
<tr><td>Finance</td><td><code>faker.finance.amount()</code></td><td>¥23400 (After setting locale)</td></tr>
<tr><td>Git</td><td><code>faker.git.commitMessage()</code></td><td>feat: add products list page</td></tr>
<tr><td>Hacker</td><td><code>faker.hacker.phrase()</code></td><td>Try to reboot the SQL bus, maybe it will bypass the virtual application!</td></tr>
<tr><td>Helpers</td><td><code>faker.helpers.userCard()</code></td><td><code>{ avatar: '...', email: '{ first }{ last }{ number }@{domain}', first: '...' }</code>  All of the values are self-consistent (e.g. same first + last name in the email, too)</td></tr>
<tr><td>Image</td><td><code>faker.image.avatar()</code></td><td><code>https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/233.jpg</code> <a href="https://camo.githubusercontent.com/d8a369201a8a68672b1a12f173328c8219d58644ca2af595c64f60d39f93b0cb/68747470733a2f2f636c6f7564666c6172652d697066732e636f6d2f697066732f516d64335735447568674869724c484756697869365637364c68436b5a557a36706e467435414a426979764879652f6176617461722f3233332e6a7067"><img src="https://camo.githubusercontent.com/d8a369201a8a68672b1a12f173328c8219d58644ca2af595c64f60d39f93b0cb/68747470733a2f2f636c6f7564666c6172652d697066732e636f6d2f697066732f516d64335735447568674869724c484756697869365637364c68436b5a557a36706e467435414a426979764879652f6176617461722f3233332e6a7067" alt="img" /></a></td></tr>
<tr><td>Internet</td><td><code>faker.internet.color()</code></td><td>#630c7b</td></tr>
<tr><td>Lorem</td><td><code>faker.lorem.paragraph()</code></td><td>Word, words, sentences, slug (lorem-ipsum), paragraph(s), text, lines</td></tr>
<tr><td>Music</td><td><code>faker.music.genre()</code></td><td>R&amp;B</td></tr>
<tr><td>Name</td><td><code>faker.name.firstName()</code></td><td>Cameron</td></tr>
<tr><td>Phone</td><td><code>faker.phone.phoneNumber()</code></td><td>+1 291-299-0192</td></tr>
<tr><td>Random</td><td><code>faker.random.locale()</code></td><td>fr_CA</td></tr>
<tr><td>System</td><td><code>faker.system.directoryPath()</code></td><td>C:\Documents\Newsletters\</td></tr>
<tr><td>Vehicle</td><td><code>faker.vehicle.vehicle()</code></td><td>2011 Dodge Caravan</td></tr>
</tbody></table>
<h2 id="api-methods"><a class="header" href="#api-methods">API Methods</a></h2>
<p>Faker provides many useful utility functions.</p>
<h3 id="fakeraddress"><a class="header" href="#fakeraddress">faker.address</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>zipCode</td><td>Get fake zip code</td></tr>
<tr><td>zipCodeByState</td><td>Get fake zip code by state</td></tr>
<tr><td>city</td><td>Get fake city</td></tr>
<tr><td>cityPrefix</td><td>Get fake city prefix</td></tr>
<tr><td>citySuffix</td><td>Get fake city suffix</td></tr>
<tr><td>cityName</td><td>Get fake city name</td></tr>
<tr><td>streetName</td><td>Get fake street name</td></tr>
<tr><td>streetAddress</td><td>Get fake street address</td></tr>
<tr><td>streetSuffix</td><td>Get fake street suffix</td></tr>
<tr><td>streetPrefix</td><td>Get fake street prefix</td></tr>
<tr><td>secondaryAddress</td><td>Get fake secondary address</td></tr>
<tr><td>county</td><td>Get fake county</td></tr>
<tr><td>country</td><td>Get fake country</td></tr>
<tr><td>countryCode</td><td>Get fake country code</td></tr>
<tr><td>state</td><td>Get fake state</td></tr>
<tr><td>stateAbbr</td><td>Get fake state abbreviation</td></tr>
<tr><td>latitude</td><td>Get fake latitude</td></tr>
<tr><td>longitude</td><td>Get fake longitude</td></tr>
<tr><td>direction</td><td>Get fake direction</td></tr>
<tr><td>cardinalDirection</td><td>Get fake cardinal direction</td></tr>
<tr><td>ordinalDirection</td><td>Get fake ordinal direction</td></tr>
<tr><td>nearbyGPSCoordinate</td><td>Get fake near by gps coordinate</td></tr>
<tr><td>timeZone</td><td>Get fake timezone</td></tr>
</tbody></table>
<h3 id="fakeranimal"><a class="header" href="#fakeranimal">faker.animal</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>dog</td><td>Get fake dog type</td></tr>
<tr><td>cat</td><td>Get fake cat type</td></tr>
<tr><td>snake</td><td>Get fake snake type</td></tr>
<tr><td>bear</td><td>Get fake bear type</td></tr>
<tr><td>lion</td><td>Get fake lion type</td></tr>
<tr><td>cetacean</td><td>Get fake cetacean type</td></tr>
<tr><td>horse</td><td>Get fake horse type</td></tr>
<tr><td>bird</td><td>Get fake bird type</td></tr>
<tr><td>cow</td><td>Get fake cow type</td></tr>
<tr><td>fish</td><td>Get fake fish type</td></tr>
<tr><td>crocodilia</td><td>Get fake crocodilia type</td></tr>
<tr><td>insect</td><td>Get fake insect type</td></tr>
<tr><td>rabbit</td><td>Get fake rabbit type</td></tr>
</tbody></table>
<h3 id="fakercommerce"><a class="header" href="#fakercommerce">faker.commerce</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>color</td><td>Get fake color name</td></tr>
<tr><td>department</td><td>Get fake department name</td></tr>
<tr><td>productName</td><td>Get fake product name</td></tr>
<tr><td>price</td><td>Get fake price count</td></tr>
<tr><td>productAdjective</td><td>Get fake product adjective</td></tr>
<tr><td>productMaterial</td><td>Get fake product material data</td></tr>
<tr><td>product</td><td>Get fake product name</td></tr>
<tr><td>productDescription</td><td>Get fake product description</td></tr>
</tbody></table>
<h3 id="fakercompany"><a class="header" href="#fakercompany">faker.company</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>suffixes</td><td>Get fake company suffixes</td></tr>
<tr><td>companyName</td><td>Get fake company name</td></tr>
<tr><td>companySuffix</td><td>Get fake company suffix</td></tr>
<tr><td>bs</td><td>Get fake company business services</td></tr>
<tr><td>catchPhraseAdjective</td><td>Get fake product adjective</td></tr>
<tr><td>catchPhraseDescriptor</td><td>Get fake product material data</td></tr>
<tr><td>catchPhraseNoun</td><td>Get fake product name</td></tr>
<tr><td>bsAdjective</td><td>Get fake business services adjective</td></tr>
<tr><td>bsBuzz</td><td>Get fake business services buzz</td></tr>
<tr><td>bsNoun</td><td>Get fake business services noun</td></tr>
</tbody></table>
<h3 id="fakerdatabase"><a class="header" href="#fakerdatabase">faker.database</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>column</td><td>Get fake database column name</td></tr>
<tr><td>type</td><td>Get fake database column datatype</td></tr>
<tr><td>collation</td><td>Get fake database collation</td></tr>
<tr><td>engine</td><td>Get fake database engine</td></tr>
</tbody></table>
<h3 id="fakerdatatype"><a class="header" href="#fakerdatatype">faker.datatype</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>number</td><td>Generates a random number</td></tr>
<tr><td>float</td><td>Generates a random floating number</td></tr>
<tr><td>datetime</td><td>Generates a random datetime</td></tr>
<tr><td>string</td><td>Generates a random string</td></tr>
<tr><td>uuid</td><td>Generates a valid uuid</td></tr>
<tr><td>boolean</td><td>Generates a boolean</td></tr>
<tr><td>hexaDecimal</td><td>Generates a hexadecimal</td></tr>
<tr><td>json</td><td>Generates a valid json object</td></tr>
<tr><td>array</td><td>Generates an array</td></tr>
</tbody></table>
<h3 id="fakerdate"><a class="header" href="#fakerdate">faker.date</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>past</td><td>Get a date <code>N</code> years into the past</td></tr>
<tr><td>future</td><td>Get a date <code>N</code> years into the future</td></tr>
<tr><td>between</td><td>Get a random date between the dates given</td></tr>
<tr><td>betweens</td><td>Get an array of 3 dates ( by default ) of sorted randoms dates between the dates given</td></tr>
<tr><td>recent</td><td>Get a date <code>N</code> days from the recent past</td></tr>
<tr><td>soon</td><td>Get a date <code>N</code> days into the future</td></tr>
<tr><td>month</td><td>Generates a random value of date month</td></tr>
<tr><td>weekday</td><td>Generates a random value of date weekday</td></tr>
</tbody></table>
<h3 id="fakerfake"><a class="header" href="#fakerfake">faker.fake</a></h3>
<h3 id="fakerfinance"><a class="header" href="#fakerfinance">faker.finance</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>account</td><td>Generates a random finance account</td></tr>
<tr><td>accountName</td><td>Generates a random finance account name</td></tr>
<tr><td>routingNumber</td><td>Generates a random finance routing number</td></tr>
<tr><td>mask</td><td>Generates a random finance mask template</td></tr>
<tr><td>amount</td><td>Generates a random amount of transaction</td></tr>
<tr><td>transactionType</td><td>Generates a random transaction type</td></tr>
<tr><td>currencyCode</td><td>Generates a random currency code</td></tr>
<tr><td>currencyName</td><td>Generates a random currency name</td></tr>
<tr><td>currencySymbol</td><td>Generates a random currency symbol</td></tr>
<tr><td>bitcoinAddress</td><td>Generates a random bitcoin address</td></tr>
<tr><td>litecoinAddress</td><td>Generates a random litecoin address</td></tr>
<tr><td>creditCardNumber</td><td>Generates a random credit card number</td></tr>
<tr><td>creditCardCVV</td><td>Generates a random credit card CVV</td></tr>
<tr><td>ethereumAddress</td><td>Generates a random ethereum address (ETH address)</td></tr>
<tr><td>iban</td><td>Generates a random IBAN</td></tr>
<tr><td>bic</td><td>Generates a random BIC</td></tr>
<tr><td>transactionDescription</td><td>Generates a random transaction description</td></tr>
</tbody></table>
<h3 id="fakergit"><a class="header" href="#fakergit">faker.git</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>branch</td><td>Generates a random branch with hacker noun and verb</td></tr>
<tr><td>commitEntry</td><td>Generates a random commit entry with git commit message and sha</td></tr>
<tr><td>commitMessage</td><td>Generates a random commit message with hacker noun, adj and verb</td></tr>
<tr><td>commitSha</td><td>Generates a random commit SHA</td></tr>
<tr><td>shortSha</td><td>Generates a random short SHA</td></tr>
</tbody></table>
<h3 id="fakerhacker"><a class="header" href="#fakerhacker">faker.hacker</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>abbreviation</td><td>Generates a random hacker abbreviation</td></tr>
<tr><td>adjective</td><td>Generates a random hacker adjective</td></tr>
<tr><td>noun</td><td>Generates a random hacker noun</td></tr>
<tr><td>verb</td><td>Generates a random hacker verb</td></tr>
<tr><td>ingverb</td><td>Generates a random hacker ingverb</td></tr>
<tr><td>phrase</td><td>Generates a random hacker phrase</td></tr>
</tbody></table>
<h3 id="fakerhelpers"><a class="header" href="#fakerhelpers">faker.helpers</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>randomize</td><td>Get a random element from an array</td></tr>
<tr><td>slugify</td><td>Removes unwanted characters from URI string</td></tr>
<tr><td>replaceSymbolWithNumber</td><td>Parses string for a symbol and replace it with a random number from 1-10</td></tr>
<tr><td>replaceSymbols</td><td>Parses string for symbols (numbers or letters) and replaces them appropriately (# will be replaced with number, ? with letter and * will be replaced with number or letter)</td></tr>
<tr><td>replaceCreditCardSymbols</td><td>Replace symbols in a credit card schema including Luhn checksum</td></tr>
<tr><td>repeatString</td><td>String repeat helper, alternative to String.prototype.repeat</td></tr>
<tr><td>shuffle</td><td>Takes an array and randomizes it in place then returns it using the modern version of the Fisher-Yates algorithm</td></tr>
<tr><td>mustache</td><td>Generates a string with mustache {{ }}</td></tr>
<tr><td>createCard</td><td>Generates a human card</td></tr>
<tr><td>contextualCard</td><td>Generates a human contextual card</td></tr>
<tr><td>userCard</td><td>Generates a website user card</td></tr>
<tr><td>createTransaction</td><td>Generates a transaction</td></tr>
</tbody></table>
<h3 id="fakerimage"><a class="header" href="#fakerimage">faker.image</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>image</td><td>Generates a random image</td></tr>
<tr><td>avatar</td><td>Generates a random avatar</td></tr>
<tr><td>imageUrl</td><td>Generates a random image url</td></tr>
<tr><td>abstract</td><td>Generates a random abstract image</td></tr>
<tr><td>animals</td><td>Generates a random animals image</td></tr>
<tr><td>business</td><td>Generates a random business image</td></tr>
<tr><td>cats</td><td>Generates a random cats image</td></tr>
<tr><td>city</td><td>Generates a random city image</td></tr>
<tr><td>food</td><td>Generates a random food image</td></tr>
<tr><td>nightlife</td><td>Generates a random nightlife image</td></tr>
<tr><td>fashion</td><td>Generates a random fashion image</td></tr>
<tr><td>people</td><td>Generates a random people image</td></tr>
<tr><td>nature</td><td>Generates a random nature image</td></tr>
<tr><td>sports</td><td>Generates a random sports image</td></tr>
<tr><td>technics</td><td>Generates a random technics image</td></tr>
<tr><td>transport</td><td>Generates a random transport image</td></tr>
<tr><td>dataUri</td><td>Generates a random data uri</td></tr>
<tr><td>lorempixel</td><td>Generates a random image url from lorempixel</td></tr>
<tr><td>unsplash</td><td>Generates a random image url from unsplash</td></tr>
<tr><td>lorempicsum</td><td>Generates a random image url from lorem picsum</td></tr>
</tbody></table>
<h3 id="fakerinternet"><a class="header" href="#fakerinternet">faker.internet</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>avatar</td><td>Generates a random avatar</td></tr>
<tr><td>email</td><td>Generates a random email</td></tr>
<tr><td>exampleEmail</td><td>Generates a random example email</td></tr>
<tr><td>userName</td><td>Generates a random user name</td></tr>
<tr><td>protocol</td><td>Generates a random internet protocol (http or https)</td></tr>
<tr><td>httpMethod</td><td>Generates a random http method</td></tr>
<tr><td>url</td><td>Generates a random url</td></tr>
<tr><td>domainName</td><td>Generates a random domain name</td></tr>
<tr><td>domainSuffix</td><td>Generates a random domain suffix</td></tr>
<tr><td>domainWord</td><td>Generates a random domain word</td></tr>
<tr><td>ip</td><td>Generates a random ip</td></tr>
<tr><td>ipv6</td><td>Generates a random ipv6</td></tr>
<tr><td>port</td><td>Generates a random port number</td></tr>
<tr><td>userAgent</td><td>Generates a random user agent</td></tr>
<tr><td>color</td><td>Generates a random hexadecimal color</td></tr>
<tr><td>mac</td><td>Generates a random mac address</td></tr>
<tr><td>password</td><td>Generates a random password</td></tr>
</tbody></table>
<h3 id="fakerlorem"><a class="header" href="#fakerlorem">faker.lorem</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>word</td><td>Generates a random lorem word</td></tr>
<tr><td>words</td><td>Generates a random lorem words</td></tr>
<tr><td>sentence</td><td>Generates a random lorem sentence</td></tr>
<tr><td>slug</td><td>Generates a random lorem slug</td></tr>
<tr><td>sentences</td><td>Generates a random lorem sentences</td></tr>
<tr><td>paragraph</td><td>Generates a random lorem paragraph</td></tr>
<tr><td>paragraphs</td><td>Generates a random lorem paragraphs</td></tr>
<tr><td>text</td><td>Generates a random lorem text</td></tr>
<tr><td>lines</td><td>Generates a random lorem lines</td></tr>
</tbody></table>
<h3 id="fakermersenne"><a class="header" href="#fakermersenne">faker.mersenne</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>rand</td><td>Generates a random mersenne rand</td></tr>
<tr><td>seed</td><td>Generates a random mersenne seed</td></tr>
<tr><td>seed_array</td><td>Generates a random datetime seed init by array</td></tr>
</tbody></table>
<h3 id="fakermusic"><a class="header" href="#fakermusic">faker.music</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>genre</td><td>Generates a random music genre</td></tr>
</tbody></table>
<h3 id="fakername"><a class="header" href="#fakername">faker.name</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>firstName</td><td>Generates a random human first name</td></tr>
<tr><td>lastName</td><td>Generates a random human last name</td></tr>
<tr><td>middleName</td><td>Generates a random human middle name</td></tr>
<tr><td>findName</td><td>Generates a random human first name and last name</td></tr>
<tr><td>jobTitle</td><td>Generates a random human job title, combination of jobDescriptor, jobArea and jobType</td></tr>
<tr><td>gender</td><td>Generates a random gender</td></tr>
<tr><td>prefix</td><td>Generates a random locale with gender specific name prefix</td></tr>
<tr><td>suffix</td><td>Generates a random locale with gender specific name suffix</td></tr>
<tr><td>title</td><td>Generates a random human title</td></tr>
<tr><td>jobDescriptor</td><td>Generates a random human job descriptor</td></tr>
<tr><td>jobArea</td><td>Generates a random human job area</td></tr>
<tr><td>jobType</td><td>Generates a random human job type</td></tr>
</tbody></table>
<h3 id="fakerphone"><a class="header" href="#fakerphone">faker.phone</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>phoneNumber</td><td>Generates a random phone number</td></tr>
<tr><td>phoneNumberFormat</td><td>Generates a random phone number with requested format (Array index)</td></tr>
<tr><td>phoneFormats</td><td>Generates a random phone number format</td></tr>
</tbody></table>
<h3 id="fakerrandom"><a class="header" href="#fakerrandom">faker.random</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>arrayElement</td><td>Takes an array and returns a random element of the array</td></tr>
<tr><td>arrayElements</td><td>Takes an array and returns a subset with random elements of the array</td></tr>
<tr><td>objectElement</td><td>Takes an object and returns a random key or value</td></tr>
<tr><td>word</td><td>Generates a random word</td></tr>
<tr><td>words</td><td>Generate <code>N</code> random words, with <code>N</code> defaulting to a random number between 1 and 3</td></tr>
<tr><td>locale</td><td>Generates a random locale</td></tr>
<tr><td>alpha</td><td>Generates lower/upper alphabetic characters</td></tr>
<tr><td>alphaNumeric</td><td>Generates alphanumeric characters</td></tr>
</tbody></table>
<h3 id="fakersystem"><a class="header" href="#fakersystem">faker.system</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>fileName</td><td>Generates a random filenames without system path separators</td></tr>
<tr><td>commonFileName</td><td>Generates a random filenames without system path separators</td></tr>
<tr><td>mimeType</td><td>Generates a random mimetypes</td></tr>
<tr><td>commonFileType</td><td>Generates a random commonly used file type</td></tr>
<tr><td>commonFileExt</td><td>Generates a random commonly used file extension</td></tr>
<tr><td>fileType</td><td>Get any file type available as mime-type</td></tr>
<tr><td>fileExt</td><td>Generates a random file extension</td></tr>
<tr><td>directoryPath</td><td>Generates a random directory path</td></tr>
<tr><td>filePath</td><td>Generates a random unix fs file full path</td></tr>
<tr><td>semver</td><td>Generate semantic version</td></tr>
</tbody></table>
<h3 id="fakertime"><a class="header" href="#fakertime">faker.time</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>recent</td><td>Get recent timestamp in Unix time format</td></tr>
</tbody></table>
<h3 id="fakerunique"><a class="header" href="#fakerunique">faker.unique</a></h3>
<h3 id="fakervehicle"><a class="header" href="#fakervehicle">faker.vehicle</a></h3>
<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody>
<tr><td>vehicle</td><td>Generates a random vehicle name</td></tr>
<tr><td>manufacturer</td><td>Generates a random vehicle manufacturer name</td></tr>
<tr><td>model</td><td>Generates a random vehicle model name</td></tr>
<tr><td>type</td><td>Generates a random vehicle type</td></tr>
<tr><td>fuel</td><td>Generates a random vehicle fuel type</td></tr>
<tr><td>vin</td><td>Generates a random vehicle vin number</td></tr>
<tr><td>color</td><td>Generates a random vehicle color</td></tr>
<tr><td>vrm</td><td>Generates a random vehicle vrm</td></tr>
<tr><td>bicycle</td><td>Generates a random bicycle type</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nodejs-事件循环"><a class="header" href="#nodejs-事件循环">Node.js 事件循环</a></h2>
<p><strong>事件循环</strong>是了解 Node.js 最重要的方面之一。</p>
<p>为什么这么重要？ 因为它阐明了 Node.js 如何做到异步且具有非阻塞的 I/O，所以它基本上阐明了 Node.js 的“杀手级应用”，正是这一点使它成功了。</p>
<p>Node.js JavaScript 代码运行在单个线程上。 每次只处理一件事。</p>
<p>这个限制实际上非常有用，因为它大大简化了编程方式，而不必担心并发问题。</p>
<p>只需要注意如何编写代码，并避免任何可能阻塞线程的事情，例如同步的网络调用或无限的循环。</p>
<p>通常，在大多数浏览器中，每个浏览器选项卡都有一个事件循环，以使每个进程都隔离开，并避免使用无限的循环或繁重的处理来阻止整个浏览器的网页。</p>
<p>该环境管理多个并发的事件循环，例如处理 API 调用。 Web 工作进程也运行在自己的事件循环中。</p>
<p>主要需要关心代码会在单个事件循环上运行，并且在编写代码时牢记这一点，以避免阻塞它。</p>
<h3 id="阻塞事件循环"><a class="header" href="#阻塞事件循环">阻塞事件循环</a></h3>
<p>任何花费太长时间才能将控制权返回给事件循环的 JavaScript 代码，都会阻塞页面中任何 JavaScript 代码的执行，甚至阻塞 UI 线程，并且用户无法单击浏览、滚动页面等。</p>
<p>JavaScript 中几乎所有的 I/O 基元都是非阻塞的。 网络请求、文件系统操作等。 被阻塞是个异常，这就是 JavaScript 如此之多基于回调（最近越来越多基于 promise 和 async/await）的原因。</p>
<h3 id="调用堆栈"><a class="header" href="#调用堆栈">调用堆栈</a></h3>
<p>调用堆栈是一个 LIFO 队列（后进先出）。</p>
<p>事件循环不断地检查调用堆栈，以查看是否需要运行任何函数。</p>
<p>当执行时，它会将找到的所有函数调用添加到调用堆栈中，并按顺序执行每个函数。</p>
<h3 id="一个简单的事件循环的阐释"><a class="header" href="#一个简单的事件循环的阐释">一个简单的事件循环的阐释</a></h3>
<pre><code class="language-js">const bar = () =&gt; console.log('bar')
const baz = () =&gt; console.log('baz')
const foo = () =&gt; { 
    console.log('foo')  setTimeout(bar, 0)  baz()
}
foo()
</code></pre>
<pre><code class="language-bash">foo
baz
bar
</code></pre>
<p>当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 setTimeout，将 <code>bar</code> 作为参数传入，并传入 0 作为定时器指示它尽快运行。 然后调用 baz()。</p>
<h4 id="调用堆栈-1"><a class="header" href="#调用堆栈-1"><strong>调用堆栈</strong></a></h4>
<p><img src="nodejs/../images/call-stack-second-example.png" alt="" /></p>
<h4 id="调用顺序"><a class="header" href="#调用顺序">调用顺序</a></h4>
<p><img src="nodejs/../images/execution-order-second-example.png" alt="" /></p>
<h4 id="消息队列"><a class="header" href="#消息队列">消息队列</a></h4>
<p>当调用 setTimeout() 时，浏览器或 Node.js 会启动定时器。 当定时器到期时（在此示例中会立即到期，因为将超时值设为 0），则回调函数会被放入“<strong>消息队列</strong>”中。</p>
<p>在消息队列中，用户触发的事件（如单击或键盘事件、或获取响应）也会在此排队，然后代码才有机会对其作出反应。 类似 <code>onLoad</code> 这样的 DOM 事件也如此。</p>
<p>事件循环会赋予调用堆栈优先级,它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。</p>
<p>我们不必等待诸如 <code>setTimeout</code>、fetch、或其他的函数来完成它们自身的工作，因为它们是由浏览器提供的，并且位于它们自身的线程中</p>
<p>例如，如果将 <code>setTimeout</code> 的超时设置为 2 秒，但不必等待 2 秒，等待发生在其他地方。</p>
<h3 id="es6-作业队列"><a class="header" href="#es6-作业队列">ES6 作业队列</a></h3>
<p>ECMAScript 2015 引入了作业队列的概念,Promise 使用了该队列（也在 ES6/ES2015 中引入）</p>
<p>这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。</p>
<p>在当前函数结束之前 resolve 的 Promise 会在当前函数之后被立即执行。</p>
<p>有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。</p>
<pre><code class="language-js">const bar = () =&gt; console.log('bar')
const baz = () =&gt; console.log('baz')
const foo = () =&gt; {  console.log('foo')  setTimeout(bar, 0)  new Promise((resolve, reject) =&gt;    resolve('应该在 baz 之后、bar 之前')  ).then(resolve =&gt; console.log(resolve))  baz()}
foo()
</code></pre>
<pre><code class="language-txt">foo
baz
应该在 baz 之后、bar 之前
bar
</code></pre>
<p>这是 Promise（以及基于 promise 构建的 async/await）与通过 <code>setTimeout()</code> 或其他平台 API 的普通的旧异步函数之间的巨大区别。</p>
<h3 id="processnexttick"><a class="header" href="#processnexttick">process.nextTick()</a></h3>
<p>当尝试了解 Node.js 事件循环时，其中一个重要的部分就是 <code>process.nextTick()</code>。</p>
<p>每当事件循环进行一次完整的行程时，我们都将其称为一个滴答。</p>
<p>当将一个函数传给 <code>process.nextTick()</code> 时，则指示引擎在当前操作结束（在下一个事件循环滴答开始之前）时调用此函数：</p>
<pre><code class="language-js">process.nextTick(() =&gt; {
  //做些事情
})
</code></pre>
<p>事件循环正在忙于处理当前的函数代码。</p>
<p>当该操作结束时，JS 引擎会运行在该操作期间传给 <code>nextTick</code> 调用的所有函数。</p>
<p>当要确保在下一个事件循环迭代中代码已被执行，则使用 <code>nextTick()</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="从命令行运行nodejs"><a class="header" href="#从命令行运行nodejs">从命令行运行Nodejs</a></h2>
<pre><code class="language-shell">node app.js
</code></pre>
<h2 id="nodejs-程序退出"><a class="header" href="#nodejs-程序退出">Node.js 程序退出</a></h2>
<blockquote>
<p>注意：<code>process</code> 不需要 &quot;require&quot;，它是自动可用的。</p>
</blockquote>
<p><strong>强制退出</strong></p>
<pre><code class="language-js">process.exit(1)
</code></pre>
<p><strong>设定错误码</strong></p>
<p>当程序结束时，Node.js 会返回该退出码。</p>
<pre><code>
process.exitCode = 1
</code></pre>
<p><strong>信号终止</strong></p>
<pre><code class="language-js">const express = require('express')
const app = express()
app.get('/', (req, res) =&gt; {  res.send('你好')})
const server = app.listen(3000, () =&gt; console.log('服务器已就绪'))
# 监听TERM信号
process.on('SIGTERM', () =&gt; {  server.close(() =&gt; {    console.log('进程已终止')  })})

# 发送中断信号
process.kill(process.pid, 'SIGTERM')
</code></pre>
<h2 id="读取环境变量"><a class="header" href="#读取环境变量">读取环境变量</a></h2>
<blockquote>
<p>注意：<code>process</code> 不需要 &quot;require&quot;，它是自动可用的。</p>
</blockquote>
<p>Node.js 的 <code>process</code> 核心模块提供了 <code>env</code> 属性，该属性承载了在启动进程时设置的所有环境变量。</p>
<pre><code class="language-js">process.env.NODE_ENV // &quot;development&quot;
</code></pre>
<h2 id="nodejs-repl"><a class="header" href="#nodejs-repl">Node.js REPL</a></h2>
<p><em>REPL 也被称为运行评估打印循环，是一种编程语言环境（主要是控制台窗口），它使用单个表达式作为用户输入，并在执行后将结果返回到控制台。</em></p>
<h3 id="使用-tab-键自动补全"><a class="header" href="#使用-tab-键自动补全">使用 tab 键自动补全</a></h3>
<h3 id="探索-javascript-对象"><a class="header" href="#探索-javascript-对象">探索 JavaScript 对象</a></h3>
<p>尝试输入 JavaScript 类的名称，例如 <code>Number</code>，添加一个点号并按下 <code>tab</code>。</p>
<p>REPL 会打印可以在该类上访问的所有属性和方法</p>
<h3 id="探索全局对象"><a class="header" href="#探索全局对象">探索全局对象</a></h3>
<p>通过输入 <code>global.</code> 并按下 <code>tab</code>，可以检查可以访问的全局变量</p>
<h3 id="_-特殊变量"><a class="header" href="#_-特殊变量">_ 特殊变量</a></h3>
<p>如果在某些代码之后输入 <code>_</code>，则会打印最后一次操作的结果。</p>
<h3 id="点命令"><a class="header" href="#点命令">点命令</a></h3>
<p>一些特殊的命令，所有这些命令都以点号 <code>.</code> 开头。它们是：</p>
<ul>
<li><code>.help</code>: 显示点命令的帮助。</li>
<li><code>.editor</code>: 启用编辑器模式，可以轻松地编写多行 JavaScript 代码。当处于此模式时，按下 ctrl-D 可以运行编写的代码。</li>
<li><code>.break</code>: 当输入多行的表达式时，输入 <code>.break</code> 命令可以中止进一步的输入。相当于按下 ctrl-C。</li>
<li><code>.clear</code>: 将 REPL 上下文重置为空对象，并清除当前正在输入的任何多行的表达式。</li>
<li><code>.load</code>: 加载 JavaScript 文件（相对于当前工作目录）。</li>
<li><code>.save</code>: 将在 REPL 会话中输入的所有内容保存到文件（需指定文件名）。</li>
<li><code>.exit</code>: 退出 REPL（相当于按下两次 ctrl-C）。</li>
</ul>
<h3 id="从命令行接收参数"><a class="header" href="#从命令行接收参数">从命令行接收参数</a></h3>
<pre><code class="language-bash">node app.js name=joe
node app.js joe
</code></pre>
<pre><code class="language-js">process.argv.forEach((val, index) =&gt; {
  console.log(`${index}: ${val}`)
})
const args = process.argv.slice(2)

</code></pre>
<p>使用 <a href="https://www.npmjs.com/package/minimist"><code>minimist</code></a> 库，该库有助于处理参数：</p>
<pre><code class="language-js">const args = require('minimist')(process.argv.slice(2))
args['name'] //joe
</code></pre>
<pre><code class="language-bash">node app.js --name=joe
</code></pre>
<h2 id="输出到命令行"><a class="header" href="#输出到命令行">输出到命令行</a></h2>
<h3 id="使用控制台模块的基础输出"><a class="header" href="#使用控制台模块的基础输出">使用控制台模块的基础输出</a></h3>
<p>Node.js 提供了 <a href="http://nodejs.cn/api/console.html"><code>console</code> 模块</a>，该模块提供了大量非常有用的与命令行交互的方法。</p>
<pre><code class="language-js">const x = 'x'
const y = 'y'
console.log(x, y)
</code></pre>
<h3 id="格式化输出"><a class="header" href="#格式化输出">格式化输出</a></h3>
<pre><code class="language-js">console.log('我的%s已经%d岁', '猫', 2)
</code></pre>
<ul>
<li><code>%s</code> 会格式化变量为字符串</li>
<li><code>%d</code> 会格式化变量为数字</li>
<li><code>%i</code> 会格式化变量为其整数部分</li>
<li><code>%o</code> 会格式化变量为对象</li>
</ul>
<pre><code class="language-js">console.log('%o', Number)
</code></pre>
<h3 id="清除控制台"><a class="header" href="#清除控制台">清除控制台</a></h3>
<p><code>console.clear()</code> 会清除控制台（其行为可能取决于所使用的控制台）。</p>
<h3 id="统计打印字符串次数"><a class="header" href="#统计打印字符串次数">统计打印字符串次数</a></h3>
<p><code>console.count()</code> 是一个便利的方法。</p>
<p>count 方法会对打印的字符串的次数进行计数，并在其旁边打印计数：</p>
<h3 id="打印堆栈踪迹"><a class="header" href="#打印堆栈踪迹">打印堆栈踪迹</a></h3>
<p>在某些情况下，打印函数的调用堆栈踪迹很有用</p>
<pre><code class="language-js">const function2 = () =&gt; console.trace()
const function1 = () =&gt; function2()
function1()
</code></pre>
<h3 id="计算耗时"><a class="header" href="#计算耗时">计算耗时</a></h3>
<pre><code class="language-js">const doSomething = () =&gt; console.log('测试')
const measureDoingSomething = () =&gt; {
  console.time('doSomething()')
  //做点事，并测量所需的时间。
  doSomething()
  console.timeEnd('doSomething()')
}
measureDoingSomething()
</code></pre>
<h3 id="stdout-和-stderr"><a class="header" href="#stdout-和-stderr">stdout 和 stderr</a></h3>
<p>console.log 非常适合在控制台中打印消息。 这就是所谓的标准输出（或称为 <code>stdout</code>）。</p>
<p><code>console.error</code> 会打印到 <code>stderr</code> 流。</p>
<p>它不会出现在控制台中，但是会出现在错误日志中。</p>
<h3 id="为输出着色"><a class="header" href="#为输出着色">为输出着色</a></h3>
<p>可以使用<a href="https://gist.github.com/iamnewton/8754917">转义序列</a>在控制台中为文本的输出着色。 转义序列是一组标识颜色的字符。</p>
<pre><code class="language-js">console.log('\x1b[33m%s\x1b[0m', '你好')
</code></pre>
<p>当然，这是执行此操作的底层方法。 为控制台输出着色的最简单方法是使用库。 <a href="https://github.com/chalk/chalk">Chalk</a> 是一个这样的库，除了为其着色外，它还有助于其他样式的设置（例如使文本变为粗体、斜体或带下划线）。</p>
<p>可以使用 <code>npm install chalk</code> 进行安装，然后就可以使用它：</p>
<pre><code class="language-js">const chalk = require('chalk')
console.log(chalk.yellow('你好'))
</code></pre>
<p>与尝试记住转义代码相比，使用 <code>chalk.yellow</code> 方便得多，并且代码更具可读性。</p>
<h3 id="创建进度条"><a class="header" href="#创建进度条">创建进度条</a></h3>
<p><a href="https://www.npmjs.com/package/progress">Progress</a> 是一个很棒的软件包，可在控制台中创建进度条。 使用 <code>npm install progress</code> 进行安装。.</p>
<p>以下代码段会创建一个 10 步的进度条，每 100 毫秒完成一步。 当进度条结束时，则清除定时器：</p>
<pre><code class="language-.js">ProgressBar = require('progress')
let progress = new ProgressBar('aaa', 100);

let a = setInterval(() =&gt; {
    progress.tick();
    console.log(1)
    if (progress.complete) {
        clearInterval(a)
        console.log('end')
    }
}, 100);
</code></pre>
<h2 id="从命令行接收输入"><a class="header" href="#从命令行接收输入">从命令行接收输入</a></h2>
<pre><code class="language-js">const readline = require('readline').createInterface({  input: process.stdin,  output: process.stdout})
readline.question(`你叫什么名字?`, name =&gt; {  console.log(`你好 ${name}!`)  readline.close()})
</code></pre>
<pre><code class="language-js">const inquirer = require('inquirer')
var questions = [  {    type: 'input',    name: 'name',    message: &quot;你叫什么名字?&quot;  }]
inquirer.prompt(questions).then(answers =&gt; {  console.log(`你好 ${answers['name']}!`)})
</code></pre>
<h2 id="使用-exports-从-nodejs-文件中公开功能"><a class="header" href="#使用-exports-从-nodejs-文件中公开功能">使用 exports 从 Node.js 文件中公开功能</a></h2>
<p>Node.js 具有内置的模块系统。</p>
<p>Node.js 文件可以导入其他 Node.js 文件公开的功能。</p>
<p>当想要导入某些东西时，使用</p>
<pre><code class="language-js">const library = require('./library')
</code></pre>
<p>可以导入存在于当前文件夹中的 <code>library.js</code> 文件中公开的功能。</p>
<p>在此文件中，必须先公开功能，然后其他文件才能将其导入。</p>
<p>默认情况下，文件中定义的任何其他对象或变量都是私有的，不会公开给外界。</p>
<p>这就是 <a href="http://nodejs.cn/api/modules.html"><code>module</code> 系统</a>提供的 <code>module.exports</code> API 可以做的事。</p>
<p>当将对象或函数赋值为新的 <code>exports</code> 属性时，这就是要被公开的内容，因此，可以将其导入应用程序的其他部分或其他应用程序中。</p>
<p>可以通过两种方式进行操作。</p>
<ul>
<li>
<p>第一种方式是将对象赋值给 <code>module.exports</code>（这是模块系统提供的对象），这会使文件只导出该对象：</p>
<pre><code class="language-js">const car = {  brand: 'Ford',  model: 'Fiesta'}
module.exports = car
//在另一个文件中
const car = require('./car')
</code></pre>
</li>
<li>
<p>第二种方式是将要导出的对象添加为 <code>exports</code> 的属性。这种方式可以导出多个对象、函数或数据：</p>
<pre><code class="language-js">const car = {
  brand: 'Ford',
  model: 'Fiesta'
}

exports.car = car

# 或直接
exports.car = {
  brand: 'Ford',
  model: 'Fiesta'
}
</code></pre>
<p>在另一个文件中，则通过引用导入的属性来使用它：</p>
<pre><code class="language-js">const items = require('./items')
items.car
</code></pre>
<pre><code>const car = require('./items').car
</code></pre>
<p><code>module.exports</code> 和 <code>export</code> 之间有什么区别？</p>
<p>前者公开了它指向的对象。 后者公开了它指向的对象的属性。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="包管理简介"><a class="header" href="#包管理简介">包管理简介</a></h2>
<p><code>npm</code> 是 Node.js 标准的软件包管理器。</p>
<h3 id="安装所有依赖"><a class="header" href="#安装所有依赖">安装所有依赖</a></h3>
<pre><code class="language-bash">npm install
</code></pre>
<h3 id="安装某个软件包"><a class="header" href="#安装某个软件包">安装某个软件包</a></h3>
<pre><code class="language-bash">npm install &lt;package-name&gt;
</code></pre>
<p>通常会在此命令中看到更多标志：</p>
<ul>
<li><code>--save</code> 安装并添加条目到 <code>package.json</code> 文件的 dependencies。</li>
<li><code>--save-dev</code> 安装并添加条目到 <code>package.json</code> 文件的 devDependencies。</li>
</ul>
<p>区别主要是，<code>devDependencies</code> 通常是开发的工具（例如测试的库），而 <code>dependencies</code> 则是与生产环境中的应用程序相关。</p>
<h3 id="更新软件包"><a class="header" href="#更新软件包">更新软件包</a></h3>
<pre><code class="language-console">npm update
npm update &lt;package-name&gt;

</code></pre>
<h3 id="版本控制"><a class="header" href="#版本控制">版本控制</a></h3>
<p>在所有这些情况中，版本控制都有很大的帮助，<code>npm</code> 遵循语义版本控制标准。</p>
<h3 id="运行任务"><a class="header" href="#运行任务">运行任务</a></h3>
<p>package.json 文件支持一种用于指定命令行任务（可通过使用以下方式运行）的格式：</p>
<pre><code class="language-console">npm run &lt;task-name&gt;
</code></pre>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;start-dev&quot;: &quot;node lib/server-development&quot;,
    &quot;start&quot;: &quot;node lib/server-production&quot;
  },
}
</code></pre>
<p>使用此特性运行 Webpack 是很常见的：</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;watch&quot;: &quot;webpack --watch --progress --colors --config webpack.conf.js&quot;,
    &quot;dev&quot;: &quot;webpack --progress --colors --config webpack.conf.js&quot;,
    &quot;prod&quot;: &quot;NODE_ENV=production webpack -p --config webpack.conf.js&quot;,
  },
}
</code></pre>
<h2 id="npm-将软件包安装到哪里"><a class="header" href="#npm-将软件包安装到哪里">npm 将软件包安装到哪里</a></h2>
<p>当使用 <code>npm</code> 安装软件包时，可以执行两种安装类型：</p>
<ul>
<li>本地安装</li>
<li>全局安装</li>
</ul>
<p>默认情况下，当输入 <code>npm install</code> 命令时，例如：</p>
<pre><code class="language-bash">npm install lodash
</code></pre>
<p>软件包会被安装到当前文件树中的 <code>node_modules</code> 子文件夹下。</p>
<p>在这种情况下，<code>npm</code> 还会在当前文件夹中存在的 <code>package.json</code> 文件的 <code>dependencies</code> 属性中添加 <code>lodash</code> 条目。</p>
<p>使用 <code>-g</code> 标志可以执行全局安装：</p>
<pre><code class="language-bash">npm install -g lodash
</code></pre>
<p>在这种情况下，<code>npm</code> 不会将软件包安装到本地文件夹下，而是使用全局的位置。</p>
<p>全局的位置到底在哪里？</p>
<p><code>npm root -g</code> 命令会告知其在计算机上的确切位置</p>
<p>但是，如果使用 <code>nvm</code> 管理 Node.js 版本，则该位置会有所不同。</p>
<p>例如，使用 <code>nvm</code>，则软件包的位置可能为 <code>/Users/joe/.nvm/versions/node/v8.9.0/lib/node_modules</code>。</p>
<h2 id="如何使用或执行-npm-安装的软件包"><a class="header" href="#如何使用或执行-npm-安装的软件包">如何使用或执行 npm 安装的软件包</a></h2>
<p>当使用 <code>npm</code> 将软件包安装到 <code>node_modules</code> 文件夹中或全局安装时，如何在 Node.js 代码中使用它？</p>
<p>假设使用以下命令安装了流行的 JavaScript 实用工具库 <code>lodash</code>：</p>
<pre><code class="language-bash">npm install lodash
</code></pre>
<p>这会把软件包安装到本地的 <code>node_modules</code> 文件夹中。</p>
<p>若要在代码中使用它，则只需使用 <code>require</code> 将其导入到程序中：</p>
<pre><code class="language-js">const _ = require('lodash')
</code></pre>
<p>如果软件包是可执行文件，该怎么办？</p>
<p>在这种情况下，它会把可执行文件放到 <code>node_modules/.bin/</code> 文件夹下。</p>
<p>验证这一点的简单示例是 <a href="https://www.npmjs.com/package/cowsay">cowsay</a>。</p>
<p>cowsay 软件包提供了一个命令行程序，可以执行该程序以使母牛说些话（以及其他动物也可以说话）。</p>
<p>当使用 <code>npm install cowsay</code> 安装软件包时，它会在 node_modules 文件夹中安装自身以及一些依赖包：</p>
<p>有一个隐藏的 .bin 文件夹，其中包含指向 cowsay 二进制文件的符号链接：</p>
<p>如何执行这些文件？</p>
<p>可以输入 <code>./node_modules/.bin/cowsay</code> 来运行它，但是最新版本的 npm（自 5.2 起）中包含的 npx 是更好的选择。 只需运行：</p>
<pre><code class="language-bash">npx cowsay
</code></pre>
<h2 id="packagejson-指南"><a class="header" href="#packagejson-指南">package.json 指南</a></h2>
<h3 id="实例文件"><a class="header" href="#实例文件">实例文件</a></h3>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;test-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;A Vue.js project&quot;,
  &quot;main&quot;: &quot;src/main.js&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,
    &quot;start&quot;: &quot;npm run dev&quot;,
    &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;,
    &quot;test&quot;: &quot;npm run unit&quot;,
    &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit&quot;,
    &quot;build&quot;: &quot;node build/build.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;vue&quot;: &quot;^2.5.2&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,
    &quot;babel-core&quot;: &quot;^6.22.1&quot;,
    &quot;babel-eslint&quot;: &quot;^8.2.1&quot;,
    &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;,
    &quot;babel-jest&quot;: &quot;^21.0.2&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.1&quot;,
    &quot;babel-plugin-dynamic-import-node&quot;: &quot;^1.2.0&quot;,
    &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;,
    &quot;babel-plugin-transform-es2015-modules-commonjs&quot;: &quot;^6.26.0&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;,
    &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.5.0&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;,
    &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;,
    &quot;chalk&quot;: &quot;^2.0.1&quot;,
    &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;,
    &quot;css-loader&quot;: &quot;^0.28.0&quot;,
    &quot;eslint&quot;: &quot;^4.15.0&quot;,
    &quot;eslint-config-airbnb-base&quot;: &quot;^11.3.0&quot;,
    &quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;,
    &quot;eslint-import-resolver-webpack&quot;: &quot;^0.8.3&quot;,
    &quot;eslint-loader&quot;: &quot;^1.7.1&quot;,
    &quot;eslint-plugin-import&quot;: &quot;^2.7.0&quot;,
    &quot;eslint-plugin-vue&quot;: &quot;^4.0.0&quot;,
    &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;,
    &quot;file-loader&quot;: &quot;^1.1.4&quot;,
    &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;,
    &quot;jest&quot;: &quot;^22.0.4&quot;,
    &quot;jest-serializer-vue&quot;: &quot;^0.3.0&quot;,
    &quot;node-notifier&quot;: &quot;^5.1.2&quot;,
    &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^3.2.0&quot;,
    &quot;ora&quot;: &quot;^1.2.0&quot;,
    &quot;portfinder&quot;: &quot;^1.0.13&quot;,
    &quot;postcss-import&quot;: &quot;^11.0.0&quot;,
    &quot;postcss-loader&quot;: &quot;^2.0.8&quot;,
    &quot;postcss-url&quot;: &quot;^7.2.1&quot;,
    &quot;rimraf&quot;: &quot;^2.6.0&quot;,
    &quot;semver&quot;: &quot;^5.3.0&quot;,
    &quot;shelljs&quot;: &quot;^0.7.6&quot;,
    &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.1&quot;,
    &quot;url-loader&quot;: &quot;^0.5.8&quot;,
    &quot;vue-jest&quot;: &quot;^1.0.2&quot;,
    &quot;vue-loader&quot;: &quot;^13.3.0&quot;,
    &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;,
    &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;,
    &quot;webpack&quot;: &quot;^3.6.0&quot;,
    &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;,
    &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;,
    &quot;webpack-merge&quot;: &quot;^4.1.0&quot;
  },
  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&gt;= 6.0.0&quot;,
    &quot;npm&quot;: &quot;&gt;= 3.0.0&quot;
  },
  &quot;browserslist&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;]
}
</code></pre>
<p>这里有很多东西：</p>
<ul>
<li><code>version</code> 表明了当前的版本。</li>
<li><code>name</code> 设置了应用程序/软件包的名称。</li>
<li><code>description</code> 是应用程序/软件包的简短描述。</li>
<li><code>main</code> 设置了应用程序的入口点。</li>
<li><code>private</code> 如果设置为 <code>true</code>，则可以防止应用程序/软件包被意外地发布到 <code>npm</code>。</li>
<li><code>scripts</code> 定义了一组可以运行的 node 脚本。</li>
<li><code>dependencies</code> 设置了作为依赖安装的 <code>npm</code> 软件包的列表。</li>
<li><code>devDependencies</code> 设置了作为开发依赖安装的 <code>npm</code> 软件包的列表。</li>
<li><code>engines</code> 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。</li>
<li><code>browserslist</code> 用于告知要支持哪些浏览器（及其版本）。</li>
</ul>
<p>以上所有的这些属性都可被 <code>npm</code> 或其他工具使用。</p>
<h3 id="属性分类"><a class="header" href="#属性分类">属性分类</a></h3>
<h4 id="name"><a class="header" href="#name">name</a></h4>
<p>名称必须少于 214 个字符，且不能包含空格，只能包含小写字母、连字符（<code>-</code>）或下划线（<code>_</code>）。</p>
<p>这是因为当软件包在 <code>npm</code> 上发布时，它会基于此属性获得自己的 URL。</p>
<p>如果在 GitHub 上公开地发布此软件包，则 GitHub 仓库的名称是作为此属性的不错选择。</p>
<h4 id="author"><a class="header" href="#author">author</a></h4>
<p>列出软件包的作者名称。</p>
<p>示例：</p>
<pre><code class="language-json">{
  &quot;author&quot;: &quot;NodeJS中文网 &lt;mail@nodejs.cn&gt; (http://nodejs.cn)&quot;
}
</code></pre>
<pre><code class="language-json">{
  &quot;author&quot;: {
    &quot;name&quot;: &quot;NodeJS中文网&quot;,
    &quot;email&quot;: &quot;mail@nodejs.cn&quot;,
    &quot;url&quot;: &quot;http://nodejs.cn&quot;
  }
}
</code></pre>
<h4 id="contributors"><a class="header" href="#contributors">contributors</a></h4>
<pre><code class="language-json">{
  &quot;contributors&quot;: [&quot;NodeJS中文网 &lt;mail@nodejs.cn&gt; (http://nodejs.cn))&quot;]
}
</code></pre>
<pre><code class="language-json">{
  &quot;contributors&quot;: [
    {
      &quot;name&quot;: &quot;NodeJS中文网&quot;,
      &quot;email&quot;: &quot;mail@nodejs.cn&quot;,
      &quot;url&quot;: &quot;http://nodejs.cn&quot;
    }
  ]
}
</code></pre>
<h4 id="bugs"><a class="header" href="#bugs">bugs</a></h4>
<p>链接到软件包的问题跟踪器，最常用的是 GitHub 的 issues 页面。</p>
<pre><code class="language-json">{
  &quot;bugs&quot;: &quot;https://github.com/nodejscn/node-api-cn/issues&quot;
}
</code></pre>
<h4 id="homepage"><a class="header" href="#homepage">homepage</a></h4>
<pre><code class="language-json">{
  &quot;homepage&quot;: &quot;http://nodejs.cn&quot;
}
</code></pre>
<h4 id="version"><a class="header" href="#version">version</a></h4>
<pre><code class="language-json">&quot;version&quot;: &quot;1.0.0&quot;
</code></pre>
<h4 id="license"><a class="header" href="#license">license</a></h4>
<p>指定软件包的许可证。</p>
<pre><code class="language-json">&quot;license&quot;: &quot;MIT&quot;
</code></pre>
<h4 id="keywords"><a class="header" href="#keywords">keywords</a></h4>
<p>此属性包含与软件包功能相关的关键字数组。</p>
<pre><code class="language-json">&quot;keywords&quot;: [
  &quot;email&quot;,
  &quot;machine learning&quot;,
  &quot;ai&quot;
]
</code></pre>
<p>这有助于人们在浏览相似的软件包或浏览 https://www.npmjs.com/ 网站时找到你的软件包。</p>
<h4 id="description"><a class="header" href="#description">description</a></h4>
<p>如果要将软件包发布到 <code>npm</code>，则这个属性特别有用，人们可以知道该软件包是干啥用的。</p>
<pre><code class="language-json">&quot;description&quot;: &quot;NodeJS中文网入门教程&quot;
</code></pre>
<h4 id="repository"><a class="header" href="#repository">repository</a></h4>
<p>此属性指定了此程序包仓库所在的位置。</p>
<pre><code class="language-json">&quot;repository&quot;: &quot;github:nodejscn/node-api-cn&quot;,
</code></pre>
<p>注意 <code>github</code> 前缀。 其他流行的服务商还包括：</p>
<pre><code class="language-json">&quot;repository&quot;: &quot;gitlab:nodejscn/node-api-cn&quot;,
&quot;repository&quot;: &quot;bitbucket:nodejscn/node-api-cn&quot;,

</code></pre>
<p>可以显式地设置版本控制系统：</p>
<pre><code class="language-json">&quot;repository&quot;: {
  &quot;type&quot;: &quot;git&quot;,
  &quot;url&quot;: &quot;https://github.com/nodejscn/node-api-cn.git&quot;
}
&quot;repository&quot;: {
  &quot;type&quot;: &quot;svn&quot;,
  &quot;url&quot;: &quot;...&quot;
}
</code></pre>
<h4 id="main"><a class="header" href="#main">main</a></h4>
<p>设置软件包的入口点。</p>
<p>当在应用程序中导入此软件包时，应用程序会在该位置搜索模块的导出。</p>
<pre><code class="language-json">&quot;main&quot;: &quot;src/main.js&quot;
</code></pre>
<h4 id="private"><a class="header" href="#private">private</a></h4>
<p>如果设置为 <code>true</code>，则可以防止应用程序/软件包被意外发布到 <code>npm</code> 上。</p>
<h4 id="scripts"><a class="header" href="#scripts">scripts</a></h4>
<p>可以定义一组可以运行的 node 脚本。</p>
<pre><code class="language-json">&quot;scripts&quot;: {
  &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,
  &quot;start&quot;: &quot;npm run dev&quot;,
  &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;,
  &quot;test&quot;: &quot;npm run unit&quot;,
  &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit&quot;,
  &quot;build&quot;: &quot;node build/build.js&quot;
}
</code></pre>
<p>这些脚本是命令行应用程序。 可以通过调用 <code>npm run XXXX</code> 或 <code>yarn XXXX</code> 来运行它们，其中 <code>XXXX</code> 是命令的名称。 例如：<code>npm run dev</code>。</p>
<p>可以为命令使用任何的名称，脚本也可以是任何操作。</p>
<h4 id="dependencies"><a class="header" href="#dependencies">dependencies</a></h4>
<p>设置作为依赖安装的 <code>npm</code> 软件包的列表。</p>
<p>当使用 npm 或 yarn 安装软件包时：</p>
<pre><code class="language-bash">npm install &lt;PACKAGENAME&gt;
yarn add &lt;PACKAGENAME&gt;
</code></pre>
<pre><code class="language-json">&quot;dependencies&quot;: {
  &quot;vue&quot;: &quot;^2.5.2&quot;
}
</code></pre>
<h4 id="devdependencies"><a class="header" href="#devdependencies">devDependencies</a></h4>
<p>设置作为开发依赖安装的 <code>npm</code> 软件包的列表。</p>
<p>它们不同于 <code>dependencies</code>，因为它们只需安装在开发机器上，而无需在生产环境中运行代码。</p>
<p>当使用 npm 或 yarn 安装软件包时：</p>
<pre><code class="language-bash">npm install --save-dev &lt;PACKAGENAME&gt;
yarn add --dev &lt;PACKAGENAME&gt;
</code></pre>
<h4 id="engines"><a class="header" href="#engines">engines</a></h4>
<pre><code class="language-json">&quot;engines&quot;: {
  &quot;node&quot;: &quot;&gt;= 6.0.0&quot;,
  &quot;npm&quot;: &quot;&gt;= 3.0.0&quot;,
  &quot;yarn&quot;: &quot;^0.13.0&quot;
}
</code></pre>
<h4 id="browserslist"><a class="header" href="#browserslist">browserslist</a></h4>
<p>用于告知要支持哪些浏览器（及其版本）。 Babel、Autoprefixer 和其他工具会用到它，以将所需的 polyfill 和 fallback 添加到目标浏览器。</p>
<pre><code class="language-json">&quot;browserslist&quot;: [
  &quot;&gt; 1%&quot;,
  &quot;last 2 versions&quot;,
  &quot;not ie &lt;= 8&quot;
]
</code></pre>
<p>此配置意味着需要支持使用率超过 1％（来自 <a href="https://caniuse.com/">CanIUse.com</a> 的统计信息）的所有浏览器的最新的 2 个主版本，但不含 IE8 及更低的版本。</p>
<h3 id="命令特有的属性"><a class="header" href="#命令特有的属性">命令特有的属性</a></h3>
<p><code>package.json</code> 文件还可以承载命令特有的配置，例如 Babel、ESLint 等。</p>
<p>每个都有特有的属性，例如 <code>eslintConfig</code>、<code>babel</code> 等。 它们是命令特有的，可以在相应的命令/项目文档中找到如何使用它们。</p>
<h3 id="软件包版本"><a class="header" href="#软件包版本">软件包版本</a></h3>
<p>在上面的描述中，已经看到类似以下的版本号：<code>〜3.0.0</code> 或 <code>^0.13.0</code>。 它们是什么意思，还可以使用哪些其他的版本说明符？</p>
<p>该符号指定了软件包能从该依赖接受的更新。</p>
<p>鉴于使用了 semver（语义版本控制），所有的版本都有 3 个数字，第一个是主版本，第二个是次版本，第三个是补丁版本，详见<a href="http://nodejs.cn/website2.nodejs.cn/learn/semantic-versioning-using-npm/">规则</a>。</p>
<p>还可以在范围内组合以上大部分内容，例如：<code>1.0.0 || &gt;=1.1.0 &lt;1.2.0</code>，即使用 1.0.0 或从 1.1.0 开始但低于 1.2.0 的版本。</p>
<h2 id="package-lockjson-文件"><a class="header" href="#package-lockjson-文件">package-lock.json 文件</a></h2>
<p>在版本 5 中，npm 引入了 <code>package-lock.json</code> 文件。</p>
<p>该文件旨在跟踪被安装的每个软件包的确切版本，以便产品可以以相同的方式被 100％ 复制（即使软件包的维护者更新了软件包）。</p>
<p>这解决了 <code>package.json</code> 一直尚未解决的特殊问题。 在 package.json 中，可以使用 semver 表示法设置要升级到的版本（补丁版本或次版本），例如：</p>
<ul>
<li>如果写入的是 <code>〜0.13.0</code>，则只更新补丁版本：即 <code>0.13.1</code> 可以，但 <code>0.14.0</code> 不可以。</li>
<li>如果写入的是 <code>^0.13.0</code>，则要更新补丁版本和次版本：即 <code>0.13.1</code>、<code>0.14.0</code>、依此类推。</li>
<li>如果写入的是 <code>0.13.0</code>，则始终使用确切的版本。</li>
</ul>
<p>无需将 node_modules 文件夹（该文件夹通常很大）提交到 Git，当尝试使用 <code>npm install</code> 命令在另一台机器上复制项目时，如果指定了 <code>〜</code> 语法并且软件包发布了补丁版本，则该软件包会被安装。 <code>^</code> 和次版本也一样。</p>
<p>因此，原始的项目和新初始化的项目实际上是不同的。 即使补丁版本或次版本不应该引入重大的更改，但还是可能引入缺陷。</p>
<p><code>package-lock.json</code> 会固化当前安装的每个软件包的版本，当运行 <code>npm install</code>时，<code>npm</code> 会使用这些确切的版本。</p>
<p>这个概念并不新鲜，其他编程语言的软件包管理器（例如 PHP 中的 Composer）使用类似的系统已有多年。</p>
<p><code>package-lock.json</code> 文件需要被提交到 Git 仓库，以便被其他人获取（如果项目是公开的或有合作者，或者将 Git 作为部署源）。</p>
<p>当运行 <code>npm update</code> 时，<code>package-lock.json</code> 文件中的依赖的版本会被更新。</p>
<h2 id="查看-npm-包安装的版本"><a class="header" href="#查看-npm-包安装的版本">查看 npm 包安装的版本</a></h2>
<p>若要查看所有已安装的 npm 软件包（包括它们的依赖包）的最新版本，则：</p>
<pre><code class="language-bash">npm list
</code></pre>
<p><code>npm list -g</code> 也一样，但适用于全局安装的软件包。</p>
<p>若要仅获取顶层的软件包（基本上就是告诉 npm 要安装并在 <code>package.json</code> 中列出的软件包），则运行 <code>npm list --depth=0</code>：</p>
<pre><code class="language-bash">npm list --depth=0
</code></pre>
<p>也可以通过指定名称来获取特定软件包的版本：</p>
<pre><code class="language-bash">❯ npm list cowsay
/Users/joe/dev/node/cowsay
└── cowsay@1.3.1

</code></pre>
<p>这也适用于安装的软件包的依赖：</p>
<pre><code class="language-bash">❯ npm list minimist
/Users/joe/dev/node/cowsay
└─┬ cowsay@1.3.1
  └─┬ optimist@0.6.1
    └── minimist@0.0.10
</code></pre>
<p>如果要查看软件包在 npm 仓库上最新的可用版本，则运行 <code>npm view [package_name] version</code>：</p>
<pre><code class="language-bash">❯ npm view cowsay version
1.3.1

</code></pre>
<h2 id="安装-npm-包的旧版本"><a class="header" href="#安装-npm-包的旧版本">安装 npm 包的旧版本</a></h2>
<pre><code class="language-bash">npm install &lt;package&gt;@&lt;version&gt;
npm install cowsay
npm install cowsay@1.2.0
npm install -g webpack@4.16.4

//可能还有需要列出软件包所有的以前的版本。 可以使用
npm view &lt;package&gt; versions：
</code></pre>
<p>若要发现软件包的新版本，则运行 <code>npm outdated</code>。</p>
<p>以下是一个仓库中一些过时的软件包的列表，该仓库已很长时间没有更新：</p>
<p>这些更新中有些是主版本。 运行 <code>npm update</code> 不会更新那些版本。 主版本永远不会被这种方式更新</p>
<p>若要将所有软件包更新到新的主版本，则全局地安装 <code>npm-check-updates</code> 软件包：</p>
<pre><code class="language-bash">npm install -g npm-check-updates
ncu -u

//这会升级 package.json 文件的 dependencies 和 devDependencies 中的所有版本，以便 npm 可以安装新的主版本。
npm update
npm install
</code></pre>
<h2 id="npm-的语义版本控制"><a class="header" href="#npm-的语义版本控制">npm 的语义版本控制</a></h2>
<p>语义版本控制的概念很简单：所有的版本都有 3 个数字：<code>x.y.z</code>。</p>
<ul>
<li>第一个数字是主版本。</li>
<li>第二个数字是次版本。</li>
<li>第三个数字是补丁版本。</li>
</ul>
<p>当发布新的版本时，不仅仅是随心所欲地增加数字，还要遵循以下规则：</p>
<ul>
<li>当进行不兼容的 API 更改时，则升级主版本。</li>
<li>当以向后兼容的方式添加功能时，则升级次版本。</li>
<li>当进行向后兼容的缺陷修复时，则升级补丁版本。</li>
</ul>
<p>该约定在所有编程语言中均被采用，每个 <code>npm</code> 软件包都必须遵守该约定，这一点非常重要，因为整个系统都依赖于此。</p>
<p>因为 <code>npm</code> 设置了一些规则，可用于在 <code>package.json</code> 文件中选择要将软件包更新到的版本（当运行 <code>npm update</code> 时）。</p>
<p>规则使用了这些符号：</p>
<ul>
<li><code>^</code> : 自动执行补丁版本的升级</li>
<li><code>~</code>：自动执行 补丁版本、次版本的升级</li>
<li><code>&gt;</code>：接受高于指定版本的任何版本</li>
<li><code>&gt;=</code> 接受等于或高于指定版本的任何版本。</li>
<li><code>&lt;</code>接受低于指定版本的任何版本。</li>
<li><code>&lt;=</code>接受等于或低于指定版本的任何版本。</li>
<li><code>=</code>接受确切的版本。</li>
<li><code>-</code> 接受一定范围的版本。例如：<code>2.1.0 - 2.6.2</code>。</li>
<li><code>||</code> 组合集合。例如 <code>&lt; 2.1 || &gt; 2.6</code>。</li>
</ul>
<p>可以合并其中的一些符号，例如 <code>1.0.0 || &gt;=1.1.0 &lt;1.2.0</code>，即使用 1.0.0 或从 1.1.0 开始但低于 1.2.0 的版本。</p>
<ul>
<li>无符号: 仅接受指定的特定版本（例如 <code>1.2.1</code>）。</li>
<li><code>latest</code>: 使用可用的最新版本。</li>
</ul>
<h2 id="卸载-npm-软件包"><a class="header" href="#卸载-npm-软件包">卸载 npm 软件包</a></h2>
<p>若要卸载之前在本地安装（在 <code>node_modules</code> 文件夹使用 <code>npm install &lt;package-name&gt;</code>）的软件包，则从项目的根文件夹（包含 <code>node_modules</code> 文件夹的文件夹）中运行：</p>
<pre><code class="language-bash">npm uninstall &lt;package-name&gt;
</code></pre>
<p>如果使用 <code>-S</code> 或 <code>--save</code> 标志，则此操作还会移除 <code>package.json</code> 文件中的引用。</p>
<p>如果程序包是开发依赖项（列出在 <code>package.json</code> 文件的 devDependencies 中），则必须使用 <code>-D</code> 或 <code>--save-dev</code> 标志从文件中移除：</p>
<pre><code class="language-bash">npm uninstall -S &lt;package-name&gt;
npm uninstall -D &lt;package-name&gt;
</code></pre>
<p>如果该软件包是全局安装的，则需要添加 <code>-g</code> 或 <code>--global</code> 标志：</p>
<pre><code class="language-bash">npm uninstall -g &lt;package-name&gt;
</code></pre>
<h2 id="npm-全局或本地的软件包"><a class="header" href="#npm-全局或本地的软件包">npm 全局或本地的软件包</a></h2>
<p>本地和全局的软件包之间的主要区别是：</p>
<ul>
<li><strong>本地的软件包</strong> 安装在运行 <code>npm install &lt;package-name&gt;</code> 的目录中，并且放置在此目录下的 <code>node_modules</code> 文件夹中。</li>
<li><strong>全局的软件包</strong> 放在系统中的单独位置（确切的位置取决于设置），无论在何处运行 <code>npm install -g &lt;package-name&gt;</code>。</li>
</ul>
<p>在代码中，应该只引入本地的软件包：</p>
<pre><code class="language-js">require('package-name')

</code></pre>
<p>所以何时应该以一种或另一种方式安装？</p>
<p>通常，所有的软件包都应本地安装。</p>
<p>这样可以确保计算机中可以有数十个应用程序，并且如果需要，每个应用程序都可以运行不同的版本。</p>
<p>更新全局软件包会使所有的项目都使用新的版本，这可能会导致维护方面的噩梦，因为某些软件包可能会破坏与其他依赖项的兼容性等。</p>
<p>所有的项目都有自己的软件包本地版本，即使这看起来有点浪费资源，但与可能产生的负面影响相比也很小。</p>
<p>当程序包提供了可从 shell（CLI）运行的可执行命令、且可在项目间复用时，则该程序包应被全局安装。</p>
<p>也可以在本地安装可执行命令并使用 npx 运行，但是某些软件包最好在全局安装。</p>
<p>一些流行的全局软件包的示例有：</p>
<ul>
<li><code>npm</code></li>
<li><code>create-react-app</code></li>
<li><code>vue-cli</code></li>
<li><code>grunt-cli</code></li>
<li><code>mocha</code></li>
<li><code>react-native-cli</code></li>
<li><code>gatsby-cli</code></li>
<li><code>forever</code></li>
<li><code>nodemon</code></li>
</ul>
<pre><code class="language-bash">npm list -g --depth 0
</code></pre>
<h2 id="npm-依赖与开发依赖"><a class="header" href="#npm-依赖与开发依赖">npm 依赖与开发依赖</a></h2>
<p>当使用 <code>npm install &lt;package-name&gt;</code> 安装 npm 软件包时，是将其安装为依赖项。</p>
<p>该软件包会被自动地列出在 package.json 文件中的 <code>dependencies</code> 列表下（在 npm 5 之前：必须手动指定 <code>--save</code>）。</p>
<p>当添加了 <code>-D</code> 或 <code>--save-dev</code> 标志时，则会将其安装为开发依赖项（会被添加到 <code>devDependencies</code> 列表）。</p>
<p>开发依赖是仅用于开发的程序包，在生产环境中并不需要。 例如测试的软件包、webpack 或 Babel。</p>
<p>当投入生产环境时，如果输入 <code>npm install</code> 且该文件夹包含 <code>package.json</code> 文件时，则会安装它们，因为 npm 会假定这是开发部署。</p>
<p>需要设置 <code>--production</code> 标志（<code>npm install --production</code>），以避免安装这些开发依赖项。</p>
<h2 id="nodejs-包运行器-npx"><a class="header" href="#nodejs-包运行器-npx">Node.js 包运行器 npx</a></h2>
<p><code>npx</code> 是一个非常强大的命令，从 <strong>npm</strong> 的 5.2 版本（发布于 2017 年 7 月）开始可用。</p>
<blockquote>
<p>如果不想安装 npm，则可以<a href="https://www.npmjs.com/package/npx">安装 npx 为独立的软件包</a>。</p>
</blockquote>
<p><strong><code>**npx</code> 可以运行使用 Node.js 构建并通过 npm 仓库发布的代码。</strong>**</p>
<h3 id="轻松地运行本地命令"><a class="header" href="#轻松地运行本地命令">轻松地运行本地命令</a></h3>
<p>Node.js 开发者过去通常将大多数可执行命令发布为全局的软件包，以使它们处于路径中且可被立即地执行。</p>
<p>这很痛苦，因为无法真正地安装同一命令的不同版本。</p>
<p>运行 <code>npx commandname</code> 会自动地在项目的 <code>node_modules</code> 文件夹中找到命令的正确引用，而无需知道确切的路径，也不需要在全局和用户路径中安装软件包。</p>
<h3 id="无需安装的命令执行"><a class="header" href="#无需安装的命令执行">无需安装的命令执行</a></h3>
<p><code>npx</code> 的另一个重要的特性是，无需先安装命令即可运行命令。</p>
<p>这非常有用，主要是因为：</p>
<ol>
<li>不需要安装任何东西。</li>
<li>可以使用 @version 语法运行同一命令的不同版本。</li>
</ol>
<p>使用 <code>npx</code> 的一个典型演示是使用 <code>cowsay</code> 命令。 <code>cowsay</code> 会打印一头母牛，并在命令中说出你写的内容。 例如：</p>
<p><code>cowsay &quot;你好&quot;</code> 会打印：</p>
<pre><code class="language-console">CONSOLEcopy
 _______
&lt; 你好 &gt;
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
</code></pre>
<p>只有之前已从 npm 全局安装了 <code>cowsay</code> 命令，才可以这样做，否则，当尝试运行该命令时会获得错误。</p>
<p><code>npx</code> 可以运行该 npm 命令，而无需在本地安装：</p>
<pre><code class="language-bash">npx cowsay &quot;你好&quot;
</code></pre>
<p>会执行这个工作。</p>
<p>这是一个有趣但无用的命令。 其他场景有：</p>
<ul>
<li>运行 <code>vue</code> CLI 工具以创建新的应用程序并运行它们：<code>npx @vue/cli create my-vue-app</code>。</li>
<li>使用 <code>create-react-app</code> 创建新的 <code>React</code> 应用：<code>npx create-react-app my-react-app</code>。</li>
</ul>
<p>还有更多其他的场景。</p>
<p>当被下载完，则下载的代码会被擦除。</p>
<h3 id="使用不同的-nodejs-版本运行代码"><a class="header" href="#使用不同的-nodejs-版本运行代码">使用不同的 Node.js 版本运行代码</a></h3>
<p>使用 <code>@</code> 指定版本，并将其与 <a href="https://www.npmjs.com/package/node"><code>node</code> npm 软件包</a> 结合使用：</p>
<pre><code class="language-bash">npx node@10 -v #v10.18.1
npx node@12 -v #v12.14.1
</code></pre>
<p>这有助于避免使用 <code>nvm</code> 之类的工具或其他 Node.js 版本管理工具。</p>
<h3 id="直接从-url-运行任意代码片段"><a class="header" href="#直接从-url-运行任意代码片段">直接从 URL 运行任意代码片段</a></h3>
<p><code>npx</code> 并不限制使用 npm 仓库上发布的软件包。</p>
<p>可以运行位于 GitHub gist 中的代码，例如：</p>
<pre><code class="language-bash">npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32
</code></pre>
<p>当然，当运行不受控制的代码时，需要格外小心，因为强大的功能带来了巨大的责任。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="settimeout"><a class="header" href="#settimeout"><code>setTimeout</code></a></h2>
<pre><code class="language-js">setTimeout(() =&gt; {  // 2 秒之后运行}, 2000)
setTimeout(() =&gt; {  // 50 毫秒之后运行}, 50)
</code></pre>
<p>该语法定义了一个新的函数。 可以在其中调用所需的任何其他函数，也可以传入现有的函数名称和一组参数：</p>
<pre><code class="language-js">const myFunction = (firstParam, secondParam) =&gt; {
  // 做些事情
}

// 2 秒之后运行
setTimeout(myFunction, 2000, firstParam, secondParam)
</code></pre>
<pre><code class="language-js">const id = setTimeout(() =&gt; {  // 应该在 2 秒之后运行}, 2000)
// 改变主意了clearTimeout(id)
</code></pre>
<h3 id="零延迟"><a class="header" href="#零延迟">零延迟</a></h3>
<p>如果将超时延迟指定为 <code>0</code>，则回调函数会被尽快执行（但是是在当前函数执行之后）：</p>
<pre><code class="language-js">setTimeout(() =&gt; {
  console.log('后者 ')
}, 0)

console.log(' 前者 ')
</code></pre>
<h2 id="setinterval"><a class="header" href="#setinterval"><code>setInterval</code></a></h2>
<p><code>setInterval</code> 是一个类似于 <code>setTimeout</code> 的函数，不同之处在于：它会在指定的特定时间间隔（以毫秒为单位）一直地运行回调函数，而不是只运行一次：</p>
<pre><code class="language-js">setInterval(() =&gt; {
  // 每 2 秒运行一次
}, 2000)
</code></pre>
<p>上面的函数每隔 2 秒运行一次，除非使用 <code>clearInterval</code> 告诉它停止（传入 <code>setInterval</code> 返回的间隔定时器 id）：</p>
<pre><code class="language-js">const interval = setInterval(() =&gt; {
  if (App.somethingIWait === 'arrived') {
    clearInterval(interval)
    return
  }
  // 否则做些事情
}, 100)
</code></pre>
<h2 id="递归的-settimeout"><a class="header" href="#递归的-settimeout">递归的 setTimeout</a></h2>
<p><code>setInterval</code> 每 n 毫秒启动一个函数，而无需考虑函数何时完成执行。</p>
<p>如果一个函数总是花费相同的时间，那就没问题了：</p>
<p>函数可能需要不同的执行时间，这具体取决于网络条件</p>
<p>为了避免这种情况，可以在回调函数完成时安排要被调用的递归的 setTimeout：</p>
<pre><code class="language-js">const myFunction = () =&gt; {
  // 做些事情

  setTimeout(myFunction, 1000)
}

setTimeout(myFunction, 1000)
</code></pre>
<h2 id="setimmediate"><a class="header" href="#setimmediate">setImmediate</a></h2>
<p>当要异步地（但要尽可能快）执行某些代码时，其中一个选择是使用 Node.js 提供的 <code>setImmediate()</code> 函数：</p>
<pre><code class="language-js">setImmediate(() =&gt; {
  //运行一些东西
})
</code></pre>
<p>作为 setImmediate() 参数传入的任何函数都是在事件循环的下一个迭代中执行的回调。</p>
<p><code>setImmediate()</code> 与 <code>setTimeout(() =&gt; {}, 0)</code>（传入 0 毫秒的超时）、<code>process.nextTick()</code> 有何不同？</p>
<p>传给 <code>process.nextTick()</code> 的函数会在事件循环的当前迭代中（当前操作结束之后）被执行。 这意味着它会始终在 <code>setTimeout</code> 和 <code>setImmediate</code> 之前执行。</p>
<p>延迟 0 毫秒的 <code>setTimeout()</code> 回调与 <code>setImmediate()</code> 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="promise-简介"><a class="header" href="#promise-简介">Promise 简介</a></h2>
<p>Promise 通常被定义为<strong>最终会变为可用值的代理</strong>。</p>
<p>Promise 是一种处理异步代码（而不会陷入<a href="http://callbackhell.com/">回调地狱</a>）的方式。</p>
<h3 id="promise-如何运作"><a class="header" href="#promise-如何运作">Promise 如何运作</a></h3>
<p>当 promise 被调用后，它会以<strong>处理中状态</strong>开始。 这意味着调用的函数会继续执行，而 promise 仍处于处理中直到解决为止，从而为调用的函数提供所请求的任何数据。</p>
<pre><code class="language-js">let done = true
const isItDoneYet = new Promise((resolve, reject) =&gt; {  if (done) { 
    const workDone = '这是创建的东西'    
    resolve(workDone)  
} else {   
    const why = '仍然在处理其他事情'    reject(why)  
}})
</code></pre>
<h3 id="promisifying技术"><a class="header" href="#promisifying技术">Promisifying技术</a></h3>
<pre><code class="language-js">const fs = require('fs')

const getFile = (fileName) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    fs.readFile(fileName, (err, data) =&gt; {
      if (err) {
        reject(err)  // 调用 `reject` 会导致 promise 失败，无论是否传入错误作为参数，
        return        // 且不再进行下去。
      }
      resolve(data)
    })
  })
}

getFile('/etc/passwd')
.then(data =&gt; console.log(data))
.catch(err =&gt; console.error(err))
</code></pre>
<p><em>在最新版本的 Node.js 中，无需为大多数 API 进行手动地转换。如果需要 promisifying 的函数具有正确的签名，则</em> <a href="http://nodejs.cn/api/util.html#util_util_promisify_original">util 模块</a><em>中有一个 promisifying 函数可以完成此操作。</em></p>
<h3 id="链式-promise"><a class="header" href="#链式-promise">链式 promise</a></h3>
<pre><code class="language-js">const status = response =&gt; 
{  if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) {    return Promise.resolve(response)  }  return Promise.reject(new Error(response.statusText))}
const json = response =&gt; response.json()
fetch('/todos.json')  .then(status)    // 注意，`status` 函数实际上在这里被调用，并且同样返回 promise，  .then(json)      // 这里唯一的区别是的 `json` 函数会返回解决时传入 `data` 的 promise，  .then(data =&gt; {  // 这是 `data` 会在此处作为匿名函数的第一个参数的原因。    console.log('请求成功获得 JSON 响应', data)  })  .catch(error =&gt; {    console.log('请求失败', error)  })
</code></pre>
<h3 id="处理错误"><a class="header" href="#处理错误">处理错误</a></h3>
<p>当 promise 链中的任何内容失败并引发错误或拒绝 promise 时，则控制权会转到链中最近的 <code>catch()</code> 语句。</p>
<pre><code class="language-js">new Promise((resolve, reject) =&gt; {  throw new Error('错误')}).catch(err =&gt; {  console.error(err)})
// 或
new Promise((resolve, reject) =&gt; {  reject('错误')}).catch(err =&gt; {  console.error(err)})
</code></pre>
<p><strong>级联错误</strong></p>
<p>如果在 <code>catch()</code> 内部引发错误，则可以附加第二个 <code>catch()</code>来处理，依此类推。</p>
<pre><code class="language-js">new Promise((resolve, reject) =&gt; {
  throw new Error('错误')
})
  .catch(err =&gt; {
    throw new Error('错误')
  })
  .catch(err =&gt; {
    console.error(err)
  })
</code></pre>
<h3 id="编排-promise"><a class="header" href="#编排-promise">编排 promise</a></h3>
<p>如果需要同步不同的 promise，则 <code>Promise.all()</code> 可以帮助定义 promise 列表，并在所有 promise 都被解决后执行一些操作。</p>
<pre><code class="language-js">const f1 = fetch('/something.json')const f2 = fetch('/something2.json')
Promise.all([f1, f2]).then(res =&gt; {    
    console.log('结果的数组', res)  
}) .catch(err =&gt; {    console.error(err)  })
</code></pre>
<p>ES2015 解构赋值语法也可以执行：</p>
<pre><code class="language-js">Promise.all([f1, f2]).then(([res1, res2]) =&gt; {
  console.log('结果', res1, res2)
})
</code></pre>
<h4 id="promiserace"><a class="header" href="#promiserace"><code>Promise.race()</code></a></h4>
<p>当传给其的首个 promise 被解决时，则 <code>Promise.race()</code> 开始运行，并且只运行一次附加的回调（传入第一个被解决的 promise 的结果）。</p>
<pre><code class="language-js">const first = new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, 500, '第一个')
})
const second = new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, 100, '第二个')
})

Promise.race([first, second]).then(result =&gt; {
  console.log(result) // 第二个
})
</code></pre>
<h2 id="async-和-await-的现代异步"><a class="header" href="#async-和-await-的现代异步">Async 和 Await 的现代异步</a></h2>
<h3 id="介绍"><a class="header" href="#介绍">介绍</a></h3>
<p>JavaScript 在很短的时间内从回调发展到了 promise（ES2015），且自 ES2017 以来，异步的 JavaScript 使用 async/await 语法甚至更加简单。</p>
<p>异步函数是 promise 和生成器的组合，基本上，它们是 promise 的更高级别的抽象。 而 async/await 建立在 promise 之上。</p>
<h3 id="为什么引入-asyncawait"><a class="header" href="#为什么引入-asyncawait">为什么引入 async/await</a></h3>
<p>它们减少了 promises 的样板，且减少了 promise 链的“不破坏链条”的限制。</p>
<h3 id="工作原理"><a class="header" href="#工作原理">工作原理</a></h3>
<pre><code class="language-js">const doSomethingAsync = () =&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; resolve('做些事情'), 3000)
  })
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="scripts-脚本使用指南"><a class="header" href="#scripts-脚本使用指南">scripts 脚本使用指南</a></h2>
<p>Node 开发离不开 npm，而脚本功能是 npm 最强大、最常用的功能之一。</p>
<p>本文介绍如何使用 npm 脚本（npm scripts）。</p>
<h2 id="scripts-脚本是什么"><a class="header" href="#scripts-脚本是什么">scripts 脚本是什么</a></h2>
<p>npm 允许在package.json文件里面，使用scripts字段定义脚本命令。</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;node build.js&quot;
  }
}
</code></pre>
<p>上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。</p>
<p>比如，build命令对应的脚本是node build.js。</p>
<p>命令行下使用npm run命令，就可以执行这段脚本。</p>
<pre><code>$ npm run build
</code></pre>
<p>等同于</p>
<pre><code>$ node build.js
</code></pre>
<p>这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多。</p>
<ol>
<li>项目的相关脚本，可以集中在一个地方。</li>
<li>不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。</li>
<li>可以利用 npm 提供的很多辅助功能。</li>
<li>查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令。</li>
</ol>
<h2 id="执行原理"><a class="header" href="#执行原理">执行原理</a></h2>
<p>npm 脚本的原理非常简单</p>
<pre><code>每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。
</code></pre>
<p>因此，只要是 Shell（Bash）可以运行的命令，就可以写在 npm 脚本里面。</p>
<ul>
<li>
<p>比较特别的是，npm run新建的这个 Shell，<strong>会将当前目录的node_modules/.bin子目录加入PATH变量</strong>，执行结束后，再将PATH变量恢复原样。这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，<strong>都可以直接用脚本名调用，而不必加上路径</strong>。</p>
</li>
<li>
<p>由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面</p>
</li>
<li>
<p>npm 脚本的退出规则，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。</p>
</li>
</ul>
<h2 id="通配符"><a class="header" href="#通配符">通配符</a></h2>
<p><strong>由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。</strong></p>
<pre><code>&quot;lint&quot;: &quot;jshint *.js&quot;
&quot;lint&quot;: &quot;jshint **/*.js&quot;
</code></pre>
<p>上面代码中，*表示任意文件名，**表示任意一层子目录。</p>
<p>如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。</p>
<pre><code>&quot;test&quot;: &quot;tap test/\*.js&quot;
</code></pre>
<h2 id="传参"><a class="header" href="#传参">传参</a></h2>
<pre><code># 向 npm 脚本传入参数，要使用--标明。
&quot;lint&quot;: &quot;jshint **.js&quot;
</code></pre>
<p>向上面的<em>npm run lint</em>命令传入参数，必须写成下面这样。</p>
<pre><code class="language-shell">$ npm run lint --  --reporter checkstyle &gt; checkstyle.xml
</code></pre>
<p>也可以在package.json里面再封装一个命令。</p>
<pre><code>&quot;lint&quot;: &quot;jshint **.js&quot;,
&quot;lint:checkstyle&quot;: &quot;npm run lint -- --reporter checkstyle &gt; checkstyle.xml&quot;
</code></pre>
<h2 id="执行顺序"><a class="header" href="#执行顺序">执行顺序</a></h2>
<p>如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。</p>
<p>如果是并行执行（即同时的平行执行），可以使用&amp;符号。</p>
<pre><code>$ npm run script1.js &amp; npm run script2.js
</code></pre>
<p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&amp;&amp;符号。</p>
<pre><code>$ npm run script1.js &amp;&amp; npm run script2.js
</code></pre>
<p>这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：：<a href="https://github.com/paulpflug/script-runner">script-runner</a>、<a href="https://github.com/mysticatea/npm-run-all">npm-run-all</a>、<a href="https://github.com/coderaiser/redrun">redrun</a>。</p>
<h2 id="默认值"><a class="header" href="#默认值">默认值</a></h2>
<p>一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。</p>
<pre><code>&quot;start&quot;: &quot;node server.js&quot;，
&quot;install&quot;: &quot;node-gyp rebuild&quot;
</code></pre>
<pre><code>上面代码中，npm run start的默认值是node server.js，前提是项目根目录下有server.js这个脚本；

npm run install的默认值是node-gyp rebuild，前提是项目根目录下有binding.gyp文件。
</code></pre>
<h2 id="钩子"><a class="header" href="#钩子">钩子</a></h2>
<p>npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。</p>
<pre><code class="language-json">&quot;prebuild&quot;: &quot;echo I run before the build script&quot;,
&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;,
&quot;postbuild&quot;: &quot;echo I run after the build script&quot;
</code></pre>
<p>用户执行npm run build的时候，会自动按照下面的顺序执行。</p>
<pre><code>npm run prebuild &amp;&amp; npm run build &amp;&amp; npm run postbuild
</code></pre>
<p>因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。</p>
<pre><code>&quot;clean&quot;: &quot;rimraf ./dist &amp;&amp; mkdir dist&quot;,
&quot;prebuild&quot;: &quot;npm run clean&quot;,
&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;
</code></pre>
<p><strong>npm 默认提供下面这些钩子。</strong></p>
<pre><code>prepublish，postpublish
preinstall，postinstall
preuninstall，postuninstall
preversion，postversion
pretest，posttest
prestop，poststop
prestart，poststart
prerestart，postrestart
</code></pre>
<p>**自定义的脚本命令也可以加上pre和post钩子。**比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。</p>
<p>不过，双重的pre和post无效，比如prepretest和postposttest是无效的。</p>
<p><strong>npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等</strong>。</p>
<p>所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。</p>
<pre><code class="language-js">const TARGET = process.env.npm_lifecycle_event;

if (TARGET === 'test') {
  console.log(`Running the test task!`);
}

if (TARGET === 'pretest') {
  console.log(`Running the pretest task!`);
}

if (TARGET === 'posttest') {
  console.log(`Running the posttest task!`);
}
</code></pre>
<p><strong>注意，prepublish这个钩子不仅会在npm publish命令之前运行，还会在npm install（不带任何参数）命令之前运行</strong>。</p>
<pre><code>这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子prepare，行为等同于prepublish，而从 npm 5 开始，prepublish将只在npm publish命令之前运行。
</code></pre>
<h2 id="简写形式"><a class="header" href="#简写形式">简写形式</a></h2>
<p><strong>四个常用的 npm 脚本有简写形式</strong>。</p>
<pre><code>npm start是npm run start
npm stop是npm run stop的简写
npm test是npm run test的简写
npm restart是npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start的简写
</code></pre>
<pre><code>npm start、npm stop和npm restart都比较好理解，而npm restart是一个复合命令，实际上会执行三个脚本命令：stop、restart、start
</code></pre>
<p>具体的执行顺序如下。</p>
<pre><code>prerestart
prestop
stop
poststop
restart
prestart
start
poststart
postrestart
</code></pre>
<h2 id="变量"><a class="header" href="#变量">变量</a></h2>
<p>npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。</p>
<p>首先，<strong>通过npm_package_前缀，npm 脚本可以拿到package.json里面的字段</strong>。比如，下面是一个package.json。</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;foo&quot;, 
  &quot;version&quot;: &quot;1.2.5&quot;,
  &quot;scripts&quot;: {
    &quot;view&quot;: &quot;node view.js&quot;
  }
}
</code></pre>
<p>那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。</p>
<pre><code class="language-js">// view.js
console.log(process.env.npm_package_name); // foo
console.log(process.env.npm_package_version); // 1.2.5
</code></pre>
<p>上面代码中，我们通过环境变量process.env对象，拿到package.json的字段值。</p>
<p>如果是 Bash 脚本，可以用<code>$npm_package_name</code>和<code>$npm_package_version</code>取到这两个值。</p>
<p>npm_package_前缀也支持嵌套的package.json字段。</p>
<pre><code class="language-json">  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;xxx&quot;
  },
  scripts: {
    &quot;view&quot;: &quot;echo $npm_package_repository_type&quot;
  }
</code></pre>
<p>上面代码中，repository字段的type属性，可以通过npm_package_repository_type取到。</p>
<p>下面是另外一个例子。</p>
<pre><code class="language-json">&quot;scripts&quot;: {
  &quot;install&quot;: &quot;foo.js&quot;
}
</code></pre>
<p>上面代码中，npm_package_scripts_install变量的值等于foo.js。</p>
<p><strong>然后，npm 脚本还可以通过npm_config_前缀，拿到 npm 的配置变量</strong>，即npm config get xxx命令返回的值。</p>
<p>比如，当前模块的发行标签，可以通过npm_config_tag取到。</p>
<pre><code>&quot;view&quot;: &quot;echo $npm_config_tag&quot;,
</code></pre>
<p>注意，package.json里面的config对象，可以被环境变量覆盖。</p>
<pre><code class="language-json">{ 
  &quot;name&quot; : &quot;foo&quot;,
  &quot;config&quot; : { &quot;port&quot; : &quot;8080&quot; },
  &quot;scripts&quot; : { &quot;start&quot; : &quot;node server.js&quot; }
}
</code></pre>
<p>上面代码中，npm_package_config_port变量返回的是8080。这个值可以用下面的方法覆盖。</p>
<pre><code>$ npm config set foo:port 80
</code></pre>
<p><strong>最后，env命令可以列出所有环境变量。</strong></p>
<pre><code>&quot;env&quot;: &quot;env&quot;
</code></pre>
<h2 id="常用脚本"><a class="header" href="#常用脚本">常用脚本</a></h2>
<pre><code>// 删除目录
&quot;clean&quot;: &quot;rm -rf dist &amp;&amp; mkdir dist&quot;,
&quot;example&quot;: &quot;export DEBUG=table* &amp;&amp; babel-node ./example/example.js&quot;,
&quot;test&quot;: &quot;export DEBUG=table &amp;&amp; babel-node ./test/test.js&quot;,
&quot;build&quot;: &quot;./node_modules/.bin/babel src --out-dir dist&quot;,
</code></pre>
<pre><code>// 可以简写成下面的形式
&quot;build&quot;: &quot;babel src --out-dir dist&quot;,
&quot;build:pkg&quot;: &quot;babel bin --out-dir dist/bin --copy-files&quot;,
&quot;prepublishOnly&quot;: &quot;npm run clean &amp;&amp; npm run build&quot;,
</code></pre>
<pre><code>// 配置环境变量
&quot;start&quot;: &quot;export DEBUG=table* &amp;&amp; node scripts/start.js&quot;,
&quot;build&quot;: &quot;node ./scripts/build.js&quot;,
&quot;test&quot;: &quot;node scripts/test.js --env=jsdom&quot;,
&quot;pub:es&quot;: &quot;npm run clean &amp;&amp; export BABEL_ENV=production &amp;&amp; babel src --out-dir es --copy-files&quot;,
&quot;pub:lib&quot;: &quot;npm run clean &amp;&amp; export BABEL_ENV=node &amp;&amp; babel src --out-dir lib --copy-files&quot;,
&quot;pub:um&quot;: &quot;npm run clean:dist &amp;&amp; export RABEL_ENV=production &amp;&amp; webpack --config ./config/webpack.config.pub.js&quot;,
&quot;pub:optimized&quot;: &quot;rm es/setting.js es/i18n.js es/index.local.js &amp;&amp; rm lib.settings.js lib/i18n.js lib/index.local.js&quot;,
&quot;prepublishOnly&quot;: &quot;npm run pub:lib &amp;&amp; npm run pub:es &amp;&amp; npm run pub:umd &amp;&amp; npm run pub:optimized&quot;
</code></pre>
<pre><code>// 本地搭建一个 HTTP 服务
&quot;serve&quot;: &quot;http-server -p 9090 dist/&quot;,
</code></pre>
<pre><code>// 打开浏览器
&quot;open:dev&quot;: &quot;opener http://localhost:9090&quot;,
</code></pre>
<pre><code>// 实时刷新
 &quot;livereload&quot;: &quot;live-reload --port 9091 dist/&quot;,
</code></pre>
<pre><code>// 构建 HTML 文件
&quot;build:html&quot;: &quot;jade index.jade &gt; dist/index.html&quot;,
</code></pre>
<pre><code>// 只要 CSS 文件有变动，就重新执行构建
&quot;watch:css&quot;: &quot;watch 'npm run build:css' assets/styles/&quot;,
</code></pre>
<pre><code>// 只要 HTML 文件有变动，就重新执行构建
&quot;watch:html&quot;: &quot;watch 'npm run build:html' assets/html&quot;,
</code></pre>
<pre><code>// 部署到 Amazon S3
&quot;deploy:prod&quot;: &quot;s3-cli sync ./dist/ s3://example-com/prod-site/&quot;,
</code></pre>
<pre><code>// 构建 favicon
&quot;build:favicon&quot;: &quot;node scripts/favicon.js&quot;,
</code></pre>
<p><a href="https://ruanyifeng.com/blog/2016/10/npm_scripts.html">参考链接</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-1"><a class="header" href="#简介-1">简介</a></h1>
<p>表示两种相互对立的状态间的切换，多用于触发「开/关」。</p>
<h1 id="基本用法"><a class="header" href="#基本用法">基本用法</a></h1>
<p>绑定<code>v-model</code>到一个<code>Boolean</code>类型的变量。可以使用<code>active-color</code>属性与<code>inactive-color</code>属性来设置开关的背景色。</p>
<pre><code class="language-vue">&lt;el-switch
  v-model=&quot;value&quot;
  active-color=&quot;#13ce66&quot;
  inactive-color=&quot;#ff4949&quot;&gt;
&lt;/el-switch&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value: true
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="文字描述"><a class="header" href="#文字描述">文字描述</a></h1>
<pre><code class="language-vue">&lt;el-switch
  style=&quot;display: block&quot;
  v-model=&quot;value2&quot;
  active-color=&quot;#13ce66&quot;
  inactive-color=&quot;#ff4949&quot;
  active-text=&quot;按月付费&quot;
  inactive-text=&quot;按年付费&quot;&gt;
&lt;/el-switch&gt;

</code></pre>
<h1 id="扩展的-value-类型"><a class="header" href="#扩展的-value-类型">扩展的 value 类型</a></h1>
<p>设置<code>active-value</code>和<code>inactive-value</code>属性，接受<code>Boolean</code>, <code>String</code>或<code>Number</code>类型的值。</p>
<pre><code class="language-vue">&lt;el-tooltip :content=&quot;'Switch value: ' + value&quot; placement=&quot;top&quot;&gt;
  &lt;el-switch
    v-model=&quot;value&quot;
    active-color=&quot;#13ce66&quot;
    inactive-color=&quot;#ff4949&quot;
    active-value=&quot;100&quot;
    inactive-value=&quot;0&quot;&gt;
  &lt;/el-switch&gt;
&lt;/el-tooltip&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value: '100'
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="禁用状态"><a class="header" href="#禁用状态">禁用状态</a></h1>
<pre><code class="language-vue">&lt;el-switch
  v-model=&quot;value1&quot;
  disabled&gt;
&lt;/el-switch&gt;
</code></pre>
<h1 id="属性事件和方法"><a class="header" href="#属性事件和方法">属性事件和方法</a></h1>
<h2 id="attributes"><a class="header" href="#attributes">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">boolean / string / number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">width</td><td style="text-align: left">switch 的宽度（像素）</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">40</td></tr>
<tr><td style="text-align: left">active-icon-class</td><td style="text-align: left">switch 打开时所显示图标的类名，设置此项会忽略 <code>active-text</code></td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">inactive-icon-class</td><td style="text-align: left">switch 关闭时所显示图标的类名，设置此项会忽略 <code>inactive-text</code></td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">active-text</td><td style="text-align: left">switch 打开时的文字描述</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">inactive-text</td><td style="text-align: left">switch 关闭时的文字描述</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">active-value</td><td style="text-align: left">switch 打开时的值</td><td style="text-align: left">boolean / string / number</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">inactive-value</td><td style="text-align: left">switch 关闭时的值</td><td style="text-align: left">boolean / string / number</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">active-color</td><td style="text-align: left">switch 打开时的背景色</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">#409EFF</td></tr>
<tr><td style="text-align: left">inactive-color</td><td style="text-align: left">switch 关闭时的背景色</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">#C0CCDA</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">switch 对应的 name 属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">validate-event</td><td style="text-align: left">改变 switch 状态时是否触发表单的校验</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">true</td></tr>
</tbody></table>
<h2 id="events"><a class="header" href="#events"><a href="https://element.eleme.cn/#/zh-CN/component/switch#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">switch 状态发生变化时的回调函数</td><td style="text-align: left">新状态的值</td></tr>
</tbody></table>
<h2 id="methods"><a class="header" href="#methods"><a href="https://element.eleme.cn/#/zh-CN/component/switch#methods">¶</a>Methods</a></h2>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">focus</td><td style="text-align: left">使 Switch 获取焦点</td><td style="text-align: left">-</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-树形控件"><a class="header" href="#tree-树形控件">Tree 树形控件</a></h1>
<p>用清晰的层级结构展示信息，可展开或折叠。</p>
<h1 id="基础用法"><a class="header" href="#基础用法">基础用法</a></h1>
<pre><code class="language-vue">&lt;el-tree :data=&quot;data&quot; :props=&quot;defaultProps&quot; @node-click=&quot;handleNodeClick&quot;&gt;&lt;/el-tree&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        data: [{
          label: '一级 1',
          children: [{
            label: '二级 1-1',
            children: [{
              label: '三级 1-1-1'
            }]
          }]
        }, {
          label: '一级 2',
          children: [{
            label: '二级 2-1',
            children: [{
              label: '三级 2-1-1'
            }]
          }, {
            label: '二级 2-2',
            children: [{
              label: '三级 2-2-1'
            }]
          }]
        }, {
          label: '一级 3',
          children: [{
            label: '二级 3-1',
            children: [{
              label: '三级 3-1-1'
            }]
          }, {
            label: '二级 3-2',
            children: [{
              label: '三级 3-2-1'
            }]
          }]
        }],
        defaultProps: {
          children: 'children',
          label: 'label'
        }
      };
    },
    methods: {
      handleNodeClick(data) {
        console.log(data);
      }
    }
  };
&lt;/script&gt;


</code></pre>
<h1 id="可选择"><a class="header" href="#可选择">可选择</a></h1>
<p>适用于需要选择层级时使用。</p>
<p>本例还展示了动态加载节点数据的方法。</p>
<pre><code class="language-vue">&lt;el-tree
  :props=&quot;props&quot;
  :load=&quot;loadNode&quot;
  lazy
  show-checkbox
  @check-change=&quot;handleCheckChange&quot;&gt;
&lt;/el-tree&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        props: {
          label: 'name',
          children: 'zones'
        },
        count: 1
      };
    },
    methods: {
      handleCheckChange(data, checked, indeterminate) {
        console.log(data, checked, indeterminate);
      },
      handleNodeClick(data) {
        console.log(data);
      },
      loadNode(node, resolve) {
        if (node.level === 0) {
          return resolve([{ name: 'region1' }, { name: 'region2' }]);
        }
        if (node.level &gt; 3) return resolve([]);

        var hasChild;
        if (node.data.name === 'region1') {
          hasChild = true;
        } else if (node.data.name === 'region2') {
          hasChild = false;
        } else {
          hasChild = Math.random() &gt; 0.5;
        }

        setTimeout(() =&gt; {
          var data;
          if (hasChild) {
            data = [{
              name: 'zone' + this.count++
            }, {
              name: 'zone' + this.count++
            }];
          } else {
            data = [];
          }

          resolve(data);
        }, 500);
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="懒加载自定义叶子节点"><a class="header" href="#懒加载自定义叶子节点">懒加载自定义叶子节点</a></h1>
<p>由于在点击节点时才进行该层数据的获取，默认情况下 Tree 无法预知某个节点是否为叶子节点，所以会为每个节点添加一个下拉按钮，如果节点没有下层数据，则点击后下拉按钮会消失。同时，你也可以提前告知 Tree 某个节点是否为叶子节点，从而避免在叶子节点前渲染下拉按钮。</p>
<pre><code class="language-vue">&lt;el-tree
  :props=&quot;props&quot;
  :load=&quot;loadNode&quot;
  lazy
  show-checkbox&gt;
&lt;/el-tree&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        props: {
          label: 'name',
          children: 'zones',
          isLeaf: 'leaf'
        },
      };
    },
    methods: {
      loadNode(node, resolve) {
        if (node.level === 0) {
          return resolve([{ name: 'region' }]);
        }
        if (node.level &gt; 1) return resolve([]);

        setTimeout(() =&gt; {
          const data = [{
            name: 'leaf',
            leaf: true
          }, {
            name: 'zone'
          }];

          resolve(data);
        }, 500);
      }
    }
  };
&lt;/script&gt;

</code></pre>
<h1 id="默认展开和默认选中"><a class="header" href="#默认展开和默认选中">默认展开和默认选中</a></h1>
<p>可将 Tree 的某些节点设置为默认展开或默认选中</p>
<p>分别通过<code>default-expanded-keys</code>和<code>default-checked-keys</code>设置默认展开和默认选中的节点。需要注意的是，此时必须设置<code>node-key</code>，其值为节点数据中的一个字段名，该字段在整棵树中是唯一的。</p>
<pre><code class="language-vue">&lt;el-tree
  :data=&quot;data&quot;
  show-checkbox
  node-key=&quot;id&quot;
  :default-expanded-keys=&quot;[2, 3]&quot;
  :default-checked-keys=&quot;[5]&quot;
  :props=&quot;defaultProps&quot;&gt;
&lt;/el-tree&gt;

   defaultProps: {
          children: 'children',
          label: 'label'
        }
v
</code></pre>
<h1 id="禁用状态-1"><a class="header" href="#禁用状态-1">禁用状态</a></h1>
<p>通过<code>disabled</code>设置禁用状态。</p>
<pre><code class="language-vue">&lt;el-tree
  :data=&quot;data&quot;
  show-checkbox
  node-key=&quot;id&quot;
  :default-expanded-keys=&quot;[2, 3]&quot;
  :default-checked-keys=&quot;[5]&quot;&gt;
&lt;/el-tree&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        data: [{
          id: 1,
          label: '一级 2',
          children: [{
            id: 3,
            label: '二级 2-1',
            children: [{
              id: 4,
              label: '三级 3-1-1'
            }, {
              id: 5,
              label: '三级 3-1-2',
              disabled: true
            }]
          }, {
            id: 2,
            label: '二级 2-2',
            disabled: true,
            children: [{
              id: 6,
              label: '三级 3-2-1'
            }, {
              id: 7,
              label: '三级 3-2-2',
              disabled: true
            }]
          }]
        }],
        defaultProps: {
          children: 'children',
          label: 'label'
        }
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="树节点的选择"><a class="header" href="#树节点的选择">树节点的选择</a></h1>
<p>本例展示如何获取和设置选中节点。获取和设置各有两种方式：通过 node 或通过 key。如果需要通过 key 来获取或设置，则必须设置<code>node-key</code>。</p>
<pre><code class="language-vue">&lt;el-tree
  :data=&quot;data&quot;
  show-checkbox
  default-expand-all
  node-key=&quot;id&quot;
  ref=&quot;tree&quot;
  highlight-current
  :props=&quot;defaultProps&quot;&gt;
&lt;/el-tree&gt;

&lt;div class=&quot;buttons&quot;&gt;
  &lt;el-button @click=&quot;getCheckedNodes&quot;&gt;通过 node 获取&lt;/el-button&gt;
  &lt;el-button @click=&quot;getCheckedKeys&quot;&gt;通过 key 获取&lt;/el-button&gt;
  &lt;el-button @click=&quot;setCheckedNodes&quot;&gt;通过 node 设置&lt;/el-button&gt;
  &lt;el-button @click=&quot;setCheckedKeys&quot;&gt;通过 key 设置&lt;/el-button&gt;
  &lt;el-button @click=&quot;resetChecked&quot;&gt;清空&lt;/el-button&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    methods: {
      getCheckedNodes() {
        console.log(this.$refs.tree.getCheckedNodes());
      },
      getCheckedKeys() {
        console.log(this.$refs.tree.getCheckedKeys());
      },
      setCheckedNodes() {
        this.$refs.tree.setCheckedNodes([{
          id: 5,
          label: '二级 2-1'
        }, {
          id: 9,
          label: '三级 1-1-1'
        }]);
      },
      setCheckedKeys() {
        this.$refs.tree.setCheckedKeys([3]);
      },
      resetChecked() {
        this.$refs.tree.setCheckedKeys([]);
      }
    },
</code></pre>
<h1 id="自定义节点内容"><a class="header" href="#自定义节点内容">自定义节点内容</a></h1>
<p>可以通过两种方法进行树节点内容的自定义：<code>render-content</code>和 scoped slot。使用<code>render-content</code>指定渲染函数，该函数返回需要的节点区内容即可。渲染函数的用法请参考 Vue 文档。使用 scoped slot 会传入两个参数<code>node</code>和<code>data</code>，分别表示当前节点的 Node 对象和当前节点的数据。注意：由于 jsfiddle 不支持 JSX 语法，所以<code>render-content</code>示例在 jsfiddle 中无法运行。但是在实际的项目中，只要正确地配置了相关依赖，就可以正常运行。</p>
<pre><code class="language-vue">&lt;div class=&quot;custom-tree-container&quot;&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;p&gt;使用 render-content&lt;/p&gt;
    &lt;el-tree
      :data=&quot;data&quot;
      show-checkbox
      node-key=&quot;id&quot;
      default-expand-all
      :expand-on-click-node=&quot;false&quot;
      :render-content=&quot;renderContent&quot;&gt;
    &lt;/el-tree&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;p&gt;使用 scoped slot&lt;/p&gt;
    &lt;el-tree
      :data=&quot;data&quot;
      show-checkbox
      node-key=&quot;id&quot;
      default-expand-all
      :expand-on-click-node=&quot;false&quot;&gt;
      &lt;span class=&quot;custom-tree-node&quot; slot-scope=&quot;{ node, data }&quot;&gt;
        &lt;span&gt;{{ node.label }}&lt;/span&gt;
        &lt;span&gt;
          &lt;el-button
            type=&quot;text&quot;
            size=&quot;mini&quot;
            @click=&quot;() =&gt; append(data)&quot;&gt;
            Append
          &lt;/el-button&gt;
          &lt;el-button
            type=&quot;text&quot;
            size=&quot;mini&quot;
            @click=&quot;() =&gt; remove(node, data)&quot;&gt;
            Delete
          &lt;/el-button&gt;
        &lt;/span&gt;
      &lt;/span&gt;
    &lt;/el-tree&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
  let id = 1000;

  export default {
    data() {
      const data = [{
        id: 1,
        label: '一级 1',
        children: [{
          id: 4,
          label: '二级 1-1',
          children: [{
            id: 9,
            label: '三级 1-1-1'
          }, {
            id: 10,
            label: '三级 1-1-2'
          }]
        }]
      }, {
        id: 2,
        label: '一级 2',
        children: [{
          id: 5,
          label: '二级 2-1'
        }, {
          id: 6,
          label: '二级 2-2'
        }]
      }, {
        id: 3,
        label: '一级 3',
        children: [{
          id: 7,
          label: '二级 3-1'
        }, {
          id: 8,
          label: '二级 3-2'
        }]
      }];
      return {
        data: JSON.parse(JSON.stringify(data)),
        data: JSON.parse(JSON.stringify(data))
      }
    },

    methods: {
      append(data) {
        const newChild = { id: id++, label: 'testtest', children: [] };
        if (!data.children) {
          this.$set(data, 'children', []);
        }
        data.children.push(newChild);
      },

      remove(node, data) {
        const parent = node.parent;
        const children = parent.data.children || parent.data;
        const index = children.findIndex(d =&gt; d.id === data.id);
        children.splice(index, 1);
      },

      renderContent(h, { node, data, store }) {
        return (
          &lt;span class=&quot;custom-tree-node&quot;&gt;
            &lt;span&gt;{node.label}&lt;/span&gt;
            &lt;span&gt;
              &lt;el-button size=&quot;mini&quot; type=&quot;text&quot; on-click={ () =&gt; this.append(data) }&gt;Append&lt;/el-button&gt;
              &lt;el-button size=&quot;mini&quot; type=&quot;text&quot; on-click={ () =&gt; this.remove(node, data) }&gt;Delete&lt;/el-button&gt;
            &lt;/span&gt;
          &lt;/span&gt;);
      }
    }
  };
&lt;/script&gt;

&lt;style&gt;
  .custom-tree-node {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 14px;
    padding-right: 8px;
  }
&lt;/style&gt;
</code></pre>
<h1 id="节点过滤"><a class="header" href="#节点过滤">节点过滤</a></h1>
<p>在需要对节点进行过滤时，调用 Tree 实例的<code>filter</code>方法，参数为关键字。需要注意的是，此时需要设置<code>filter-node-method</code>，值为过滤函数。</p>
<pre><code class="language-vue">&lt;el-input
  placeholder=&quot;输入关键字进行过滤&quot;
  v-model=&quot;filterText&quot;&gt;
&lt;/el-input&gt;

&lt;el-tree
  class=&quot;filter-tree&quot;
  :data=&quot;data&quot;
  :props=&quot;defaultProps&quot;
  default-expand-all
  :filter-node-method=&quot;filterNode&quot;
  ref=&quot;tree&quot;&gt;
&lt;/el-tree&gt;

&lt;script&gt;
  export default {
    watch: {
      filterText(val) {
        this.$refs.tree.filter(val);
      }
    },

    methods: {
      filterNode(value, data) {
        if (!value) return true;
        return data.label.indexOf(value) !== -1;
      }
    },

</code></pre>
<h1 id="手风琴模式"><a class="header" href="#手风琴模式">手风琴模式</a></h1>
<p>对于同一级的节点，每次只能展开一个</p>
<pre><code class="language-vue">&lt;el-tree
  :data=&quot;data&quot;
  :props=&quot;defaultProps&quot;
  accordion
  @node-click=&quot;handleNodeClick&quot;&gt;
&lt;/el-tree&gt;
</code></pre>
<h1 id="可拖拽节点"><a class="header" href="#可拖拽节点">可拖拽节点</a></h1>
<pre><code class="language-vue">&lt;el-tree
  :data=&quot;data&quot;
  node-key=&quot;id&quot;
  default-expand-all
  @node-drag-start=&quot;handleDragStart&quot;
  @node-drag-enter=&quot;handleDragEnter&quot;
  @node-drag-leave=&quot;handleDragLeave&quot;
  @node-drag-over=&quot;handleDragOver&quot;
  @node-drag-end=&quot;handleDragEnd&quot;
  @node-drop=&quot;handleDrop&quot;
  draggable
  :allow-drop=&quot;allowDrop&quot;
  :allow-drag=&quot;allowDrag&quot;&gt;
&lt;/el-tree&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        data: [{
          id: 1,
          label: '一级 1',
          children: [{
            id: 4,
            label: '二级 1-1',
            children: [{
              id: 9,
              label: '三级 1-1-1'
            }, {
              id: 10,
              label: '三级 1-1-2'
            }]
          }]
        }, {
          id: 2,
          label: '一级 2',
          children: [{
            id: 5,
            label: '二级 2-1'
          }, {
            id: 6,
            label: '二级 2-2'
          }]
        }, {
          id: 3,
          label: '一级 3',
          children: [{
            id: 7,
            label: '二级 3-1'
          }, {
            id: 8,
            label: '二级 3-2',
            children: [{
             id: 11,
              label: '三级 3-2-1'
            }, {
              id: 12,
              label: '三级 3-2-2'
            }, {
              id: 13,
              label: '三级 3-2-3'
            }]
          }]
        }],
        defaultProps: {
          children: 'children',
          label: 'label'
        }
      };
    },
    methods: {
      handleDragStart(node, ev) {
        console.log('drag start', node);
      },
      handleDragEnter(draggingNode, dropNode, ev) {
        console.log('tree drag enter: ', dropNode.label);
      },
      handleDragLeave(draggingNode, dropNode, ev) {
        console.log('tree drag leave: ', dropNode.label);
      },
      handleDragOver(draggingNode, dropNode, ev) {
        console.log('tree drag over: ', dropNode.label);
      },
      handleDragEnd(draggingNode, dropNode, dropType, ev) {
        console.log('tree drag end: ', dropNode &amp;&amp; dropNode.label, dropType);
      },
      handleDrop(draggingNode, dropNode, dropType, ev) {
        console.log('tree drop: ', dropNode.label, dropType);
      },
      allowDrop(draggingNode, dropNode, type) {
        if (dropNode.data.label === '二级 3-1') {
          return type !== 'inner';
        } else {
          return true;
        }
      },
      allowDrag(draggingNode) {
        return draggingNode.data.label.indexOf('三级 3-2-2') === -1;
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="属性事件和方法-1"><a class="header" href="#属性事件和方法-1">属性事件和方法</a></h1>
<h2 id="attributes-1"><a class="header" href="#attributes-1">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">data</td><td style="text-align: left">展示数据</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">empty-text</td><td style="text-align: left">内容为空的时候展示的文本</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">node-key</td><td style="text-align: left">每个树节点用来作为唯一标识的属性，整棵树应该是唯一的</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">props</td><td style="text-align: left">配置选项，具体看下表</td><td style="text-align: left">object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">render-after-expand</td><td style="text-align: left">是否在第一次展开某个树节点后才渲染其子节点</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">load</td><td style="text-align: left">加载子树数据的方法，仅当 lazy 属性为true 时生效</td><td style="text-align: left">function(node, resolve)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">render-content</td><td style="text-align: left">树节点的内容区的渲染 Function</td><td style="text-align: left">Function(h, { node, data, store }</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">highlight-current</td><td style="text-align: left">是否高亮当前选中节点，默认值是 false。</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">default-expand-all</td><td style="text-align: left">是否默认展开所有节点</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">expand-on-click-node</td><td style="text-align: left">是否在点击节点的时候展开或者收缩节点， 默认值为 true，如果为 false，则只有点箭头图标的时候才会展开或者收缩节点。</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">check-on-click-node</td><td style="text-align: left">是否在点击节点的时候选中节点，默认值为 false，即只有在点击复选框时才会选中节点。</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">auto-expand-parent</td><td style="text-align: left">展开子节点的时候是否自动展开父节点</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">default-expanded-keys</td><td style="text-align: left">默认展开的节点的 key 的数组</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">show-checkbox</td><td style="text-align: left">节点是否可被选择</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">check-strictly</td><td style="text-align: left">在显示复选框的情况下，是否严格的遵循父子不互相关联的做法，默认为 false</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">default-checked-keys</td><td style="text-align: left">默认勾选的节点的 key 的数组</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">current-node-key</td><td style="text-align: left">当前选中的节点</td><td style="text-align: left">string, number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">filter-node-method</td><td style="text-align: left">对树节点进行筛选时执行的方法，返回 true 表示这个节点可以显示，返回 false 则表示这个节点会被隐藏</td><td style="text-align: left">Function(value, data, node)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">accordion</td><td style="text-align: left">是否每次只打开一个同级树节点展开</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">indent</td><td style="text-align: left">相邻级节点间的水平缩进，单位为像素</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">16</td></tr>
<tr><td style="text-align: left">icon-class</td><td style="text-align: left">自定义树节点的图标</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">lazy</td><td style="text-align: left">是否懒加载子节点，需与 load 方法结合使用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">draggable</td><td style="text-align: left">是否开启拖拽节点功能</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">allow-drag</td><td style="text-align: left">判断节点能否被拖拽</td><td style="text-align: left">Function(node)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">allow-drop</td><td style="text-align: left">拖拽时判定目标节点能否被放置。<code>type</code> 参数有三种情况：'prev'、'inner' 和 'next'，分别表示放置在目标节点前、插入至目标节点和放置在目标节点后</td><td style="text-align: left">Function(draggingNode, dropNode, type)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h2 id="props"><a class="header" href="#props"><a href="https://element.eleme.cn/#/zh-CN/component/tree#props">¶</a>props</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">label</td><td style="text-align: left">指定节点标签为节点对象的某个属性值</td><td style="text-align: left">string, function(data, node)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">children</td><td style="text-align: left">指定子树为节点对象的某个属性值</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">指定节点选择框是否禁用为节点对象的某个属性值</td><td style="text-align: left">boolean, function(data, node)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">isLeaf</td><td style="text-align: left">指定节点是否为叶子节点，仅在指定了 lazy 属性的情况下生效</td><td style="text-align: left">boolean, function(data, node)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h2 id="方法"><a class="header" href="#方法"><a href="https://element.eleme.cn/#/zh-CN/component/tree#fang-fa">¶</a>方法</a></h2>
<p><code>Tree</code> 内部使用了 Node 类型的对象来包装用户传入的数据，用来保存目前节点的状态。 <code>Tree</code> 拥有如下方法：</p>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">filter</td><td style="text-align: left">对树节点进行筛选操作</td><td style="text-align: left">接收一个任意类型的参数，该参数会在 filter-node-method 中作为第一个参数</td></tr>
<tr><td style="text-align: left">updateKeyChildren</td><td style="text-align: left">通过 keys 设置节点子元素，使用此方法必须设置 node-key 属性</td><td style="text-align: left">(key, data) 接收两个参数，1. 节点 key 2. 节点数据的数组</td></tr>
<tr><td style="text-align: left">getCheckedNodes</td><td style="text-align: left">若节点可被选择（即 <code>show-checkbox</code> 为 <code>true</code>），则返回目前被选中的节点所组成的数组</td><td style="text-align: left">(leafOnly, includeHalfChecked) 接收两个 boolean 类型的参数，1. 是否只是叶子节点，默认值为 <code>false</code> 2. 是否包含半选节点，默认值为 <code>false</code></td></tr>
<tr><td style="text-align: left">setCheckedNodes</td><td style="text-align: left">设置目前勾选的节点，使用此方法必须设置 node-key 属性</td><td style="text-align: left">(nodes) 接收勾选节点数据的数组</td></tr>
<tr><td style="text-align: left">getCheckedKeys</td><td style="text-align: left">若节点可被选择（即 <code>show-checkbox</code> 为 <code>true</code>），则返回目前被选中的节点的 key 所组成的数组</td><td style="text-align: left">(leafOnly) 接收一个 boolean 类型的参数，若为 <code>true</code> 则仅返回被选中的叶子节点的 keys，默认值为 <code>false</code></td></tr>
<tr><td style="text-align: left">setCheckedKeys</td><td style="text-align: left">通过 keys 设置目前勾选的节点，使用此方法必须设置 node-key 属性</td><td style="text-align: left">(keys, leafOnly) 接收两个参数，1. 勾选节点的 key 的数组 2. boolean 类型的参数，若为 <code>true</code> 则仅设置叶子节点的选中状态，默认值为 <code>false</code></td></tr>
<tr><td style="text-align: left">setChecked</td><td style="text-align: left">通过 key / data 设置某个节点的勾选状态，使用此方法必须设置 node-key 属性</td><td style="text-align: left">(key/data, checked, deep) 接收三个参数，1. 勾选节点的 key 或者 data 2. boolean 类型，节点是否选中 3. boolean 类型，是否设置子节点 ，默认为 false</td></tr>
<tr><td style="text-align: left">getHalfCheckedNodes</td><td style="text-align: left">若节点可被选择（即 <code>show-checkbox</code> 为 <code>true</code>），则返回目前半选中的节点所组成的数组</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">getHalfCheckedKeys</td><td style="text-align: left">若节点可被选择（即 <code>show-checkbox</code> 为 <code>true</code>），则返回目前半选中的节点的 key 所组成的数组</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">getCurrentKey</td><td style="text-align: left">获取当前被选中节点的 key，使用此方法必须设置 node-key 属性，若没有节点被选中则返回 null</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">getCurrentNode</td><td style="text-align: left">获取当前被选中节点的 data，若没有节点被选中则返回 null</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">setCurrentKey</td><td style="text-align: left">通过 key 设置某个节点的当前选中状态，使用此方法必须设置 node-key 属性</td><td style="text-align: left">(key) 待被选节点的 key，若为 null 则取消当前高亮的节点</td></tr>
<tr><td style="text-align: left">setCurrentNode</td><td style="text-align: left">通过 node 设置某个节点的当前选中状态，使用此方法必须设置 node-key 属性</td><td style="text-align: left">(node) 待被选节点的 node</td></tr>
<tr><td style="text-align: left">getNode</td><td style="text-align: left">根据 data 或者 key 拿到 Tree 组件中的 node</td><td style="text-align: left">(data) 要获得 node 的 key 或者 data</td></tr>
<tr><td style="text-align: left">remove</td><td style="text-align: left">删除 Tree 中的一个节点，使用此方法必须设置 node-key 属性</td><td style="text-align: left">(data) 要删除的节点的 data 或者 node</td></tr>
<tr><td style="text-align: left">append</td><td style="text-align: left">为 Tree 中的一个节点追加一个子节点</td><td style="text-align: left">(data, parentNode) 接收两个参数，1. 要追加的子节点的 data 2. 子节点的 parent 的 data、key 或者 node</td></tr>
<tr><td style="text-align: left">insertBefore</td><td style="text-align: left">为 Tree 的一个节点的前面增加一个节点</td><td style="text-align: left">(data, refNode) 接收两个参数，1. 要增加的节点的 data 2. 要增加的节点的后一个节点的 data、key 或者 node</td></tr>
<tr><td style="text-align: left">insertAfter</td><td style="text-align: left">为 Tree 的一个节点的后面增加一个节点</td><td style="text-align: left">(data, refNode) 接收两个参数，1. 要增加的节点的 data 2. 要增加的节点的前一个节点的 data、key 或者 node</td></tr>
</tbody></table>
<h2 id="events-1"><a class="header" href="#events-1"><a href="https://element.eleme.cn/#/zh-CN/component/tree#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">node-click</td><td style="text-align: left">节点被点击时的回调</td><td style="text-align: left">共三个参数，依次为：传递给 <code>data</code> 属性的数组中该节点所对应的对象、节点对应的 Node、节点组件本身。</td></tr>
<tr><td style="text-align: left">node-contextmenu</td><td style="text-align: left">当某一节点被鼠标右键点击时会触发该事件</td><td style="text-align: left">共四个参数，依次为：event、传递给 <code>data</code> 属性的数组中该节点所对应的对象、节点对应的 Node、节点组件本身。</td></tr>
<tr><td style="text-align: left">check-change</td><td style="text-align: left">节点选中状态发生变化时的回调</td><td style="text-align: left">共三个参数，依次为：传递给 <code>data</code> 属性的数组中该节点所对应的对象、节点本身是否被选中、节点的子树中是否有被选中的节点</td></tr>
<tr><td style="text-align: left">check</td><td style="text-align: left">当复选框被点击的时候触发</td><td style="text-align: left">共两个参数，依次为：传递给 <code>data</code> 属性的数组中该节点所对应的对象、树目前的选中状态对象，包含 checkedNodes、checkedKeys、halfCheckedNodes、halfCheckedKeys 四个属性</td></tr>
<tr><td style="text-align: left">current-change</td><td style="text-align: left">当前选中节点变化时触发的事件</td><td style="text-align: left">共两个参数，依次为：当前节点的数据，当前节点的 Node 对象</td></tr>
<tr><td style="text-align: left">node-expand</td><td style="text-align: left">节点被展开时触发的事件</td><td style="text-align: left">共三个参数，依次为：传递给 <code>data</code> 属性的数组中该节点所对应的对象、节点对应的 Node、节点组件本身</td></tr>
<tr><td style="text-align: left">node-collapse</td><td style="text-align: left">节点被关闭时触发的事件</td><td style="text-align: left">共三个参数，依次为：传递给 <code>data</code> 属性的数组中该节点所对应的对象、节点对应的 Node、节点组件本身</td></tr>
<tr><td style="text-align: left">node-drag-start</td><td style="text-align: left">节点开始拖拽时触发的事件</td><td style="text-align: left">共两个参数，依次为：被拖拽节点对应的 Node、event</td></tr>
<tr><td style="text-align: left">node-drag-enter</td><td style="text-align: left">拖拽进入其他节点时触发的事件</td><td style="text-align: left">共三个参数，依次为：被拖拽节点对应的 Node、所进入节点对应的 Node、event</td></tr>
<tr><td style="text-align: left">node-drag-leave</td><td style="text-align: left">拖拽离开某个节点时触发的事件</td><td style="text-align: left">共三个参数，依次为：被拖拽节点对应的 Node、所离开节点对应的 Node、event</td></tr>
<tr><td style="text-align: left">node-drag-over</td><td style="text-align: left">在拖拽节点时触发的事件（类似浏览器的 mouseover 事件）</td><td style="text-align: left">共三个参数，依次为：被拖拽节点对应的 Node、当前进入节点对应的 Node、event</td></tr>
<tr><td style="text-align: left">node-drag-end</td><td style="text-align: left">拖拽结束时（可能未成功）触发的事件</td><td style="text-align: left">共四个参数，依次为：被拖拽节点对应的 Node、结束拖拽时最后进入的节点（可能为空）、被拖拽节点的放置位置（before、after、inner）、event</td></tr>
<tr><td style="text-align: left">node-drop</td><td style="text-align: left">拖拽成功完成时触发的事件</td><td style="text-align: left">共四个参数，依次为：被拖拽节点对应的 Node、结束拖拽时最后进入的节点、被拖拽节点的放置位置（before、after、inner）、event</td></tr>
</tbody></table>
<h2 id="scoped-slot"><a class="header" href="#scoped-slot"><a href="https://element.eleme.cn/#/zh-CN/component/tree#scoped-slot">¶</a>Scoped Slot</a></h2>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">—</td><td style="text-align: left">自定义树节点的内容，参数为 { node, data }</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backtop-回到顶部"><a class="header" href="#backtop-回到顶部">Backtop 回到顶部</a></h1>
<p>返回页面顶部的操作按钮</p>
<h1 id="基础用法-1"><a class="header" href="#基础用法-1">基础用法</a></h1>
<p>滑动页面即可看到右下方的按钮。</p>
<pre><code class="language-vue">&lt;template&gt;
  Scroll down to see the bottom-right button.
  &lt;el-backtop target=&quot;.page-component__scroll .el-scrollbar__wrap&quot;&gt;&lt;/el-backtop&gt;
&lt;/template&gt;
</code></pre>
<h1 id="自定义显示内容"><a class="header" href="#自定义显示内容">自定义显示内容</a></h1>
<p>显示区域被固定为 40px * 40px 的区域, 其中的内容可支持自定义。</p>
<pre><code class="language-vue">&lt;template&gt;
  Scroll down to see the bottom-right button.
  &lt;el-backtop target=&quot;.page-component__scroll .el-scrollbar__wrap&quot; :bottom=&quot;100&quot;&gt;
    &lt;div
      style=&quot;{
        height: 100%;
        width: 100%;
        background-color: #f2f5f6;
        box-shadow: 0 0 6px rgba(0,0,0, .12);
        text-align: center;
        line-height: 40px;
        color: #1989fa;
      }&quot;
    &gt;
      UP
    &lt;/div&gt;
  &lt;/el-backtop&gt;
&lt;/template&gt;
</code></pre>
<h1 id="属性事件和方法-2"><a class="header" href="#属性事件和方法-2">属性事件和方法</a></h1>
<h2 id="attributes-2"><a class="header" href="#attributes-2">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">target</td><td style="text-align: left">触发滚动的对象</td><td style="text-align: left">string</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">visibility-height</td><td style="text-align: left">滚动高度达到此参数值才出现</td><td style="text-align: left">number</td><td style="text-align: left"></td><td style="text-align: left">200</td></tr>
<tr><td style="text-align: left">right</td><td style="text-align: left">控制其显示位置, 距离页面右边距</td><td style="text-align: left">number</td><td style="text-align: left"></td><td style="text-align: left">40</td></tr>
<tr><td style="text-align: left">bottom</td><td style="text-align: left">控制其显示位置, 距离页面底部距离</td><td style="text-align: left">number</td><td style="text-align: left"></td><td style="text-align: left">40</td></tr>
</tbody></table>
<h2 id="events-2"><a class="header" href="#events-2"><a href="https://element.eleme.cn/#/zh-CN/component/backtop#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">click</td><td style="text-align: left">点击按钮触发的事件</td><td style="text-align: left">点击事件</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="card-卡片"><a class="header" href="#card-卡片">Card 卡片</a></h1>
<p>将信息聚合在卡片容器中展示。</p>
<h1 id="基础用法-2"><a class="header" href="#基础用法-2">基础用法</a></h1>
<p>包含标题，内容和操作。</p>
<p>Card 组件包括<code>header</code>和<code>body</code>部分，<code>header</code>部分需要有显式具名 slot 分发，同时也是可选的。</p>
<pre><code class="language-vue">&lt;el-card class=&quot;box-card&quot;&gt;
  &lt;div slot=&quot;header&quot; class=&quot;clearfix&quot;&gt;
    &lt;span&gt;卡片名称&lt;/span&gt;
    &lt;el-button style=&quot;float: right; padding: 3px 0&quot; type=&quot;text&quot;&gt;操作按钮&lt;/el-button&gt;
  &lt;/div&gt;
  &lt;div v-for=&quot;o in 4&quot; :key=&quot;o&quot; class=&quot;text item&quot;&gt;
    {{'列表内容 ' + o }}
  &lt;/div&gt;
&lt;/el-card&gt;

&lt;style&gt;
  .text {
    font-size: 14px;
  }

  .item {
    margin-bottom: 18px;
  }

  .clearfix:before,
  .clearfix:after {
    display: table;
    content: &quot;&quot;;
  }
  .clearfix:after {
    clear: both
  }

  .box-card {
    width: 480px;
  }
&lt;/style&gt;
</code></pre>
<h1 id="带图片"><a class="header" href="#带图片">带图片</a></h1>
<p>配置<code>body-style</code>属性来自定义<code>body</code>部分的<code>style</code>，我们还使用了布局组件。</p>
<pre><code class="language-vue">&lt;el-row&gt;
  &lt;el-col :span=&quot;8&quot; v-for=&quot;(o, index) in 2&quot; :key=&quot;o&quot; :offset=&quot;index &gt; 0 ? 2 : 0&quot;&gt;
    &lt;el-card :body-style=&quot;{ padding: '0px' }&quot;&gt;
      &lt;img src=&quot;https://shadow.elemecdn.com/app/element/hamburger.9cf7b091-55e9-11e9-a976-7f4d0b07eef6.png&quot; class=&quot;image&quot;&gt;
      &lt;div style=&quot;padding: 14px;&quot;&gt;
        &lt;span&gt;好吃的汉堡&lt;/span&gt;
        &lt;div class=&quot;bottom clearfix&quot;&gt;
          &lt;time class=&quot;time&quot;&gt;{{ currentDate }}&lt;/time&gt;
          &lt;el-button type=&quot;text&quot; class=&quot;button&quot;&gt;操作按钮&lt;/el-button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/el-card&gt;
  &lt;/el-col&gt;
&lt;/el-row&gt;

&lt;style&gt;
  .time {
    font-size: 13px;
    color: #999;
  }
  
  .bottom {
    margin-top: 13px;
    line-height: 12px;
  }

  .button {
    padding: 0;
    float: right;
  }

  .image {
    width: 100%;
    display: block;
  }

  .clearfix:before,
  .clearfix:after {
      display: table;
      content: &quot;&quot;;
  }
  
  .clearfix:after {
      clear: both
  }
&lt;/style&gt;

&lt;script&gt;
export default {
  data() {
    return {
      currentDate: new Date()
    };
  }
}
&lt;/script&gt;
</code></pre>
<h1 id="卡片阴影"><a class="header" href="#卡片阴影">卡片阴影</a></h1>
<p>通过<code>shadow</code>属性设置卡片阴影出现的时机：<code>always</code>、<code>hover</code>或<code>never</code>。</p>
<pre><code class="language-vue">&lt;el-row :gutter=&quot;12&quot;&gt;
  &lt;el-col :span=&quot;8&quot;&gt;
    &lt;el-card shadow=&quot;always&quot;&gt;
      总是显示
    &lt;/el-card&gt;
  &lt;/el-col&gt;
  &lt;el-col :span=&quot;8&quot;&gt;
    &lt;el-card shadow=&quot;hover&quot;&gt;
      鼠标悬浮时显示
    &lt;/el-card&gt;
  &lt;/el-col&gt;
  &lt;el-col :span=&quot;8&quot;&gt;
    &lt;el-card shadow=&quot;never&quot;&gt;
      从不显示
    &lt;/el-card&gt;
  &lt;/el-col&gt;
&lt;/el-row&gt;
</code></pre>
<h1 id="attributes-3"><a class="header" href="#attributes-3">Attributes</a></h1>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">header</td><td style="text-align: left">设置 header，也可以通过 <code>slot#header</code> 传入 DOM</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">body-style</td><td style="text-align: left">设置 body 的样式</td><td style="text-align: left">object</td><td style="text-align: left">—</td><td style="text-align: left">{ padding: '20px' }</td></tr>
<tr><td style="text-align: left">shadow</td><td style="text-align: left">设置阴影显示时机</td><td style="text-align: left">string</td><td style="text-align: left">always / hover / never</td><td style="text-align: left">always</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="form-表单"><a class="header" href="#form-表单">Form 表单</a></h1>
<p>由输入框、选择器、单选框、多选框等控件组成，用以收集、校验、提交数据</p>
<h1 id="典型表单"><a class="header" href="#典型表单">典型表单</a></h1>
<p>在 Form 组件中，每一个表单域由一个 Form-Item 组件构成，表单域中可以放置各种类型的表单控件，包括 Input、Select、Checkbox、Radio、Switch、DatePicker、TimePicker</p>
<pre><code class="language-vue">&lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; label-width=&quot;80px&quot;&gt;
  &lt;el-form-item label=&quot;活动名称&quot;&gt;
    &lt;el-input v-model=&quot;form.name&quot;&gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;活动区域&quot;&gt;
    &lt;el-select v-model=&quot;form.region&quot; placeholder=&quot;请选择活动区域&quot;&gt;
      &lt;el-option label=&quot;区域一&quot; value=&quot;shanghai&quot;&gt;&lt;/el-option&gt;
      &lt;el-option label=&quot;区域二&quot; value=&quot;beijing&quot;&gt;&lt;/el-option&gt;
    &lt;/el-select&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;活动时间&quot;&gt;
    &lt;el-col :span=&quot;11&quot;&gt;
      &lt;el-date-picker type=&quot;date&quot; placeholder=&quot;选择日期&quot; v-model=&quot;form.date1&quot; style=&quot;width: 100%;&quot;&gt;&lt;/el-date-picker&gt;
    &lt;/el-col&gt;
    &lt;el-col class=&quot;line&quot; :span=&quot;2&quot;&gt;-&lt;/el-col&gt;
    &lt;el-col :span=&quot;11&quot;&gt;
      &lt;el-time-picker placeholder=&quot;选择时间&quot; v-model=&quot;form.date2&quot; style=&quot;width: 100%;&quot;&gt;&lt;/el-time-picker&gt;
    &lt;/el-col&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;即时配送&quot;&gt;
    &lt;el-switch v-model=&quot;form.delivery&quot;&gt;&lt;/el-switch&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;活动性质&quot;&gt;
    &lt;el-checkbox-group v-model=&quot;form.type&quot;&gt;
      &lt;el-checkbox label=&quot;美食/餐厅线上活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;
      &lt;el-checkbox label=&quot;地推活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;
      &lt;el-checkbox label=&quot;线下主题活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;
      &lt;el-checkbox label=&quot;单纯品牌曝光&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;
    &lt;/el-checkbox-group&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;特殊资源&quot;&gt;
    &lt;el-radio-group v-model=&quot;form.resource&quot;&gt;
      &lt;el-radio label=&quot;线上品牌商赞助&quot;&gt;&lt;/el-radio&gt;
      &lt;el-radio label=&quot;线下场地免费&quot;&gt;&lt;/el-radio&gt;
    &lt;/el-radio-group&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;活动形式&quot;&gt;
    &lt;el-input type=&quot;textarea&quot; v-model=&quot;form.desc&quot;&gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item&gt;
    &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit&quot;&gt;立即创建&lt;/el-button&gt;
    &lt;el-button&gt;取消&lt;/el-button&gt;
  &lt;/el-form-item&gt;
&lt;/el-form&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        form: {
          name: '',
          region: '',
          date1: '',
          date2: '',
          delivery: false,
          type: [],
          resource: '',
          desc: ''
        }
      }
    },
    methods: {
      onSubmit() {
        console.log('submit!');
      }
    }
  }
&lt;/script&gt;
</code></pre>
<blockquote>
<p>即：当一个 form 元素中只有一个输入框时，在该输入框中按下回车应提交该表单。如果希望阻止这一默认行为，可以在 <code>&lt;el-form&gt;</code> 标签上添加 <code>@submit.native.prevent</code>。</p>
</blockquote>
<h1 id="行内表单"><a class="header" href="#行内表单">行内表单</a></h1>
<p>当垂直方向空间受限且表单较简单时，可以在一行内放置表单。</p>
<p>设置 <code>inline</code> 属性可以让表单域变为行内的表单域</p>
<pre><code class="language-vue">&lt;el-form :inline=&quot;true&quot; :model=&quot;formInline&quot; class=&quot;demo-form-inline&quot;&gt;
  &lt;el-form-item label=&quot;审批人&quot;&gt;
    &lt;el-input v-model=&quot;formInline.user&quot; placeholder=&quot;审批人&quot;&gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;活动区域&quot;&gt;
    &lt;el-select v-model=&quot;formInline.region&quot; placeholder=&quot;活动区域&quot;&gt;
      &lt;el-option label=&quot;区域一&quot; value=&quot;shanghai&quot;&gt;&lt;/el-option&gt;
      &lt;el-option label=&quot;区域二&quot; value=&quot;beijing&quot;&gt;&lt;/el-option&gt;
    &lt;/el-select&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item&gt;
    &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit&quot;&gt;查询&lt;/el-button&gt;
  &lt;/el-form-item&gt;
&lt;/el-form&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        formInline: {
          user: '',
          region: ''
        }
      }
    },
    methods: {
      onSubmit() {
        console.log('submit!');
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="对齐方式"><a class="header" href="#对齐方式">对齐方式</a></h1>
<p>通过设置 <code>label-position</code> 属性可以改变表单域标签的位置，可选值为 <code>top</code>、<code>left</code>，当设为 <code>top</code> 时标签会置于表单域的顶部</p>
<pre><code class="language-vue">&lt;el-radio-group v-model=&quot;labelPosition&quot; size=&quot;small&quot;&gt;
  &lt;el-radio-button label=&quot;left&quot;&gt;左对齐&lt;/el-radio-button&gt;
  &lt;el-radio-button label=&quot;right&quot;&gt;右对齐&lt;/el-radio-button&gt;
  &lt;el-radio-button label=&quot;top&quot;&gt;顶部对齐&lt;/el-radio-button&gt;
&lt;/el-radio-group&gt;
&lt;div style=&quot;margin: 20px;&quot;&gt;&lt;/div&gt;
&lt;el-form :label-position=&quot;labelPosition&quot; label-width=&quot;80px&quot; :model=&quot;formLabelAlign&quot;&gt;
  &lt;el-form-item label=&quot;名称&quot;&gt;
    &lt;el-input v-model=&quot;formLabelAlign.name&quot;&gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;活动区域&quot;&gt;
    &lt;el-input v-model=&quot;formLabelAlign.region&quot;&gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;活动形式&quot;&gt;
    &lt;el-input v-model=&quot;formLabelAlign.type&quot;&gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
&lt;/el-form&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        labelPosition: 'right',
        formLabelAlign: {
          name: '',
          region: '',
          type: ''
        }
      };
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="表单验证"><a class="header" href="#表单验证">表单验证</a></h1>
<p>在防止用户犯错的前提下，尽可能让用户更早地发现并纠正错误。</p>
<p>​	Form 组件提供了表单验证的功能，只需要通过 <code>rules</code> 属性传入约定的验证规则，并将 Form-Item 的 <code>prop</code> 属性设置为需校验的字段名即可。校验规则参见 <a href="https://github.com/yiminghe/async-validator">async-validator</a></p>
<pre><code class="language-vue">&lt;el-form :model=&quot;ruleForm&quot; :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt;
  &lt;el-form-item label=&quot;活动名称&quot; prop=&quot;name&quot;&gt;
    &lt;el-input v-model=&quot;ruleForm.name&quot;&gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;活动区域&quot; prop=&quot;region&quot;&gt;
    &lt;el-select v-model=&quot;ruleForm.region&quot; placeholder=&quot;请选择活动区域&quot;&gt;
      &lt;el-option label=&quot;区域一&quot; value=&quot;shanghai&quot;&gt;&lt;/el-option&gt;
      &lt;el-option label=&quot;区域二&quot; value=&quot;beijing&quot;&gt;&lt;/el-option&gt;
    &lt;/el-select&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;活动时间&quot; required&gt;
    &lt;el-col :span=&quot;11&quot;&gt;
      &lt;el-form-item prop=&quot;date1&quot;&gt;
        &lt;el-date-picker type=&quot;date&quot; placeholder=&quot;选择日期&quot; v-model=&quot;ruleForm.date1&quot; style=&quot;width: 100%;&quot;&gt;&lt;/el-date-picker&gt;
      &lt;/el-form-item&gt;
    &lt;/el-col&gt;
    &lt;el-col class=&quot;line&quot; :span=&quot;2&quot;&gt;-&lt;/el-col&gt;
    &lt;el-col :span=&quot;11&quot;&gt;
      &lt;el-form-item prop=&quot;date2&quot;&gt;
        &lt;el-time-picker placeholder=&quot;选择时间&quot; v-model=&quot;ruleForm.date2&quot; style=&quot;width: 100%;&quot;&gt;&lt;/el-time-picker&gt;
      &lt;/el-form-item&gt;
    &lt;/el-col&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;即时配送&quot; prop=&quot;delivery&quot;&gt;
    &lt;el-switch v-model=&quot;ruleForm.delivery&quot;&gt;&lt;/el-switch&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;活动性质&quot; prop=&quot;type&quot;&gt;
    &lt;el-checkbox-group v-model=&quot;ruleForm.type&quot;&gt;
      &lt;el-checkbox label=&quot;美食/餐厅线上活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;
      &lt;el-checkbox label=&quot;地推活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;
      &lt;el-checkbox label=&quot;线下主题活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;
      &lt;el-checkbox label=&quot;单纯品牌曝光&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;
    &lt;/el-checkbox-group&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;特殊资源&quot; prop=&quot;resource&quot;&gt;
    &lt;el-radio-group v-model=&quot;ruleForm.resource&quot;&gt;
      &lt;el-radio label=&quot;线上品牌商赞助&quot;&gt;&lt;/el-radio&gt;
      &lt;el-radio label=&quot;线下场地免费&quot;&gt;&lt;/el-radio&gt;
    &lt;/el-radio-group&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;活动形式&quot; prop=&quot;desc&quot;&gt;
    &lt;el-input type=&quot;textarea&quot; v-model=&quot;ruleForm.desc&quot;&gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item&gt;
    &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm('ruleForm')&quot;&gt;立即创建&lt;/el-button&gt;
    &lt;el-button @click=&quot;resetForm('ruleForm')&quot;&gt;重置&lt;/el-button&gt;
  &lt;/el-form-item&gt;
&lt;/el-form&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        ruleForm: {
          name: '',
          region: '',
          date1: '',
          date2: '',
          delivery: false,
          type: [],
          resource: '',
          desc: ''
        },
        rules: {
          name: [
            { required: true, message: '请输入活动名称', trigger: 'blur' },
            { min: 3, max: 5, message: '长度在 3 到 5 个字符', trigger: 'blur' }
          ],
          region: [
            { required: true, message: '请选择活动区域', trigger: 'change' }
          ],
          date1: [
            { type: 'date', required: true, message: '请选择日期', trigger: 'change' }
          ],
          date2: [
            { type: 'date', required: true, message: '请选择时间', trigger: 'change' }
          ],
          type: [
            { type: 'array', required: true, message: '请至少选择一个活动性质', trigger: 'change' }
          ],
          resource: [
            { required: true, message: '请选择活动资源', trigger: 'change' }
          ],
          desc: [
            { required: true, message: '请填写活动形式', trigger: 'blur' }
          ]
        }
      };
    },
    methods: {
      submitForm(formName) {
        this.$refs[formName].validate((valid) =&gt; {
          if (valid) {
            alert('submit!');
          } else {
            console.log('error submit!!');
            return false;
          }
        });
      },
      resetForm(formName) {
        this.$refs[formName].resetFields();
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h2 id="自定义校验规则"><a class="header" href="#自定义校验规则">自定义校验规则</a></h2>
<p>这个例子中展示了如何使用自定义验证规则来完成密码的二次验证。</p>
<p>本例还使用<code>status-icon</code>属性为输入框添加了表示校验结果的反馈图标。</p>
<pre><code class="language-vue">&lt;el-form :model=&quot;ruleForm&quot; status-icon :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt;
  &lt;el-form-item label=&quot;密码&quot; prop=&quot;pass&quot;&gt;
    &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm.pass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkPass&quot;&gt;
    &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm.checkPass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt;
    &lt;el-input v-model.number=&quot;ruleForm.age&quot;&gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item&gt;
    &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm('ruleForm')&quot;&gt;提交&lt;/el-button&gt;
    &lt;el-button @click=&quot;resetForm('ruleForm')&quot;&gt;重置&lt;/el-button&gt;
  &lt;/el-form-item&gt;
&lt;/el-form&gt;
&lt;script&gt;
  export default {
    data() {
      var checkAge = (rule, value, callback) =&gt; {
        if (!value) {
          return callback(new Error('年龄不能为空'));
        }
        setTimeout(() =&gt; {
          if (!Number.isInteger(value)) {
            callback(new Error('请输入数字值'));
          } else {
            if (value &lt; 18) {
              callback(new Error('必须年满18岁'));
            } else {
              callback();
            }
          }
        }, 1000);
      };
      var validatePass = (rule, value, callback) =&gt; {
        if (value === '') {
          callback(new Error('请输入密码'));
        } else {
          if (this.ruleForm.checkPass !== '') {
            this.$refs.ruleForm.validateField('checkPass');
          }
          callback();
        }
      };
      var validatePass2 = (rule, value, callback) =&gt; {
        if (value === '') {
          callback(new Error('请再次输入密码'));
        } else if (value !== this.ruleForm.pass) {
          callback(new Error('两次输入密码不一致!'));
        } else {
          callback();
        }
      };
      return {
        ruleForm: {
          pass: '',
          checkPass: '',
          age: ''
        },
        rules: {
          pass: [
            { validator: validatePass, trigger: 'blur' }
          ],
          checkPass: [
            { validator: validatePass2, trigger: 'blur' }
          ],
          age: [
            { validator: checkAge, trigger: 'blur' }
          ]
        }
      };
    },
    methods: {
      submitForm(formName) {
        this.$refs[formName].validate((valid) =&gt; {
          if (valid) {
            alert('submit!');
          } else {
            console.log('error submit!!');
            return false;
          }
        });
      },
      resetForm(formName) {
        this.$refs[formName].resetFields();
      }
    }
  }
&lt;/script&gt;
</code></pre>
<blockquote>
<p>自定义校验 callback 必须被调用。 更多高级用法可参考 <a href="https://github.com/yiminghe/async-validator">async-validator</a>。</p>
</blockquote>
<h1 id="动态增减表单项"><a class="header" href="#动态增减表单项">动态增减表单项</a></h1>
<p>除了在 Form 组件上一次性传递所有的验证规则外还可以在单个的表单域上传递属性的验证规则</p>
<pre><code class="language-vue">
        var index = this.dynamicValidateForm.domains.indexOf(item)
        if (index !== -1) {
          this.dynamicValidateForm.domains.splice(index, 1)
        }
      },
      addDomain() {
        this.dynamicValidateForm.domains.push({
          value: '',
          key: Date.now()
        });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="数字类型验证"><a class="header" href="#数字类型验证">数字类型验证</a></h1>
<p>数字类型的验证需要在 <code>v-model</code> 处加上 <code>.number</code> 的修饰符，这是 <code>Vue</code> 自身提供的用于将绑定值转化为 <code>number</code> 类型的修饰符。</p>
<pre><code class="language-vue">&lt;el-form :model=&quot;numberValidateForm&quot; ref=&quot;numberValidateForm&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt;
  &lt;el-form-item
    label=&quot;年龄&quot;
    prop=&quot;age&quot;
    :rules=&quot;[
      { required: true, message: '年龄不能为空'},
      { type: 'number', message: '年龄必须为数字值'}
    ]&quot;
  &gt;
    &lt;el-input type=&quot;age&quot; v-model.number=&quot;numberValidateForm.age&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item&gt;
    &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm('numberValidateForm')&quot;&gt;提交&lt;/el-button&gt;
    &lt;el-button @click=&quot;resetForm('numberValidateForm')&quot;&gt;重置&lt;/el-button&gt;
  &lt;/el-form-item&gt;
&lt;/el-form&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        numberValidateForm: {
          age: ''
        }
      };
    },
    methods: {
      submitForm(formName) {
        this.$refs[formName].validate((valid) =&gt; {
          if (valid) {
            alert('submit!');
          } else {
            console.log('error submit!!');
            return false;
          }
        });
      },
      resetForm(formName) {
        this.$refs[formName].resetFields();
      }
    }
  }
&lt;/script&gt;

</code></pre>
<blockquote>
<p>嵌套在 <code>el-form-item</code> 中的 <code>el-form-item</code> 标签宽度默认为零，不会继承 <code>el-form</code> 的 <code>label-width</code>。如果需要可以为其单独设置 <code>label-width</code> 属性。</p>
</blockquote>
<h1 id="表单内组件尺寸控制"><a class="header" href="#表单内组件尺寸控制">表单内组件尺寸控制</a></h1>
<p>通过设置 Form 上的 <code>size</code> 属性可以使该表单内所有可调节大小的组件继承该尺寸。Form-Item 也具有该属性。</p>
<p>如果希望某个表单项或某个表单组件的尺寸不同于 Form 上的<code>size</code>属性，直接为这个表单项或表单组件设置自己的<code>size</code>即可</p>
<pre><code class="language-vue">&lt;el-form ref=&quot;form&quot; :model=&quot;sizeForm&quot; label-width=&quot;80px&quot; size=&quot;mini&quot;&gt;
  &lt;el-form-item label=&quot;活动名称&quot;&gt;
    &lt;el-input v-model=&quot;sizeForm.name&quot;&gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;活动区域&quot;&gt;
    &lt;el-select v-model=&quot;sizeForm.region&quot; placeholder=&quot;请选择活动区域&quot;&gt;
      &lt;el-option label=&quot;区域一&quot; value=&quot;shanghai&quot;&gt;&lt;/el-option&gt;
      &lt;el-option label=&quot;区域二&quot; value=&quot;beijing&quot;&gt;&lt;/el-option&gt;
    &lt;/el-select&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;活动时间&quot;&gt;
    &lt;el-col :span=&quot;11&quot;&gt;
      &lt;el-date-picker type=&quot;date&quot; placeholder=&quot;选择日期&quot; v-model=&quot;sizeForm.date1&quot; style=&quot;width: 100%;&quot;&gt;&lt;/el-date-picker&gt;
    &lt;/el-col&gt;
    &lt;el-col class=&quot;line&quot; :span=&quot;2&quot;&gt;-&lt;/el-col&gt;
    &lt;el-col :span=&quot;11&quot;&gt;
      &lt;el-time-picker placeholder=&quot;选择时间&quot; v-model=&quot;sizeForm.date2&quot; style=&quot;width: 100%;&quot;&gt;&lt;/el-time-picker&gt;
    &lt;/el-col&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;活动性质&quot;&gt;
    &lt;el-checkbox-group v-model=&quot;sizeForm.type&quot;&gt;
      &lt;el-checkbox-button label=&quot;美食/餐厅线上活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox-button&gt;
      &lt;el-checkbox-button label=&quot;地推活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox-button&gt;
      &lt;el-checkbox-button label=&quot;线下主题活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox-button&gt;
    &lt;/el-checkbox-group&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;特殊资源&quot;&gt;
    &lt;el-radio-group v-model=&quot;sizeForm.resource&quot; size=&quot;medium&quot;&gt;
      &lt;el-radio border label=&quot;线上品牌商赞助&quot;&gt;&lt;/el-radio&gt;
      &lt;el-radio border label=&quot;线下场地免费&quot;&gt;&lt;/el-radio&gt;
    &lt;/el-radio-group&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item size=&quot;large&quot;&gt;
    &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit&quot;&gt;立即创建&lt;/el-button&gt;
    &lt;el-button&gt;取消&lt;/el-button&gt;
  &lt;/el-form-item&gt;
&lt;/el-form&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        sizeForm: {
          name: '',
          region: '',
          date1: '',
          date2: '',
          delivery: false,
          type: [],
          resource: '',
          desc: ''
        }
      };
    },
    methods: {
      onSubmit() {
        console.log('submit!');
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="属性事件和方法-3"><a class="header" href="#属性事件和方法-3">属性事件和方法</a></h1>
<h2 id="form-attributes"><a class="header" href="#form-attributes">Form Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">model</td><td style="text-align: left">表单数据对象</td><td style="text-align: left">object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">rules</td><td style="text-align: left">表单验证规则</td><td style="text-align: left">object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">inline</td><td style="text-align: left">行内表单模式</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">label-position</td><td style="text-align: left">表单域标签的位置，如果值为 left 或者 right 时，则需要设置 <code>label-width</code></td><td style="text-align: left">string</td><td style="text-align: left">right/left/top</td><td style="text-align: left">right</td></tr>
<tr><td style="text-align: left">label-width</td><td style="text-align: left">表单域标签的宽度，例如 '50px'。作为 Form 直接子元素的 form-item 会继承该值。支持 <code>auto</code>。</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">label-suffix</td><td style="text-align: left">表单域标签的后缀</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">hide-required-asterisk</td><td style="text-align: left">是否显示必填字段的标签旁边的红色星号</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">show-message</td><td style="text-align: left">是否显示校验错误信息</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">inline-message</td><td style="text-align: left">是否以行内形式展示校验信息</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">status-icon</td><td style="text-align: left">是否在输入框中显示校验结果反馈图标</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">validate-on-rule-change</td><td style="text-align: left">是否在 <code>rules</code> 属性改变后立即触发一次验证</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">用于控制该表单内组件的尺寸</td><td style="text-align: left">string</td><td style="text-align: left">medium / small / mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用该表单内的所有组件。若设置为 true，则表单内组件上的 disabled 属性不再生效</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
</tbody></table>
<h2 id="form-methods"><a class="header" href="#form-methods"><a href="https://element.eleme.cn/#/zh-CN/component/form#form-methods">¶</a>Form Methods</a></h2>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">validate</td><td style="text-align: left">对整个表单进行校验的方法，参数为一个回调函数。该回调函数会在校验结束后被调用，并传入两个参数：是否校验成功和未通过校验的字段。若不传入回调函数，则会返回一个 promise</td><td style="text-align: left">Function(callback: Function(boolean, object))</td></tr>
<tr><td style="text-align: left">validateField</td><td style="text-align: left">对部分表单字段进行校验的方法</td><td style="text-align: left">Function(props: array | string, callback: Function(errorMessage: string))</td></tr>
<tr><td style="text-align: left">resetFields</td><td style="text-align: left">对整个表单进行重置，将所有字段值重置为初始值并移除校验结果</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">clearValidate</td><td style="text-align: left">移除表单项的校验结果。传入待移除的表单项的 prop 属性或者 prop 组成的数组，如不传则移除整个表单的校验结果</td><td style="text-align: left">Function(props: array | string)</td></tr>
</tbody></table>
<h2 id="form-events"><a class="header" href="#form-events"><a href="https://element.eleme.cn/#/zh-CN/component/form#form-events">¶</a>Form Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">validate</td><td style="text-align: left">任一表单项被校验后触发</td><td style="text-align: left">被校验的表单项 prop 值，校验是否通过，错误消息（如果存在）</td></tr>
</tbody></table>
<h2 id="form-item-attributes"><a class="header" href="#form-item-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/form#form-item-attributes">¶</a>Form-Item Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">prop</td><td style="text-align: left">表单域 model 字段，在使用 validate、resetFields 方法的情况下，该属性是必填的</td><td style="text-align: left">string</td><td style="text-align: left">传入 Form 组件的 <code>model</code> 中的字段</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">label</td><td style="text-align: left">标签文本</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">label-width</td><td style="text-align: left">表单域标签的的宽度，例如 '50px'。支持 <code>auto</code>。</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">required</td><td style="text-align: left">是否必填，如不设置，则会根据校验规则自动生成</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">rules</td><td style="text-align: left">表单验证规则</td><td style="text-align: left">object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">error</td><td style="text-align: left">表单域验证错误信息, 设置该值会使表单验证状态变为<code>error</code>，并显示该错误信息</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">show-message</td><td style="text-align: left">是否显示校验错误信息</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">inline-message</td><td style="text-align: left">以行内形式展示校验信息</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">用于控制该表单域下组件的尺寸</td><td style="text-align: left">string</td><td style="text-align: left">medium / small / mini</td><td style="text-align: left">-</td></tr>
</tbody></table>
<h2 id="form-item-slot"><a class="header" href="#form-item-slot"><a href="https://element.eleme.cn/#/zh-CN/component/form#form-item-slot">¶</a>Form-Item Slot</a></h2>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">—</td><td style="text-align: left">Form Item 的内容</td></tr>
<tr><td style="text-align: left">label</td><td style="text-align: left">标签文本的内容</td></tr>
</tbody></table>
<h2 id="form-item-scoped-slot"><a class="header" href="#form-item-scoped-slot"><a href="https://element.eleme.cn/#/zh-CN/component/form#form-item-scoped-slot">¶</a>Form-Item Scoped Slot</a></h2>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">error</td><td style="text-align: left">自定义表单校验信息的显示方式，参数为 { error }</td></tr>
</tbody></table>
<h2 id="form-item-methods"><a class="header" href="#form-item-methods"><a href="https://element.eleme.cn/#/zh-CN/component/form#form-item-methods">¶</a>Form-Item Methods</a></h2>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">resetField</td><td style="text-align: left">对该表单项进行重置，将其值重置为初始值并移除校验结果</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">clearValidate</td><td style="text-align: left">移除该表单项的校验结果</td><td style="text-align: left"></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-图片"><a class="header" href="#image-图片">Image 图片</a></h1>
<p>图片容器，在保留原生img的特性下，支持懒加载，自定义占位、加载失败等</p>
<h1 id="基础用法-3"><a class="header" href="#基础用法-3">基础用法</a></h1>
<p>可通过<code>fit</code>确定图片如何适应到容器框，同原生 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit">object-fit</a>。</p>
<pre><code class="language-vue">&lt;div class=&quot;demo-image&quot;&gt;
  &lt;div class=&quot;block&quot; v-for=&quot;fit in fits&quot; :key=&quot;fit&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;{{ fit }}&lt;/span&gt;
    &lt;el-image
      style=&quot;width: 100px; height: 100px&quot;
      :src=&quot;url&quot;
      :fit=&quot;fit&quot;&gt;&lt;/el-image&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        fits: ['fill', 'contain', 'cover', 'none', 'scale-down'],
        url: 'https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg'
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="占位内容"><a class="header" href="#占位内容">占位内容</a></h1>
<p>可通过<code>slot = placeholder</code>可自定义占位内容</p>
<pre><code class="language-vue">&lt;div class=&quot;demo-image__placeholder&quot;&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;默认&lt;/span&gt;
    &lt;el-image :src=&quot;src&quot;&gt;&lt;/el-image&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;自定义&lt;/span&gt;
    &lt;el-image :src=&quot;src&quot;&gt;
      &lt;div slot=&quot;placeholder&quot; class=&quot;image-slot&quot;&gt;
        加载中&lt;span class=&quot;dot&quot;&gt;...&lt;/span&gt;
      &lt;/div&gt;
    &lt;/el-image&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        src: 'https://cube.elemecdn.com/6/94/4d3ea53c084bad6931a56d5158a48jpeg.jpeg'
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="加载失败"><a class="header" href="#加载失败">加载失败</a></h1>
<p>可通过<code>slot = error</code>可自定义加载失败内容</p>
<pre><code class="language-vue">&lt;div class=&quot;demo-image__error&quot;&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;默认&lt;/span&gt;
    &lt;el-image&gt;&lt;/el-image&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;自定义&lt;/span&gt;
    &lt;el-image&gt;
      &lt;div slot=&quot;error&quot; class=&quot;image-slot&quot;&gt;
        &lt;i class=&quot;el-icon-picture-outline&quot;&gt;&lt;/i&gt;
      &lt;/div&gt;
    &lt;/el-image&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h1 id="懒加载"><a class="header" href="#懒加载">懒加载</a></h1>
<p>可通过<code>lazy</code>开启懒加载功能，当图片滚动到可视范围内才会加载。可通过<code>scroll-container</code>来设置滚动容器，若未定义，则为最近一个<code>overflow</code>值为<code>auto</code>或<code>scroll</code>的父元素。</p>
<pre><code class="language-vue">&lt;div class=&quot;demo-image__lazy&quot;&gt;
  &lt;el-image v-for=&quot;url in urls&quot; :key=&quot;url&quot; :src=&quot;url&quot; lazy&gt;&lt;/el-image&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        urls: [
          'https://fuss10.elemecdn.com/a/3f/3302e58f9a181d2509f3dc0fa68b0jpeg.jpeg',
          'https://fuss10.elemecdn.com/1/34/19aa98b1fcb2781c4fba33d850549jpeg.jpeg',
          'https://fuss10.elemecdn.com/0/6f/e35ff375812e6b0020b6b4e8f9583jpeg.jpeg',
          'https://fuss10.elemecdn.com/9/bb/e27858e973f5d7d3904835f46abbdjpeg.jpeg',
          'https://fuss10.elemecdn.com/d/e6/c4d93a3805b3ce3f323f7974e6f78jpeg.jpeg',
          'https://fuss10.elemecdn.com/3/28/bbf893f792f03a54408b3b7a7ebf0jpeg.jpeg',
          'https://fuss10.elemecdn.com/2/11/6535bcfb26e4c79b48ddde44f4b6fjpeg.jpeg'
        ]
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="大图预览"><a class="header" href="#大图预览">大图预览</a></h1>
<p>可通过 <code>previewSrcList</code> 开启预览大图的功能。</p>
<pre><code class="language-vue">&lt;div class=&quot;demo-image__preview&quot;&gt;
  &lt;el-image 
    style=&quot;width: 100px; height: 100px&quot;
    :src=&quot;url&quot; 
    :preview-src-list=&quot;srcList&quot;&gt;
  &lt;/el-image&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        url: 'https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg',
        srcList: [
          'https://fuss10.elemecdn.com/8/27/f01c15bb73e1ef3793e64e6b7bbccjpeg.jpeg',
          'https://fuss10.elemecdn.com/1/8e/aeffeb4de74e2fde4bd74fc7b4486jpeg.jpeg'
        ]
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="属性事件和方法-4"><a class="header" href="#属性事件和方法-4">属性事件和方法</a></h1>
<h2 id="attributes-4"><a class="header" href="#attributes-4">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">src</td><td style="text-align: left">图片源，同原生</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">fit</td><td style="text-align: left">确定图片如何适应容器框，同原生 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit">object-fit</a></td><td style="text-align: left">string</td><td style="text-align: left">fill / contain / cover / none / scale-down</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">alt</td><td style="text-align: left">原生 alt</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">referrer-policy</td><td style="text-align: left">原生 referrerPolicy</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">lazy</td><td style="text-align: left">是否开启懒加载</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">scroll-container</td><td style="text-align: left">开启懒加载后，监听 scroll 事件的容器</td><td style="text-align: left">string / HTMLElement</td><td style="text-align: left">—</td><td style="text-align: left">最近一个 overflow 值为 auto 或 scroll 的父元素</td></tr>
<tr><td style="text-align: left">preview-src-list</td><td style="text-align: left">开启图片预览功能</td><td style="text-align: left">Array</td><td style="text-align: left">—</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">z-index</td><td style="text-align: left">设置图片预览的 z-index</td><td style="text-align: left">Number</td><td style="text-align: left">—</td><td style="text-align: left">2000</td></tr>
</tbody></table>
<h2 id="events-3"><a class="header" href="#events-3"><a href="https://element.eleme.cn/#/zh-CN/component/image#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">load</td><td style="text-align: left">图片加载成功触发</td><td style="text-align: left">(e: Event)</td></tr>
<tr><td style="text-align: left">error</td><td style="text-align: left">图片加载失败触发</td><td style="text-align: left">(e: Error)</td></tr>
</tbody></table>
<h2 id="slots"><a class="header" href="#slots"><a href="https://element.eleme.cn/#/zh-CN/component/image#slots">¶</a>Slots</a></h2>
<table><thead><tr><th style="text-align: left">名称</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">placeholder</td><td style="text-align: left">图片未加载的占位内容</td></tr>
<tr><td style="text-align: left">error</td><td style="text-align: left">加载失败的内容</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="breadcrumb-面包屑"><a class="header" href="#breadcrumb-面包屑">Breadcrumb 面包屑</a></h1>
<p>显示当前页面的路径，快速返回之前的任意页面。</p>
<h1 id="基础用法-4"><a class="header" href="#基础用法-4">基础用法</a></h1>
<p>在<code>el-breadcrumb</code>中使用<code>el-breadcrumb-item</code>标签表示从首页开始的每一级。Element 提供了一个<code>separator</code>属性，在<code>el-breadcrumb</code>标签中设置它来决定分隔符，它只能是字符串，默认为斜杠<code>/</code>。</p>
<pre><code class="language-vue">&lt;el-breadcrumb separator=&quot;/&quot;&gt;
  &lt;el-breadcrumb-item :to=&quot;{ path: '/' }&quot;&gt;首页&lt;/el-breadcrumb-item&gt;
  &lt;el-breadcrumb-item&gt;&lt;a href=&quot;/&quot;&gt;活动管理&lt;/a&gt;&lt;/el-breadcrumb-item&gt;
  &lt;el-breadcrumb-item&gt;活动列表&lt;/el-breadcrumb-item&gt;
  &lt;el-breadcrumb-item&gt;活动详情&lt;/el-breadcrumb-item&gt;
&lt;/el-breadcrumb&gt;
</code></pre>
<h1 id="图标分隔符"><a class="header" href="#图标分隔符">图标分隔符</a></h1>
<p>通过设置 <code>separator-class</code> 可使用相应的 <code>iconfont</code> 作为分隔符，注意这将使 <code>separator</code> 设置失效</p>
<pre><code class="language-vue">&lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt;
  &lt;el-breadcrumb-item :to=&quot;{ path: '/' }&quot;&gt;首页&lt;/el-breadcrumb-item&gt;
  &lt;el-breadcrumb-item&gt;活动管理&lt;/el-breadcrumb-item&gt;
  &lt;el-breadcrumb-item&gt;活动列表&lt;/el-breadcrumb-item&gt;
  &lt;el-breadcrumb-item&gt;活动详情&lt;/el-breadcrumb-item&gt;
&lt;/el-breadcrumb&gt;
</code></pre>
<h1 id="属性事件和方法-5"><a class="header" href="#属性事件和方法-5">属性事件和方法</a></h1>
<h2 id="breadcrumb-attributes"><a class="header" href="#breadcrumb-attributes">Breadcrumb Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">separator</td><td style="text-align: left">分隔符</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">斜杠'/'</td></tr>
<tr><td style="text-align: left">separator-class</td><td style="text-align: left">图标分隔符 class</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">-</td></tr>
</tbody></table>
<h2 id="breadcrumb-item-attributes"><a class="header" href="#breadcrumb-item-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/breadcrumb#breadcrumb-item-attributes">¶</a>Breadcrumb Item Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">to</td><td style="text-align: left">路由跳转对象，同 <code>vue-router</code> 的 <code>to</code></td><td style="text-align: left">string/object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">replace</td><td style="text-align: left">在使用 to 进行路由跳转时，启用 replace 将不会向 history 添加新记录</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dropdown-下拉菜单"><a class="header" href="#dropdown-下拉菜单">Dropdown 下拉菜单</a></h1>
<p>将动作或菜单折叠到下拉菜单中。</p>
<h1 id="基础用法-5"><a class="header" href="#基础用法-5">基础用法</a></h1>
<p>移动到下拉菜单上，展开更多操作。</p>
<p>通过组件<code>slot</code>来设置下拉触发的元素以及需要通过具名<code>slot</code>为<code>dropdown</code> 来设置下拉菜单。默认情况下，下拉按钮只要<code>hover</code>即可，无需点击也会显示下拉菜单。</p>
<pre><code class="language-vue">&lt;el-dropdown&gt;
  &lt;span class=&quot;el-dropdown-link&quot;&gt;
    下拉菜单&lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt;
  &lt;/span&gt;
  &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;
    &lt;el-dropdown-item&gt;黄金糕&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item&gt;狮子头&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item&gt;螺蛳粉&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item disabled&gt;双皮奶&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item divided&gt;蚵仔煎&lt;/el-dropdown-item&gt;
  &lt;/el-dropdown-menu&gt;
&lt;/el-dropdown&gt;

&lt;style&gt;
  .el-dropdown-link {
    cursor: pointer;
    color: #409EFF;
  }
  .el-icon-arrow-down {
    font-size: 12px;
  }
&lt;/style&gt;
</code></pre>
<h1 id="可使用按钮触发下拉菜单"><a class="header" href="#可使用按钮触发下拉菜单">可使用按钮触发下拉菜单。</a></h1>
<p>设置<code>split-button</code>属性来让触发下拉元素呈现为按钮组，左边是功能按钮，右边是触发下拉菜单的按钮，设置为<code>true</code>即可。</p>
<pre><code class="language-vue">&lt;el-dropdown&gt;
  &lt;el-button type=&quot;primary&quot;&gt;
    更多菜单&lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt;
  &lt;/el-button&gt;
  &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;
    &lt;el-dropdown-item&gt;黄金糕&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item&gt;狮子头&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item&gt;螺蛳粉&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item&gt;双皮奶&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item&gt;蚵仔煎&lt;/el-dropdown-item&gt;
  &lt;/el-dropdown-menu&gt;
&lt;/el-dropdown&gt;
&lt;el-dropdown split-button type=&quot;primary&quot; @click=&quot;handleClick&quot;&gt;
  更多菜单
  &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;
    &lt;el-dropdown-item&gt;黄金糕&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item&gt;狮子头&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item&gt;螺蛳粉&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item&gt;双皮奶&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item&gt;蚵仔煎&lt;/el-dropdown-item&gt;
  &lt;/el-dropdown-menu&gt;
&lt;/el-dropdown&gt;

&lt;style&gt;
  .el-dropdown {
    vertical-align: top;
  }
  .el-dropdown + .el-dropdown {
    margin-left: 15px;
  }
  .el-icon-arrow-down {
    font-size: 12px;
  }
&lt;/style&gt;

&lt;script&gt;
  export default {
    methods: {
      handleClick() {
        alert('button click');
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="触发方式"><a class="header" href="#触发方式">触发方式</a></h1>
<p>可以配置 click 激活或者 hover 激活。</p>
<p>在<code>trigger</code>属性设置为<code>click</code>即可。</p>
<pre><code class="language-vue">&lt;el-row class=&quot;block-col-2&quot;&gt;
  &lt;el-col :span=&quot;12&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;hover 激活&lt;/span&gt;
    &lt;el-dropdown&gt;
      &lt;span class=&quot;el-dropdown-link&quot;&gt;
        下拉菜单&lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt;
      &lt;/span&gt;
      &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;
        &lt;el-dropdown-item icon=&quot;el-icon-plus&quot;&gt;黄金糕&lt;/el-dropdown-item&gt;
        &lt;el-dropdown-item icon=&quot;el-icon-circle-plus&quot;&gt;狮子头&lt;/el-dropdown-item&gt;
        &lt;el-dropdown-item icon=&quot;el-icon-circle-plus-outline&quot;&gt;螺蛳粉&lt;/el-dropdown-item&gt;
        &lt;el-dropdown-item icon=&quot;el-icon-check&quot;&gt;双皮奶&lt;/el-dropdown-item&gt;
        &lt;el-dropdown-item icon=&quot;el-icon-circle-check&quot;&gt;蚵仔煎&lt;/el-dropdown-item&gt;
      &lt;/el-dropdown-menu&gt;
    &lt;/el-dropdown&gt;
  &lt;/el-col&gt;
  &lt;el-col :span=&quot;12&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;click 激活&lt;/span&gt;
    &lt;el-dropdown trigger=&quot;click&quot;&gt;
      &lt;span class=&quot;el-dropdown-link&quot;&gt;
        下拉菜单&lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt;
      &lt;/span&gt;
      &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;
        &lt;el-dropdown-item icon=&quot;el-icon-plus&quot;&gt;黄金糕&lt;/el-dropdown-item&gt;
        &lt;el-dropdown-item icon=&quot;el-icon-circle-plus&quot;&gt;狮子头&lt;/el-dropdown-item&gt;
        &lt;el-dropdown-item icon=&quot;el-icon-circle-plus-outline&quot;&gt;螺蛳粉&lt;/el-dropdown-item&gt;
        &lt;el-dropdown-item icon=&quot;el-icon-check&quot;&gt;双皮奶&lt;/el-dropdown-item&gt;
        &lt;el-dropdown-item icon=&quot;el-icon-circle-check&quot;&gt;蚵仔煎&lt;/el-dropdown-item&gt;
      &lt;/el-dropdown-menu&gt;
    &lt;/el-dropdown&gt;
  &lt;/el-col&gt;
&lt;/el-row&gt;

&lt;style&gt;
  .el-dropdown-link {
    cursor: pointer;
    color: #409EFF;
  }
  .el-icon-arrow-down {
    font-size: 12px;
  }
  .demonstration {
    display: block;
    color: #8492a6;
    font-size: 14px;
    margin-bottom: 20px;
  }
&lt;/style&gt;
</code></pre>
<h1 id="菜单隐藏方式"><a class="header" href="#菜单隐藏方式">菜单隐藏方式</a></h1>
<p>可以<code>hide-on-click</code>属性来配置。</p>
<p>下拉菜单默认在点击菜单项后会被隐藏，将<code>hide-on-click</code>属性默认为<code>false</code>可以关闭此功能。</p>
<pre><code class="language-vue">&lt;el-dropdown :hide-on-click=&quot;false&quot;&gt;
  &lt;span class=&quot;el-dropdown-link&quot;&gt;
    下拉菜单&lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt;
  &lt;/span&gt;
  &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;
    &lt;el-dropdown-item&gt;黄金糕&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item&gt;狮子头&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item&gt;螺蛳粉&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item disabled&gt;双皮奶&lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item divided&gt;蚵仔煎&lt;/el-dropdown-item&gt;
  &lt;/el-dropdown-menu&gt;
&lt;/el-dropdown&gt;

&lt;style&gt;
  .el-dropdown-link {
    cursor: pointer;
    color: #409EFF;
  }
  .el-icon-arrow-down {
    font-size: 12px;
  }
&lt;/style&gt;
</code></pre>
<h1 id="属性事件和方法-6"><a class="header" href="#属性事件和方法-6">属性事件和方法</a></h1>
<h2 id="dropdown-attributes"><a class="header" href="#dropdown-attributes">Dropdown Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">type</td><td style="text-align: left">菜单按钮类型，同 Button 组件(只在<code>split-button</code>为 true 的情况下有效)</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">菜单尺寸，在<code>split-button</code>为 true 的情况下也对触发按钮生效</td><td style="text-align: left">string</td><td style="text-align: left">medium / small / mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">split-button</td><td style="text-align: left">下拉触发元素呈现为按钮组</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">placement</td><td style="text-align: left">菜单弹出位置</td><td style="text-align: left">string</td><td style="text-align: left">top/top-start/top-end/bottom/bottom-start/bottom-end</td><td style="text-align: left">bottom-end</td></tr>
<tr><td style="text-align: left">trigger</td><td style="text-align: left">触发下拉的行为</td><td style="text-align: left">string</td><td style="text-align: left">hover, click</td><td style="text-align: left">hover</td></tr>
<tr><td style="text-align: left">hide-on-click</td><td style="text-align: left">是否在点击菜单项后隐藏菜单</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">show-timeout</td><td style="text-align: left">展开下拉菜单的延时（仅在 trigger 为 hover 时有效）</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">250</td></tr>
<tr><td style="text-align: left">hide-timeout</td><td style="text-align: left">收起下拉菜单的延时（仅在 trigger 为 hover 时有效）</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">150</td></tr>
<tr><td style="text-align: left">tabindex</td><td style="text-align: left">Dropdown 组件的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex">tabindex</a></td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
</tbody></table>
<h2 id="dropdown-slots"><a class="header" href="#dropdown-slots"><a href="https://element.eleme.cn/#/zh-CN/component/dropdown#dropdown-slots">¶</a>Dropdown Slots</a></h2>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">—</td><td style="text-align: left">触发下拉列表显示的元素。 注意： 必须是一个元素或者或者组件</td></tr>
<tr><td style="text-align: left">dropdown</td><td style="text-align: left">下拉列表，通常是 <code>&lt;el-dropdown-menu&gt;</code> 组件</td></tr>
</tbody></table>
<h2 id="dropdown-events"><a class="header" href="#dropdown-events"><a href="https://element.eleme.cn/#/zh-CN/component/dropdown#dropdown-events">¶</a>Dropdown Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">click</td><td style="text-align: left"><code>split-button</code> 为 true 时，点击左侧按钮的回调</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">command</td><td style="text-align: left">点击菜单项触发的事件回调</td><td style="text-align: left">dropdown-item 的指令</td></tr>
<tr><td style="text-align: left">visible-change</td><td style="text-align: left">下拉框出现/隐藏时触发</td><td style="text-align: left">出现则为 true，隐藏则为 false</td></tr>
</tbody></table>
<h2 id="dropdown-menu-item-attributes"><a class="header" href="#dropdown-menu-item-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/dropdown#dropdown-menu-item-attributes">¶</a>Dropdown Menu Item Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">command</td><td style="text-align: left">指令</td><td style="text-align: left">string/number/object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">divided</td><td style="text-align: left">显示分割线</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">icon</td><td style="text-align: left">图标类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navmenu-导航菜单"><a class="header" href="#navmenu-导航菜单">NavMenu 导航菜单</a></h1>
<p>为网站提供导航功能的菜单。</p>
<h1 id="顶栏"><a class="header" href="#顶栏">顶栏</a></h1>
<p>适用广泛的基础用法。</p>
<p>导航菜单默认为垂直模式，通过<code>mode</code>属性可以使导航菜单变更为水平模式。另外，在菜单中通过<code>submenu</code>组件可以生成二级菜单。Menu 还提供了<code>background-color</code>、<code>text-color</code>和<code>active-text-color</code>，分别用于设置菜单的背景色、菜单的文字颜色和当前激活菜单的文字颜色。</p>
<pre><code class="language-vue">&lt;el-menu :default-active=&quot;activeIndex&quot; class=&quot;el-menu-demo&quot; mode=&quot;horizontal&quot; @select=&quot;handleSelect&quot;&gt;
  &lt;el-menu-item index=&quot;1&quot;&gt;处理中心&lt;/el-menu-item&gt;
  &lt;el-submenu index=&quot;2&quot;&gt;
    &lt;template slot=&quot;title&quot;&gt;我的工作台&lt;/template&gt;
    &lt;el-menu-item index=&quot;2-1&quot;&gt;选项1&lt;/el-menu-item&gt;
    &lt;el-menu-item index=&quot;2-2&quot;&gt;选项2&lt;/el-menu-item&gt;
    &lt;el-menu-item index=&quot;2-3&quot;&gt;选项3&lt;/el-menu-item&gt;
    &lt;el-submenu index=&quot;2-4&quot;&gt;
      &lt;template slot=&quot;title&quot;&gt;选项4&lt;/template&gt;
      &lt;el-menu-item index=&quot;2-4-1&quot;&gt;选项1&lt;/el-menu-item&gt;
      &lt;el-menu-item index=&quot;2-4-2&quot;&gt;选项2&lt;/el-menu-item&gt;
      &lt;el-menu-item index=&quot;2-4-3&quot;&gt;选项3&lt;/el-menu-item&gt;
    &lt;/el-submenu&gt;
  &lt;/el-submenu&gt;
  &lt;el-menu-item index=&quot;3&quot; disabled&gt;消息中心&lt;/el-menu-item&gt;
  &lt;el-menu-item index=&quot;4&quot;&gt;&lt;a href=&quot;https://www.ele.me&quot; target=&quot;_blank&quot;&gt;订单管理&lt;/a&gt;&lt;/el-menu-item&gt;
&lt;/el-menu&gt;
&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;
&lt;el-menu
  :default-active=&quot;activeIndex2&quot;
  class=&quot;el-menu-demo&quot;
  mode=&quot;horizontal&quot;
  @select=&quot;handleSelect&quot;
  background-color=&quot;#545c64&quot;
  text-color=&quot;#fff&quot;
  active-text-color=&quot;#ffd04b&quot;&gt;
  &lt;el-menu-item index=&quot;1&quot;&gt;处理中心&lt;/el-menu-item&gt;
  &lt;el-submenu index=&quot;2&quot;&gt;
    &lt;template slot=&quot;title&quot;&gt;我的工作台&lt;/template&gt;
    &lt;el-menu-item index=&quot;2-1&quot;&gt;选项1&lt;/el-menu-item&gt;
    &lt;el-menu-item index=&quot;2-2&quot;&gt;选项2&lt;/el-menu-item&gt;
    &lt;el-menu-item index=&quot;2-3&quot;&gt;选项3&lt;/el-menu-item&gt;
    &lt;el-submenu index=&quot;2-4&quot;&gt;
      &lt;template slot=&quot;title&quot;&gt;选项4&lt;/template&gt;
      &lt;el-menu-item index=&quot;2-4-1&quot;&gt;选项1&lt;/el-menu-item&gt;
      &lt;el-menu-item index=&quot;2-4-2&quot;&gt;选项2&lt;/el-menu-item&gt;
      &lt;el-menu-item index=&quot;2-4-3&quot;&gt;选项3&lt;/el-menu-item&gt;
    &lt;/el-submenu&gt;
  &lt;/el-submenu&gt;
  &lt;el-menu-item index=&quot;3&quot; disabled&gt;消息中心&lt;/el-menu-item&gt;
  &lt;el-menu-item index=&quot;4&quot;&gt;&lt;a href=&quot;https://www.ele.me&quot; target=&quot;_blank&quot;&gt;订单管理&lt;/a&gt;&lt;/el-menu-item&gt;
&lt;/el-menu&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        activeIndex: '1',
        activeIndex2: '1'
      };
    },
    methods: {
      handleSelect(key, keyPath) {
        console.log(key, keyPath);
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="侧栏"><a class="header" href="#侧栏">侧栏</a></h1>
<p>垂直菜单，可内嵌子菜单。</p>
<p>通过<code>el-menu-item-group</code>组件可以实现菜单进行分组，分组名可以通过<code>title</code>属性直接设定，也可以通过具名 slot 来设定。</p>
<pre><code class="language-vue">&lt;el-row class=&quot;tac&quot;&gt;
  &lt;el-col :span=&quot;12&quot;&gt;
    &lt;h5&gt;默认颜色&lt;/h5&gt;
    &lt;el-menu
      default-active=&quot;2&quot;
      class=&quot;el-menu-vertical-demo&quot;
      @open=&quot;handleOpen&quot;
      @close=&quot;handleClose&quot;&gt;
      &lt;el-submenu index=&quot;1&quot;&gt;
        &lt;template slot=&quot;title&quot;&gt;
          &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt;
          &lt;span&gt;导航一&lt;/span&gt;
        &lt;/template&gt;
        &lt;el-menu-item-group&gt;
          &lt;template slot=&quot;title&quot;&gt;分组一&lt;/template&gt;
          &lt;el-menu-item index=&quot;1-1&quot;&gt;选项1&lt;/el-menu-item&gt;
          &lt;el-menu-item index=&quot;1-2&quot;&gt;选项2&lt;/el-menu-item&gt;
        &lt;/el-menu-item-group&gt;
        &lt;el-menu-item-group title=&quot;分组2&quot;&gt;
          &lt;el-menu-item index=&quot;1-3&quot;&gt;选项3&lt;/el-menu-item&gt;
        &lt;/el-menu-item-group&gt;
        &lt;el-submenu index=&quot;1-4&quot;&gt;
          &lt;template slot=&quot;title&quot;&gt;选项4&lt;/template&gt;
          &lt;el-menu-item index=&quot;1-4-1&quot;&gt;选项1&lt;/el-menu-item&gt;
        &lt;/el-submenu&gt;
      &lt;/el-submenu&gt;
      &lt;el-menu-item index=&quot;2&quot;&gt;
        &lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;
        &lt;span slot=&quot;title&quot;&gt;导航二&lt;/span&gt;
      &lt;/el-menu-item&gt;
      &lt;el-menu-item index=&quot;3&quot; disabled&gt;
        &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt;
        &lt;span slot=&quot;title&quot;&gt;导航三&lt;/span&gt;
      &lt;/el-menu-item&gt;
      &lt;el-menu-item index=&quot;4&quot;&gt;
        &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;
        &lt;span slot=&quot;title&quot;&gt;导航四&lt;/span&gt;
      &lt;/el-menu-item&gt;
    &lt;/el-menu&gt;
  &lt;/el-col&gt;
  &lt;el-col :span=&quot;12&quot;&gt;
    &lt;h5&gt;自定义颜色&lt;/h5&gt;
    &lt;el-menu
      default-active=&quot;2&quot;
      class=&quot;el-menu-vertical-demo&quot;
      @open=&quot;handleOpen&quot;
      @close=&quot;handleClose&quot;
      background-color=&quot;#545c64&quot;
      text-color=&quot;#fff&quot;
      active-text-color=&quot;#ffd04b&quot;&gt;
      &lt;el-submenu index=&quot;1&quot;&gt;
        &lt;template slot=&quot;title&quot;&gt;
          &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt;
          &lt;span&gt;导航一&lt;/span&gt;
        &lt;/template&gt;
        &lt;el-menu-item-group&gt;
          &lt;template slot=&quot;title&quot;&gt;分组一&lt;/template&gt;
          &lt;el-menu-item index=&quot;1-1&quot;&gt;选项1&lt;/el-menu-item&gt;
          &lt;el-menu-item index=&quot;1-2&quot;&gt;选项2&lt;/el-menu-item&gt;
        &lt;/el-menu-item-group&gt;
        &lt;el-menu-item-group title=&quot;分组2&quot;&gt;
          &lt;el-menu-item index=&quot;1-3&quot;&gt;选项3&lt;/el-menu-item&gt;
        &lt;/el-menu-item-group&gt;
        &lt;el-submenu index=&quot;1-4&quot;&gt;
          &lt;template slot=&quot;title&quot;&gt;选项4&lt;/template&gt;
          &lt;el-menu-item index=&quot;1-4-1&quot;&gt;选项1&lt;/el-menu-item&gt;
        &lt;/el-submenu&gt;
      &lt;/el-submenu&gt;
      &lt;el-menu-item index=&quot;2&quot;&gt;
        &lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;
        &lt;span slot=&quot;title&quot;&gt;导航二&lt;/span&gt;
      &lt;/el-menu-item&gt;
      &lt;el-menu-item index=&quot;3&quot; disabled&gt;
        &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt;
        &lt;span slot=&quot;title&quot;&gt;导航三&lt;/span&gt;
      &lt;/el-menu-item&gt;
      &lt;el-menu-item index=&quot;4&quot;&gt;
        &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;
        &lt;span slot=&quot;title&quot;&gt;导航四&lt;/span&gt;
      &lt;/el-menu-item&gt;
    &lt;/el-menu&gt;
  &lt;/el-col&gt;
&lt;/el-row&gt;

&lt;script&gt;
  export default {
    methods: {
      handleOpen(key, keyPath) {
        console.log(key, keyPath);
      },
      handleClose(key, keyPath) {
        console.log(key, keyPath);
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="折叠"><a class="header" href="#折叠">折叠</a></h1>
<pre><code class="language-vue">&lt;el-radio-group v-model=&quot;isCollapse&quot; style=&quot;margin-bottom: 20px;&quot;&gt;
  &lt;el-radio-button :label=&quot;false&quot;&gt;展开&lt;/el-radio-button&gt;
  &lt;el-radio-button :label=&quot;true&quot;&gt;收起&lt;/el-radio-button&gt;
&lt;/el-radio-group&gt;
&lt;el-menu default-active=&quot;1-4-1&quot; class=&quot;el-menu-vertical-demo&quot; @open=&quot;handleOpen&quot; @close=&quot;handleClose&quot; :collapse=&quot;isCollapse&quot;&gt;
  &lt;el-submenu index=&quot;1&quot;&gt;
    &lt;template slot=&quot;title&quot;&gt;
      &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt;
      &lt;span slot=&quot;title&quot;&gt;导航一&lt;/span&gt;
    &lt;/template&gt;
    &lt;el-menu-item-group&gt;
      &lt;span slot=&quot;title&quot;&gt;分组一&lt;/span&gt;
      &lt;el-menu-item index=&quot;1-1&quot;&gt;选项1&lt;/el-menu-item&gt;
      &lt;el-menu-item index=&quot;1-2&quot;&gt;选项2&lt;/el-menu-item&gt;
    &lt;/el-menu-item-group&gt;
    &lt;el-menu-item-group title=&quot;分组2&quot;&gt;
      &lt;el-menu-item index=&quot;1-3&quot;&gt;选项3&lt;/el-menu-item&gt;
    &lt;/el-menu-item-group&gt;
    &lt;el-submenu index=&quot;1-4&quot;&gt;
      &lt;span slot=&quot;title&quot;&gt;选项4&lt;/span&gt;
      &lt;el-menu-item index=&quot;1-4-1&quot;&gt;选项1&lt;/el-menu-item&gt;
    &lt;/el-submenu&gt;
  &lt;/el-submenu&gt;
  &lt;el-menu-item index=&quot;2&quot;&gt;
    &lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;
    &lt;span slot=&quot;title&quot;&gt;导航二&lt;/span&gt;
  &lt;/el-menu-item&gt;
  &lt;el-menu-item index=&quot;3&quot; disabled&gt;
    &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt;
    &lt;span slot=&quot;title&quot;&gt;导航三&lt;/span&gt;
  &lt;/el-menu-item&gt;
  &lt;el-menu-item index=&quot;4&quot;&gt;
    &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;
    &lt;span slot=&quot;title&quot;&gt;导航四&lt;/span&gt;
  &lt;/el-menu-item&gt;
&lt;/el-menu&gt;

&lt;style&gt;
  .el-menu-vertical-demo:not(.el-menu--collapse) {
    width: 200px;
    min-height: 400px;
  }
&lt;/style&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        isCollapse: true
      };
    },
    methods: {
      handleOpen(key, keyPath) {
        console.log(key, keyPath);
      },
      handleClose(key, keyPath) {
        console.log(key, keyPath);
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="属性事件和方法-7"><a class="header" href="#属性事件和方法-7">属性事件和方法</a></h1>
<h2 id="menu-attribute"><a class="header" href="#menu-attribute">Menu Attribute</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">mode</td><td style="text-align: left">模式</td><td style="text-align: left">string</td><td style="text-align: left">horizontal / vertical</td><td style="text-align: left">vertical</td></tr>
<tr><td style="text-align: left">collapse</td><td style="text-align: left">是否水平折叠收起菜单（仅在 mode 为 vertical 时可用）</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">background-color</td><td style="text-align: left">菜单的背景色（仅支持 hex 格式）</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">#ffffff</td></tr>
<tr><td style="text-align: left">text-color</td><td style="text-align: left">菜单的文字颜色（仅支持 hex 格式）</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">#303133</td></tr>
<tr><td style="text-align: left">active-text-color</td><td style="text-align: left">当前激活菜单的文字颜色（仅支持 hex 格式）</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">#409EFF</td></tr>
<tr><td style="text-align: left">default-active</td><td style="text-align: left">当前激活菜单的 index</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">default-openeds</td><td style="text-align: left">当前打开的 sub-menu 的 index 的数组</td><td style="text-align: left">Array</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">unique-opened</td><td style="text-align: left">是否只保持一个子菜单的展开</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">menu-trigger</td><td style="text-align: left">子菜单打开的触发方式(只在 mode 为 horizontal 时有效)</td><td style="text-align: left">string</td><td style="text-align: left">hover / click</td><td style="text-align: left">hover</td></tr>
<tr><td style="text-align: left">router</td><td style="text-align: left">是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">collapse-transition</td><td style="text-align: left">是否开启折叠动画</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
</tbody></table>
<h2 id="menu-methods"><a class="header" href="#menu-methods"><a href="https://element.eleme.cn/#/zh-CN/component/menu#menu-methods">¶</a>Menu Methods</a></h2>
<table><thead><tr><th style="text-align: left">方法名称</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">open</td><td style="text-align: left">展开指定的 sub-menu</td><td style="text-align: left">index: 需要打开的 sub-menu 的 index</td></tr>
<tr><td style="text-align: left">close</td><td style="text-align: left">收起指定的 sub-menu</td><td style="text-align: left">index: 需要收起的 sub-menu 的 index</td></tr>
</tbody></table>
<h2 id="menu-events"><a class="header" href="#menu-events"><a href="https://element.eleme.cn/#/zh-CN/component/menu#menu-events">¶</a>Menu Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">select</td><td style="text-align: left">菜单激活回调</td><td style="text-align: left">index: 选中菜单项的 index, indexPath: 选中菜单项的 index path</td></tr>
<tr><td style="text-align: left">open</td><td style="text-align: left">sub-menu 展开的回调</td><td style="text-align: left">index: 打开的 sub-menu 的 index， indexPath: 打开的 sub-menu 的 index path</td></tr>
<tr><td style="text-align: left">close</td><td style="text-align: left">sub-menu 收起的回调</td><td style="text-align: left">index: 收起的 sub-menu 的 index， indexPath: 收起的 sub-menu 的 index path</td></tr>
</tbody></table>
<h2 id="submenu-attribute"><a class="header" href="#submenu-attribute"><a href="https://element.eleme.cn/#/zh-CN/component/menu#submenu-attribute">¶</a>SubMenu Attribute</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">index</td><td style="text-align: left">唯一标志</td><td style="text-align: left">string/null</td><td style="text-align: left">—</td><td style="text-align: left">null</td></tr>
<tr><td style="text-align: left">popper-class</td><td style="text-align: left">弹出菜单的自定义类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">show-timeout</td><td style="text-align: left">展开 sub-menu 的延时</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">300</td></tr>
<tr><td style="text-align: left">hide-timeout</td><td style="text-align: left">收起 sub-menu 的延时</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">300</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">popper-append-to-body</td><td style="text-align: left">是否将弹出菜单插入至 body 元素。在菜单的定位出现问题时，可尝试修改该属性</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">一级子菜单：true / 非一级子菜单：false</td></tr>
</tbody></table>
<h2 id="menu-item-attribute"><a class="header" href="#menu-item-attribute"><a href="https://element.eleme.cn/#/zh-CN/component/menu#menu-item-attribute">¶</a>Menu-Item Attribute</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">index</td><td style="text-align: left">唯一标志</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">route</td><td style="text-align: left">Vue Router 路径对象</td><td style="text-align: left">Object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
</tbody></table>
<h2 id="menu-group-attribute"><a class="header" href="#menu-group-attribute"><a href="https://element.eleme.cn/#/zh-CN/component/menu#menu-group-attribute">¶</a>Menu-Group Attribute</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">title</td><td style="text-align: left">分组标题</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="steps-步骤条"><a class="header" href="#steps-步骤条">Steps 步骤条</a></h2>
<p>引导用户按照流程完成任务的分步导航条，可根据实际应用场景设定步骤，步骤不得少于 2 步。</p>
<h1 id="基础用法-6"><a class="header" href="#基础用法-6">基础用法</a></h1>
<p>设置<code>active</code>属性，接受一个<code>Number</code>，表明步骤的 index，从 0 开始。需要定宽的步骤条时，设置<code>space</code>属性即可，它接受<code>Number</code>，单位为<code>px</code>，如果不设置，则为自适应。设置<code>finish-status</code>属性可以改变已经完成的步骤的状态。</p>
<pre><code class="language-vue">&lt;el-steps :active=&quot;active&quot; finish-status=&quot;success&quot;&gt;
  &lt;el-step title=&quot;步骤 1&quot;&gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;步骤 2&quot;&gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;步骤 3&quot;&gt;&lt;/el-step&gt;
&lt;/el-steps&gt;

&lt;el-button style=&quot;margin-top: 12px;&quot; @click=&quot;next&quot;&gt;下一步&lt;/el-button&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        active: 0
      };
    },

    methods: {
      next() {
        if (this.active++ &gt; 2) this.active = 0;
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="含状态步骤条"><a class="header" href="#含状态步骤条">含状态步骤条</a></h1>
<p>也可以使用<code>title</code>具名分发，可以用<code>slot</code>的方式来取代属性的设置，在本文档最后的列表中有所有的 slot name 可供参考。</p>
<pre><code class="language-vue">&lt;el-steps :space=&quot;200&quot; :active=&quot;1&quot; finish-status=&quot;success&quot;&gt;
  &lt;el-step title=&quot;已完成&quot;&gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;进行中&quot;&gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;步骤 3&quot;&gt;&lt;/el-step&gt;
&lt;/el-steps&gt;
</code></pre>
<h1 id="有描述的步骤条"><a class="header" href="#有描述的步骤条">有描述的步骤条</a></h1>
<pre><code class="language-vue">&lt;el-steps :active=&quot;1&quot;&gt;
  &lt;el-step title=&quot;步骤 1&quot; description=&quot;这是一段很长很长很长的描述性文字&quot;&gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;步骤 2&quot; description=&quot;这是一段很长很长很长的描述性文字&quot;&gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;步骤 3&quot; description=&quot;这段就没那么长了&quot;&gt;&lt;/el-step&gt;
&lt;/el-steps&gt;
</code></pre>
<h1 id="居中的步骤条"><a class="header" href="#居中的步骤条">居中的步骤条</a></h1>
<p>标题和描述都将居中。</p>
<pre><code class="language-vue">&lt;el-steps :active=&quot;2&quot; align-center&gt;
  &lt;el-step title=&quot;步骤1&quot; description=&quot;这是一段很长很长很长的描述性文字&quot;&gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;步骤2&quot; description=&quot;这是一段很长很长很长的描述性文字&quot;&gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;步骤3&quot; description=&quot;这是一段很长很长很长的描述性文字&quot;&gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;步骤4&quot; description=&quot;这是一段很长很长很长的描述性文字&quot;&gt;&lt;/el-step&gt;
&lt;/el-steps&gt;
</code></pre>
<h1 id="带图标的步骤条"><a class="header" href="#带图标的步骤条">带图标的步骤条</a></h1>
<p>通过<code>icon</code>属性来设置图标，图标的类型可以参考 Icon 组件的文档，除此以外，还能通过具名<code>slot</code>来使用自定义的图标。</p>
<pre><code class="language-vue">&lt;el-steps :active=&quot;1&quot;&gt;
  &lt;el-step title=&quot;步骤 1&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;步骤 2&quot; icon=&quot;el-icon-upload&quot;&gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;步骤 3&quot; icon=&quot;el-icon-picture&quot;&gt;&lt;/el-step&gt;
&lt;/el-steps&gt;
</code></pre>
<h1 id="竖式步骤条"><a class="header" href="#竖式步骤条">竖式步骤条</a></h1>
<p>只需要在<code>el-steps</code>元素中设置<code>direction</code>属性为<code>vertical</code>即可。</p>
<pre><code class="language-vue">&lt;div style=&quot;height: 300px;&quot;&gt;
  &lt;el-steps direction=&quot;vertical&quot; :active=&quot;1&quot;&gt;
    &lt;el-step title=&quot;步骤 1&quot;&gt;&lt;/el-step&gt;
    &lt;el-step title=&quot;步骤 2&quot;&gt;&lt;/el-step&gt;
    &lt;el-step title=&quot;步骤 3&quot; description=&quot;这是一段很长很长很长的描述性文字&quot;&gt;&lt;/el-step&gt;
  &lt;/el-steps&gt;
&lt;/div&gt;
</code></pre>
<h1 id="简洁风格的步骤条"><a class="header" href="#简洁风格的步骤条">简洁风格的步骤条</a></h1>
<p>设置 <code>simple</code> 可应用简洁风格，该条件下 <code>align-center</code> / <code>description</code> / <code>direction</code> / <code>space</code> 都将失效。</p>
<pre><code class="language-vue">&lt;el-steps :active=&quot;1&quot; simple&gt;
  &lt;el-step title=&quot;步骤 1&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;步骤 2&quot; icon=&quot;el-icon-upload&quot;&gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;步骤 3&quot; icon=&quot;el-icon-picture&quot;&gt;&lt;/el-step&gt;
&lt;/el-steps&gt;

&lt;el-steps :active=&quot;1&quot; finish-status=&quot;success&quot; simple style=&quot;margin-top: 20px&quot;&gt;
  &lt;el-step title=&quot;步骤 1&quot; &gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;步骤 2&quot; &gt;&lt;/el-step&gt;
  &lt;el-step title=&quot;步骤 3&quot; &gt;&lt;/el-step&gt;
&lt;/el-steps&gt;
</code></pre>
<h1 id="属性事件和方法-8"><a class="header" href="#属性事件和方法-8">属性事件和方法</a></h1>
<h2 id="steps-attributes"><a class="header" href="#steps-attributes">Steps Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">space</td><td style="text-align: left">每个 step 的间距，不填写将自适应间距。支持百分比。</td><td style="text-align: left">number / string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">direction</td><td style="text-align: left">显示方向</td><td style="text-align: left">string</td><td style="text-align: left">vertical/horizontal</td><td style="text-align: left">horizontal</td></tr>
<tr><td style="text-align: left">active</td><td style="text-align: left">设置当前激活步骤</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">process-status</td><td style="text-align: left">设置当前步骤的状态</td><td style="text-align: left">string</td><td style="text-align: left">wait / process / finish / error / success</td><td style="text-align: left">process</td></tr>
<tr><td style="text-align: left">finish-status</td><td style="text-align: left">设置结束步骤的状态</td><td style="text-align: left">string</td><td style="text-align: left">wait / process / finish / error / success</td><td style="text-align: left">finish</td></tr>
<tr><td style="text-align: left">align-center</td><td style="text-align: left">进行居中对齐</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">simple</td><td style="text-align: left">是否应用简洁风格</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">false</td></tr>
</tbody></table>
<h2 id="step-attributes"><a class="header" href="#step-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/steps#step-attributes">¶</a>Step Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">title</td><td style="text-align: left">标题</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">description</td><td style="text-align: left">描述性文字</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">icon</td><td style="text-align: left">图标</td><td style="text-align: left">传入 icon 的 class 全名来自定义 icon，也支持 slot 方式写入</td><td style="text-align: left">string</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">status</td><td style="text-align: left">设置当前步骤的状态，不设置则根据 steps 确定状态</td><td style="text-align: left">wait / process / finish / error / success</td><td style="text-align: left">-</td><td style="text-align: left"></td></tr>
</tbody></table>
<h2 id="step-slot"><a class="header" href="#step-slot"><a href="https://element.eleme.cn/#/zh-CN/component/steps#step-slot">¶</a>Step Slot</a></h2>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">icon</td><td style="text-align: left">自定义图标</td></tr>
<tr><td style="text-align: left">title</td><td style="text-align: left">自定义标题</td></tr>
<tr><td style="text-align: left">description</td><td style="text-align: left">自定义描述性文字</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tabs-标签页"><a class="header" href="#tabs-标签页">Tabs 标签页</a></h1>
<p>分隔内容上有关联但属于不同类别的数据集合。</p>
<h1 id="基础用法-7"><a class="header" href="#基础用法-7">基础用法</a></h1>
<p>abs 组件提供了选项卡功能，默认选中第一个标签页，你也可以通过 <code>value</code> 属性来指定当前选中的标签页</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-tabs v-model=&quot;activeName&quot; @tab-click=&quot;handleClick&quot;&gt;
    &lt;el-tab-pane label=&quot;用户管理&quot; name=&quot;first&quot;&gt;用户管理&lt;/el-tab-pane&gt;
    &lt;el-tab-pane label=&quot;配置管理&quot; name=&quot;second&quot;&gt;配置管理&lt;/el-tab-pane&gt;
    &lt;el-tab-pane label=&quot;角色管理&quot; name=&quot;third&quot;&gt;角色管理&lt;/el-tab-pane&gt;
    &lt;el-tab-pane label=&quot;定时任务补偿&quot; name=&quot;fourth&quot;&gt;定时任务补偿&lt;/el-tab-pane&gt;
  &lt;/el-tabs&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        activeName: 'second'
      };
    },
    methods: {
      handleClick(tab, event) {
        console.log(tab, event);
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="选项卡样式"><a class="header" href="#选项卡样式">选项卡样式</a></h1>
<p>只需要设置 <code>type</code> 属性为 <code>card</code> 就可以使选项卡改变为标签风格。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-tabs v-model=&quot;activeName&quot; type=&quot;card&quot; @tab-click=&quot;handleClick&quot;&gt;
    &lt;el-tab-pane label=&quot;用户管理&quot; name=&quot;first&quot;&gt;用户管理&lt;/el-tab-pane&gt;
    &lt;el-tab-pane label=&quot;配置管理&quot; name=&quot;second&quot;&gt;配置管理&lt;/el-tab-pane&gt;
    &lt;el-tab-pane label=&quot;角色管理&quot; name=&quot;third&quot;&gt;角色管理&lt;/el-tab-pane&gt;
    &lt;el-tab-pane label=&quot;定时任务补偿&quot; name=&quot;fourth&quot;&gt;定时任务补偿&lt;/el-tab-pane&gt;
  &lt;/el-tabs&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        activeName: 'first'
      };
    },
    methods: {
      handleClick(tab, event) {
        console.log(tab, event);
      }
    }
  };
&lt;/script&gt;

</code></pre>
<h1 id="卡片化"><a class="header" href="#卡片化">卡片化</a></h1>
<p>将<code>type</code>设置为<code>border-card</code>。</p>
<pre><code class="language-vue">&lt;el-tabs type=&quot;border-card&quot;&gt;
  &lt;el-tab-pane label=&quot;用户管理&quot;&gt;用户管理&lt;/el-tab-pane&gt;
  &lt;el-tab-pane label=&quot;配置管理&quot;&gt;配置管理&lt;/el-tab-pane&gt;
  &lt;el-tab-pane label=&quot;角色管理&quot;&gt;角色管理&lt;/el-tab-pane&gt;
  &lt;el-tab-pane label=&quot;定时任务补偿&quot;&gt;定时任务补偿&lt;/el-tab-pane&gt;
&lt;/el-tabs&gt;
</code></pre>
<h1 id="位置"><a class="header" href="#位置">位置</a></h1>
<p>可以通过 <code>tab-position</code> 设置标签的位置</p>
<p>标签一共有四个方向的设置 <code>tabPosition=&quot;left|right|top|bottom&quot;</code></p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-radio-group v-model=&quot;tabPosition&quot; style=&quot;margin-bottom: 30px;&quot;&gt;
    &lt;el-radio-button label=&quot;top&quot;&gt;top&lt;/el-radio-button&gt;
    &lt;el-radio-button label=&quot;right&quot;&gt;right&lt;/el-radio-button&gt;
    &lt;el-radio-button label=&quot;bottom&quot;&gt;bottom&lt;/el-radio-button&gt;
    &lt;el-radio-button label=&quot;left&quot;&gt;left&lt;/el-radio-button&gt;
  &lt;/el-radio-group&gt;

  &lt;el-tabs :tab-position=&quot;tabPosition&quot; style=&quot;height: 200px;&quot;&gt;
    &lt;el-tab-pane label=&quot;用户管理&quot;&gt;用户管理&lt;/el-tab-pane&gt;
    &lt;el-tab-pane label=&quot;配置管理&quot;&gt;配置管理&lt;/el-tab-pane&gt;
    &lt;el-tab-pane label=&quot;角色管理&quot;&gt;角色管理&lt;/el-tab-pane&gt;
    &lt;el-tab-pane label=&quot;定时任务补偿&quot;&gt;定时任务补偿&lt;/el-tab-pane&gt;
  &lt;/el-tabs&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        tabPosition: 'left'
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="自定义标签页"><a class="header" href="#自定义标签页">自定义标签页</a></h1>
<pre><code class="language-vue">&lt;el-tabs type=&quot;border-card&quot;&gt;
  &lt;el-tab-pane&gt;
    &lt;span slot=&quot;label&quot;&gt;&lt;i class=&quot;el-icon-date&quot;&gt;&lt;/i&gt; 我的行程&lt;/span&gt;
    我的行程
  &lt;/el-tab-pane&gt;
  &lt;el-tab-pane label=&quot;消息中心&quot;&gt;消息中心&lt;/el-tab-pane&gt;
  &lt;el-tab-pane label=&quot;角色管理&quot;&gt;角色管理&lt;/el-tab-pane&gt;
  &lt;el-tab-pane label=&quot;定时任务补偿&quot;&gt;定时任务补偿&lt;/el-tab-pane&gt;
&lt;/el-tabs&gt;
</code></pre>
<h1 id="动态增减标签页"><a class="header" href="#动态增减标签页">动态增减标签页</a></h1>
<pre><code class="language-vue">&lt;el-tabs v-model=&quot;editableTabsValue&quot; type=&quot;card&quot; editable @edit=&quot;handleTabsEdit&quot;&gt;
  &lt;el-tab-pane
    :key=&quot;item.name&quot;
    v-for=&quot;(item, index) in editableTabs&quot;
    :label=&quot;item.title&quot;
    :name=&quot;item.name&quot;
  &gt;
    {{item.content}}
  &lt;/el-tab-pane&gt;
&lt;/el-tabs&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        editableTabsValue: '2',
        editableTabs: [{
          title: 'Tab 1',
          name: '1',
          content: 'Tab 1 content'
        }, {
          title: 'Tab 2',
          name: '2',
          content: 'Tab 2 content'
        }],
        tabIndex: 2
      }
    },
    methods: {
      handleTabsEdit(targetName, action) {
        if (action === 'add') {
          let newTabName = ++this.tabIndex + '';
          this.editableTabs.push({
            title: 'New Tab',
            name: newTabName,
            content: 'New Tab content'
          });
          this.editableTabsValue = newTabName;
        }
        if (action === 'remove') {
          let tabs = this.editableTabs;
          let activeName = this.editableTabsValue;
          if (activeName === targetName) {
            tabs.forEach((tab, index) =&gt; {
              if (tab.name === targetName) {
                let nextTab = tabs[index + 1] || tabs[index - 1];
                if (nextTab) {
                  activeName = nextTab.name;
                }
              }
            });
          }
          
          this.editableTabsValue = activeName;
          this.editableTabs = tabs.filter(tab =&gt; tab.name !== targetName);
        }
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="自定义增加标签页触发器"><a class="header" href="#自定义增加标签页触发器">自定义增加标签页触发器</a></h1>
<pre><code class="language-vue">&lt;div style=&quot;margin-bottom: 20px;&quot;&gt;
  &lt;el-button
    size=&quot;small&quot;
    @click=&quot;addTab(editableTabsValue)&quot;
  &gt;
    add tab
  &lt;/el-button&gt;
&lt;/div&gt;
&lt;el-tabs v-model=&quot;editableTabsValue&quot; type=&quot;card&quot; closable @tab-remove=&quot;removeTab&quot;&gt;
  &lt;el-tab-pane
    v-for=&quot;(item, index) in editableTabs&quot;
    :key=&quot;item.name&quot;
    :label=&quot;item.title&quot;
    :name=&quot;item.name&quot;
  &gt;
    {{item.content}}
  &lt;/el-tab-pane&gt;
&lt;/el-tabs&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        editableTabsValue: '2',
        editableTabs: [{
          title: 'Tab 1',
          name: '1',
          content: 'Tab 1 content'
        }, {
          title: 'Tab 2',
          name: '2',
          content: 'Tab 2 content'
        }],
        tabIndex: 2
      }
    },
    methods: {
      addTab(targetName) {
        let newTabName = ++this.tabIndex + '';
        this.editableTabs.push({
          title: 'New Tab',
          name: newTabName,
          content: 'New Tab content'
        });
        this.editableTabsValue = newTabName;
      },
      removeTab(targetName) {
        let tabs = this.editableTabs;
        let activeName = this.editableTabsValue;
        if (activeName === targetName) {
          tabs.forEach((tab, index) =&gt; {
            if (tab.name === targetName) {
              let nextTab = tabs[index + 1] || tabs[index - 1];
              if (nextTab) {
                activeName = nextTab.name;
              }
            }
          });
        }
        
        this.editableTabsValue = activeName;
        this.editableTabs = tabs.filter(tab =&gt; tab.name !== targetName);
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="属性事件和方法-9"><a class="header" href="#属性事件和方法-9">属性事件和方法</a></h1>
<h2 id="tabs-attributes"><a class="header" href="#tabs-attributes">Tabs Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值，选中选项卡的 name</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">第一个选项卡的 name</td></tr>
<tr><td style="text-align: left">type</td><td style="text-align: left">风格类型</td><td style="text-align: left">string</td><td style="text-align: left">card/border-card</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">closable</td><td style="text-align: left">标签是否可关闭</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">addable</td><td style="text-align: left">标签是否可增加</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">editable</td><td style="text-align: left">标签是否同时可增加和关闭</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">tab-position</td><td style="text-align: left">选项卡所在位置</td><td style="text-align: left">string</td><td style="text-align: left">top/right/bottom/left</td><td style="text-align: left">top</td></tr>
<tr><td style="text-align: left">stretch</td><td style="text-align: left">标签的宽度是否自撑开</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">before-leave</td><td style="text-align: left">切换标签之前的钩子，若返回 false 或者返回 Promise 且被 reject，则阻止切换。</td><td style="text-align: left">Function(activeName, oldActiveName)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h2 id="tabs-events"><a class="header" href="#tabs-events"><a href="https://element.eleme.cn/#/zh-CN/component/tabs#tabs-events">¶</a>Tabs Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">tab-click</td><td style="text-align: left">tab 被选中时触发</td><td style="text-align: left">被选中的标签 tab 实例</td></tr>
<tr><td style="text-align: left">tab-remove</td><td style="text-align: left">点击 tab 移除按钮后触发</td><td style="text-align: left">被删除的标签的 name</td></tr>
<tr><td style="text-align: left">tab-add</td><td style="text-align: left">点击 tabs 的新增按钮后触发</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">edit</td><td style="text-align: left">点击 tabs 的新增按钮或 tab 被关闭后触发</td><td style="text-align: left">(targetName, action)</td></tr>
</tbody></table>
<h2 id="tab-pane-attributes"><a class="header" href="#tab-pane-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/tabs#tab-pane-attributes">¶</a>Tab-pane Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">label</td><td style="text-align: left">选项卡标题</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">与选项卡绑定值 value 对应的标识符，表示选项卡别名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">该选项卡在选项卡列表中的顺序值，如第一个选项卡则为'1'</td></tr>
<tr><td style="text-align: left">closable</td><td style="text-align: left">标签是否可关闭</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">lazy</td><td style="text-align: left">标签是否延迟渲染</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pageheader-页头"><a class="header" href="#pageheader-页头">PageHeader 页头</a></h1>
<p>如果页面的路径比较简单，推荐使用页头组件而非面包屑组件。</p>
<h1 id="基础"><a class="header" href="#基础">基础</a></h1>
<pre><code class="language-vue">&lt;el-page-header @back=&quot;goBack&quot; content=&quot;详情页面&quot;&gt;
&lt;/el-page-header&gt;

&lt;script&gt;
  export default {
    methods: {
      goBack() {
        console.log('go back');
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="attributes-5"><a class="header" href="#attributes-5">Attributes</a></h1>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">title</td><td style="text-align: left">标题</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">返回</td></tr>
<tr><td style="text-align: left">content</td><td style="text-align: left">内容</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h1 id="events-4"><a class="header" href="#events-4"><a href="https://element.eleme.cn/#/zh-CN/component/page-header#events">¶</a>Events</a></h1>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">back</td><td style="text-align: left">点击左侧区域触发</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h1 id="slots-1"><a class="header" href="#slots-1"><a href="https://element.eleme.cn/#/zh-CN/component/page-header#slots">¶</a>Slots</a></h1>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">title</td><td style="text-align: left">标题内容</td></tr>
<tr><td style="text-align: left">content</td><td style="text-align: left">内容</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notification-通知"><a class="header" href="#notification-通知">Notification 通知</a></h1>
<p>悬浮出现在页面角落，显示全局的通知提醒消息。</p>
<h1 id="基本用法-1"><a class="header" href="#基本用法-1">基本用法</a></h1>
<p>适用性广泛的通知栏</p>
<p>Notification 组件提供通知功能，Element 注册了<code>$notify</code>方法，接收一个<code>options</code>字面量参数，在最简单的情况下，你可以设置<code>title</code>字段和<code>message</code>字段，用于设置通知的标题和正文。默认情况下，经过一段时间后 Notification 组件会自动关闭，但是通过设置<code>duration</code>，可以控制关闭的时间间隔，特别的是，如果设置为<code>0</code>，则不会自动关闭。注意：<code>duration</code>接收一个<code>Number</code>，单位为毫秒，默认为<code>4500</code>。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button
    plain
    @click=&quot;open1&quot;&gt;
    可自动关闭
  &lt;/el-button&gt;
  &lt;el-button
    plain
    @click=&quot;open2&quot;&gt;
    不会自动关闭
    &lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open1() {
        const h = this.$createElement;

        this.$notify({
          title: '标题名称',
          message: h('i', { style: 'color: teal'}, '这是提示文案这是提示文案这是提示文案这是提示文案这是提示文案这是提示文案这是提示文案这是提示文案')
        });
      },

      open2() {
        this.$notify({
          title: '提示',
          message: '这是一条不会自动关闭的消息',
          duration: 0
        });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="带有倾向性"><a class="header" href="#带有倾向性">带有倾向性</a></h1>
<p>带有 icon，常用来显示「成功、警告、消息、错误」类的系统消息</p>
<p>Element 为 Notification 组件准备了四种通知类型：<code>success</code>, <code>warning</code>, <code>info</code>, <code>error</code>。通过<code>type</code>字段来设置，除此以外的值将被忽略。同时，我们也为 Notification 的各种 type 注册了方法，可以在不传入<code>type</code>字段的情况下像<code>open3</code>和<code>open4</code>那样直接调用。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button
    plain
    @click=&quot;open1&quot;&gt;
    成功
  &lt;/el-button&gt;
  &lt;el-button
    plain
    @click=&quot;open2&quot;&gt;
    警告
  &lt;/el-button&gt;
  &lt;el-button
    plain
    @click=&quot;open3&quot;&gt;
    消息
  &lt;/el-button&gt;
  &lt;el-button
    plain
    @click=&quot;open4&quot;&gt;
    错误
  &lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open1() {
        this.$notify({
          title: '成功',
          message: '这是一条成功的提示消息',
          type: 'success'
        });
      },

      open2() {
        this.$notify({
          title: '警告',
          message: '这是一条警告的提示消息',
          type: 'warning'
        });
      },

      open3() {
        this.$notify.info({
          title: '消息',
          message: '这是一条消息的提示消息'
        });
      },

      open4() {
        this.$notify.error({
          title: '错误',
          message: '这是一条错误的提示消息'
        });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="自定义弹出位置"><a class="header" href="#自定义弹出位置">自定义弹出位置</a></h1>
<p>可以让 Notification 从屏幕四角中的任意一角弹出</p>
<p>使用<code>position</code>属性定义 Notification 的弹出位置，支持四个选项：<code>top-right</code>、<code>top-left</code>、<code>bottom-right</code>、<code>bottom-left</code>，默认为<code>top-right</code>。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button
    plain
    @click=&quot;open1&quot;&gt;
    右上角
  &lt;/el-button&gt;
  &lt;el-button
    plain
    @click=&quot;open2&quot;&gt;
    右下角
  &lt;/el-button&gt;
  &lt;el-button
    plain
    @click=&quot;open3&quot;&gt;
    左下角
  &lt;/el-button&gt;
  &lt;el-button
    plain
    @click=&quot;open4&quot;&gt;
    左上角
  &lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open1() {
        this.$notify({
          title: '自定义位置',
          message: '右上角弹出的消息'
        });
      },

      open2() {
        this.$notify({
          title: '自定义位置',
          message: '右下角弹出的消息',
          position: 'bottom-right'
        });
      },

      open3() {
        this.$notify({
          title: '自定义位置',
          message: '左下角弹出的消息',
          position: 'bottom-left'
        });
      },

      open4() {
        this.$notify({
          title: '自定义位置',
          message: '左上角弹出的消息',
          position: 'top-left'
        });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="带有偏移"><a class="header" href="#带有偏移">带有偏移</a></h1>
<p>让 Notification 偏移一些位置</p>
<p>Notification 提供设置偏移量的功能，通过设置 <code>offset</code> 字段，可以使弹出的消息距屏幕边缘偏移一段距离。注意在同一时刻，所有的 Notification 实例应当具有一个相同的偏移量。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button
    plain
    @click=&quot;open&quot;&gt;
    偏移的消息
  &lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open() {
        this.$notify({
          title: '偏移',
          message: '这是一条带有偏移的提示消息',
          offset: 100
        });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="使用-html-片段"><a class="header" href="#使用-html-片段">使用 HTML 片段</a></h1>
<p>将<code>dangerouslyUseHTMLString</code>属性设置为 true，<code>message</code> 就会被当作 HTML 片段处理。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button
    plain
    @click=&quot;open&quot;&gt;
    使用 HTML 片段
  &lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open() {
        this.$notify({
          title: 'HTML 片段',
          dangerouslyUseHTMLString: true,
          message: '&lt;strong&gt;这是 &lt;i&gt;HTML&lt;/i&gt; 片段&lt;/strong&gt;'
        });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="隐藏关闭按钮"><a class="header" href="#隐藏关闭按钮">隐藏关闭按钮</a></h1>
<p>可以不显示关闭按钮</p>
<p>将<code>showClose</code>属性设置为<code>false</code>即可隐藏关闭按钮。</p>
<pre><code>&lt;template&gt;
  &lt;el-button
    plain
    @click=&quot;open&quot;&gt;
    隐藏关闭按钮
  &lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open() {
        this.$notify.success({
          title: 'Info',
          message: '这是一条没有关闭按钮的消息',
          showClose: false
        });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="全局方法"><a class="header" href="#全局方法">全局方法</a></h1>
<p>Element 为 <code>Vue.prototype</code> 添加了全局方法 <code>$notify</code>。因此在 vue instance 中可以采用本页面中的方式调用 Notification。</p>
<h1 id="单独引用"><a class="header" href="#单独引用">单独引用</a></h1>
<p>单独引入 Notification：</p>
<pre><code class="language-javascript">import { Notification } from 'element-ui';
</code></pre>
<p>此时调用方法为 <code>Notification(options)</code>。我们也为每个 type 定义了各自的方法，如 <code>Notification.success(options)</code>。并且可以调用 <code>Notification.closeAll()</code> 手动关闭所有实例。</p>
<h1 id="options"><a class="header" href="#options">Options</a></h1>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">title</td><td style="text-align: left">标题</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">message</td><td style="text-align: left">说明文字</td><td style="text-align: left">string/Vue.VNode</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">dangerouslyUseHTMLString</td><td style="text-align: left">是否将 message 属性作为 HTML 片段处理</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">type</td><td style="text-align: left">主题样式，如果不在可选值内将被忽略</td><td style="text-align: left">string</td><td style="text-align: left">success/warning/info/error</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">iconClass</td><td style="text-align: left">自定义图标的类名。若设置了 <code>type</code>，则 <code>iconClass</code> 会被覆盖</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">customClass</td><td style="text-align: left">自定义类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">duration</td><td style="text-align: left">显示时间, 毫秒。设为 0 则不会自动关闭</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">4500</td></tr>
<tr><td style="text-align: left">position</td><td style="text-align: left">自定义弹出位置</td><td style="text-align: left">string</td><td style="text-align: left">top-right/top-left/bottom-right/bottom-left</td><td style="text-align: left">top-right</td></tr>
<tr><td style="text-align: left">showClose</td><td style="text-align: left">是否显示关闭按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">onClose</td><td style="text-align: left">关闭时的回调函数</td><td style="text-align: left">function</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">onClick</td><td style="text-align: left">点击 Notification 时的回调函数</td><td style="text-align: left">function</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">offset</td><td style="text-align: left">偏移的距离，在同一时刻，所有的 Notification 实例应当具有一个相同的偏移量</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
</tbody></table>
<h1 id="方法-1"><a class="header" href="#方法-1"><a href="https://element.eleme.cn/#/zh-CN/component/notification#fang-fa">¶</a>方法</a></h1>
<p>调用 <code>Notification</code> 或 <code>this.$notify</code> 会返回当前 Notification 的实例。如果需要手动关闭实例，可以调用它的 <code>close</code> 方法。</p>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">close</td><td style="text-align: left">关闭当前的 Notification</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alert-警告"><a class="header" href="#alert-警告">Alert 警告</a></h1>
<p>用于页面中展示重要的提示信息。</p>
<h1 id="基本用法-2"><a class="header" href="#基本用法-2">基本用法</a></h1>
<p>Alert 组件提供四种主题，由<code>type</code>属性指定，默认值为<code>info</code>。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-alert
    title=&quot;成功提示的文案&quot;
    type=&quot;success&quot;&gt;
  &lt;/el-alert&gt;
  &lt;el-alert
    title=&quot;消息提示的文案&quot;
    type=&quot;info&quot;&gt;
  &lt;/el-alert&gt;
  &lt;el-alert
    title=&quot;警告提示的文案&quot;
    type=&quot;warning&quot;&gt;
  &lt;/el-alert&gt;
  &lt;el-alert
    title=&quot;错误提示的文案&quot;
    type=&quot;error&quot;&gt;
  &lt;/el-alert&gt;
&lt;/template&gt;
</code></pre>
<h1 id="主题"><a class="header" href="#主题">主题</a></h1>
<p>Alert 组件提供了两个不同的主题：<code>light</code>和<code>dark</code>。</p>
<pre><code class="language-vue">template&gt;
  &lt;el-alert
    title=&quot;成功提示的文案&quot;
    type=&quot;success&quot;
    effect=&quot;dark&quot;&gt;
  &lt;/el-alert&gt;
  &lt;el-alert
    title=&quot;消息提示的文案&quot;
    type=&quot;info&quot;
    effect=&quot;dark&quot;&gt;
  &lt;/el-alert&gt;
  &lt;el-alert
    title=&quot;警告提示的文案&quot;
    type=&quot;warning&quot;
    effect=&quot;dark&quot;&gt;
  &lt;/el-alert&gt;
  &lt;el-alert
    title=&quot;错误提示的文案&quot;
    type=&quot;error&quot;
    effect=&quot;dark&quot;&gt;
  &lt;/el-alert&gt;
&lt;/template&gt;
</code></pre>
<h1 id="自定义关闭按钮"><a class="header" href="#自定义关闭按钮">自定义关闭按钮</a></h1>
<p>在 Alert 组件中，你可以设置是否可关闭，关闭按钮的文本以及关闭时的回调函数。<code>closable</code>属性决定是否可关闭，接受<code>boolean</code>，默认为<code>true</code>。你可以设置<code>close-text</code>属性来代替右侧的关闭图标，注意：<code>close-text</code>必须为文本。设置<code>close</code>事件来设置关闭时的回调。</p>
<pre><code class="language-vue">template&gt;
  &lt;el-alert
    title=&quot;不可关闭的 alert&quot;
    type=&quot;success&quot;
    :closable=&quot;false&quot;&gt;
  &lt;/el-alert&gt;
  &lt;el-alert
    title=&quot;自定义 close-text&quot;
    type=&quot;info&quot;
    close-text=&quot;知道了&quot;&gt;
  &lt;/el-alert&gt;
  &lt;el-alert
    title=&quot;设置了回调的 alert&quot;
    type=&quot;warning&quot;
    @close=&quot;hello&quot;&gt;
  &lt;/el-alert&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      hello() {
        alert('Hello World!');
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="带有-icon"><a class="header" href="#带有-icon">带有 icon</a></h1>
<pre><code class="language-vue">通过设置show-icon属性来显示 Alert 的 icon，这能更有效地向用户展示你的显示意图。

&lt;template&gt;
  &lt;el-alert
    title=&quot;成功提示的文案&quot;
    type=&quot;success&quot;
    show-icon&gt;
  &lt;/el-alert&gt;
  &lt;el-alert
    title=&quot;消息提示的文案&quot;
    type=&quot;info&quot;
    show-icon&gt;
  &lt;/el-alert&gt;
  &lt;el-alert
    title=&quot;警告提示的文案&quot;
    type=&quot;warning&quot;
    show-icon&gt;
  &lt;/el-alert&gt;
  &lt;el-alert
    title=&quot;错误提示的文案&quot;
    type=&quot;error&quot;
    show-icon&gt;
  &lt;/el-alert&gt;
&lt;/template&gt;
</code></pre>
<h1 id="文字居中"><a class="header" href="#文字居中">文字居中</a></h1>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-alert
    title=&quot;成功提示的文案&quot;
    type=&quot;success&quot;
    center
    show-icon&gt;
  &lt;/el-alert&gt;
  &lt;el-alert
    title=&quot;消息提示的文案&quot;
    type=&quot;info&quot;
    center
    show-icon&gt;
  &lt;/el-alert&gt;
  &lt;el-alert
    title=&quot;警告提示的文案&quot;
    type=&quot;warning&quot;
    center
    show-icon&gt;
  &lt;/el-alert&gt;
  &lt;el-alert
    title=&quot;错误提示的文案&quot;
    type=&quot;error&quot;
    center
    show-icon&gt;
  &lt;/el-alert&gt;
&lt;/template&gt;
</code></pre>
<h1 id="带有辅助性文字介绍"><a class="header" href="#带有辅助性文字介绍">带有辅助性文字介绍</a></h1>
<p>除了必填的<code>title</code>属性外，你可以设置<code>description</code>属性来帮助你更好地介绍，我们称之为辅助性文字。辅助性文字只能存放单行文本，会自动换行显示。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-alert
    title=&quot;带辅助性文字介绍&quot;
    type=&quot;success&quot;
    description=&quot;这是一句绕口令：黑灰化肥会挥发发灰黑化肥挥发；灰黑化肥会挥发发黑灰化肥发挥。 黑灰化肥会挥发发灰黑化肥黑灰挥发化为灰……&quot;&gt;
  &lt;/el-alert&gt;
&lt;/template&gt;
</code></pre>
<h1 id="带有-icon-和辅助性文字介绍"><a class="header" href="#带有-icon-和辅助性文字介绍">带有 icon 和辅助性文字介绍</a></h1>
<h1 id="属性事件和方法-10"><a class="header" href="#属性事件和方法-10">属性事件和方法</a></h1>
<h2 id="attributes-6"><a class="header" href="#attributes-6">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">title</td><td style="text-align: left">标题</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">type</td><td style="text-align: left">主题</td><td style="text-align: left">string</td><td style="text-align: left">success/warning/info/error</td><td style="text-align: left">info</td></tr>
<tr><td style="text-align: left">description</td><td style="text-align: left">辅助性文字。也可通过默认 slot 传入</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">closable</td><td style="text-align: left">是否可关闭</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">center</td><td style="text-align: left">文字是否居中</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">close-text</td><td style="text-align: left">关闭按钮自定义文本</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">show-icon</td><td style="text-align: left">是否显示图标</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">effect</td><td style="text-align: left">选择提供的主题</td><td style="text-align: left">string</td><td style="text-align: left">light/dark</td><td style="text-align: left">light</td></tr>
</tbody></table>
<h2 id="slot"><a class="header" href="#slot"><a href="https://element.eleme.cn/#/zh-CN/component/alert#slot">¶</a>Slot</a></h2>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">—</td><td style="text-align: left">描述</td></tr>
<tr><td style="text-align: left">title</td><td style="text-align: left">标题的内容</td></tr>
</tbody></table>
<h2 id="events-5"><a class="header" href="#events-5"><a href="https://element.eleme.cn/#/zh-CN/component/alert#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">close</td><td style="text-align: left">关闭alert时触发的事件</td><td style="text-align: left">—</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loading-加载"><a class="header" href="#loading-加载">Loading 加载</a></h1>
<p>加载数据时显示动效。</p>
<h3 id="区域加载"><a class="header" href="#区域加载">区域加载</a></h3>
<p>在表格等容器中加载数据时显示。</p>
<p>Element 提供了两种调用 Loading 的方法：指令和服务。对于自定义指令<code>v-loading</code>，只需要绑定<code>Boolean</code>即可。默认状况下，Loading 遮罩会插入到绑定元素的子节点，通过添加<code>body</code>修饰符，可以使遮罩插入至 DOM 中的 body 上。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    v-loading=&quot;loading&quot;
    :data=&quot;tableData&quot;
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column
      prop=&quot;date&quot;
      label=&quot;日期&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;address&quot;
      label=&quot;地址&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;

&lt;style&gt;
  body {
    margin: 0;
  }
&lt;/style&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        tableData: [{
          date: '2016-05-03',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }, {
          date: '2016-05-02',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }, {
          date: '2016-05-04',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }],
        loading: true
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="自定义"><a class="header" href="#自定义">自定义</a></h1>
<p>可自定义加载文案、图标和背景色。</p>
<p>在绑定了<code>v-loading</code>指令的元素上添加<code>element-loading-text</code>属性，其值会被渲染为加载文案，并显示在加载图标的下方。类似地，<code>element-loading-spinner</code>和<code>element-loading-background</code>属性分别用来设定图标类名和背景色值。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    v-loading=&quot;loading&quot;
    element-loading-text=&quot;拼命加载中&quot;
    element-loading-spinner=&quot;el-icon-loading&quot;
    element-loading-background=&quot;rgba(0, 0, 0, 0.8)&quot;
    :data=&quot;tableData&quot;
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column
      prop=&quot;date&quot;
      label=&quot;日期&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;address&quot;
      label=&quot;地址&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        tableData: [{
          date: '2016-05-03',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }, {
          date: '2016-05-02',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }, {
          date: '2016-05-04',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }],
        loading: true
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="整页加载"><a class="header" href="#整页加载">整页加载</a></h1>
<p>当使用指令方式时，全屏遮罩需要添加<code>fullscreen</code>修饰符（遮罩会插入至 body 上），此时若需要锁定屏幕的滚动，可以使用<code>lock</code>修饰符；当使用服务方式时，遮罩默认即为全屏，无需额外设置。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button
    type=&quot;primary&quot;
    @click=&quot;openFullScreen1&quot;
    v-loading.fullscreen.lock=&quot;fullscreenLoading&quot;&gt;
    指令方式
  &lt;/el-button&gt;
  &lt;el-button
    type=&quot;primary&quot;
    @click=&quot;openFullScreen2&quot;&gt;
    服务方式
  &lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        fullscreenLoading: false
      }
    },
    methods: {
      openFullScreen1() {
        this.fullscreenLoading = true;
        setTimeout(() =&gt; {
          this.fullscreenLoading = false;
        }, 2000);
      },
      openFullScreen2() {
        const loading = this.$loading({
          lock: true,
          text: 'Loading',
          spinner: 'el-icon-loading',
          background: 'rgba(0, 0, 0, 0.7)'
        });
        setTimeout(() =&gt; {
          loading.close();
        }, 2000);
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="服务"><a class="header" href="#服务">服务</a></h1>
<p>Loading 还可以以服务的方式调用。引入 Loading 服务：</p>
<pre><code class="language-javascript">import { Loading } from 'element-ui';
</code></pre>
<p>在需要调用时：</p>
<pre><code class="language-javascript">Loading.service(options);
</code></pre>
<p>其中 <code>options</code> 参数为 Loading 的配置项，具体见下表。<code>LoadingService</code> 会返回一个 Loading 实例，可通过调用该实例的 <code>close</code> 方法来关闭它：</p>
<pre><code class="language-javascript">let loadingInstance = Loading.service(options);
this.$nextTick(() =&gt; { // 以服务的方式调用的 Loading 需要异步关闭
  loadingInstance.close();
});
</code></pre>
<p>需要注意的是，以服务的方式调用的全屏 Loading 是单例的：若在前一个全屏 Loading 关闭前再次调用全屏 Loading，并不会创建一个新的 Loading 实例，而是返回现有全屏 Loading 的实例：</p>
<pre><code class="language-javascript">let loadingInstance1 = Loading.service({ fullscreen: true });
let loadingInstance2 = Loading.service({ fullscreen: true });
console.log(loadingInstance1 === loadingInstance2); // true
</code></pre>
<p>此时调用它们中任意一个的 <code>close</code> 方法都能关闭这个全屏 Loading。</p>
<p>如果完整引入了 Element，那么 Vue.prototype 上会有一个全局方法 <code>$loading</code>，它的调用方式为：<code>this.$loading(options)</code>，同样会返回一个 Loading 实例。</p>
<h1 id="options-1"><a class="header" href="#options-1">Options</a></h1>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">target</td><td style="text-align: left">Loading 需要覆盖的 DOM 节点。可传入一个 DOM 对象或字符串；若传入字符串，则会将其作为参数传入 <code>document.querySelector</code>以获取到对应 DOM 节点</td><td style="text-align: left">object/string</td><td style="text-align: left">—</td><td style="text-align: left">document.body</td></tr>
<tr><td style="text-align: left">body</td><td style="text-align: left">同 <code>v-loading</code> 指令中的 <code>body</code> 修饰符</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">fullscreen</td><td style="text-align: left">同 <code>v-loading</code> 指令中的 <code>fullscreen</code> 修饰符</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">lock</td><td style="text-align: left">同 <code>v-loading</code> 指令中的 <code>lock</code> 修饰符</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">text</td><td style="text-align: left">显示在加载图标下方的加载文案</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">spinner</td><td style="text-align: left">自定义加载图标类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">background</td><td style="text-align: left">遮罩背景色</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">customClass</td><td style="text-align: left">Loading 的自定义类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messagebox-弹框"><a class="header" href="#messagebox-弹框">MessageBox 弹框</a></h1>
<p>模拟系统的消息提示框而实现的一套模态对话框组件，用于消息提示、确认消息和提交内容。</p>
<p>从场景上说，MessageBox 的作用是美化系统自带的 <code>alert</code>、<code>confirm</code> 和 <code>prompt</code>，因此适合展示较为简单的内容。如果需要弹出较为复杂的内容，请使用 Dialog。</p>
<p>调用<code>$alert</code>方法即可打开消息提示，它模拟了系统的 <code>alert</code>，无法通过按下 ESC 或点击框外关闭。此例中接收了两个参数，<code>message</code>和<code>title</code>。值得一提的是，窗口被关闭后，它默认会返回一个<code>Promise</code>对象便于进行后续操作的处理。若不确定浏览器是否支持<code>Promise</code>，可自行引入第三方 polyfill 或像本例一样使用回调进行后续处理。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button type=&quot;text&quot; @click=&quot;open&quot;&gt;点击打开 Message Box&lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open() {
        this.$alert('这是一段内容', '标题名称', {
          confirmButtonText: '确定',
          callback: action =&gt; {
            this.$message({
              type: 'info',
              message: `action: ${ action }`
            });
          }
        });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="确认消息"><a class="header" href="#确认消息">确认消息</a></h1>
<p>调用<code>$confirm</code>方法即可打开消息提示，它模拟了系统的 <code>confirm</code>。Message Box 组件也拥有极高的定制性，我们可以传入<code>options</code>作为第三个参数，它是一个字面量对象。<code>type</code>字段表明消息类型，可以为<code>success</code>，<code>error</code>，<code>info</code>和<code>warning</code>，无效的设置将会被忽略。注意，第二个参数<code>title</code>必须定义为<code>String</code>类型，如果是<code>Object</code>，会被理解为<code>options</code>。在这里我们用了 Promise 来处理后续响应。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button type=&quot;text&quot; @click=&quot;open&quot;&gt;点击打开 Message Box&lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open() {
        this.$confirm('此操作将永久删除该文件, 是否继续?', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() =&gt; {
          this.$message({
            type: 'success',
            message: '删除成功!'
          });
        }).catch(() =&gt; {
          this.$message({
            type: 'info',
            message: '已取消删除'
          });          
        });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="提交内容"><a class="header" href="#提交内容">提交内容</a></h1>
<pre><code class="language-vue">调用$prompt方法即可打开消息提示，它模拟了系统的 prompt。可以用inputPattern字段自己规定匹配模式，或者用inputValidator规定校验函数，可以返回Boolean或String，返回false或字符串时均表示校验未通过，同时返回的字符串相当于定义了inputErrorMessage字段。此外，可以用inputPlaceholder字段来定义输入框的占位符。

&lt;template&gt;
  &lt;el-button type=&quot;text&quot; @click=&quot;open&quot;&gt;点击打开 Message Box&lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open() {
        this.$prompt('请输入邮箱', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          inputPattern: /[\w!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[\w!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[\w](?:[\w-]*[\w])?\.)+[\w](?:[\w-]*[\w])?/,
          inputErrorMessage: '邮箱格式不正确'
        }).then(({ value }) =&gt; {
          this.$message({
            type: 'success',
            message: '你的邮箱是: ' + value
          });
        }).catch(() =&gt; {
          this.$message({
            type: 'info',
            message: '取消输入'
          });       
        });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="自定义-1"><a class="header" href="#自定义-1">自定义</a></h1>
<p>可自定义配置不同内容。</p>
<p>以上三个方法都是对<code>$msgbox</code>方法的再包装。本例直接调用<code>$msgbox</code>方法，使用了<code>showCancelButton</code>字段，用于显示取消按钮。另外可使用<code>cancelButtonClass</code>为其添加自定义样式，使用<code>cancelButtonText</code>来自定义按钮文本（Confirm 按钮也具有相同的字段，在文末的字段说明中有完整的字段列表）。此例还使用了<code>beforeClose</code>属性，它的值是一个方法，会在 MessageBox 的实例关闭前被调用，同时暂停实例的关闭。它有三个参数：<code>action</code>、实例本身和<code>done</code>方法。使用它能够在关闭前对实例进行一些操作，比如为确定按钮添加<code>loading</code>状态等；此时若需要关闭实例，可以调用<code>done</code>方法（若在<code>beforeClose</code>中没有调用<code>done</code>，则实例不会关闭）。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button type=&quot;text&quot; @click=&quot;open&quot;&gt;点击打开 Message Box&lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open() {
        const h = this.$createElement;
        this.$msgbox({
          title: '消息',
          message: h('p', null, [
            h('span', null, '内容可以是 '),
            h('i', { style: 'color: teal' }, 'VNode')
          ]),
          showCancelButton: true,
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          beforeClose: (action, instance, done) =&gt; {
            if (action === 'confirm') {
              instance.confirmButtonLoading = true;
              instance.confirmButtonText = '执行中...';
              setTimeout(() =&gt; {
                done();
                setTimeout(() =&gt; {
                  instance.confirmButtonLoading = false;
                }, 300);
              }, 3000);
            } else {
              done();
            }
          }
        }).then(action =&gt; {
          this.$message({
            type: 'info',
            message: 'action: ' + action
          });
        });
      }
    }
  }
&lt;/script&gt;

</code></pre>
<h1 id="使用-html-片段-1"><a class="header" href="#使用-html-片段-1">使用 HTML 片段</a></h1>
<pre><code class="language-vue">将dangerouslyUseHTMLString属性设置为 true，message 就会被当作 HTML 片段处理。

&lt;template&gt;
  &lt;el-button type=&quot;text&quot; @click=&quot;open&quot;&gt;点击打开 Message Box&lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open() {
        this.$alert('&lt;strong&gt;这是 &lt;i&gt;HTML&lt;/i&gt; 片段&lt;/strong&gt;', 'HTML 片段', {
          dangerouslyUseHTMLString: true
        });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="区分取消与关闭"><a class="header" href="#区分取消与关闭">区分取消与关闭</a></h1>
<p>有些场景下，点击取消按钮与点击关闭按钮有着不同的含义。</p>
<p>默认情况下，当用户触发取消（点击取消按钮）和触发关闭（点击关闭按钮或遮罩层、按下 ESC 键）时，Promise 的 reject 回调和<code>callback</code>回调的参数均为 'cancel'。如果将<code>distinguishCancelAndClose</code>属性设置为 true，则上述两种行为的参数分别为 'cancel' 和 'close'。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button type=&quot;text&quot; @click=&quot;open&quot;&gt;点击打开 Message Box&lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open() {
        this.$confirm('检测到未保存的内容，是否在离开页面前保存修改？', '确认信息', {
          distinguishCancelAndClose: true,
          confirmButtonText: '保存',
          cancelButtonText: '放弃修改'
        })
          .then(() =&gt; {
            this.$message({
              type: 'info',
              message: '保存修改'
            });
          })
          .catch(action =&gt; {
            this.$message({
              type: 'info',
              message: action === 'cancel'
                ? '放弃保存并离开页面'
                : '停留在当前页面'
            })
          });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="居中布局"><a class="header" href="#居中布局">居中布局</a></h1>
<p>将 <code>center</code> 设置为 <code>true</code> 即可开启居中布局</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button type=&quot;text&quot; @click=&quot;open&quot;&gt;点击打开 Message Box&lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open() {
        this.$confirm('此操作将永久删除该文件, 是否继续?', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning',
          center: true
        }).then(() =&gt; {
          this.$message({
            type: 'success',
            message: '删除成功!'
          });
        }).catch(() =&gt; {
          this.$message({
            type: 'info',
            message: '已取消删除'
          });
        });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="全局方法-1"><a class="header" href="#全局方法-1">全局方法</a></h1>
<p>如果你完整引入了 Element，它会为 Vue.prototype 添加如下全局方法：$msgbox, $alert, $confirm 和 $prompt。因此在 Vue instance 中可以采用本页面中的方式调用 <code>MessageBox</code>。调用参数为：</p>
<ul>
<li><code>$msgbox(options)</code></li>
<li><code>$alert(message, title, options)</code> 或 <code>$alert(message, options)</code></li>
<li><code>$confirm(message, title, options)</code> 或 <code>$confirm(message, options)</code></li>
<li><code>$prompt(message, title, options)</code> 或 <code>$prompt(message, options)</code></li>
</ul>
<h1 id="单独引用-1"><a class="header" href="#单独引用-1">单独引用</a></h1>
<p>如果单独引入 <code>MessageBox</code>：</p>
<pre><code class="language-javascript">import { MessageBox } from 'element-ui';
</code></pre>
<p>那么对应于上述四个全局方法的调用方法依次为：MessageBox, MessageBox.alert, MessageBox.confirm 和 MessageBox.prompt，调用参数与全局方法相同。</p>
<h1 id="options-2"><a class="header" href="#options-2">Options</a></h1>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">title</td><td style="text-align: left">MessageBox 标题</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">message</td><td style="text-align: left">MessageBox 消息正文内容</td><td style="text-align: left">string / VNode</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">dangerouslyUseHTMLString</td><td style="text-align: left">是否将 message 属性作为 HTML 片段处理</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">type</td><td style="text-align: left">消息类型，用于显示图标</td><td style="text-align: left">string</td><td style="text-align: left">success / info / warning / error</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">iconClass</td><td style="text-align: left">自定义图标的类名，会覆盖 <code>type</code></td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">customClass</td><td style="text-align: left">MessageBox 的自定义类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">callback</td><td style="text-align: left">若不使用 Promise，可以使用此参数指定 MessageBox 关闭后的回调</td><td style="text-align: left">function(action, instance)，action 的值为'confirm', 'cancel'或'close', instance 为 MessageBox 实例，可以通过它访问实例上的属性和方法</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">showClose</td><td style="text-align: left">MessageBox 是否显示右上角关闭按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">beforeClose</td><td style="text-align: left">MessageBox 关闭前的回调，会暂停实例的关闭</td><td style="text-align: left">function(action, instance, done)，action 的值为'confirm', 'cancel'或'close'；instance 为 MessageBox 实例，可以通过它访问实例上的属性和方法；done 用于关闭 MessageBox 实例</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">distinguishCancelAndClose</td><td style="text-align: left">是否将取消（点击取消按钮）与关闭（点击关闭按钮或遮罩层、按下 ESC 键）进行区分</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">lockScroll</td><td style="text-align: left">是否在 MessageBox 出现时将 body 滚动锁定</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">showCancelButton</td><td style="text-align: left">是否显示取消按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false（以 confirm 和 prompt 方式调用时为 true）</td></tr>
<tr><td style="text-align: left">showConfirmButton</td><td style="text-align: left">是否显示确定按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">cancelButtonText</td><td style="text-align: left">取消按钮的文本内容</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">取消</td></tr>
<tr><td style="text-align: left">confirmButtonText</td><td style="text-align: left">确定按钮的文本内容</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">确定</td></tr>
<tr><td style="text-align: left">cancelButtonClass</td><td style="text-align: left">取消按钮的自定义类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">confirmButtonClass</td><td style="text-align: left">确定按钮的自定义类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">closeOnClickModal</td><td style="text-align: left">是否可通过点击遮罩关闭 MessageBox</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true（以 alert 方式调用时为 false）</td></tr>
<tr><td style="text-align: left">closeOnPressEscape</td><td style="text-align: left">是否可通过按下 ESC 键关闭 MessageBox</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true（以 alert 方式调用时为 false）</td></tr>
<tr><td style="text-align: left">closeOnHashChange</td><td style="text-align: left">是否在 hashchange 时关闭 MessageBox</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">showInput</td><td style="text-align: left">是否显示输入框</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false（以 prompt 方式调用时为 true）</td></tr>
<tr><td style="text-align: left">inputPlaceholder</td><td style="text-align: left">输入框的占位符</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">inputType</td><td style="text-align: left">输入框的类型</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">text</td></tr>
<tr><td style="text-align: left">inputValue</td><td style="text-align: left">输入框的初始文本</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">inputPattern</td><td style="text-align: left">输入框的校验表达式</td><td style="text-align: left">regexp</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">inputValidator</td><td style="text-align: left">输入框的校验函数。可以返回布尔值或字符串，若返回一个字符串, 则返回结果会被赋值给 inputErrorMessage</td><td style="text-align: left">function</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">inputErrorMessage</td><td style="text-align: left">校验未通过时的提示文本</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">输入的数据不合法!</td></tr>
<tr><td style="text-align: left">center</td><td style="text-align: left">是否居中布局</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">roundButton</td><td style="text-align: left">是否使用圆角按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-消息提示"><a class="header" href="#message-消息提示">Message 消息提示</a></h1>
<p>常用于主动操作后的反馈提示。与 Notification 的区别是后者更多用于系统级通知的被动提醒。</p>
<h1 id="基础用法-8"><a class="header" href="#基础用法-8">基础用法</a></h1>
<p>从顶部出现，3 秒后自动消失。</p>
<p>Message 在配置上与 Notification 非常类似，所以部分 options 在此不做详尽解释，文末有 options 列表，可以结合 Notification 的文档理解它们。Element 注册了一个<code>$message</code>方法用于调用，Message 可以接收一个字符串或一个 VNode 作为参数，它会被显示为正文内容。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button :plain=&quot;true&quot; @click=&quot;open&quot;&gt;打开消息提示&lt;/el-button&gt;
  &lt;el-button :plain=&quot;true&quot; @click=&quot;openVn&quot;&gt;VNode&lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open() {
        this.$message('这是一条消息提示');
      },

      openVn() {
        const h = this.$createElement;
        this.$message({
          message: h('p', null, [
            h('span', null, '内容可以是 '),
            h('i', { style: 'color: teal' }, 'VNode')
          ])
        });
      }
    }
  }
&lt;/script&gt;

</code></pre>
<h1 id="不同状态"><a class="header" href="#不同状态">不同状态</a></h1>
<p>用来显示「成功、警告、消息、错误」类的操作反馈。</p>
<p>当需要自定义更多属性时，Message 也可以接收一个对象为参数。比如，设置<code>type</code>字段可以定义不同的状态，默认为<code>info</code>。此时正文内容以<code>message</code>的值传入。同时，我们也为 Message 的各种 type 注册了方法，可以在不传入<code>type</code>字段的情况下像<code>open4</code>那样直接调用。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button :plain=&quot;true&quot; @click=&quot;open2&quot;&gt;成功&lt;/el-button&gt;
  &lt;el-button :plain=&quot;true&quot; @click=&quot;open3&quot;&gt;警告&lt;/el-button&gt;
  &lt;el-button :plain=&quot;true&quot; @click=&quot;open1&quot;&gt;消息&lt;/el-button&gt;
  &lt;el-button :plain=&quot;true&quot; @click=&quot;open4&quot;&gt;错误&lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open1() {
        this.$message('这是一条消息提示');
      },
      open2() {
        this.$message({
          message: '恭喜你，这是一条成功消息',
          type: 'success'
        });
      },

      open3() {
        this.$message({
          message: '警告哦，这是一条警告消息',
          type: 'warning'
        });
      },

      open4() {
        this.$message.error('错了哦，这是一条错误消息');
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="可关闭"><a class="header" href="#可关闭">可关闭</a></h1>
<p>默认的 Message 是不可以被人工关闭的，如果需要可手动关闭的 Message，可以使用<code>showClose</code>字段。此外，和 Notification 一样，Message 拥有可控的<code>duration</code>，设置<code>0</code>为不会被自动关闭，默认为 3000 毫秒。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button :plain=&quot;true&quot; @click=&quot;open1&quot;&gt;消息&lt;/el-button&gt;
  &lt;el-button :plain=&quot;true&quot; @click=&quot;open2&quot;&gt;成功&lt;/el-button&gt;
  &lt;el-button :plain=&quot;true&quot; @click=&quot;open3&quot;&gt;警告&lt;/el-button&gt;
  &lt;el-button :plain=&quot;true&quot; @click=&quot;open4&quot;&gt;错误&lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      open1() {
        this.$message({
          showClose: true,
          message: '这是一条消息提示'
        });
      },

      open2() {
        this.$message({
          showClose: true,
          message: '恭喜你，这是一条成功消息',
          type: 'success'
        });
      },

      open3() {
        this.$message({
          showClose: true,
          message: '警告哦，这是一条警告消息',
          type: 'warning'
        });
      },

      open4() {
        this.$message({
          showClose: true,
          message: '错了哦，这是一条错误消息',
          type: 'error'
        });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="文字居中-1"><a class="header" href="#文字居中-1">文字居中</a></h1>
<p>使用 <code>center</code> 属性让文字水平居中。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button :plain=&quot;true&quot; @click=&quot;openCenter&quot;&gt;文字居中&lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      openCenter() {
        this.$message({
          message: '居中的文字',
          center: true
        });
      }
    }
  }
&lt;/script&gt;

</code></pre>
<h1 id="使用-html-片段-2"><a class="header" href="#使用-html-片段-2">使用 HTML 片段</a></h1>
<p><code>message</code> 属性支持传入 HTML 片段</p>
<p>将<code>dangerouslyUseHTMLString</code>属性设置为 true，<code>message</code> 就会被当作 HTML 片段处理。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button :plain=&quot;true&quot; @click=&quot;openHTML&quot;&gt;使用 HTML 片段&lt;/el-button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      openHTML() {
        this.$message({
          dangerouslyUseHTMLString: true,
          message: '&lt;strong&gt;这是 &lt;i&gt;HTML&lt;/i&gt; 片段&lt;/strong&gt;'
        });
      }
    }
  }
&lt;/script&gt;
</code></pre>
<p><code>message</code> 属性虽然支持传入 HTML 片段，但是在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS 攻击</a>。因此在 <code>dangerouslyUseHTMLString</code> 打开的情况下，请确保 <code>message</code> 的内容是可信的，<strong>永远不要</strong>将用户提交的内容赋值给 <code>message</code> 属性。</p>
<h1 id="全局方法-2"><a class="header" href="#全局方法-2">全局方法</a></h1>
<p>Element 为 Vue.prototype 添加了全局方法 $message。因此在 vue instance 中可以采用本页面中的方式调用 <code>Message</code>。</p>
<h1 id="单独引用-2"><a class="header" href="#单独引用-2">单独引用</a></h1>
<p>单独引入 <code>Message</code>：</p>
<pre><code class="language-javascript">import { Message } from 'element-ui';
</code></pre>
<p>此时调用方法为 <code>Message(options)</code>。我们也为每个 type 定义了各自的方法，如 <code>Message.success(options)</code>。并且可以调用 <code>Message.closeAll()</code> 手动关闭所有实例。</p>
<h1 id="属性事件和方法-11"><a class="header" href="#属性事件和方法-11">属性事件和方法</a></h1>
<h2 id="options-3"><a class="header" href="#options-3">Options</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">message</td><td style="text-align: left">消息文字</td><td style="text-align: left">string / VNode</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">type</td><td style="text-align: left">主题</td><td style="text-align: left">string</td><td style="text-align: left">success/warning/info/error</td><td style="text-align: left">info</td></tr>
<tr><td style="text-align: left">iconClass</td><td style="text-align: left">自定义图标的类名，会覆盖 <code>type</code></td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">dangerouslyUseHTMLString</td><td style="text-align: left">是否将 message 属性作为 HTML 片段处理</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">customClass</td><td style="text-align: left">自定义类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">duration</td><td style="text-align: left">显示时间, 毫秒。设为 0 则不会自动关闭</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">3000</td></tr>
<tr><td style="text-align: left">showClose</td><td style="text-align: left">是否显示关闭按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">center</td><td style="text-align: left">文字是否居中</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">onClose</td><td style="text-align: left">关闭时的回调函数, 参数为被关闭的 message 实例</td><td style="text-align: left">function</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">offset</td><td style="text-align: left">Message 距离窗口顶部的偏移量</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">20</td></tr>
</tbody></table>
<h2 id="方法-2"><a class="header" href="#方法-2"><a href="https://element.eleme.cn/#/zh-CN/component/message#fang-fa">¶</a>方法</a></h2>
<p>调用 <code>Message</code> 或 <code>this.$message</code> 会返回当前 Message 的实例。如果需要手动关闭实例，可以调用它的 <code>close</code> 方法。</p>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">close</td><td style="text-align: left">关闭当前的 Message</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="popconfirm-气泡确认框"><a class="header" href="#popconfirm-气泡确认框">Popconfirm 气泡确认框</a></h1>
<p>点击元素，弹出气泡确认框。</p>
<h1 id="基础用法-9"><a class="header" href="#基础用法-9">基础用法</a></h1>
<p>Popconfirm 的属性与 Popover 很类似，因此对于重复属性，请参考 Popover 的文档，在此文档中不做详尽解释。</p>
<p>在 Popconfirm 中，只有 <code>title</code> 属性可用，<code>content</code> 属性不会被展示。</p>
<pre><code class="language-vue">&lt;template&gt;
&lt;el-popconfirm
  title=&quot;这是一段内容确定删除吗？&quot;
&gt;
  &lt;el-button slot=&quot;reference&quot;&gt;删除&lt;/el-button&gt;
&lt;/el-popconfirm&gt;
&lt;/template&gt;
</code></pre>
<h1 id="自定义-2"><a class="header" href="#自定义-2">自定义</a></h1>
<p>可以在 Popconfirm 中自定义内容。</p>
<pre><code class="language-vue">&lt;template&gt;
&lt;el-popconfirm
  confirmButtonText='好的'
  cancelButtonText='不用了'
  icon=&quot;el-icon-info&quot;
  iconColor=&quot;red&quot;
  title=&quot;这是一段内容确定删除吗？&quot;
&gt;
  &lt;el-button slot=&quot;reference&quot;&gt;删除&lt;/el-button&gt;
&lt;/el-popconfirm&gt;
&lt;/template&gt;
</code></pre>
<h1 id="属性事件和方法-12"><a class="header" href="#属性事件和方法-12">属性事件和方法</a></h1>
<h2 id="attributes-7"><a class="header" href="#attributes-7">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">title</td><td style="text-align: left">标题</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">confirmButtonText</td><td style="text-align: left">确认按钮文字</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">cancelButtonText</td><td style="text-align: left">取消按钮文字</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">confirmButtonType</td><td style="text-align: left">确认按钮类型</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">Primary</td></tr>
<tr><td style="text-align: left">cancelButtonType</td><td style="text-align: left">取消按钮类型</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">Text</td></tr>
<tr><td style="text-align: left">icon</td><td style="text-align: left">Icon</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">el-icon-question</td></tr>
<tr><td style="text-align: left">iconColor</td><td style="text-align: left">Icon 颜色</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">#f90</td></tr>
<tr><td style="text-align: left">hideIcon</td><td style="text-align: left">是否隐藏 Icon</td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
</tbody></table>
<h2 id="slot-1"><a class="header" href="#slot-1"><a href="https://element.eleme.cn/#/zh-CN/component/popconfirm#slot">¶</a>Slot</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">reference</td><td style="text-align: left">触发 Popconfirm 显示的 HTML 元素</td></tr>
</tbody></table>
<h2 id="events-6"><a class="header" href="#events-6"><a href="https://element.eleme.cn/#/zh-CN/component/popconfirm#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">onConfirm</td><td style="text-align: left">点击确认按钮时触发</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">onCancel</td><td style="text-align: left">点击取消按钮时触发</td><td style="text-align: left">—</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="popover-弹出框"><a class="header" href="#popover-弹出框">Popover 弹出框</a></h1>
<h1 id="基础用法-10"><a class="header" href="#基础用法-10">基础用法</a></h1>
<p>Popover 的属性与 Tooltip 很类似，它们都是基于<code>Vue-popper</code>开发的，因此对于重复属性，请参考 Tooltip 的文档，在此文档中不做详尽解释</p>
<p><code>trigger</code>属性用于设置何时触发 Popover，支持四种触发方式：<code>hover</code>，<code>click</code>，<code>focus</code> 和 <code>manual</code>。对于触发 Popover 的元素，有两种写法：使用 <code>slot=&quot;reference&quot;</code> 的具名插槽，或使用自定义指令<code>v-popover</code>指向 Popover 的索引<code>ref</code>。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-popover
    placement=&quot;top-start&quot;
    title=&quot;标题&quot;
    width=&quot;200&quot;
    trigger=&quot;hover&quot;
    content=&quot;这是一段内容,这是一段内容,这是一段内容,这是一段内容。&quot;&gt;
    &lt;el-button slot=&quot;reference&quot;&gt;hover 激活&lt;/el-button&gt;
  &lt;/el-popover&gt;

  &lt;el-popover
    placement=&quot;bottom&quot;
    title=&quot;标题&quot;
    width=&quot;200&quot;
    trigger=&quot;click&quot;
    content=&quot;这是一段内容,这是一段内容,这是一段内容,这是一段内容。&quot;&gt;
    &lt;el-button slot=&quot;reference&quot;&gt;click 激活&lt;/el-button&gt;
  &lt;/el-popover&gt;

  &lt;el-popover
    ref=&quot;popover&quot;
    placement=&quot;right&quot;
    title=&quot;标题&quot;
    width=&quot;200&quot;
    trigger=&quot;focus&quot;
    content=&quot;这是一段内容,这是一段内容,这是一段内容,这是一段内容。&quot;&gt;
  &lt;/el-popover&gt;
  &lt;el-button v-popover:popover&gt;focus 激活&lt;/el-button&gt;

  &lt;el-popover
    placement=&quot;bottom&quot;
    title=&quot;标题&quot;
    width=&quot;200&quot;
    trigger=&quot;manual&quot;
    content=&quot;这是一段内容,这是一段内容,这是一段内容,这是一段内容。&quot;
    v-model=&quot;visible&quot;&gt;
    &lt;el-button slot=&quot;reference&quot; @click=&quot;visible = !visible&quot;&gt;手动激活&lt;/el-button&gt;
  &lt;/el-popover&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        visible: false
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="嵌套信息"><a class="header" href="#嵌套信息">嵌套信息</a></h1>
<p>利用分发取代<code>content</code>属性</p>
<pre><code class="language-vue">&lt;el-popover
  placement=&quot;right&quot;
  width=&quot;400&quot;
  trigger=&quot;click&quot;&gt;
  &lt;el-table :data=&quot;gridData&quot;&gt;
    &lt;el-table-column width=&quot;150&quot; property=&quot;date&quot; label=&quot;日期&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column width=&quot;100&quot; property=&quot;name&quot; label=&quot;姓名&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column width=&quot;300&quot; property=&quot;address&quot; label=&quot;地址&quot;&gt;&lt;/el-table-column&gt;
  &lt;/el-table&gt;
  &lt;el-button slot=&quot;reference&quot;&gt;click 激活&lt;/el-button&gt;
&lt;/el-popover&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        gridData: [{
          date: '2016-05-02',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }, {
          date: '2016-05-04',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }, {
          date: '2016-05-01',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }, {
          date: '2016-05-03',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }]
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="嵌套操作"><a class="header" href="#嵌套操作">嵌套操作</a></h1>
<pre><code class="language-vue">&lt;el-popover
  placement=&quot;top&quot;
  width=&quot;160&quot;
  v-model=&quot;visible&quot;&gt;
  &lt;p&gt;这是一段内容这是一段内容确定删除吗？&lt;/p&gt;
  &lt;div style=&quot;text-align: right; margin: 0&quot;&gt;
    &lt;el-button size=&quot;mini&quot; type=&quot;text&quot; @click=&quot;visible = false&quot;&gt;取消&lt;/el-button&gt;
    &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;visible = false&quot;&gt;确定&lt;/el-button&gt;
  &lt;/div&gt;
  &lt;el-button slot=&quot;reference&quot;&gt;删除&lt;/el-button&gt;
&lt;/el-popover&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        visible: false,
      };
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="属性事件和方法-13"><a class="header" href="#属性事件和方法-13">属性事件和方法</a></h1>
<h2 id="attributes-8"><a class="header" href="#attributes-8">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">trigger</td><td style="text-align: left">触发方式</td><td style="text-align: left">String</td><td style="text-align: left">click/focus/hover/manual</td><td style="text-align: left">click</td></tr>
<tr><td style="text-align: left">title</td><td style="text-align: left">标题</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">content</td><td style="text-align: left">显示的内容，也可以通过 <code>slot</code> 传入 DOM</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">width</td><td style="text-align: left">宽度</td><td style="text-align: left">String, Number</td><td style="text-align: left">—</td><td style="text-align: left">最小宽度 150px</td></tr>
<tr><td style="text-align: left">placement</td><td style="text-align: left">出现位置</td><td style="text-align: left">String</td><td style="text-align: left">top/top-start/top-end/bottom/bottom-start/bottom-end/left/left-start/left-end/right/right-start/right-end</td><td style="text-align: left">bottom</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">Popover 是否可用</td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">状态是否可见</td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">offset</td><td style="text-align: left">出现位置的偏移量</td><td style="text-align: left">Number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">transition</td><td style="text-align: left">定义渐变动画</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">fade-in-linear</td></tr>
<tr><td style="text-align: left">visible-arrow</td><td style="text-align: left">是否显示 Tooltip 箭头，更多参数可见<a href="https://github.com/element-component/vue-popper">Vue-popper</a></td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">popper-options</td><td style="text-align: left"><a href="https://popper.js.org/documentation.html">popper.js</a> 的参数</td><td style="text-align: left">Object</td><td style="text-align: left">参考 <a href="https://popper.js.org/documentation.html">popper.js</a> 文档</td><td style="text-align: left"><code>{ boundariesElement: 'body', gpuAcceleration: false }</code></td></tr>
<tr><td style="text-align: left">popper-class</td><td style="text-align: left">为 popper 添加类名</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">open-delay</td><td style="text-align: left">触发方式为 hover 时的显示延迟，单位为毫秒</td><td style="text-align: left">Number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">close-delay</td><td style="text-align: left">触发方式为 hover 时的隐藏延迟，单位为毫秒</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">200</td></tr>
<tr><td style="text-align: left">tabindex</td><td style="text-align: left">Popover 组件的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex">tabindex</a></td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
</tbody></table>
<h2 id="slot-2"><a class="header" href="#slot-2"><a href="https://element.eleme.cn/#/zh-CN/component/popover#slot">¶</a>Slot</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">—</td><td style="text-align: left">Popover 内嵌 HTML 文本</td></tr>
<tr><td style="text-align: left">reference</td><td style="text-align: left">触发 Popover 显示的 HTML 元素</td></tr>
</tbody></table>
<h2 id="events-7"><a class="header" href="#events-7"><a href="https://element.eleme.cn/#/zh-CN/component/popover#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">show</td><td style="text-align: left">显示时触发</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">after-enter</td><td style="text-align: left">显示动画播放完毕后触发</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">hide</td><td style="text-align: left">隐藏时触发</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">after-leave</td><td style="text-align: left">隐藏动画播放完毕后触发</td><td style="text-align: left">—</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-2"><a class="header" href="#简介-2">简介</a></h1>
<p>通过拖动滑块在一个固定区间内进行选择</p>
<h1 id="基础用法-11"><a class="header" href="#基础用法-11">基础用法</a></h1>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;默认&lt;/span&gt;
    &lt;el-slider v-model=&quot;value1&quot;&gt;&lt;/el-slider&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;自定义初始值&lt;/span&gt;
    &lt;el-slider v-model=&quot;value2&quot;&gt;&lt;/el-slider&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;隐藏 Tooltip&lt;/span&gt;
    &lt;el-slider v-model=&quot;value3&quot; :show-tooltip=&quot;false&quot;&gt;&lt;/el-slider&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;格式化 Tooltip&lt;/span&gt;
    &lt;el-slider v-model=&quot;value4&quot; :format-tooltip=&quot;formatTooltip&quot;&gt;&lt;/el-slider&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;禁用&lt;/span&gt;
    &lt;el-slider v-model=&quot;value5&quot; disabled&gt;&lt;/el-slider&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value1: 0,
        value2: 50,
        value3: 36,
        value4: 48,
        value5: 42
      }
    },
    methods: {
      formatTooltip(val) {
        return val / 100;
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="离散值"><a class="header" href="#离散值">离散值</a></h1>
<p>改变<code>step</code>的值可以改变步长，通过设置<code>show-stops</code>属性可以显示间断点</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;不显示间断点&lt;/span&gt;
    &lt;el-slider
      v-model=&quot;value1&quot;
      :step=&quot;10&quot;&gt;
    &lt;/el-slider&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;显示间断点&lt;/span&gt;
    &lt;el-slider
      v-model=&quot;value2&quot;
      :step=&quot;10&quot;
      show-stops&gt;
    &lt;/el-slider&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value1: 0,
        value2: 0
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="带有输入框"><a class="header" href="#带有输入框">带有输入框</a></h1>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;el-slider
      v-model=&quot;value&quot;
      show-input&gt;
    &lt;/el-slider&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value: 0
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="范围选择"><a class="header" href="#范围选择">范围选择</a></h1>
<p>支持选择某一数值范围</p>
<p>设置<code>range</code>即可开启范围选择，此时绑定值是一个数组，其元素分别为最小边界值和最大边界值</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;el-slider
      v-model=&quot;value&quot;
      range
      show-stops
      :max=&quot;10&quot;&gt;
    &lt;/el-slider&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value: [4, 8]
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="竖向模式"><a class="header" href="#竖向模式">竖向模式</a></h1>
<p>设置<code>vertical</code>可使 Slider 变成竖向模式，此时必须设置高度<code>height</code>属性</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;el-slider
      v-model=&quot;value&quot;
      vertical
      height=&quot;200px&quot;&gt;
    &lt;/el-slider&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value: 0
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="展示标记"><a class="header" href="#展示标记">展示标记</a></h1>
<p>设置 <code>marks</code> 属性可以展示标记</p>
<pre><code class="language-vue">template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;el-slider
      v-model=&quot;value&quot;
      range
      :marks=&quot;marks&quot;&gt;
    &lt;/el-slider&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value: [30, 60],
        marks: {
          0: '0°C',
          8: '8°C',
          37: '37°C',
          50: {
            style: {
              color: '#1989FA'
            },
            label: this.$createElement('strong', '50%')
          }
        }
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="属性事件和方法-14"><a class="header" href="#属性事件和方法-14">属性事件和方法</a></h1>
<h2 id="attributes-9"><a class="header" href="#attributes-9">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">min</td><td style="text-align: left">最小值</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">max</td><td style="text-align: left">最大值</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">100</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">step</td><td style="text-align: left">步长</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left">show-input</td><td style="text-align: left">是否显示输入框，仅在非范围选择时有效</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">show-input-controls</td><td style="text-align: left">在显示输入框的情况下，是否显示输入框的控制按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">input-size</td><td style="text-align: left">输入框的尺寸</td><td style="text-align: left">string</td><td style="text-align: left">large / medium / small / mini</td><td style="text-align: left">small</td></tr>
<tr><td style="text-align: left">show-stops</td><td style="text-align: left">是否显示间断点</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">show-tooltip</td><td style="text-align: left">是否显示 tooltip</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">format-tooltip</td><td style="text-align: left">格式化 tooltip message</td><td style="text-align: left">function(value)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">range</td><td style="text-align: left">是否为范围选择</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">vertical</td><td style="text-align: left">是否竖向模式</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">height</td><td style="text-align: left">Slider 高度，竖向模式时必填</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">label</td><td style="text-align: left">屏幕阅读器标签</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">debounce</td><td style="text-align: left">输入时的去抖延迟，毫秒，仅在<code>show-input</code>等于true时有效</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">300</td></tr>
<tr><td style="text-align: left">tooltip-class</td><td style="text-align: left">tooltip 的自定义类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">marks</td><td style="text-align: left">标记， key 的类型必须为 number 且取值在闭区间 <code>[min, max]</code> 内，每个标记可以单独设置样式</td><td style="text-align: left">object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h2 id="events-8"><a class="header" href="#events-8"><a href="https://element.eleme.cn/#/zh-CN/component/slider#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">值改变时触发（使用鼠标拖曳时，只在松开鼠标后触发）</td><td style="text-align: left">改变后的值</td></tr>
<tr><td style="text-align: left">input</td><td style="text-align: left">数据改变时触发（使用鼠标拖曳时，活动过程实时触发）</td><td style="text-align: left">改变后的值</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timeline-时间线"><a class="header" href="#timeline-时间线">Timeline 时间线</a></h1>
<p>可视化地呈现时间流信息。</p>
<h1 id="基础用法-12"><a class="header" href="#基础用法-12">基础用法</a></h1>
<p>Timeline 可拆分成多个按照时间戳正序或倒序排列的 activity，时间戳是其区分于其他控件的重要特征，使⽤时注意与 Steps 步骤条等区分。</p>
<p>Timeline 可拆分成多个按照时间戳正序或倒序排列的 activity，时间戳是其区分于其他控件的重要特征，使⽤时注意与 Steps 步骤条等区分。</p>
<pre><code class="language-vue">&lt;div class=&quot;block&quot;&gt;
  &lt;div class=&quot;radio&quot;&gt;
    排序：
    &lt;el-radio-group v-model=&quot;reverse&quot;&gt;
      &lt;el-radio :label=&quot;true&quot;&gt;倒序&lt;/el-radio&gt;
      &lt;el-radio :label=&quot;false&quot;&gt;正序&lt;/el-radio&gt;
    &lt;/el-radio-group&gt;
  &lt;/div&gt;

  &lt;el-timeline :reverse=&quot;reverse&quot;&gt;
    &lt;el-timeline-item
      v-for=&quot;(activity, index) in activities&quot;
      :key=&quot;index&quot;
      :timestamp=&quot;activity.timestamp&quot;&gt;
      {{activity.content}}
    &lt;/el-timeline-item&gt;
  &lt;/el-timeline&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        reverse: true,
        activities: [{
          content: '活动按期开始',
          timestamp: '2018-04-15'
        }, {
          content: '通过审核',
          timestamp: '2018-04-13'
        }, {
          content: '创建成功',
          timestamp: '2018-04-11'
        }]
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="定义节点样式"><a class="header" href="#定义节点样式">⾃定义节点样式</a></h1>
<p>可根据实际场景⾃定义节点尺⼨、颜⾊，或直接使⽤图标。</p>
<pre><code class="language-vue">&lt;div class=&quot;block&quot;&gt;
  &lt;el-timeline&gt;
    &lt;el-timeline-item
      v-for=&quot;(activity, index) in activities&quot;
      :key=&quot;index&quot;
      :icon=&quot;activity.icon&quot;
      :type=&quot;activity.type&quot;
      :color=&quot;activity.color&quot;
      :size=&quot;activity.size&quot;
      :timestamp=&quot;activity.timestamp&quot;&gt;
      {{activity.content}}
    &lt;/el-timeline-item&gt;
  &lt;/el-timeline&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        activities: [{
          content: '支持使用图标',
          timestamp: '2018-04-12 20:46',
          size: 'large',
          type: 'primary',
          icon: 'el-icon-more'
        }, {
          content: '支持自定义颜色',
          timestamp: '2018-04-03 20:46',
          color: '#0bbd87'
        }, {
          content: '支持自定义尺寸',
          timestamp: '2018-04-03 20:46',
          size: 'large'
        }, {
          content: '默认样式的节点',
          timestamp: '2018-04-03 20:46'
        }]
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="定义时间戳"><a class="header" href="#定义时间戳">⾃定义时间戳</a></h1>
<pre><code class="language-vue">&lt;div class=&quot;block&quot;&gt;
  &lt;el-timeline&gt;
    &lt;el-timeline-item timestamp=&quot;2018/4/12&quot; placement=&quot;top&quot;&gt;
      &lt;el-card&gt;
        &lt;h4&gt;更新 Github 模板&lt;/h4&gt;
        &lt;p&gt;王小虎 提交于 2018/4/12 20:46&lt;/p&gt;
      &lt;/el-card&gt;
    &lt;/el-timeline-item&gt;
    &lt;el-timeline-item timestamp=&quot;2018/4/3&quot; placement=&quot;top&quot;&gt;
      &lt;el-card&gt;
        &lt;h4&gt;更新 Github 模板&lt;/h4&gt;
        &lt;p&gt;王小虎 提交于 2018/4/3 20:46&lt;/p&gt;
      &lt;/el-card&gt;
    &lt;/el-timeline-item&gt;
    &lt;el-timeline-item timestamp=&quot;2018/4/2&quot; placement=&quot;top&quot;&gt;
      &lt;el-card&gt;
        &lt;h4&gt;更新 Github 模板&lt;/h4&gt;
        &lt;p&gt;王小虎 提交于 2018/4/2 20:46&lt;/p&gt;
      &lt;/el-card&gt;
    &lt;/el-timeline-item&gt;
  &lt;/el-timeline&gt;
&lt;/div&gt;
</code></pre>
<h1 id="属性事件和方法-15"><a class="header" href="#属性事件和方法-15">属性事件和方法</a></h1>
<h2 id="timeline-attributes"><a class="header" href="#timeline-attributes">Timeline Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">reverse</td><td style="text-align: left">指定节点排序方向，默认为正序</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
</tbody></table>
<h2 id="timeline-item-attributes"><a class="header" href="#timeline-item-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/timeline#timeline-item-attributes">¶</a>Timeline-item Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">timestamp</td><td style="text-align: left">时间戳</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">hide-timestamp</td><td style="text-align: left">是否隐藏时间戳</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">placement</td><td style="text-align: left">时间戳位置</td><td style="text-align: left">string</td><td style="text-align: left">top / bottom</td><td style="text-align: left">bottom</td></tr>
<tr><td style="text-align: left">type</td><td style="text-align: left">节点类型</td><td style="text-align: left">string</td><td style="text-align: left">primary / success / warning / danger / info</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">color</td><td style="text-align: left">节点颜色</td><td style="text-align: left">string</td><td style="text-align: left">hsl / hsv / hex / rgb</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">节点尺寸</td><td style="text-align: left">string</td><td style="text-align: left">normal / large</td><td style="text-align: left">normal</td></tr>
<tr><td style="text-align: left">icon</td><td style="text-align: left">节点图标</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">-</td></tr>
</tbody></table>
<h2 id="timeline-item-slot"><a class="header" href="#timeline-item-slot"><a href="https://element.eleme.cn/#/zh-CN/component/timeline#timeline-item-slot">¶</a>Timeline-Item Slot</a></h2>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">—</td><td style="text-align: left">Timeline-Item 的内容</td></tr>
<tr><td style="text-align: left">dot</td><td style="text-align: left">自定义节点</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="tooltip-文字提示"><a class="header" href="#tooltip-文字提示">Tooltip 文字提示</a></h1>
<p>常用于展示鼠标 hover 时的提示信息。</p>
<h1 id="基础用法-13"><a class="header" href="#基础用法-13">基础用法</a></h1>
<p>在这里我们提供 9 种不同方向的展示方式，可以通过以下完整示例来理解，选择你要的效果。</p>
<p>使用<code>content</code>属性来决定<code>hover</code>时的提示信息。由<code>placement</code>属性决定展示效果：<code>placement</code>属性值为：<code>方向-对齐位置</code>；四个方向：<code>top</code>、<code>left</code>、<code>right</code>、<code>bottom</code>；三种对齐位置：<code>start</code>, <code>end</code>，默认为空。如<code>placement=&quot;left-end&quot;</code>，则提示信息出现在目标元素的左侧，且提示信息的底部与目标元素的底部对齐。</p>
<pre><code class="language-vue">&lt;div class=&quot;box&quot;&gt;
  &lt;div class=&quot;top&quot;&gt;
    &lt;el-tooltip class=&quot;item&quot; effect=&quot;dark&quot; content=&quot;Top Left 提示文字&quot; placement=&quot;top-start&quot;&gt;
      &lt;el-button&gt;上左&lt;/el-button&gt;
    &lt;/el-tooltip&gt;
    &lt;el-tooltip class=&quot;item&quot; effect=&quot;dark&quot; content=&quot;Top Center 提示文字&quot; placement=&quot;top&quot;&gt;
      &lt;el-button&gt;上边&lt;/el-button&gt;
    &lt;/el-tooltip&gt;
    &lt;el-tooltip class=&quot;item&quot; effect=&quot;dark&quot; content=&quot;Top Right 提示文字&quot; placement=&quot;top-end&quot;&gt;
      &lt;el-button&gt;上右&lt;/el-button&gt;
    &lt;/el-tooltip&gt;
  &lt;/div&gt;
  &lt;div class=&quot;left&quot;&gt;
    &lt;el-tooltip class=&quot;item&quot; effect=&quot;dark&quot; content=&quot;Left Top 提示文字&quot; placement=&quot;left-start&quot;&gt;
      &lt;el-button&gt;左上&lt;/el-button&gt;
    &lt;/el-tooltip&gt;
    &lt;el-tooltip class=&quot;item&quot; effect=&quot;dark&quot; content=&quot;Left Center 提示文字&quot; placement=&quot;left&quot;&gt;
      &lt;el-button&gt;左边&lt;/el-button&gt;
    &lt;/el-tooltip&gt;
    &lt;el-tooltip class=&quot;item&quot; effect=&quot;dark&quot; content=&quot;Left Bottom 提示文字&quot; placement=&quot;left-end&quot;&gt;
      &lt;el-button&gt;左下&lt;/el-button&gt;
    &lt;/el-tooltip&gt;
  &lt;/div&gt;

  &lt;div class=&quot;right&quot;&gt;
    &lt;el-tooltip class=&quot;item&quot; effect=&quot;dark&quot; content=&quot;Right Top 提示文字&quot; placement=&quot;right-start&quot;&gt;
      &lt;el-button&gt;右上&lt;/el-button&gt;
    &lt;/el-tooltip&gt;
    &lt;el-tooltip class=&quot;item&quot; effect=&quot;dark&quot; content=&quot;Right Center 提示文字&quot; placement=&quot;right&quot;&gt;
      &lt;el-button&gt;右边&lt;/el-button&gt;
    &lt;/el-tooltip&gt;
    &lt;el-tooltip class=&quot;item&quot; effect=&quot;dark&quot; content=&quot;Right Bottom 提示文字&quot; placement=&quot;right-end&quot;&gt;
      &lt;el-button&gt;右下&lt;/el-button&gt;
    &lt;/el-tooltip&gt;
  &lt;/div&gt;
  &lt;div class=&quot;bottom&quot;&gt;
    &lt;el-tooltip class=&quot;item&quot; effect=&quot;dark&quot; content=&quot;Bottom Left 提示文字&quot; placement=&quot;bottom-start&quot;&gt;
      &lt;el-button&gt;下左&lt;/el-button&gt;
    &lt;/el-tooltip&gt;
    &lt;el-tooltip class=&quot;item&quot; effect=&quot;dark&quot; content=&quot;Bottom Center 提示文字&quot; placement=&quot;bottom&quot;&gt;
      &lt;el-button&gt;下边&lt;/el-button&gt;
    &lt;/el-tooltip&gt;
    &lt;el-tooltip class=&quot;item&quot; effect=&quot;dark&quot; content=&quot;Bottom Right 提示文字&quot; placement=&quot;bottom-end&quot;&gt;
      &lt;el-button&gt;下右&lt;/el-button&gt;
    &lt;/el-tooltip&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
  .box {
    width: 400px;

    .top {
      text-align: center;
    }

    .left {
      float: left;
      width: 60px;
    }

    .right {
      float: right;
      width: 60px;
    }

    .bottom {
      clear: both;
      text-align: center;
    }

    .item {
      margin: 4px;
    }

    .left .el-tooltip__popper,
    .right .el-tooltip__popper {
      padding: 8px 10px;
    }
  }
&lt;/style&gt;
</code></pre>
<h1 id="主题-1"><a class="header" href="#主题-1">主题</a></h1>
<p>Tooltip 组件提供了两个不同的主题：<code>dark</code>和<code>light</code>。</p>
<p>通过设置<code>effect</code>属性来改变主题，默认为<code>dark</code>。</p>
<pre><code class="language-vue">&lt;el-tooltip content=&quot;Top center&quot; placement=&quot;top&quot;&gt;
  &lt;el-button&gt;Dark&lt;/el-button&gt;
&lt;/el-tooltip&gt;
&lt;el-tooltip content=&quot;Bottom center&quot; placement=&quot;bottom&quot; effect=&quot;light&quot;&gt;
  &lt;el-button&gt;Light&lt;/el-button&gt;
&lt;/el-tooltip&gt;
</code></pre>
<h1 id="更多-content"><a class="header" href="#更多-content">更多 Content</a></h1>
<p>展示多行文本或者是设置文本内容的格式</p>
<p>用具名 slot 分发<code>content</code>，替代<code>tooltip</code>中的<code>content</code>属性。</p>
<pre><code class="language-vue">&lt;el-tooltip placement=&quot;top&quot;&gt;
  &lt;div slot=&quot;content&quot;&gt;多行信息&lt;br/&gt;第二行信息&lt;/div&gt;
  &lt;el-button&gt;Top center&lt;/el-button&gt;
&lt;/el-tooltip&gt;
</code></pre>
<h1 id="高级扩展"><a class="header" href="#高级扩展">高级扩展</a></h1>
<p>除了这些基本设置外，还有一些属性可以让使用者更好的定制自己的效果：</p>
<p><code>transition</code> 属性可以定制显隐的动画效果，默认为<code>fade-in-linear</code>。 如果需要关闭 <code>tooltip</code> 功能，<code>disabled</code> 属性可以满足这个需求，它接受一个<code>Boolean</code>，设置为<code>true</code>即可。</p>
<p>事实上，这是基于 <a href="https://github.com/element-component/vue-popper">Vue-popper</a> 的扩展，你可以自定义任意 Vue-popper 中允许定义的字段。 当然 Tooltip 组件实际上十分强大，文末的 API 文档会做一一说明。</p>
<p>点击关闭 tooltip 功能</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-tooltip
    :disabled=&quot;disabled&quot;
    content=&quot;点击关闭 tooltip 功能&quot;
    placement=&quot;bottom&quot;
    effect=&quot;light&quot;
  &gt;
    &lt;el-button @click=&quot;disabled = !disabled&quot;
      &gt;点击{{ disabled ? &quot;开启&quot; : &quot;关闭&quot; }} tooltip 功能&lt;/el-button
    &gt;
  &lt;/el-tooltip&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      disabled: false,
    };
  },
};
&lt;/script&gt;
</code></pre>
<blockquote>
<p>tooltip 内不支持 <code>router-link</code> 组件，请使用 <code>vm.$router.push</code> 代替。</p>
<p>tooltip 内不支持 disabled form 元素，参考<a href="https://developer.mozilla.org/en-US/docs/Web/Events/mouseenter">MDN</a>，请在 disabled form 元素外层添加一层包裹元素。</p>
</blockquote>
<h1 id="属性事件和方法-16"><a class="header" href="#属性事件和方法-16">属性事件和方法</a></h1>
<h2 id="attributes-10"><a class="header" href="#attributes-10">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">effect</td><td style="text-align: left">默认提供的主题</td><td style="text-align: left">String</td><td style="text-align: left">dark/light</td><td style="text-align: left">dark</td></tr>
<tr><td style="text-align: left">content</td><td style="text-align: left">显示的内容，也可以通过 <code>slot#content</code> 传入 DOM</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">placement</td><td style="text-align: left">Tooltip 的出现位置</td><td style="text-align: left">String</td><td style="text-align: left">top/top-start/top-end/bottom/bottom-start/bottom-end/left/left-start/left-end/right/right-start/right-end</td><td style="text-align: left">bottom</td></tr>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">状态是否可见</td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">Tooltip 是否可用</td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">offset</td><td style="text-align: left">出现位置的偏移量</td><td style="text-align: left">Number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">transition</td><td style="text-align: left">定义渐变动画</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">el-fade-in-linear</td></tr>
<tr><td style="text-align: left">visible-arrow</td><td style="text-align: left">是否显示 Tooltip 箭头，更多参数可见<a href="https://github.com/element-component/vue-popper">Vue-popper</a></td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">popper-options</td><td style="text-align: left"><a href="https://popper.js.org/documentation.html">popper.js</a> 的参数</td><td style="text-align: left">Object</td><td style="text-align: left">参考 <a href="https://popper.js.org/documentation.html">popper.js</a> 文档</td><td style="text-align: left">{ boundariesElement: 'body', gpuAcceleration: false }</td></tr>
<tr><td style="text-align: left">open-delay</td><td style="text-align: left">延迟出现，单位毫秒</td><td style="text-align: left">Number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">manual</td><td style="text-align: left">手动控制模式，设置为 true 后，mouseenter 和 mouseleave 事件将不会生效</td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">popper-class</td><td style="text-align: left">为 Tooltip 的 popper 添加类名</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">enterable</td><td style="text-align: left">鼠标是否可进入到 tooltip 中</td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">hide-after</td><td style="text-align: left">Tooltip 出现后自动隐藏延时，单位毫秒，为 0 则不会自动隐藏</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">tabindex</td><td style="text-align: left">Tooltip 组件的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex">tabindex</a></td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
</tbody></table>
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="transfer-穿梭框"><a class="header" href="#transfer-穿梭框">Transfer 穿梭框</a></h2>
<p>在两个列表间选择</p>
<h1 id="基础用法-14"><a class="header" href="#基础用法-14">基础用法</a></h1>
<p>Transfer 的数据通过 <code>data</code> 属性传入。数据需要是一个对象数组，每个对象有以下属性：<code>key</code> 为数据的唯一性标识，<code>label</code> 为显示文本，<code>disabled</code> 表示该项数据是否禁止转移。目标列表中的数据项会同步到绑定至 <code>v-model</code> 的变量，值为数据项的 <code>key</code> 所组成的数组。当然，如果希望在初始状态时目标列表不为空，可以像本例一样为 <code>v-model</code> 绑定的变量赋予一个初始值。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-transfer v-model=&quot;value&quot; :data=&quot;data&quot;&gt;&lt;/el-transfer&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      const generateData = _ =&gt; {
        const data = [];
        for (let i = 1; i &lt;= 15; i++) {
          data.push({
            key: i,
            label: `备选项 ${ i }`,
            disabled: i % 4 === 0
          });
        }
        return data;
      };
      return {
        data: generateData(),
        value: [1, 4]
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="可搜索"><a class="header" href="#可搜索">可搜索</a></h1>
<p>在数据很多的情况下，可以对数据进行搜索和过滤。</p>
<p>设置 <code>filterable</code> 为 <code>true</code> 即可开启搜索模式。默认情况下，若数据项的 <code>label</code> 属性包含搜索关键字，则会在搜索结果中显示。你也可以使用 <code>filter-method</code> 定义自己的搜索逻辑。<code>filter-method</code> 接收一个方法，当搜索关键字变化时，会将当前的关键字和每个数据项传给该方法。若方法返回 <code>true</code>，则会在搜索结果中显示对应的数据项。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-transfer
    filterable
    :filter-method=&quot;filterMethod&quot;
    filter-placeholder=&quot;请输入城市拼音&quot;
    v-model=&quot;value&quot;
    :data=&quot;data&quot;&gt;
  &lt;/el-transfer&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      const generateData = _ =&gt; {
        const data = [];
        const cities = ['上海', '北京', '广州', '深圳', '南京', '西安', '成都'];
        const pinyin = ['shanghai', 'beijing', 'guangzhou', 'shenzhen', 'nanjing', 'xian', 'chengdu'];
        cities.forEach((city, index) =&gt; {
          data.push({
            label: city,
            key: index,
            pinyin: pinyin[index]
          });
        });
        return data;
      };
      return {
        data: generateData(),
        value: [],
        filterMethod(query, item) {
          return item.pinyin.indexOf(query) &gt; -1;
        }
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="可自定义"><a class="header" href="#可自定义">可自定义</a></h1>
<p>可以对列表标题文案、按钮文案、数据项的渲染函数、列表底部的勾选状态文案、列表底部的内容区等进行自定义。</p>
<p>​	可以使用 <code>titles</code>、<code>button-texts</code>、<code>render-content</code> 和 <code>format</code> 属性分别对列表标题文案、按钮文案、数据项的渲染函数和列表顶部的勾选状态文案进行自定义。数据项的渲染还可以使用 <code>scoped-slot</code> 进行自定义。对于列表底部的内容区，提供了两个具名 slot：<code>left-footer</code> 和 <code>right-footer</code>。此外，如果希望某些数据项在初始化时就被勾选，可以使用 <code>left-default-checked</code> 和 <code>right-default-checked</code> 属性。最后，本例还展示了 <code>change</code> 事件的用法。注意：由于 jsfiddle 不支持 JSX 语法，所以使用 <code>render-content</code> 自定义数据项的例子在 jsfiddle 中无法运行。但是在实际的项目中，只要正确地配置了相关依赖，就可以正常运行。</p>
<p>script</p>
<pre><code class="language-js">&lt;style&gt;
  .transfer-footer {
    margin-left: 20px;
    padding: 6px 5px;
  }
&lt;/style&gt;

&lt;script&gt;
  export default {
    data() {
      const generateData = _ =&gt; {
        const data = [];
        for (let i = 1; i &lt;= 15; i++) {
          data.push({
            key: i,
            label: `备选项 ${ i }`,
            disabled: i % 4 === 0
          });
        }
        return data;
      };
      return {
        data: generateData(),
        value: [1],
        value4: [1],
        renderFunc(h, option) {
          return &lt;span&gt;{ option.key } - { option.label }&lt;/span&gt;;
        }
      };
    },

    methods: {
      handleChange(value, direction, movedKeys) {
        console.log(value, direction, movedKeys);
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h2 id="使用-render-content-自定义数据项"><a class="header" href="#使用-render-content-自定义数据项">使用 render-content 自定义数据项</a></h2>
<pre><code class="language-vue">  &lt;p style=&quot;text-align: center; margin: 0 0 20px&quot;&gt;使用 render-content 自定义数据项&lt;/p&gt;
  &lt;div style=&quot;text-align: center&quot;&gt;
    &lt;el-transfer
      style=&quot;text-align: left; display: inline-block&quot;
      v-model=&quot;value&quot;
      filterable
      :left-default-checked=&quot;[2, 3]&quot;
      :right-default-checked=&quot;[1]&quot;
      :render-content=&quot;renderFunc&quot;
      :titles=&quot;['Source', 'Target']&quot;
      :button-texts=&quot;['到左边', '到右边']&quot;
      :format=&quot;{
        noChecked: '${total}',
        hasChecked: '${checked}/${total}'
      }&quot;
      @change=&quot;handleChange&quot;
      :data=&quot;data&quot;&gt;
      &lt;el-button class=&quot;transfer-footer&quot; slot=&quot;left-footer&quot; size=&quot;small&quot;&gt;操作&lt;/el-button&gt;
      &lt;el-button class=&quot;transfer-footer&quot; slot=&quot;right-footer&quot; size=&quot;small&quot;&gt;操作&lt;/el-button&gt;
    &lt;/el-transfer&gt;
  &lt;/div&gt;
</code></pre>
<h2 id="使用-scoped-slot-自定义数据项"><a class="header" href="#使用-scoped-slot-自定义数据项">使用 scoped-slot 自定义数据项</a></h2>
<pre><code class="language-vue"> &lt;p style=&quot;text-align: center; margin: 50px 0 20px&quot;&gt;使用 scoped-slot 自定义数据项&lt;/p&gt;
  &lt;div style=&quot;text-align: center&quot;&gt;
    &lt;el-transfer
      style=&quot;text-align: left; display: inline-block&quot;
      v-model=&quot;value4&quot;
      filterable
      :left-default-checked=&quot;[2, 3]&quot;
      :right-default-checked=&quot;[1]&quot;
      :titles=&quot;['Source', 'Target']&quot;
      :button-texts=&quot;['到左边', '到右边']&quot;
      :format=&quot;{
        noChecked: '${total}',
        hasChecked: '${checked}/${total}'
      }&quot;
      @change=&quot;handleChange&quot;
      :data=&quot;data&quot;&gt;
      &lt;span slot-scope=&quot;{ option }&quot;&gt;{{ option.key }} - {{ option.label }}&lt;/span&gt;
      &lt;el-button class=&quot;transfer-footer&quot; slot=&quot;left-footer&quot; size=&quot;small&quot;&gt;操作&lt;/el-button&gt;
      &lt;el-button class=&quot;transfer-footer&quot; slot=&quot;right-footer&quot; size=&quot;small&quot;&gt;操作&lt;/el-button&gt;
    &lt;/el-transfer&gt;
  &lt;/div&gt;
</code></pre>
<h1 id="数据项属性别名"><a class="header" href="#数据项属性别名">数据项属性别名</a></h1>
<p>默认情况下，Transfer 仅能识别数据项中的 <code>key</code>、<code>label</code> 和 <code>disabled</code> 字段。如果你的数据的字段名不同，可以使用 <code>props</code> 属性为它们设置别名。</p>
<p>本例中的数据源没有 <code>key</code> 和 <code>label</code> 字段，在功能上与它们相同的字段名为 <code>value</code> 和 <code>desc</code>。因此可以使用<code>props</code> 属性为 <code>key</code> 和 <code>label</code> 设置别名。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-transfer
    v-model=&quot;value&quot;
    :props=&quot;{
      key: 'value',
      label: 'desc'
    }&quot;
    :data=&quot;data&quot;&gt;
  &lt;/el-transfer&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      const generateData = _ =&gt; {
        const data = [];
        for (let i = 1; i &lt;= 15; i++) {
          data.push({
            value: i,
            desc: `备选项 ${ i }`,
            disabled: i % 4 === 0
          });
        }
        return data;
      };
      return {
        data: generateData(),
        value: []
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="属性事件和方法-17"><a class="header" href="#属性事件和方法-17">属性事件和方法</a></h1>
<h2 id="attributes-11"><a class="header" href="#attributes-11">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">data</td><td style="text-align: left">Transfer 的数据源</td><td style="text-align: left">array[{ key, label, disabled }]</td><td style="text-align: left">—</td><td style="text-align: left">[ ]</td></tr>
<tr><td style="text-align: left">filterable</td><td style="text-align: left">是否可搜索</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">filter-placeholder</td><td style="text-align: left">搜索框占位符</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">请输入搜索内容</td></tr>
<tr><td style="text-align: left">filter-method</td><td style="text-align: left">自定义搜索方法</td><td style="text-align: left">function</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">target-order</td><td style="text-align: left">右侧列表元素的排序策略：若为 <code>original</code>，则保持与数据源相同的顺序；若为 <code>push</code>，则新加入的元素排在最后；若为 <code>unshift</code>，则新加入的元素排在最前</td><td style="text-align: left">string</td><td style="text-align: left">original / push / unshift</td><td style="text-align: left">original</td></tr>
<tr><td style="text-align: left">titles</td><td style="text-align: left">自定义列表标题</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">['列表 1', '列表 2']</td></tr>
<tr><td style="text-align: left">button-texts</td><td style="text-align: left">自定义按钮文案</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">[ ]</td></tr>
<tr><td style="text-align: left">render-content</td><td style="text-align: left">自定义数据项渲染函数</td><td style="text-align: left">function(h, option)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">format</td><td style="text-align: left">列表顶部勾选状态文案</td><td style="text-align: left">object{noChecked, hasChecked}</td><td style="text-align: left">—</td><td style="text-align: left">{ noChecked: '${checked}/${total}', hasChecked: '${checked}/${total}' }</td></tr>
<tr><td style="text-align: left">props</td><td style="text-align: left">数据源的字段别名</td><td style="text-align: left">object{key, label, disabled}</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">left-default-checked</td><td style="text-align: left">初始状态下左侧列表的已勾选项的 key 数组</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">[ ]</td></tr>
<tr><td style="text-align: left">right-default-checked</td><td style="text-align: left">初始状态下右侧列表的已勾选项的 key 数组</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">[ ]</td></tr>
</tbody></table>
<h2 id="slot-3"><a class="header" href="#slot-3"><a href="https://element.eleme.cn/#/zh-CN/component/transfer#slot">¶</a>Slot</a></h2>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">left-footer</td><td style="text-align: left">左侧列表底部的内容</td></tr>
<tr><td style="text-align: left">right-footer</td><td style="text-align: left">右侧列表底部的内容</td></tr>
</tbody></table>
<h2 id="scoped-slot-1"><a class="header" href="#scoped-slot-1"><a href="https://element.eleme.cn/#/zh-CN/component/transfer#scoped-slot">¶</a>Scoped Slot</a></h2>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">—</td><td style="text-align: left">自定义数据项的内容，参数为 { option }</td></tr>
</tbody></table>
<h2 id="methods-1"><a class="header" href="#methods-1"><a href="https://element.eleme.cn/#/zh-CN/component/transfer#methods">¶</a>Methods</a></h2>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">clearQuery</td><td style="text-align: left">清空某个面板的搜索关键词</td><td style="text-align: left">'left' / 'right'，指定需要清空的面板</td></tr>
</tbody></table>
<h2 id="events-9"><a class="header" href="#events-9"><a href="https://element.eleme.cn/#/zh-CN/component/transfer#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">右侧列表元素变化时触发</td><td style="text-align: left">当前值、数据移动的方向（'left' / 'right'）、发生移动的数据 key 数组</td></tr>
<tr><td style="text-align: left">left-check-change</td><td style="text-align: left">左侧列表元素被用户选中 / 取消选中时触发</td><td style="text-align: left">当前被选中的元素的 key 数组、选中状态发生变化的元素的 key 数组</td></tr>
<tr><td style="text-align: left">right-check-change</td><td style="text-align: left">右侧列表元素被用户选中 / 取消选中时触发</td><td style="text-align: left">当前被选中的元素的 key 数组、选中状态发生变化的元素的 key 数组</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-3"><a class="header" href="#简介-3">简介</a></h1>
<p>通过点击或者拖拽上传文件</p>
<h1 id="点击上传"><a class="header" href="#点击上传">点击上传</a></h1>
<p>通过 slot 你可以传入自定义的上传按钮类型和文字提示。可通过设置<code>limit</code>和<code>on-exceed</code>来限制上传文件的个数和定义超出限制时的行为。可通过设置<code>before-remove</code>来阻止文件移除操作。</p>
<pre><code class="language-vue">&lt;el-upload
  class=&quot;upload-demo&quot;
  action=&quot;https://jsonplaceholder.typicode.com/posts/&quot;
  :on-preview=&quot;handlePreview&quot;
  :on-remove=&quot;handleRemove&quot;
  :before-remove=&quot;beforeRemove&quot;
  multiple
  :limit=&quot;3&quot;
  :on-exceed=&quot;handleExceed&quot;
  :file-list=&quot;fileList&quot;&gt;
  &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt;
  &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;
&lt;/el-upload&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        fileList: [{name: 'food.jpeg', url: 'https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100'}, {name: 'food2.jpeg', url: 'https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100'}]
      };
    },
    methods: {
      handleRemove(file, fileList) {
        console.log(file, fileList);
      },
      handlePreview(file) {
        console.log(file);
      },
      handleExceed(files, fileList) {
        this.$message.warning(`当前限制选择 3 个文件，本次选择了 ${files.length} 个文件，共选择了 ${files.length + fileList.length} 个文件`);
      },
      beforeRemove(file, fileList) {
        return this.$confirm(`确定移除 ${ file.name }？`);
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="用户头像上传"><a class="header" href="#用户头像上传">用户头像上传</a></h1>
<p>使用 <code>before-upload</code> 限制用户上传的图片格式和大小。</p>
<pre><code class="language-vue">&lt;el-upload
  class=&quot;avatar-uploader&quot;
  action=&quot;https://jsonplaceholder.typicode.com/posts/&quot;
  :show-file-list=&quot;false&quot;
  :on-success=&quot;handleAvatarSuccess&quot;
  :before-upload=&quot;beforeAvatarUpload&quot;&gt;
  &lt;img v-if=&quot;imageUrl&quot; :src=&quot;imageUrl&quot; class=&quot;avatar&quot;&gt;
  &lt;i v-else class=&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;/i&gt;
&lt;/el-upload&gt;

&lt;style&gt;
  .avatar-uploader .el-upload {
    border: 1px dashed #d9d9d9;
    border-radius: 6px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
  }
  .avatar-uploader .el-upload:hover {
    border-color: #409EFF;
  }
  .avatar-uploader-icon {
    font-size: 28px;
    color: #8c939d;
    width: 178px;
    height: 178px;
    line-height: 178px;
    text-align: center;
  }
  .avatar {
    width: 178px;
    height: 178px;
    display: block;
  }
&lt;/style&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        imageUrl: ''
      };
    },
    methods: {
      handleAvatarSuccess(res, file) {
        this.imageUrl = URL.createObjectURL(file.raw);
      },
      beforeAvatarUpload(file) {
        const isJPG = file.type === 'image/jpeg';
        const isLt2M = file.size / 1024 / 1024 &lt; 2;

        if (!isJPG) {
          this.$message.error('上传头像图片只能是 JPG 格式!');
        }
        if (!isLt2M) {
          this.$message.error('上传头像图片大小不能超过 2MB!');
        }
        return isJPG &amp;&amp; isLt2M;
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="照片墙"><a class="header" href="#照片墙">照片墙</a></h1>
<p>使用 <code>list-type</code> 属性来设置文件列表的样式。</p>
<pre><code class="language-vue">&lt;el-upload
  action=&quot;https://jsonplaceholder.typicode.com/posts/&quot;
  list-type=&quot;picture-card&quot;
  :on-preview=&quot;handlePictureCardPreview&quot;
  :on-remove=&quot;handleRemove&quot;&gt;
  &lt;i class=&quot;el-icon-plus&quot;&gt;&lt;/i&gt;
&lt;/el-upload&gt;
&lt;el-dialog :visible.sync=&quot;dialogVisible&quot;&gt;
  &lt;img width=&quot;100%&quot; :src=&quot;dialogImageUrl&quot; alt=&quot;&quot;&gt;
&lt;/el-dialog&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        dialogImageUrl: '',
        dialogVisible: false
      };
    },
    methods: {
      handleRemove(file, fileList) {
        console.log(file, fileList);
      },
      handlePictureCardPreview(file) {
        this.dialogImageUrl = file.url;
        this.dialogVisible = true;
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="文件缩略图"><a class="header" href="#文件缩略图">文件缩略图</a></h1>
<p>使用 <code>scoped-slot</code> 去设置缩略图模版。</p>
<pre><code class="language-vue">&lt;el-upload
  action=&quot;#&quot;
  list-type=&quot;picture-card&quot;
  :auto-upload=&quot;false&quot;&gt;
    &lt;i slot=&quot;default&quot; class=&quot;el-icon-plus&quot;&gt;&lt;/i&gt;
    &lt;div slot=&quot;file&quot; slot-scope=&quot;{file}&quot;&gt;
      &lt;img
        class=&quot;el-upload-list__item-thumbnail&quot;
        :src=&quot;file.url&quot; alt=&quot;&quot;
      &gt;
      &lt;span class=&quot;el-upload-list__item-actions&quot;&gt;
        &lt;span
          class=&quot;el-upload-list__item-preview&quot;
          @click=&quot;handlePictureCardPreview(file)&quot;
        &gt;
          &lt;i class=&quot;el-icon-zoom-in&quot;&gt;&lt;/i&gt;
        &lt;/span&gt;
        &lt;span
          v-if=&quot;!disabled&quot;
          class=&quot;el-upload-list__item-delete&quot;
          @click=&quot;handleDownload(file)&quot;
        &gt;
          &lt;i class=&quot;el-icon-download&quot;&gt;&lt;/i&gt;
        &lt;/span&gt;
        &lt;span
          v-if=&quot;!disabled&quot;
          class=&quot;el-upload-list__item-delete&quot;
          @click=&quot;handleRemove(file)&quot;
        &gt;
          &lt;i class=&quot;el-icon-delete&quot;&gt;&lt;/i&gt;
        &lt;/span&gt;
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/el-upload&gt;
&lt;el-dialog :visible.sync=&quot;dialogVisible&quot;&gt;
  &lt;img width=&quot;100%&quot; :src=&quot;dialogImageUrl&quot; alt=&quot;&quot;&gt;
&lt;/el-dialog&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        dialogImageUrl: '',
        dialogVisible: false,
        disabled: false
      };
    },
    methods: {
      handleRemove(file) {
        console.log(file);
      },
      handlePictureCardPreview(file) {
        this.dialogImageUrl = file.url;
        this.dialogVisible = true;
      },
      handleDownload(file) {
        console.log(file);
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="图片列表缩略图"><a class="header" href="#图片列表缩略图">图片列表缩略图</a></h1>
<pre><code class="language-vue">&lt;el-upload
  class=&quot;upload-demo&quot;
  action=&quot;https://jsonplaceholder.typicode.com/posts/&quot;
  :on-preview=&quot;handlePreview&quot;
  :on-remove=&quot;handleRemove&quot;
  :file-list=&quot;fileList&quot;
  list-type=&quot;picture&quot;&gt;
  &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt;
  &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;
&lt;/el-upload&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        fileList: [{name: 'food.jpeg', url: 'https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100'}, {name: 'food2.jpeg', url: 'https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100'}]
      };
    },
    methods: {
      handleRemove(file, fileList) {
        console.log(file, fileList);
      },
      handlePreview(file) {
        console.log(file);
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="上传文件列表控制"><a class="header" href="#上传文件列表控制">上传文件列表控制</a></h1>
<pre><code class="language-vue">&lt;el-upload
  class=&quot;upload-demo&quot;
  action=&quot;https://jsonplaceholder.typicode.com/posts/&quot;
  :on-change=&quot;handleChange&quot;
  :file-list=&quot;fileList&quot;&gt;
  &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt;
  &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;
&lt;/el-upload&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        fileList: [{
          name: 'food.jpeg',
          url: 'https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100'
        }, {
          name: 'food2.jpeg',
          url: 'https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100'
        }]
      };
    },
    methods: {
      handleChange(file, fileList) {
        this.fileList = fileList.slice(-3);
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="拖拽上传"><a class="header" href="#拖拽上传">拖拽上传</a></h1>
<pre><code class="language-vue">&lt;el-upload
  class=&quot;upload-demo&quot;
  drag
  action=&quot;https://jsonplaceholder.typicode.com/posts/&quot;
  multiple&gt;
  &lt;i class=&quot;el-icon-upload&quot;&gt;&lt;/i&gt;
  &lt;div class=&quot;el-upload__text&quot;&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;/em&gt;&lt;/div&gt;
  &lt;div class=&quot;el-upload__tip&quot; slot=&quot;tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;
&lt;/el-upload&gt;
</code></pre>
<h1 id="手动上传"><a class="header" href="#手动上传">手动上传</a></h1>
<pre><code class="language-vue">&lt;el-upload
  class=&quot;upload-demo&quot;
  ref=&quot;upload&quot;
  action=&quot;https://jsonplaceholder.typicode.com/posts/&quot;
  :on-preview=&quot;handlePreview&quot;
  :on-remove=&quot;handleRemove&quot;
  :file-list=&quot;fileList&quot;
  :auto-upload=&quot;false&quot;&gt;
  &lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot;&gt;选取文件&lt;/el-button&gt;
  &lt;el-button style=&quot;margin-left: 10px;&quot; size=&quot;small&quot; type=&quot;success&quot; @click=&quot;submitUpload&quot;&gt;上传到服务器&lt;/el-button&gt;
  &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;
&lt;/el-upload&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        fileList: [{name: 'food.jpeg', url: 'https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100'}, {name: 'food2.jpeg', url: 'https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100'}]
      };
    },
    methods: {
      submitUpload() {
        this.$refs.upload.submit();
      },
      handleRemove(file, fileList) {
        console.log(file, fileList);
      },
      handlePreview(file) {
        console.log(file);
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="属性事件和方法-18"><a class="header" href="#属性事件和方法-18">属性事件和方法</a></h1>
<h2 id="attribute"><a class="header" href="#attribute">Attribute</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">action</td><td style="text-align: left">必选参数，上传的地址</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">headers</td><td style="text-align: left">设置上传的请求头部</td><td style="text-align: left">object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">multiple</td><td style="text-align: left">是否支持多选文件</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">data</td><td style="text-align: left">上传时附带的额外参数</td><td style="text-align: left">object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">上传的文件字段名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">file</td></tr>
<tr><td style="text-align: left">with-credentials</td><td style="text-align: left">支持发送 cookie 凭证信息</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">show-file-list</td><td style="text-align: left">是否显示已上传文件列表</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">drag</td><td style="text-align: left">是否启用拖拽上传</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">accept</td><td style="text-align: left">接受上传的<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-accept">文件类型</a>（thumbnail-mode 模式下此参数无效）</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">on-preview</td><td style="text-align: left">点击文件列表中已上传的文件时的钩子</td><td style="text-align: left">function(file)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">on-remove</td><td style="text-align: left">文件列表移除文件时的钩子</td><td style="text-align: left">function(file, fileList)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">on-success</td><td style="text-align: left">文件上传成功时的钩子</td><td style="text-align: left">function(response, file, fileList)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">on-error</td><td style="text-align: left">文件上传失败时的钩子</td><td style="text-align: left">function(err, file, fileList)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">on-progress</td><td style="text-align: left">文件上传时的钩子</td><td style="text-align: left">function(event, file, fileList)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">on-change</td><td style="text-align: left">文件状态改变时的钩子，添加文件、上传成功和上传失败时都会被调用</td><td style="text-align: left">function(file, fileList)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">before-upload</td><td style="text-align: left">上传文件之前的钩子，参数为上传的文件，若返回 false 或者返回 Promise 且被 reject，则停止上传。</td><td style="text-align: left">function(file)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">before-remove</td><td style="text-align: left">删除文件之前的钩子，参数为上传的文件和文件列表，若返回 false 或者返回 Promise 且被 reject，则停止删除。</td><td style="text-align: left">function(file, fileList)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">list-type</td><td style="text-align: left">文件列表的类型</td><td style="text-align: left">string</td><td style="text-align: left">text/picture/picture-card</td><td style="text-align: left">text</td></tr>
<tr><td style="text-align: left">auto-upload</td><td style="text-align: left">是否在选取文件后立即进行上传</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">file-list</td><td style="text-align: left">上传的文件列表, 例如: [{name: 'food.jpg', url: 'https://xxx.cdn.com/xxx.jpg'}]</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">[]</td></tr>
<tr><td style="text-align: left">http-request</td><td style="text-align: left">覆盖默认的上传行为，可以自定义上传的实现</td><td style="text-align: left">function</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">limit</td><td style="text-align: left">最大允许上传个数</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">on-exceed</td><td style="text-align: left">文件超出个数限制时的钩子</td><td style="text-align: left">function(files, fileList)</td><td style="text-align: left">—</td><td style="text-align: left">-</td></tr>
</tbody></table>
<h2 id="slot-4"><a class="header" href="#slot-4"><a href="https://element.eleme.cn/#/zh-CN/component/upload#slot">¶</a>Slot</a></h2>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">trigger</td><td style="text-align: left">触发文件选择框的内容</td></tr>
<tr><td style="text-align: left">tip</td><td style="text-align: left">提示说明文字</td></tr>
</tbody></table>
<h2 id="methods-2"><a class="header" href="#methods-2"><a href="https://element.eleme.cn/#/zh-CN/component/upload#methods">¶</a>Methods</a></h2>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">clearFiles</td><td style="text-align: left">清空已上传的文件列表（该方法不支持在 before-upload 中调用）</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">abort</td><td style="text-align: left">取消上传请求</td><td style="text-align: left">（ file: fileList 中的 file 对象 ）</td></tr>
<tr><td style="text-align: left">submit</td><td style="text-align: left">手动上传文件列表</td><td style="text-align: left">—</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装-2"><a class="header" href="#安装-2">安装</a></h1>
<h2 id="npm-安装"><a class="header" href="#npm-安装">npm 安装</a></h2>
<p><em>npm i element-ui -S</em></p>
<h2 id="cdn"><a class="header" href="#cdn">CDN</a></h2>
<pre><code class="language-html">&lt;!-- 引入样式 --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;
&lt;!-- 引入组件库 --&gt;
&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="divider-分割线"><a class="header" href="#divider-分割线">Divider 分割线</a></h1>
<p>区隔内容的分割线。</p>
<h1 id="基础用法-15"><a class="header" href="#基础用法-15">基础用法</a></h1>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;span&gt;青春是一个短暂的美梦, 当你醒来时, 它早已消失无踪&lt;/span&gt;
    &lt;el-divider&gt;&lt;/el-divider&gt;
    &lt;span&gt;少量的邪恶足以抵消全部高贵的品质, 害得人声名狼藉&lt;/span&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h1 id="设置文案"><a class="header" href="#设置文案">设置文案</a></h1>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;span&gt;头上一片晴天，心中一个想念&lt;/span&gt;
    &lt;el-divider content-position=&quot;left&quot;&gt;少年包青天&lt;/el-divider&gt;
    &lt;span&gt;饿了别叫妈, 叫饿了么&lt;/span&gt;
    &lt;el-divider&gt;&lt;i class=&quot;el-icon-mobile-phone&quot;&gt;&lt;/i&gt;&lt;/el-divider&gt;
    &lt;span&gt;为了无法计算的价值&lt;/span&gt;
    &lt;el-divider content-position=&quot;right&quot;&gt;阿里云&lt;/el-divider&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h1 id="垂直分割"><a class="header" href="#垂直分割">垂直分割</a></h1>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;span&gt;雨纷纷&lt;/span&gt;
    &lt;el-divider direction=&quot;vertical&quot;&gt;&lt;/el-divider&gt;
    &lt;span&gt;旧故里&lt;/span&gt;
    &lt;el-divider direction=&quot;vertical&quot;&gt;&lt;/el-divider&gt;
    &lt;span&gt;草木深&lt;/span&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h1 id="divider-attributes"><a class="header" href="#divider-attributes">Divider Attributes</a></h1>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">direction</td><td style="text-align: left">设置分割线方向</td><td style="text-align: left">string</td><td style="text-align: left">horizontal / vertical</td><td style="text-align: left">horizontal</td></tr>
<tr><td style="text-align: left">content-position</td><td style="text-align: left">设置分割线文案的位置</td><td style="text-align: left">string</td><td style="text-align: left">left / right / center</td><td style="text-align: left">center</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pagination-分页"><a class="header" href="#pagination-分页">Pagination 分页</a></h1>
<p>当数据量过多时，使用分页分解数据。</p>
<h1 id="基础用法-16"><a class="header" href="#基础用法-16">基础用法</a></h1>
<p>设置<code>layout</code>，表示需要显示的内容，用逗号分隔，布局元素会依次显示。<code>prev</code>表示上一页，<code>next</code>为下一页，<code>pager</code>表示页码列表，除此以外还提供了<code>jumper</code>和<code>total</code>，<code>size</code>和特殊的布局符号<code>-&gt;</code>，<code>-&gt;</code>后的元素会靠右显示，<code>jumper</code>表示跳页元素，<code>total</code>表示总条目数，<code>size</code>用于设置每页显示的页码数量。</p>
<pre><code class="language-vue">&lt;div class=&quot;block&quot;&gt;
  &lt;span class=&quot;demonstration&quot;&gt;页数较少时的效果&lt;/span&gt;
  &lt;el-pagination
    layout=&quot;prev, pager, next&quot;
    :total=&quot;50&quot;&gt;
  &lt;/el-pagination&gt;
&lt;/div&gt;
&lt;div class=&quot;block&quot;&gt;
  &lt;span class=&quot;demonstration&quot;&gt;大于 7 页时的效果&lt;/span&gt;
  &lt;el-pagination
    layout=&quot;prev, pager, next&quot;
    :total=&quot;1000&quot;&gt;
  &lt;/el-pagination&gt;
&lt;/div&gt;
</code></pre>
<h1 id="设置最大页码按钮数"><a class="header" href="#设置最大页码按钮数">设置最大页码按钮数</a></h1>
<pre><code class="language-vue">&lt;el-pagination
  :page-size=&quot;20&quot;
  :pager-count=&quot;11&quot;
  layout=&quot;prev, pager, next&quot;
  :total=&quot;1000&quot;&gt;
&lt;/el-pagination&gt;
</code></pre>
<h1 id="带有背景色的分页"><a class="header" href="#带有背景色的分页">带有背景色的分页</a></h1>
<pre><code class="language-vue">&lt;el-pagination
  background
  layout=&quot;prev, pager, next&quot;
  :total=&quot;1000&quot;&gt;
&lt;/el-pagination&gt;
</code></pre>
<h1 id="小型分页"><a class="header" href="#小型分页">小型分页</a></h1>
<pre><code class="language-vue">只需要一个small属性，它接受一个Boolean，默认为false，设为true即可启用。

&lt;el-pagination
  small
  layout=&quot;prev, pager, next&quot;
  :total=&quot;50&quot;&gt;
&lt;/el-pagination&gt;
</code></pre>
<h1 id="附加功能"><a class="header" href="#附加功能">附加功能</a></h1>
<p>根据场景需要，可以添加其他功能模块。</p>
<p>此例是一个完整的用例，使用了<code>size-change</code>和<code>current-change</code>事件来处理页码大小和当前页变动时候触发的事件。<code>page-sizes</code>接受一个整型数组，数组元素为展示的选择每页显示个数的选项，<code>[100, 200, 300, 400]</code>表示四个选项，每页显示 100 个，200 个，300 个或者 400 个。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;显示总数&lt;/span&gt;
    &lt;el-pagination
      @size-change=&quot;handleSizeChange&quot;
      @current-change=&quot;handleCurrentChange&quot;
      :current-page.sync=&quot;currentPage1&quot;
      :page-size=&quot;100&quot;
      layout=&quot;total, prev, pager, next&quot;
      :total=&quot;1000&quot;&gt;
    &lt;/el-pagination&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;调整每页显示条数&lt;/span&gt;
    &lt;el-pagination
      @size-change=&quot;handleSizeChange&quot;
      @current-change=&quot;handleCurrentChange&quot;
      :current-page.sync=&quot;currentPage2&quot;
      :page-sizes=&quot;[100, 200, 300, 400]&quot;
      :page-size=&quot;100&quot;
      layout=&quot;sizes, prev, pager, next&quot;
      :total=&quot;1000&quot;&gt;
    &lt;/el-pagination&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;直接前往&lt;/span&gt;
    &lt;el-pagination
      @size-change=&quot;handleSizeChange&quot;
      @current-change=&quot;handleCurrentChange&quot;
      :current-page.sync=&quot;currentPage3&quot;
      :page-size=&quot;100&quot;
      layout=&quot;prev, pager, next, jumper&quot;
      :total=&quot;1000&quot;&gt;
    &lt;/el-pagination&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;完整功能&lt;/span&gt;
    &lt;el-pagination
      @size-change=&quot;handleSizeChange&quot;
      @current-change=&quot;handleCurrentChange&quot;
      :current-page=&quot;currentPage4&quot;
      :page-sizes=&quot;[100, 200, 300, 400]&quot;
      :page-size=&quot;100&quot;
      layout=&quot;total, sizes, prev, pager, next, jumper&quot;
      :total=&quot;400&quot;&gt;
    &lt;/el-pagination&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    methods: {
      handleSizeChange(val) {
        console.log(`每页 ${val} 条`);
      },
      handleCurrentChange(val) {
        console.log(`当前页: ${val}`);
      }
    },
    data() {
      return {
        currentPage1: 5,
        currentPage2: 5,
        currentPage3: 5,
        currentPage4: 4
      };
    }
  }
&lt;/script&gt;

</code></pre>
<h1 id="当只有一页时隐藏分页"><a class="header" href="#当只有一页时隐藏分页">当只有一页时隐藏分页</a></h1>
<p>当只有一页时，通过设置 <code>hide-on-single-page</code> 属性来隐藏分页。</p>
<pre><code class="language-vue">&lt;div&gt;
 &lt;el-switch v-model=&quot;value&quot;&gt;
 &lt;/el-switch&gt;
 &lt;el-pagination
  :hide-on-single-page=&quot;value&quot;
  :total=&quot;5&quot;
  layout=&quot;prev, pager, next&quot;&gt;
&lt;/el-pagination&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value: false
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="属性事件和方法-19"><a class="header" href="#属性事件和方法-19">属性事件和方法</a></h1>
<h2 id="attributes-12"><a class="header" href="#attributes-12">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">small</td><td style="text-align: left">是否使用小型分页样式</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">background</td><td style="text-align: left">是否为分页按钮添加背景色</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">page-size</td><td style="text-align: left">每页显示条目个数，支持 .sync 修饰符</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">10</td></tr>
<tr><td style="text-align: left">total</td><td style="text-align: left">总条目数</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">page-count</td><td style="text-align: left">总页数，total 和 page-count 设置任意一个就可以达到显示页码的功能；如果要支持 page-sizes 的更改，则需要使用 total 属性</td><td style="text-align: left">Number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">pager-count</td><td style="text-align: left">页码按钮的数量，当总页数超过该值时会折叠</td><td style="text-align: left">number</td><td style="text-align: left">大于等于 5 且小于等于 21 的奇数</td><td style="text-align: left">7</td></tr>
<tr><td style="text-align: left">current-page</td><td style="text-align: left">当前页数，支持 .sync 修饰符</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left">layout</td><td style="text-align: left">组件布局，子组件名用逗号分隔</td><td style="text-align: left">String</td><td style="text-align: left"><code>sizes</code>, <code>prev</code>, <code>pager</code>, <code>next</code>, <code>jumper</code>, <code>-&gt;</code>, <code>total</code>, <code>slot</code></td><td style="text-align: left">'prev, pager, next, jumper, -&gt;, total'</td></tr>
<tr><td style="text-align: left">page-sizes</td><td style="text-align: left">每页显示个数选择器的选项设置</td><td style="text-align: left">number[]</td><td style="text-align: left">—</td><td style="text-align: left">[10, 20, 30, 40, 50, 100]</td></tr>
<tr><td style="text-align: left">popper-class</td><td style="text-align: left">每页显示个数选择器的下拉框类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">prev-text</td><td style="text-align: left">替代图标显示的上一页文字</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">next-text</td><td style="text-align: left">替代图标显示的下一页文字</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">hide-on-single-page</td><td style="text-align: left">只有一页时是否隐藏</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">-</td></tr>
</tbody></table>
<h2 id="events-10"><a class="header" href="#events-10"><a href="https://element.eleme.cn/#/zh-CN/component/pagination#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">size-change</td><td style="text-align: left">pageSize 改变时会触发</td><td style="text-align: left">每页条数</td></tr>
<tr><td style="text-align: left">current-change</td><td style="text-align: left">currentPage 改变时会触发</td><td style="text-align: left">当前页</td></tr>
<tr><td style="text-align: left">prev-click</td><td style="text-align: left">用户点击上一页按钮改变当前页后触发</td><td style="text-align: left">当前页</td></tr>
<tr><td style="text-align: left">next-click</td><td style="text-align: left">用户点击下一页按钮改变当前页后触发</td><td style="text-align: left">当前页</td></tr>
</tbody></table>
<h2 id="slot-5"><a class="header" href="#slot-5"><a href="https://element.eleme.cn/#/zh-CN/component/pagination#slot">¶</a>Slot</a></h2>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">—</td><td style="text-align: left">自定义内容，需要在 <code>layout</code> 中列出 <code>slot</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="布局"><a class="header" href="#布局">布局</a></h1>
<h2 id="基础示例"><a class="header" href="#基础示例">基础示例</a></h2>
<pre><code class="language-html">&lt;el-row&gt;
  &lt;el-col :span=&quot;24&quot;&gt;&lt;div class=&quot;grid-content bg-purple-dark&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
&lt;el-row&gt;
  &lt;el-col :span=&quot;12&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;12&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
&lt;el-row&gt;
  &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
&lt;el-row&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
</code></pre>
<h2 id="分栏间隔"><a class="header" href="#分栏间隔">分栏间隔</a></h2>
<pre><code class="language-html">&lt;el-row :gutter=&quot;20&quot;&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
</code></pre>
<h2 id="对齐"><a class="header" href="#对齐">对齐</a></h2>
<p>将 <code>type</code> 属性赋值为 'flex'，可以启用 flex 布局，并可通过 <code>justify</code> 属性来指定 start, center, end, space-between, space-around 其中的值来定义子元素的排版方式。</p>
<pre><code class="language-html">&lt;el-row type=&quot;flex&quot; class=&quot;row-bg&quot;&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
&lt;el-row type=&quot;flex&quot; class=&quot;row-bg&quot; justify=&quot;center&quot;&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
&lt;el-row type=&quot;flex&quot; class=&quot;row-bg&quot; justify=&quot;end&quot;&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
&lt;el-row type=&quot;flex&quot; class=&quot;row-bg&quot; justify=&quot;space-between&quot;&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
&lt;el-row type=&quot;flex&quot; class=&quot;row-bg&quot; justify=&quot;space-around&quot;&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
</code></pre>
<h2 id="响应式布局"><a class="header" href="#响应式布局">响应式布局</a></h2>
<p>参照了 Bootstrap 的 响应式设计，预设了五个响应尺寸：<code>xs</code>、<code>sm</code>、<code>md</code>、<code>lg</code> 和 <code>xl</code>。</p>
<pre><code class="language-html">&lt;el-row :gutter=&quot;10&quot;&gt;
  &lt;el-col :xs=&quot;8&quot; :sm=&quot;6&quot; :md=&quot;4&quot; :lg=&quot;3&quot; :xl=&quot;1&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :xs=&quot;4&quot; :sm=&quot;6&quot; :md=&quot;8&quot; :lg=&quot;9&quot; :xl=&quot;11&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :xs=&quot;4&quot; :sm=&quot;6&quot; :md=&quot;8&quot; :lg=&quot;9&quot; :xl=&quot;11&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :xs=&quot;8&quot; :sm=&quot;6&quot; :md=&quot;4&quot; :lg=&quot;3&quot; :xl=&quot;1&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;

</code></pre>
<h2 id="基于断点的隐藏类"><a class="header" href="#基于断点的隐藏类">基于断点的隐藏类</a></h2>
<p>Element 额外提供了一系列类名，用于在某些条件下隐藏元素。这些类名可以添加在任何 DOM 元素或自定义组件上。如果需要，请自行引入以下文件：</p>
<pre><code>import 'element-ui/lib/theme-chalk/display.css';
</code></pre>
<p>包含的类名及其含义为：</p>
<ul>
<li><code>hidden-xs-only</code> - 当视口在 <code>xs</code> 尺寸时隐藏</li>
<li><code>hidden-sm-only</code> - 当视口在 <code>sm</code> 尺寸时隐藏</li>
<li><code>hidden-sm-and-down</code> - 当视口在 <code>sm</code> 及以下尺寸时隐藏</li>
<li><code>hidden-sm-and-up</code> - 当视口在 <code>sm</code> 及以上尺寸时隐藏</li>
<li><code>hidden-md-only</code> - 当视口在 <code>md</code> 尺寸时隐藏</li>
<li><code>hidden-md-and-down</code> - 当视口在 <code>md</code> 及以下尺寸时隐藏</li>
<li><code>hidden-md-and-up</code> - 当视口在 <code>md</code> 及以上尺寸时隐藏</li>
<li><code>hidden-lg-only</code> - 当视口在 <code>lg</code> 尺寸时隐藏</li>
<li><code>hidden-lg-and-down</code> - 当视口在 <code>lg</code> 及以下尺寸时隐藏</li>
<li><code>hidden-lg-and-up</code> - 当视口在 <code>lg</code> 及以上尺寸时隐藏</li>
<li><code>hidden-xl-only</code> - 当视口在 <code>xl</code> 尺寸时隐藏</li>
</ul>
<h2 id="属性总览"><a class="header" href="#属性总览">属性总览</a></h2>
<h3 id="row-attributes"><a class="header" href="#row-attributes">Row Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">gutter</td><td style="text-align: left">栅格间隔</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">type</td><td style="text-align: left">布局模式，可选 flex，现代浏览器下有效</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">justify</td><td style="text-align: left">flex 布局下的水平排列方式</td><td style="text-align: left">string</td><td style="text-align: left">start/end/center/space-around/space-between</td><td style="text-align: left">start</td></tr>
<tr><td style="text-align: left">align</td><td style="text-align: left">flex 布局下的垂直排列方式</td><td style="text-align: left">string</td><td style="text-align: left">top/middle/bottom</td><td style="text-align: left">top</td></tr>
<tr><td style="text-align: left">tag</td><td style="text-align: left">自定义元素标签</td><td style="text-align: left">string</td><td style="text-align: left">*</td><td style="text-align: left">div</td></tr>
</tbody></table>
<h3 id="col-attributes"><a class="header" href="#col-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/layout#col-attributes">¶</a>Col Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">span</td><td style="text-align: left">栅格占据的列数</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">24</td></tr>
<tr><td style="text-align: left">offset</td><td style="text-align: left">栅格左侧的间隔格数</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">push</td><td style="text-align: left">栅格向右移动格数</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">pull</td><td style="text-align: left">栅格向左移动格数</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">xs</td><td style="text-align: left"><code>&lt;768px</code> 响应式栅格数或者栅格属性对象</td><td style="text-align: left">number/object (例如： {span: 4, offset: 4})</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">sm</td><td style="text-align: left"><code>≥768px</code> 响应式栅格数或者栅格属性对象</td><td style="text-align: left">number/object (例如： {span: 4, offset: 4})</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">md</td><td style="text-align: left"><code>≥992px</code> 响应式栅格数或者栅格属性对象</td><td style="text-align: left">number/object (例如： {span: 4, offset: 4})</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">lg</td><td style="text-align: left"><code>≥1200px</code> 响应式栅格数或者栅格属性对象</td><td style="text-align: left">number/object (例如： {span: 4, offset: 4})</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">xl</td><td style="text-align: left"><code>≥1920px</code> 响应式栅格数或者栅格属性对象</td><td style="text-align: left">number/object (例如： {span: 4, offset: 4})</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">tag</td><td style="text-align: left">自定义元素标签</td><td style="text-align: left">string</td><td style="text-align: left">*</td><td style="text-align: left">div</td></tr>
</tbody></table>
<h1 id="布局容器"><a class="header" href="#布局容器">布局容器</a></h1>
<h2 id="容器组件"><a class="header" href="#容器组件">容器组件</a></h2>
<p><code>&lt;el-container&gt;</code>：外层容器。当子元素中包含 <code>&lt;el-header&gt;</code> 或 <code>&lt;el-footer&gt;</code> 时，全部子元素会垂直上下排列，否则会水平左右排列。</p>
<p><code>&lt;el-header&gt;</code>：顶栏容器。</p>
<p><code>&lt;el-aside&gt;</code>：侧边栏容器。</p>
<p><code>&lt;el-main&gt;</code>：主要区域容器。</p>
<p><code>&lt;el-footer&gt;</code>：底栏容器。</p>
<blockquote>
<p>以上组件采用了 flex 布局，使用前请确定目标浏览器是否兼容。此外，<code>&lt;el-container&gt;</code> 的子元素只能是后四者，后四者的父元素也只能是 <code>&lt;el-container&gt;</code>。</p>
</blockquote>
<p><a href="https://element.eleme.cn/#/zh-CN/component/container#shi-li">常见页面布局</a></p>
<h2 id="header-attributes"><a class="header" href="#header-attributes">Header Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">height</td><td style="text-align: left">顶栏高度</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">60px</td></tr>
</tbody></table>
<h2 id="aside-attributes"><a class="header" href="#aside-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/container#aside-attributes">¶</a>Aside Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">width</td><td style="text-align: left">侧边栏宽度</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">300px</td></tr>
</tbody></table>
<h2 id="footer-attributes"><a class="header" href="#footer-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/container#footer-attributes">¶</a>Footer Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">height</td><td style="text-align: left">底栏高度</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">60px</td></tr>
</tbody></table>
<h1 id="border-边框"><a class="header" href="#border-边框">Border 边框</a></h1>
<p>我们对边框进行统一规范，可用于按钮、卡片、弹窗等组件里。</p>
<h3 id="边框"><a class="header" href="#边框">边框</a></h3>
<p>实线,虚线</p>
<h3 id="圆角"><a class="header" href="#圆角">圆角</a></h3>
<p><strong>无圆角</strong></p>
<p>border-radius: 0px</p>
<p><strong>小圆角</strong></p>
<p>border-radius: 2px</p>
<p><strong>大圆角</strong></p>
<p>border-radius: 4px</p>
<p><strong>圆形圆角</strong></p>
<p>border-radius: 30px</p>
<h3 id="投影"><a class="header" href="#投影">投影</a></h3>
<p>基础投影 box-shadow: 0 2px 4px rgba(0, 0, 0, .12), 0 0 6px rgba(0, 0, 0, .04)</p>
<p>浅色投影 box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1)</p>
<h1 id="图标"><a class="header" href="#图标">图标</a></h1>
<p>直接通过设置类名为 <code>el-icon-iconName</code> 来使用即可。例如：</p>
<p><a href="https://element.eleme.cn/#/zh-CN/component/icon#tu-biao-ji-he">图标集合</a></p>
<h1 id="按钮"><a class="header" href="#按钮">按钮</a></h1>
<h2 id="type-plainroundcircle"><a class="header" href="#type-plainroundcircle">type, plain,round,circle</a></h2>
<p>使用<code>type</code>、<code>plain</code>、<code>round</code>和<code>circle</code>属性来定义 Button 的样式。</p>
<h2 id="默认按钮"><a class="header" href="#默认按钮">默认按钮</a></h2>
<pre><code class="language-html">&lt;el-row&gt;
  &lt;el-button&gt;默认按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;success&quot;&gt;成功按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;info&quot;&gt;信息按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;warning&quot;&gt;警告按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;danger&quot;&gt;危险按钮&lt;/el-button&gt;
&lt;/el-row&gt;
</code></pre>
<h2 id="朴素按钮"><a class="header" href="#朴素按钮">朴素按钮</a></h2>
<pre><code class="language-html">

&lt;el-row&gt;
  &lt;el-button plain&gt;朴素按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;primary&quot; plain&gt;主要按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;success&quot; plain&gt;成功按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;info&quot; plain&gt;信息按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;warning&quot; plain&gt;警告按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;danger&quot; plain&gt;危险按钮&lt;/el-button&gt;
&lt;/el-row&gt;
</code></pre>
<h2 id="圆角按钮"><a class="header" href="#圆角按钮">圆角按钮</a></h2>
<pre><code class="language-html">&lt;el-row&gt;
  &lt;el-button round&gt;圆角按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;primary&quot; round&gt;主要按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;success&quot; round&gt;成功按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;info&quot; round&gt;信息按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;warning&quot; round&gt;警告按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;danger&quot; round&gt;危险按钮&lt;/el-button&gt;
&lt;/el-row&gt;
</code></pre>
<h2 id="圆形按钮"><a class="header" href="#圆形按钮">圆形按钮</a></h2>
<pre><code>&lt;el-row&gt;
  &lt;el-button icon=&quot;el-icon-search&quot; circle&gt;&lt;/el-button&gt;
  &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; circle&gt;&lt;/el-button&gt;
  &lt;el-button type=&quot;success&quot; icon=&quot;el-icon-check&quot; circle&gt;&lt;/el-button&gt;
  &lt;el-button type=&quot;info&quot; icon=&quot;el-icon-message&quot; circle&gt;&lt;/el-button&gt;
  &lt;el-button type=&quot;warning&quot; icon=&quot;el-icon-star-off&quot; circle&gt;&lt;/el-button&gt;
  &lt;el-button type=&quot;danger&quot; icon=&quot;el-icon-delete&quot; circle&gt;&lt;/el-button&gt;
&lt;/el-row&gt;
</code></pre>
<h2 id="禁用"><a class="header" href="#禁用">禁用</a></h2>
<pre><code class="language-html">&lt;el-row&gt;
  &lt;el-button disabled&gt;默认按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;primary&quot; disabled&gt;主要按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;success&quot; disabled&gt;成功按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;info&quot; disabled&gt;信息按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;warning&quot; disabled&gt;警告按钮&lt;/el-button&gt;
  &lt;el-button type=&quot;danger&quot; disabled&gt;危险按钮&lt;/el-button&gt;
&lt;/el-row&gt;
</code></pre>
<h2 id="文字按钮"><a class="header" href="#文字按钮">文字按钮</a></h2>
<pre><code class="language-html">
&lt;el-button type=&quot;text&quot;&gt;文字按钮&lt;/el-button&gt;
&lt;el-button type=&quot;text&quot; disabled&gt;文字按钮&lt;/el-button&gt;
</code></pre>
<h2 id="图标按钮"><a class="header" href="#图标按钮">图标按钮</a></h2>
<pre><code class="language-html">
&lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt;
&lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-share&quot;&gt;&lt;/el-button&gt;
&lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt;
&lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot;&gt;搜索&lt;/el-button&gt;
&lt;el-button type=&quot;primary&quot;&gt;上传&lt;i class=&quot;el-icon-upload el-icon--right&quot;&gt;&lt;/i&gt;&lt;/el-button&gt;
</code></pre>
<h2 id="按钮组"><a class="header" href="#按钮组">按钮组</a></h2>
<pre><code class="language-html">&lt;el-button-group&gt;
  &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-arrow-left&quot;&gt;上一页&lt;/el-button&gt;
  &lt;el-button type=&quot;primary&quot;&gt;下一页&lt;i class=&quot;el-icon-arrow-right el-icon--right&quot;&gt;&lt;/i&gt;&lt;/el-button&gt;
&lt;/el-button-group&gt;
&lt;el-button-group&gt;
  &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt;
  &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-share&quot;&gt;&lt;/el-button&gt;
  &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt;
&lt;/el-button-group&gt;
</code></pre>
<h2 id="加载中"><a class="header" href="#加载中">加载中</a></h2>
<pre><code class="language-html">
&lt;el-button type=&quot;primary&quot; :loading=&quot;true&quot;&gt;加载中&lt;/el-button&gt;

</code></pre>
<h2 id="按钮大小"><a class="header" href="#按钮大小">按钮大小</a></h2>
<pre><code class="language-html">&lt;el-row&gt;
  &lt;el-button&gt;默认按钮&lt;/el-button&gt;
  &lt;el-button size=&quot;medium&quot;&gt;中等按钮&lt;/el-button&gt;
  &lt;el-button size=&quot;small&quot;&gt;小型按钮&lt;/el-button&gt;
  &lt;el-button size=&quot;mini&quot;&gt;超小按钮&lt;/el-button&gt;
&lt;/el-row&gt;
&lt;el-row&gt;
  &lt;el-button round&gt;默认按钮&lt;/el-button&gt;
  &lt;el-button size=&quot;medium&quot; round&gt;中等按钮&lt;/el-button&gt;
  &lt;el-button size=&quot;small&quot; round&gt;小型按钮&lt;/el-button&gt;
  &lt;el-button size=&quot;mini&quot; round&gt;超小按钮&lt;/el-button&gt;
&lt;/el-row&gt;
</code></pre>
<h2 id="attributes-13"><a class="header" href="#attributes-13">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">size</td><td style="text-align: left">尺寸</td><td style="text-align: left">string</td><td style="text-align: left">medium / small / mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">type</td><td style="text-align: left">类型</td><td style="text-align: left">string</td><td style="text-align: left">primary / success / warning / danger / info / text</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">plain</td><td style="text-align: left">是否朴素按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">round</td><td style="text-align: left">是否圆角按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">circle</td><td style="text-align: left">是否圆形按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">loading</td><td style="text-align: left">是否加载中状态</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用状态</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">icon</td><td style="text-align: left">图标类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">autofocus</td><td style="text-align: left">是否默认聚焦</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">native-type</td><td style="text-align: left">原生 type 属性</td><td style="text-align: left">string</td><td style="text-align: left">button / submit / reset</td><td style="text-align: left">button</td></tr>
</tbody></table>
<h1 id="link-文字链接"><a class="header" href="#link-文字链接">Link 文字链接</a></h1>
<h2 id="基础用法-17"><a class="header" href="#基础用法-17">基础用法</a></h2>
<pre><code class="language-html">&lt;div&gt;
  &lt;el-link href=&quot;https://element.eleme.io&quot; target=&quot;_blank&quot;&gt;默认链接&lt;/el-link&gt;
  &lt;el-link type=&quot;primary&quot;&gt;主要链接&lt;/el-link&gt;
  &lt;el-link type=&quot;success&quot;&gt;成功链接&lt;/el-link&gt;
  &lt;el-link type=&quot;warning&quot;&gt;警告链接&lt;/el-link&gt;
  &lt;el-link type=&quot;danger&quot;&gt;危险链接&lt;/el-link&gt;
  &lt;el-link type=&quot;info&quot;&gt;信息链接&lt;/el-link&gt;
&lt;/div&gt;
</code></pre>
<h2 id="禁用状态-2"><a class="header" href="#禁用状态-2">禁用状态</a></h2>
<pre><code class="language-html">&lt;div&gt;
  &lt;el-link disabled&gt;默认链接&lt;/el-link&gt;
  &lt;el-link type=&quot;primary&quot; disabled&gt;主要链接&lt;/el-link&gt;
  &lt;el-link type=&quot;success&quot; disabled&gt;成功链接&lt;/el-link&gt;
  &lt;el-link type=&quot;warning&quot; disabled&gt;警告链接&lt;/el-link&gt;
  &lt;el-link type=&quot;danger&quot; disabled&gt;危险链接&lt;/el-link&gt;
  &lt;el-link type=&quot;info&quot; disabled&gt;信息链接&lt;/el-link&gt;
&lt;/div&gt;
</code></pre>
<h2 id="下划线"><a class="header" href="#下划线">下划线</a></h2>
<pre><code class="language-html">&lt;div&gt;
  &lt;el-link :underline=&quot;false&quot;&gt;无下划线&lt;/el-link&gt;
  &lt;el-link&gt;有下划线&lt;/el-link&gt;
&lt;/div&gt;
</code></pre>
<h2 id="图标-1"><a class="header" href="#图标-1">图标</a></h2>
<pre><code>&lt;div&gt;
  &lt;el-link icon=&quot;el-icon-edit&quot;&gt;编辑&lt;/el-link&gt;
  &lt;el-link&gt;查看&lt;i class=&quot;el-icon-view el-icon--right&quot;&gt;&lt;/i&gt; &lt;/el-link&gt;
&lt;/div&gt;
</code></pre>
<h3 id="attributes-14"><a class="header" href="#attributes-14">Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">type</td><td style="text-align: left">类型</td><td style="text-align: left">string</td><td style="text-align: left">primary / success / warning / danger / info</td><td style="text-align: left">default</td></tr>
<tr><td style="text-align: left">underline</td><td style="text-align: left">是否下划线</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用状态</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">href</td><td style="text-align: left">原生 href 属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">icon</td><td style="text-align: left">图标类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left"></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="avatar-头像"><a class="header" href="#avatar-头像">Avatar 头像</a></h1>
<p>用图标、图片或者字符的形式展示用户或事物信息。</p>
<h1 id="基本用法-3"><a class="header" href="#基本用法-3">基本用法</a></h1>
<p>通过 <code>shape</code> 和 <code>size</code> 设置头像的形状和大小。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-row class=&quot;demo-avatar demo-basic&quot;&gt;
    &lt;el-col :span=&quot;12&quot;&gt;
      &lt;div class=&quot;sub-title&quot;&gt;circle&lt;/div&gt;
      &lt;div class=&quot;demo-basic--circle&quot;&gt;
        &lt;div class=&quot;block&quot;&gt;&lt;el-avatar :size=&quot;50&quot; :src=&quot;circleUrl&quot;&gt;&lt;/el-avatar&gt;&lt;/div&gt;
        &lt;div class=&quot;block&quot; v-for=&quot;size in sizeList&quot; :key=&quot;size&quot;&gt;
          &lt;el-avatar :size=&quot;size&quot; :src=&quot;circleUrl&quot;&gt;&lt;/el-avatar&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/el-col&gt;  
    &lt;el-col :span=&quot;12&quot;&gt;
      &lt;div class=&quot;sub-title&quot;&gt;square&lt;/div&gt;
      &lt;div class=&quot;demo-basic--circle&quot;&gt;
        &lt;div class=&quot;block&quot;&gt;&lt;el-avatar shape=&quot;square&quot; :size=&quot;50&quot; :src=&quot;squareUrl&quot;&gt;&lt;/el-avatar&gt;&lt;/div&gt;
        &lt;div class=&quot;block&quot; v-for=&quot;size in sizeList&quot; :key=&quot;size&quot;&gt;
          &lt;el-avatar shape=&quot;square&quot; :size=&quot;size&quot; :src=&quot;squareUrl&quot;&gt;&lt;/el-avatar&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/el-col&gt; 
  &lt;/el-row&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data () {
      return {
        circleUrl: &quot;https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png&quot;,
        squareUrl: &quot;https://cube.elemecdn.com/9/c2/f0ee8a3c7c9638a54940382568c9dpng.png&quot;,
        sizeList: [&quot;large&quot;, &quot;medium&quot;, &quot;small&quot;]
      }
    }
  }
&lt;/script&gt;

</code></pre>
<h1 id="展示类型"><a class="header" href="#展示类型">展示类型</a></h1>
<p>支持三种类型：图标、图片和字符</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;demo-type&quot;&gt;
    &lt;div&gt;
      &lt;el-avatar icon=&quot;el-icon-user-solid&quot;&gt;&lt;/el-avatar&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;el-avatar src=&quot;https://cube.elemecdn.com/0/88/03b0d39583f48206768a7534e55bcpng.png&quot;&gt;&lt;/el-avatar&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;el-avatar&gt; user &lt;/el-avatar&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h1 id="图片加载失败的-fallback-行为"><a class="header" href="#图片加载失败的-fallback-行为">图片加载失败的 fallback 行为</a></h1>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;demo-type&quot;&gt;
    &lt;el-avatar :size=&quot;60&quot; src=&quot;https://empty&quot; @error=&quot;errorHandler&quot;&gt;
      &lt;img src=&quot;https://cube.elemecdn.com/e/fd/0fc7d20532fdaf769a25683617711png.png&quot;/&gt;
    &lt;/el-avatar&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    methods: {
      errorHandler() {
        return true
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="图片如何适应容器框"><a class="header" href="#图片如何适应容器框">图片如何适应容器框</a></h1>
<p>当展示类型为图片的时候，使用 <code>fit</code> 属性定义图片如何适应容器框，同原生 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit">object-fit</a>。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;demo-fit&quot;&gt;
    &lt;div class=&quot;block&quot; v-for=&quot;fit in fits&quot; :key=&quot;fit&quot;&gt;
        &lt;span class=&quot;title&quot;&gt;{{ fit }}&lt;/span&gt;
        &lt;el-avatar shape=&quot;square&quot; :size=&quot;100&quot; :fit=&quot;fit&quot; :src=&quot;url&quot;&gt;&lt;/el-avatar&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        fits: ['fill', 'contain', 'cover', 'none', 'scale-down'],
        url: 'https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg'
      }
    }
  }
&lt;/script&gt;

</code></pre>
<h1 id="属性事件和方法-20"><a class="header" href="#属性事件和方法-20">属性事件和方法</a></h1>
<h2 id="attributes-15"><a class="header" href="#attributes-15">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">icon</td><td style="text-align: left">设置头像的图标类型，参考 Icon 组件</td><td style="text-align: left">string</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">设置头像的大小</td><td style="text-align: left">number/string</td><td style="text-align: left">number / large / medium / small</td><td style="text-align: left">large</td></tr>
<tr><td style="text-align: left">shape</td><td style="text-align: left">设置头像的形状</td><td style="text-align: left">string</td><td style="text-align: left">circle / square</td><td style="text-align: left">circle</td></tr>
<tr><td style="text-align: left">src</td><td style="text-align: left">图片头像的资源地址</td><td style="text-align: left">string</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">srcSet</td><td style="text-align: left">以逗号分隔的一个或多个字符串列表表明一系列用户代理使用的可能的图像</td><td style="text-align: left">string</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">alt</td><td style="text-align: left">描述图像的替换文本</td><td style="text-align: left">string</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">fit</td><td style="text-align: left">当展示类型为图片的时候，设置图片如何适应容器框</td><td style="text-align: left">string</td><td style="text-align: left">fill / contain / cover / none / scale-down</td><td style="text-align: left">cover</td></tr>
</tbody></table>
<h2 id="events-11"><a class="header" href="#events-11"><a href="https://element.eleme.cn/#/zh-CN/component/avatar#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">error</td><td style="text-align: left">图片类头像加载失败的回调， 返回 false 会关闭组件默认的 fallback 行为</td><td style="text-align: left">(e: Event)</td></tr>
</tbody></table>
<h2 id="slot-6"><a class="header" href="#slot-6"><a href="https://element.eleme.cn/#/zh-CN/component/avatar#slot">¶</a>Slot</a></h2>
<table><thead><tr><th style="text-align: left">名称</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">default</td><td style="text-align: left">自定义头像展示内容</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dialog-对话框"><a class="header" href="#dialog-对话框">Dialog 对话框</a></h1>
<p>在保留当前页面状态的情况下，告知用户并承载相关操作。</p>
<h1 id="基本用法-4"><a class="header" href="#基本用法-4">基本用法</a></h1>
<p>Dialog 弹出一个对话框，适合需要定制性更大的场景</p>
<p>​	需要设置<code>visible</code>属性，它接收<code>Boolean</code>，当为<code>true</code>时显示 Dialog。Dialog 分为两个部分：<code>body</code>和<code>footer</code>，<code>footer</code>需要具名为<code>footer</code>的<code>slot</code>。<code>title</code>属性用于定义标题，它是可选的，默认值为空。最后，本例还展示了<code>before-close</code>的用法。</p>
<pre><code class="language-vue">&lt;el-button type=&quot;text&quot; @click=&quot;dialogVisible = true&quot;&gt;点击打开 Dialog&lt;/el-button&gt;

&lt;el-dialog
  title=&quot;提示&quot;
  :visible.sync=&quot;dialogVisible&quot;
  width=&quot;30%&quot;
  :before-close=&quot;handleClose&quot;&gt;
  &lt;span&gt;这是一段信息&lt;/span&gt;
  &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;
    &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt;
    &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确 定&lt;/el-button&gt;
  &lt;/span&gt;
&lt;/el-dialog&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        dialogVisible: false
      };
    },
    methods: {
      handleClose(done) {
        this.$confirm('确认关闭？')
          .then(_ =&gt; {
            done();
          })
          .catch(_ =&gt; {});
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="自定义内容"><a class="header" href="#自定义内容">自定义内容</a></h1>
<p>Dialog 组件的内容可以是任意的，甚至可以是表格或表单，下面是应用了 Element Table 和 Form 组件的两个样例。</p>
<pre><code class="language-vue">&lt;!-- Table --&gt;
&lt;el-button type=&quot;text&quot; @click=&quot;dialogTableVisible = true&quot;&gt;打开嵌套表格的 Dialog&lt;/el-button&gt;

&lt;el-dialog title=&quot;收货地址&quot; :visible.sync=&quot;dialogTableVisible&quot;&gt;
  &lt;el-table :data=&quot;gridData&quot;&gt;
    &lt;el-table-column property=&quot;date&quot; label=&quot;日期&quot; width=&quot;150&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column property=&quot;name&quot; label=&quot;姓名&quot; width=&quot;200&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column property=&quot;address&quot; label=&quot;地址&quot;&gt;&lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/el-dialog&gt;

&lt;!-- Form --&gt;
&lt;el-button type=&quot;text&quot; @click=&quot;dialogFormVisible = true&quot;&gt;打开嵌套表单的 Dialog&lt;/el-button&gt;

&lt;el-dialog title=&quot;收货地址&quot; :visible.sync=&quot;dialogFormVisible&quot;&gt;
  &lt;el-form :model=&quot;form&quot;&gt;
    &lt;el-form-item label=&quot;活动名称&quot; :label-width=&quot;formLabelWidth&quot;&gt;
      &lt;el-input v-model=&quot;form.name&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;
    &lt;/el-form-item&gt;
    &lt;el-form-item label=&quot;活动区域&quot; :label-width=&quot;formLabelWidth&quot;&gt;
      &lt;el-select v-model=&quot;form.region&quot; placeholder=&quot;请选择活动区域&quot;&gt;
        &lt;el-option label=&quot;区域一&quot; value=&quot;shanghai&quot;&gt;&lt;/el-option&gt;
        &lt;el-option label=&quot;区域二&quot; value=&quot;beijing&quot;&gt;&lt;/el-option&gt;
      &lt;/el-select&gt;
    &lt;/el-form-item&gt;
  &lt;/el-form&gt;
  &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;
    &lt;el-button @click=&quot;dialogFormVisible = false&quot;&gt;取 消&lt;/el-button&gt;
    &lt;el-button type=&quot;primary&quot; @click=&quot;dialogFormVisible = false&quot;&gt;确 定&lt;/el-button&gt;
  &lt;/div&gt;
&lt;/el-dialog&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        gridData: [{
          date: '2016-05-02',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }, {
          date: '2016-05-04',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }, {
          date: '2016-05-01',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }, {
          date: '2016-05-03',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }],
        dialogTableVisible: false,
        dialogFormVisible: false,
        form: {
          name: '',
          region: '',
          date1: '',
          date2: '',
          delivery: false,
          type: [],
          resource: '',
          desc: ''
        },
        formLabelWidth: '120px'
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="嵌套的-dialog"><a class="header" href="#嵌套的-dialog">嵌套的 Dialog</a></h1>
<p>如果需要在一个 Dialog 内部嵌套另一个 Dialog，需要使用 <code>append-to-body</code> 属性。</p>
<p>正常情况下，我们不建议使用嵌套的 Dialog，如果需要在页面上同时显示多个 Dialog，可以将它们平级放置。对于确实需要嵌套 Dialog 的场景，我们提供了<code>append-to-body</code>属性。将内层 Dialog 的该属性设置为 true，它就会插入至 body 元素上，从而保证内外层 Dialog 和遮罩层级关系的正确。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button type=&quot;text&quot; @click=&quot;outerVisible = true&quot;&gt;点击打开外层 Dialog&lt;/el-button&gt;
  
  &lt;el-dialog title=&quot;外层 Dialog&quot; :visible.sync=&quot;outerVisible&quot;&gt;
    &lt;el-dialog
      width=&quot;30%&quot;
      title=&quot;内层 Dialog&quot;
      :visible.sync=&quot;innerVisible&quot;
      append-to-body&gt;
    &lt;/el-dialog&gt;
    &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;
      &lt;el-button @click=&quot;outerVisible = false&quot;&gt;取 消&lt;/el-button&gt;
      &lt;el-button type=&quot;primary&quot; @click=&quot;innerVisible = true&quot;&gt;打开内层 Dialog&lt;/el-button&gt;
    &lt;/div&gt;
  &lt;/el-dialog&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        outerVisible: false,
        innerVisible: false
      };
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="居中布局-1"><a class="header" href="#居中布局-1">居中布局</a></h1>
<p>标题和底部可水平居中</p>
<p>将<code>center</code>设置为<code>true</code>即可使标题和底部居中。<code>center</code>仅影响标题和底部区域。Dialog 的内容是任意的，在一些情况下，内容并不适合居中布局。如果需要内容也水平居中，请自行为其添加 CSS。</p>
<pre><code class="language-vue">&lt;el-button type=&quot;text&quot; @click=&quot;centerDialogVisible = true&quot;&gt;点击打开 Dialog&lt;/el-button&gt;

&lt;el-dialog
  title=&quot;提示&quot;
  :visible.sync=&quot;centerDialogVisible&quot;
  width=&quot;30%&quot;
  center&gt;
  &lt;span&gt;需要注意的是内容是默认不居中的&lt;/span&gt;
  &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;
    &lt;el-button @click=&quot;centerDialogVisible = false&quot;&gt;取 消&lt;/el-button&gt;
    &lt;el-button type=&quot;primary&quot; @click=&quot;centerDialogVisible = false&quot;&gt;确 定&lt;/el-button&gt;
  &lt;/span&gt;
&lt;/el-dialog&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        centerDialogVisible: false
      };
    }
  };
&lt;/script&gt;
</code></pre>
<p>Dialog 的内容是懒渲染的，即在第一次被打开之前，传入的默认 slot 不会被渲染到 DOM 上。因此，如果需要执行 DOM 操作，或通过 <code>ref</code> 获取相应组件，请在 <code>open</code> 事件回调中进行。</p>
<blockquote>
<p>如果 <code>visible</code> 属性绑定的变量位于 Vuex 的 store 内，那么 <code>.sync</code> 不会正常工作。此时需要去除 <code>.sync</code> 修饰符，同时监听 Dialog 的 <code>open</code> 和 <code>close</code> 事件，在事件回调中执行 Vuex 中对应的 mutation 更新 <code>visible</code> 属性绑定的变量的值。</p>
</blockquote>
<h1 id="属性事件和方法-21"><a class="header" href="#属性事件和方法-21">属性事件和方法</a></h1>
<h2 id="attributes-16"><a class="header" href="#attributes-16">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">visible</td><td style="text-align: left">是否显示 Dialog，支持 .sync 修饰符</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">title</td><td style="text-align: left">Dialog 的标题，也可通过具名 slot （见下表）传入</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">width</td><td style="text-align: left">Dialog 的宽度</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">50%</td></tr>
<tr><td style="text-align: left">fullscreen</td><td style="text-align: left">是否为全屏 Dialog</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">top</td><td style="text-align: left">Dialog CSS 中的 margin-top 值</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">15vh</td></tr>
<tr><td style="text-align: left">modal</td><td style="text-align: left">是否需要遮罩层</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">modal-append-to-body</td><td style="text-align: left">遮罩层是否插入至 body 元素上，若为 false，则遮罩层会插入至 Dialog 的父元素上</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">append-to-body</td><td style="text-align: left">Dialog 自身是否插入至 body 元素上。嵌套的 Dialog 必须指定该属性并赋值为 true</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">lock-scroll</td><td style="text-align: left">是否在 Dialog 出现时将 body 滚动锁定</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">custom-class</td><td style="text-align: left">Dialog 的自定义类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">close-on-click-modal</td><td style="text-align: left">是否可以通过点击 modal 关闭 Dialog</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">close-on-press-escape</td><td style="text-align: left">是否可以通过按下 ESC 关闭 Dialog</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">show-close</td><td style="text-align: left">是否显示关闭按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">before-close</td><td style="text-align: left">关闭前的回调，会暂停 Dialog 的关闭</td><td style="text-align: left">function(done)，done 用于关闭 Dialog</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">center</td><td style="text-align: left">是否对头部和底部采用居中布局</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">destroy-on-close</td><td style="text-align: left">关闭时销毁 Dialog 中的元素</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
</tbody></table>
<h2 id="slot-7"><a class="header" href="#slot-7"><a href="https://element.eleme.cn/#/zh-CN/component/dialog#slot">¶</a>Slot</a></h2>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">—</td><td style="text-align: left">Dialog 的内容</td></tr>
<tr><td style="text-align: left">title</td><td style="text-align: left">Dialog 标题区的内容</td></tr>
<tr><td style="text-align: left">footer</td><td style="text-align: left">Dialog 按钮操作区的内容</td></tr>
</tbody></table>
<h2 id="events-12"><a class="header" href="#events-12"><a href="https://element.eleme.cn/#/zh-CN/component/dialog#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">open</td><td style="text-align: left">Dialog 打开的回调</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">opened</td><td style="text-align: left">Dialog 打开动画结束时的回调</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">close</td><td style="text-align: left">Dialog 关闭的回调</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">closed</td><td style="text-align: left">Dialog 关闭动画结束时的回调</td><td style="text-align: left">—</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="radio-单选框"><a class="header" href="#radio-单选框">Radio 单选框</a></h1>
<p>由于选项默认可见，不宜过多，若选项过多，建议使用 Select 选择器。</p>
<h2 id="基础使用"><a class="header" href="#基础使用">基础使用</a></h2>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-radio v-model=&quot;radio&quot; label=&quot;1&quot;&gt;备选项&lt;/el-radio&gt;
  &lt;el-radio v-model=&quot;radio&quot; label=&quot;2&quot;&gt;备选项&lt;/el-radio&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        radio: '1'
      };
    }
  }
&lt;/script&gt;
</code></pre>
<h2 id="禁用-1"><a class="header" href="#禁用-1">禁用</a></h2>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-radio disabled v-model=&quot;radio&quot; label=&quot;禁用&quot;&gt;备选项&lt;/el-radio&gt;
  &lt;el-radio disabled v-model=&quot;radio&quot; label=&quot;选中且禁用&quot;&gt;备选项&lt;/el-radio&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        radio: '选中且禁用'
      };
    }
  }
&lt;/script&gt;
</code></pre>
<h2 id="单选框组"><a class="header" href="#单选框组">单选框组</a></h2>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-radio-group v-model=&quot;radio&quot;&gt;
    &lt;el-radio :label=&quot;3&quot;&gt;备选项&lt;/el-radio&gt;
    &lt;el-radio :label=&quot;6&quot;&gt;备选项&lt;/el-radio&gt;
    &lt;el-radio :label=&quot;9&quot;&gt;备选项&lt;/el-radio&gt;
  &lt;/el-radio-group&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        radio: 3
      };
    }
  }
&lt;/script&gt;
</code></pre>
<h2 id="按钮-样式"><a class="header" href="#按钮-样式">按钮 样式</a></h2>
<p>只需要把<code>el-radio</code>元素换成<code>el-radio-button</code>元素即可，此外，Element 还提供了<code>size</code>属性</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;el-radio-group v-model=&quot;radio1&quot;&gt;
      &lt;el-radio-button label=&quot;上海&quot;&gt;&lt;/el-radio-button&gt;
      &lt;el-radio-button label=&quot;北京&quot;&gt;&lt;/el-radio-button&gt;
      &lt;el-radio-button label=&quot;广州&quot;&gt;&lt;/el-radio-button&gt;
      &lt;el-radio-button label=&quot;深圳&quot;&gt;&lt;/el-radio-button&gt;
    &lt;/el-radio-group&gt;
  &lt;/div&gt;
  &lt;div style=&quot;margin-top: 20px&quot;&gt;
    &lt;el-radio-group v-model=&quot;radio2&quot; size=&quot;medium&quot;&gt;
      &lt;el-radio-button label=&quot;上海&quot; &gt;&lt;/el-radio-button&gt;
      &lt;el-radio-button label=&quot;北京&quot;&gt;&lt;/el-radio-button&gt;
      &lt;el-radio-button label=&quot;广州&quot;&gt;&lt;/el-radio-button&gt;
      &lt;el-radio-button label=&quot;深圳&quot;&gt;&lt;/el-radio-button&gt;
    &lt;/el-radio-group&gt;
  &lt;/div&gt;
  &lt;div style=&quot;margin-top: 20px&quot;&gt;
    &lt;el-radio-group v-model=&quot;radio3&quot; size=&quot;small&quot;&gt;
      &lt;el-radio-button label=&quot;上海&quot;&gt;&lt;/el-radio-button&gt;
      &lt;el-radio-button label=&quot;北京&quot; disabled &gt;&lt;/el-radio-button&gt;
      &lt;el-radio-button label=&quot;广州&quot;&gt;&lt;/el-radio-button&gt;
      &lt;el-radio-button label=&quot;深圳&quot;&gt;&lt;/el-radio-button&gt;
    &lt;/el-radio-group&gt;
  &lt;/div&gt;
  &lt;div style=&quot;margin-top: 20px&quot;&gt;
    &lt;el-radio-group v-model=&quot;radio4&quot; disabled size=&quot;mini&quot;&gt;
      &lt;el-radio-button label=&quot;上海&quot;&gt;&lt;/el-radio-button&gt;
      &lt;el-radio-button label=&quot;北京&quot;&gt;&lt;/el-radio-button&gt;
      &lt;el-radio-button label=&quot;广州&quot;&gt;&lt;/el-radio-button&gt;
      &lt;el-radio-button label=&quot;深圳&quot;&gt;&lt;/el-radio-button&gt;
    &lt;/el-radio-group&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        radio1: '上海',
        radio2: '上海',
        radio3: '上海',
        radio4: '上海'
      };
    }
  }
&lt;/script&gt;
</code></pre>
<h2 id="带有边框"><a class="header" href="#带有边框">带有边框</a></h2>
<p>设置<code>border</code>属性可以渲染为带有边框的单选框。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;el-radio v-model=&quot;radio1&quot; label=&quot;1&quot; border&gt;备选项1&lt;/el-radio&gt;
    &lt;el-radio v-model=&quot;radio1&quot; label=&quot;2&quot; border&gt;备选项2&lt;/el-radio&gt;
  &lt;/div&gt;
  &lt;div style=&quot;margin-top: 20px&quot;&gt;
    &lt;el-radio v-model=&quot;radio2&quot; label=&quot;1&quot; border size=&quot;medium&quot;&gt;备选项1&lt;/el-radio&gt;
    &lt;el-radio v-model=&quot;radio2&quot; label=&quot;2&quot; border size=&quot;medium&quot;&gt;备选项2&lt;/el-radio&gt;
  &lt;/div&gt;
  &lt;div style=&quot;margin-top: 20px&quot;&gt;
    &lt;el-radio-group v-model=&quot;radio3&quot; size=&quot;small&quot;&gt;
      &lt;el-radio label=&quot;1&quot; border&gt;备选项1&lt;/el-radio&gt;
      &lt;el-radio label=&quot;2&quot; border disabled&gt;备选项2&lt;/el-radio&gt;
    &lt;/el-radio-group&gt;
  &lt;/div&gt;
  &lt;div style=&quot;margin-top: 20px&quot;&gt;
    &lt;el-radio-group v-model=&quot;radio4&quot; size=&quot;mini&quot; disabled&gt;
      &lt;el-radio label=&quot;1&quot; border&gt;备选项1&lt;/el-radio&gt;
      &lt;el-radio label=&quot;2&quot; border&gt;备选项2&lt;/el-radio&gt;
    &lt;/el-radio-group&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        radio1: '1',
        radio2: '1',
        radio3: '1',
        radio4: '1'
      };
    }
  }
&lt;/script&gt;
</code></pre>
<h2 id="radio-attributes"><a class="header" href="#radio-attributes">Radio Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">string / number / boolean</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">label</td><td style="text-align: left">Radio 的 value</td><td style="text-align: left">string / number / boolean</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">border</td><td style="text-align: left">是否显示边框</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">Radio 的尺寸，仅在 border 为真时有效</td><td style="text-align: left">string</td><td style="text-align: left">medium / small / mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">原生 name 属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h2 id="radio-events"><a class="header" href="#radio-events">Radio Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">绑定值变化时触发的事件</td><td style="text-align: left">选中的 Radio label 值</td></tr>
</tbody></table>
<h2 id="radio-group-attributes"><a class="header" href="#radio-group-attributes">Radio-group Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">string / number / boolean</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">单选框组尺寸，仅对按钮形式的 Radio 或带有边框的 Radio 有效</td><td style="text-align: left">string</td><td style="text-align: left">medium / small / mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">text-color</td><td style="text-align: left">按钮形式的 Radio 激活时的文本颜色</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">#ffffff</td></tr>
<tr><td style="text-align: left">fill</td><td style="text-align: left">按钮形式的 Radio 激活时的填充色和边框色</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">#409EFF</td></tr>
</tbody></table>
<h2 id="radio-group-events"><a class="header" href="#radio-group-events">Radio-group Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">绑定值变化时触发的事件</td><td style="text-align: left">选中的 Radio label 值</td></tr>
</tbody></table>
<h2 id="radio-button-attributes"><a class="header" href="#radio-button-attributes">Radio-button Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">label</td><td style="text-align: left">Radio 的 value</td><td style="text-align: left">string / number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">原生 name 属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h1 id="checkbox-多选框"><a class="header" href="#checkbox-多选框">Checkbox 多选框</a></h1>
<h2 id="基础用法-18"><a class="header" href="#基础用法-18">基础用法</a></h2>
<pre><code class="language-vue">&lt;template&gt;
  &lt;!-- `checked` 为 true 或 false --&gt;
  &lt;el-checkbox v-model=&quot;checked&quot;&gt;备选项&lt;/el-checkbox&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        checked: true
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h2 id="禁用状态-3"><a class="header" href="#禁用状态-3">禁用状态</a></h2>
<p><em>disabled</em></p>
<h2 id="多选框组"><a class="header" href="#多选框组">多选框组</a></h2>
<p><code>checkbox-group</code>元素能把多个 checkbox 管理为一组，只需要在 Group 中使用<code>v-model</code>绑定<code>Array</code>类型的变量即可。 <code>el-checkbox</code> 的 <code>label</code>属性是该 checkbox 对应的值，若该标签中无内容，则该属性也充当 checkbox 按钮后的介绍。<code>label</code>与数组中的元素值相对应，如果存在指定的值则为选中状态，否则为不选中。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;el-checkbox-group v-model=&quot;checkList&quot;&gt;
    &lt;el-checkbox label=&quot;复选框 A&quot;&gt;&lt;/el-checkbox&gt;
    &lt;el-checkbox label=&quot;复选框 B&quot;&gt;&lt;/el-checkbox&gt;
    &lt;el-checkbox label=&quot;复选框 C&quot;&gt;&lt;/el-checkbox&gt;
    &lt;el-checkbox label=&quot;禁用&quot; disabled&gt;&lt;/el-checkbox&gt;
    &lt;el-checkbox label=&quot;选中且禁用&quot; disabled&gt;&lt;/el-checkbox&gt;
  &lt;/el-checkbox-group&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        checkList: ['选中且禁用','复选框 A']
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h2 id="indeterminate-状态"><a class="header" href="#indeterminate-状态">indeterminate 状态</a></h2>
<p><code>indeterminate</code> 属性用以表示 checkbox 的不确定状态，一般用于<strong>实现全选的效果</strong></p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-checkbox :indeterminate=&quot;isIndeterminate&quot; v-model=&quot;checkAll&quot; @change=&quot;handleCheckAllChange&quot;&gt;全选&lt;/el-checkbox&gt;
  &lt;div style=&quot;margin: 15px 0;&quot;&gt;&lt;/div&gt;
  &lt;el-checkbox-group v-model=&quot;checkedCities&quot; @change=&quot;handleCheckedCitiesChange&quot;&gt;
    &lt;el-checkbox v-for=&quot;city in cities&quot; :label=&quot;city&quot; :key=&quot;city&quot;&gt;{{city}}&lt;/el-checkbox&gt;
  &lt;/el-checkbox-group&gt;
&lt;/template&gt;
&lt;script&gt;
  const cityOptions = ['上海', '北京', '广州', '深圳'];
  export default {
    data() {
      return {
        checkAll: false,
        checkedCities: ['上海', '北京'],
        cities: cityOptions,
        isIndeterminate: true
      };
    },
    methods: {
      handleCheckAllChange(val) {
        this.checkedCities = val ? cityOptions : [];
        this.isIndeterminate = false;
      },
      handleCheckedCitiesChange(value) {
        let checkedCount = value.length;
        this.checkAll = checkedCount === this.cities.length;
        this.isIndeterminate = checkedCount &gt; 0 &amp;&amp; checkedCount &lt; this.cities.length;
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h2 id="可选项目数量的限制"><a class="header" href="#可选项目数量的限制">可选项目数量的限制</a></h2>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-checkbox-group 
    v-model=&quot;checkedCities&quot;
    :min=&quot;1&quot;
    :max=&quot;2&quot;&gt;
    &lt;el-checkbox v-for=&quot;city in cities&quot; :label=&quot;city&quot; :key=&quot;city&quot;&gt;{{city}}&lt;/el-checkbox&gt;
  &lt;/el-checkbox-group&gt;
&lt;/template&gt;
&lt;script&gt;
  const cityOptions = ['上海', '北京', '广州', '深圳'];
  export default {
    data() {
      return {
        checkedCities: ['上海', '北京'],
        cities: cityOptions
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h2 id="按钮样式"><a class="header" href="#按钮样式">按钮样式</a></h2>
<p>只需要把<code>el-checkbox</code>元素替换为<code>el-checkbox-button</code>元素即可。此外，Element 还提供了<code>size</code>属性。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;el-checkbox-group v-model=&quot;checkboxGroup1&quot;&gt;
      &lt;el-checkbox-button v-for=&quot;city in cities&quot; :label=&quot;city&quot; :key=&quot;city&quot;&gt;{{city}}&lt;/el-checkbox-button&gt;
    &lt;/el-checkbox-group&gt;
  &lt;/div&gt;
  &lt;div style=&quot;margin-top: 20px&quot;&gt;
    &lt;el-checkbox-group v-model=&quot;checkboxGroup2&quot; size=&quot;medium&quot;&gt;
      &lt;el-checkbox-button v-for=&quot;city in cities&quot; :label=&quot;city&quot; :key=&quot;city&quot;&gt;{{city}}&lt;/el-checkbox-button&gt;
    &lt;/el-checkbox-group&gt;
  &lt;/div&gt;
  &lt;div style=&quot;margin-top: 20px&quot;&gt;
    &lt;el-checkbox-group v-model=&quot;checkboxGroup3&quot; size=&quot;small&quot;&gt;
      &lt;el-checkbox-button v-for=&quot;city in cities&quot; :label=&quot;city&quot; :disabled=&quot;city === '北京'&quot; :key=&quot;city&quot;&gt;{{city}}&lt;/el-checkbox-button&gt;
    &lt;/el-checkbox-group&gt;
  &lt;/div&gt;
  &lt;div style=&quot;margin-top: 20px&quot;&gt;
    &lt;el-checkbox-group v-model=&quot;checkboxGroup4&quot; size=&quot;mini&quot; disabled&gt;
      &lt;el-checkbox-button v-for=&quot;city in cities&quot; :label=&quot;city&quot; :key=&quot;city&quot;&gt;{{city}}&lt;/el-checkbox-button&gt;
    &lt;/el-checkbox-group&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  const cityOptions = ['上海', '北京', '广州', '深圳'];
  export default {
    data () {
      return {
        checkboxGroup1: ['上海'],
        checkboxGroup2: ['上海'],
        checkboxGroup3: ['上海'],
        checkboxGroup4: ['上海'],
        cities: cityOptions
      };
    }
  }
&lt;/script&gt;
</code></pre>
<h2 id="带有边框-1"><a class="header" href="#带有边框-1">带有边框</a></h2>
<p><code>&lt;el-checkbox v-model=&quot;checked1&quot; label=&quot;备选项1&quot; border&gt;&lt;/el-checkbox&gt;</code></p>
<h2 id="参数与事件"><a class="header" href="#参数与事件">参数与事件</a></h2>
<h3 id="checkbox-attributes"><a class="header" href="#checkbox-attributes">Checkbox Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">string / number / boolean</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">label</td><td style="text-align: left">选中状态的值（只有在<code>checkbox-group</code>或者绑定对象类型为<code>array</code>时有效）</td><td style="text-align: left">string / number / boolean</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">true-label</td><td style="text-align: left">选中时的值</td><td style="text-align: left">string / number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">false-label</td><td style="text-align: left">没有选中时的值</td><td style="text-align: left">string / number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">border</td><td style="text-align: left">是否显示边框</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">Checkbox 的尺寸，仅在 border 为真时有效</td><td style="text-align: left">string</td><td style="text-align: left">medium / small / mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">原生 name 属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">checked</td><td style="text-align: left">当前是否勾选</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">indeterminate</td><td style="text-align: left">设置 indeterminate 状态，只负责样式控制</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
</tbody></table>
<h3 id="checkbox-events"><a class="header" href="#checkbox-events"><a href="https://element.eleme.cn/#/zh-CN/component/checkbox#checkbox-events">¶</a>Checkbox Events</a></h3>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">当绑定值变化时触发的事件</td><td style="text-align: left">更新后的值</td></tr>
</tbody></table>
<h3 id="checkbox-group-attributes"><a class="header" href="#checkbox-group-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/checkbox#checkbox-group-attributes">¶</a>Checkbox-group Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">多选框组尺寸，仅对按钮形式的 Checkbox 或带有边框的 Checkbox 有效</td><td style="text-align: left">string</td><td style="text-align: left">medium / small / mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">min</td><td style="text-align: left">可被勾选的 checkbox 的最小数量</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">max</td><td style="text-align: left">可被勾选的 checkbox 的最大数量</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">text-color</td><td style="text-align: left">按钮形式的 Checkbox 激活时的文本颜色</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">#ffffff</td></tr>
<tr><td style="text-align: left">fill</td><td style="text-align: left">按钮形式的 Checkbox 激活时的填充色和边框色</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">#409EFF</td></tr>
</tbody></table>
<h3 id="checkbox-group-events"><a class="header" href="#checkbox-group-events"><a href="https://element.eleme.cn/#/zh-CN/component/checkbox#checkbox-group-events">¶</a>Checkbox-group Events</a></h3>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">当绑定值变化时触发的事件</td><td style="text-align: left">更新后的值</td></tr>
</tbody></table>
<h3 id="checkbox-button-attributes"><a class="header" href="#checkbox-button-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/checkbox#checkbox-button-attributes">¶</a>Checkbox-button Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">label</td><td style="text-align: left">选中状态的值（只有在<code>checkbox-group</code>或者绑定对象类型为<code>array</code>时有效）</td><td style="text-align: left">string / number / boolean</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">true-label</td><td style="text-align: left">选中时的值</td><td style="text-align: left">string / number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">false-label</td><td style="text-align: left">没有选中时的值</td><td style="text-align: left">string / number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">原生 name 属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">checked</td><td style="text-align: left">当前是否勾选</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
</tbody></table>
<h1 id="input-输入框"><a class="header" href="#input-输入框">Input 输入框</a></h1>
<h2 id="基础用法-19"><a class="header" href="#基础用法-19">基础用法</a></h2>
<pre><code class="language-html">&lt;el-input v-model=&quot;input&quot; placeholder=&quot;请输入内容&quot;&gt;&lt;/el-input&gt;

&lt;script&gt;
export default {
  data() {
    return {
      input: ''
    }
  }
}
&lt;/script&gt;
</code></pre>
<h2 id="禁用-2"><a class="header" href="#禁用-2">禁用</a></h2>
<pre><code class="language-vue">&lt;el-input
  placeholder=&quot;请输入内容&quot;
  v-model=&quot;input&quot;
  :disabled=&quot;true&quot;&gt;
&lt;/el-input&gt;
</code></pre>
<h2 id="清空"><a class="header" href="#清空">清空</a></h2>
<pre><code class="language-vue">&lt;el-input
  placeholder=&quot;请输入内容&quot;
  v-model=&quot;input&quot;
  clearable&gt;
&lt;/el-input&gt;
</code></pre>
<h2 id="密码输入"><a class="header" href="#密码输入">密码输入</a></h2>
<pre><code class="language-html">&lt;el-input placeholder=&quot;请输入密码&quot; v-model=&quot;input&quot; show-password&gt;&lt;/el-input&gt;
</code></pre>
<h2 id="带-icon-的输入框"><a class="header" href="#带-icon-的输入框">带 icon 的输入框</a></h2>
<p>可以通过 <code>prefix-icon</code> 和 <code>suffix-icon</code> 属性在 input 组件首部和尾部增加显示图标，也可以通过 slot 来放置图标。</p>
<pre><code class="language-vue">&lt;div class=&quot;demo-input-suffix&quot;&gt;
  属性方式：
  &lt;el-input
    placeholder=&quot;请选择日期&quot;
    suffix-icon=&quot;el-icon-date&quot;
    v-model=&quot;input1&quot;&gt;
  &lt;/el-input&gt;
  &lt;el-input
    placeholder=&quot;请输入内容&quot;
    prefix-icon=&quot;el-icon-search&quot;
    v-model=&quot;input2&quot;&gt;
  &lt;/el-input&gt;
&lt;/div&gt;
&lt;div class=&quot;demo-input-suffix&quot;&gt;
  slot 方式：
  &lt;el-input
    placeholder=&quot;请选择日期&quot;
    v-model=&quot;input3&quot;&gt;
    &lt;i slot=&quot;suffix&quot; class=&quot;el-input__icon el-icon-date&quot;&gt;&lt;/i&gt;
  &lt;/el-input&gt;
  &lt;el-input
    placeholder=&quot;请输入内容&quot;
    v-model=&quot;input4&quot;&gt;
    &lt;i slot=&quot;prefix&quot; class=&quot;el-input__icon el-icon-search&quot;&gt;&lt;/i&gt;
  &lt;/el-input&gt;
&lt;/div&gt;

</code></pre>
<h2 id="文本域"><a class="header" href="#文本域">文本域</a></h2>
<p>用于输入多行文本信息，通过将 <code>type</code> 属性的值指定为 textarea。</p>
<pre><code class="language-vue">&lt;el-input
  type=&quot;textarea&quot;
  :rows=&quot;2&quot;
  placeholder=&quot;请输入内容&quot;
  v-model=&quot;textarea&quot;&gt;
&lt;/el-input&gt;

</code></pre>
<h2 id="可自适应文本高度的文本域"><a class="header" href="#可自适应文本高度的文本域">可自适应文本高度的文本域</a></h2>
<pre><code class="language-vue">&lt;el-input
  type=&quot;textarea&quot;
  autosize
  placeholder=&quot;请输入内容&quot;
  v-model=&quot;textarea1&quot;&gt;
&lt;/el-input&gt;
&lt;div style=&quot;margin: 20px 0;&quot;&gt;&lt;/div&gt;
&lt;el-input
  type=&quot;textarea&quot;
  :autosize=&quot;{ minRows: 2, maxRows: 4}&quot;
  placeholder=&quot;请输入内容&quot;
  v-model=&quot;textarea2&quot;&gt;
&lt;/el-input&gt;

</code></pre>
<h2 id="复合型输入框"><a class="header" href="#复合型输入框">复合型输入框</a></h2>
<pre><code class="language-vue">&lt;div&gt;
  &lt;el-input placeholder=&quot;请输入内容&quot; v-model=&quot;input1&quot;&gt;
    &lt;template slot=&quot;prepend&quot;&gt;Http://&lt;/template&gt;
  &lt;/el-input&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-top: 15px;&quot;&gt;
  &lt;el-input placeholder=&quot;请输入内容&quot; v-model=&quot;input2&quot;&gt;
    &lt;template slot=&quot;append&quot;&gt;.com&lt;/template&gt;
  &lt;/el-input&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-top: 15px;&quot;&gt;
  &lt;el-input placeholder=&quot;请输入内容&quot; v-model=&quot;input3&quot; class=&quot;input-with-select&quot;&gt;
    &lt;el-select v-model=&quot;select&quot; slot=&quot;prepend&quot; placeholder=&quot;请选择&quot;&gt;
      &lt;el-option label=&quot;餐厅名&quot; value=&quot;1&quot;&gt;&lt;/el-option&gt;
      &lt;el-option label=&quot;订单号&quot; value=&quot;2&quot;&gt;&lt;/el-option&gt;
      &lt;el-option label=&quot;用户电话&quot; value=&quot;3&quot;&gt;&lt;/el-option&gt;
    &lt;/el-select&gt;
    &lt;el-button slot=&quot;append&quot; icon=&quot;el-icon-search&quot;&gt;&lt;/el-button&gt;
  &lt;/el-input&gt;
&lt;/div&gt;
&lt;style&gt;
  .el-select .el-input {
    width: 130px;
  }
  .input-with-select .el-input-group__prepend {
    background-color: #fff;
  }
&lt;/style&gt;
&lt;script&gt;
export default {
  data() {
    return {
      input1: '',
      input2: '',
      input3: '',
      select: ''
    }
  }
}
&lt;/script&gt;
</code></pre>
<h2 id="尺寸"><a class="header" href="#尺寸">尺寸</a></h2>
<p>可通过 <code>size</code> 属性指定输入框的尺寸，除了默认的大小外，还提供了 large、small 和 mini 三种尺寸。</p>
<pre><code class="language-vue">&lt;div class=&quot;demo-input-size&quot;&gt;
  &lt;el-input
    placeholder=&quot;请输入内容&quot;
    suffix-icon=&quot;el-icon-date&quot;
    v-model=&quot;input1&quot;&gt;
  &lt;/el-input&gt;
  &lt;el-input
    size=&quot;medium&quot;
    placeholder=&quot;请输入内容&quot;
    suffix-icon=&quot;el-icon-date&quot;
    v-model=&quot;input2&quot;&gt;
  &lt;/el-input&gt;
  &lt;el-input
    size=&quot;small&quot;
    placeholder=&quot;请输入内容&quot;
    suffix-icon=&quot;el-icon-date&quot;
    v-model=&quot;input3&quot;&gt;
  &lt;/el-input&gt;
  &lt;el-input
    size=&quot;mini&quot;
    placeholder=&quot;请输入内容&quot;
    suffix-icon=&quot;el-icon-date&quot;
    v-model=&quot;input4&quot;&gt;
  &lt;/el-input&gt;
&lt;/div&gt;
</code></pre>
<h2 id="输入建议"><a class="header" href="#输入建议">输入建议</a></h2>
<p>autocomplete 是一个可带输入建议的输入框组件，<code>fetch-suggestions</code> 是一个返回输入建议的方法属性，如 querySearch(queryString, cb)，在该方法中你可以在你的输入建议数据准备好时通过 cb(data) 返回到 autocomplete 组件中。</p>
<pre><code class="language-vue">&lt;el-row class=&quot;demo-autocomplete&quot;&gt;
  &lt;el-col :span=&quot;12&quot;&gt;
    &lt;div class=&quot;sub-title&quot;&gt;激活即列出输入建议&lt;/div&gt;
    &lt;el-autocomplete
      class=&quot;inline-input&quot;
      v-model=&quot;state1&quot;
      :fetch-suggestions=&quot;querySearch&quot;
      placeholder=&quot;请输入内容&quot;
      @select=&quot;handleSelect&quot;
    &gt;&lt;/el-autocomplete&gt;
  &lt;/el-col&gt;
  &lt;el-col :span=&quot;12&quot;&gt;
    &lt;div class=&quot;sub-title&quot;&gt;输入后匹配输入建议&lt;/div&gt;
    &lt;el-autocomplete
      class=&quot;inline-input&quot;
      v-model=&quot;state2&quot;
      :fetch-suggestions=&quot;querySearch&quot;
      placeholder=&quot;请输入内容&quot;
      :trigger-on-focus=&quot;false&quot;
      @select=&quot;handleSelect&quot;
    &gt;&lt;/el-autocomplete&gt;
  &lt;/el-col&gt;
&lt;/el-row&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        restaurants: [],
        state1: '',
        state2: ''
      };
    },
    methods: {
      querySearch(queryString, cb) {
        var restaurants = this.restaurants;
        var results = queryString ? restaurants.filter(this.createFilter(queryString)) : restaurants;
        // 调用 callback 返回建议列表的数据
        cb(results);
      },
      createFilter(queryString) {
        return (restaurant) =&gt; {
          return (restaurant.value.toLowerCase().indexOf(queryString.toLowerCase()) === 0);
        };
      },
      loadAll() {
        return [
          { &quot;value&quot;: &quot;三全鲜食（北新泾店）&quot;, &quot;address&quot;: &quot;长宁区新渔路144号&quot; },
          { &quot;value&quot;: &quot;Hot honey 首尔炸鸡（仙霞路）&quot;, &quot;address&quot;: &quot;上海市长宁区淞虹路661号&quot; },
          { &quot;value&quot;: &quot;新旺角茶餐厅&quot;, &quot;address&quot;: &quot;上海市普陀区真北路988号创邑金沙谷6号楼113&quot; },
          { &quot;value&quot;: &quot;泷千家(天山西路店)&quot;, &quot;address&quot;: &quot;天山西路438号&quot; },
          { &quot;value&quot;: &quot;胖仙女纸杯蛋糕（上海凌空店）&quot;, &quot;address&quot;: &quot;上海市长宁区金钟路968号1幢18号楼一层商铺18-101&quot; },
          { &quot;value&quot;: &quot;贡茶&quot;, &quot;address&quot;: &quot;上海市长宁区金钟路633号&quot; },
          { &quot;value&quot;: &quot;豪大大香鸡排超级奶爸&quot;, &quot;address&quot;: &quot;上海市嘉定区曹安公路曹安路1685号&quot; },
          { &quot;value&quot;: &quot;茶芝兰（奶茶，手抓饼）&quot;, &quot;address&quot;: &quot;上海市普陀区同普路1435号&quot; },
          { &quot;value&quot;: &quot;十二泷町&quot;, &quot;address&quot;: &quot;上海市北翟路1444弄81号B幢-107&quot; },
          { &quot;value&quot;: &quot;星移浓缩咖啡&quot;, &quot;address&quot;: &quot;上海市嘉定区新郁路817号&quot; },
          { &quot;value&quot;: &quot;阿姨奶茶/豪大大&quot;, &quot;address&quot;: &quot;嘉定区曹安路1611号&quot; },
          { &quot;value&quot;: &quot;新麦甜四季甜品炸鸡&quot;, &quot;address&quot;: &quot;嘉定区曹安公路2383弄55号&quot; },
          { &quot;value&quot;: &quot;Monica摩托主题咖啡店&quot;, &quot;address&quot;: &quot;嘉定区江桥镇曹安公路2409号1F，2383弄62号1F&quot; },
          { &quot;value&quot;: &quot;浮生若茶（凌空soho店）&quot;, &quot;address&quot;: &quot;上海长宁区金钟路968号9号楼地下一层&quot; },
          { &quot;value&quot;: &quot;NONO JUICE  鲜榨果汁&quot;, &quot;address&quot;: &quot;上海市长宁区天山西路119号&quot; },
          { &quot;value&quot;: &quot;CoCo都可(北新泾店）&quot;, &quot;address&quot;: &quot;上海市长宁区仙霞西路&quot; },
          { &quot;value&quot;: &quot;快乐柠檬（神州智慧店）&quot;, &quot;address&quot;: &quot;上海市长宁区天山西路567号1层R117号店铺&quot; },
          { &quot;value&quot;: &quot;Merci Paul cafe&quot;, &quot;address&quot;: &quot;上海市普陀区光复西路丹巴路28弄6号楼819&quot; },
          { &quot;value&quot;: &quot;猫山王（西郊百联店）&quot;, &quot;address&quot;: &quot;上海市长宁区仙霞西路88号第一层G05-F01-1-306&quot; },
          { &quot;value&quot;: &quot;枪会山&quot;, &quot;address&quot;: &quot;上海市普陀区棕榈路&quot; },
          { &quot;value&quot;: &quot;纵食&quot;, &quot;address&quot;: &quot;元丰天山花园(东门) 双流路267号&quot; },
          { &quot;value&quot;: &quot;钱记&quot;, &quot;address&quot;: &quot;上海市长宁区天山西路&quot; },
          { &quot;value&quot;: &quot;壹杯加&quot;, &quot;address&quot;: &quot;上海市长宁区通协路&quot; },
          { &quot;value&quot;: &quot;唦哇嘀咖&quot;, &quot;address&quot;: &quot;上海市长宁区新泾镇金钟路999号2幢（B幢）第01层第1-02A单元&quot; },
          { &quot;value&quot;: &quot;爱茜茜里(西郊百联)&quot;, &quot;address&quot;: &quot;长宁区仙霞西路88号1305室&quot; },
          { &quot;value&quot;: &quot;爱茜茜里(近铁广场)&quot;, &quot;address&quot;: &quot;上海市普陀区真北路818号近铁城市广场北区地下二楼N-B2-O2-C商铺&quot; },
          { &quot;value&quot;: &quot;鲜果榨汁（金沙江路和美广店）&quot;, &quot;address&quot;: &quot;普陀区金沙江路2239号金沙和美广场B1-10-6&quot; },
          { &quot;value&quot;: &quot;开心丽果（缤谷店）&quot;, &quot;address&quot;: &quot;上海市长宁区威宁路天山路341号&quot; },
          { &quot;value&quot;: &quot;超级鸡车（丰庄路店）&quot;, &quot;address&quot;: &quot;上海市嘉定区丰庄路240号&quot; },
          { &quot;value&quot;: &quot;妙生活果园（北新泾店）&quot;, &quot;address&quot;: &quot;长宁区新渔路144号&quot; },
          { &quot;value&quot;: &quot;香宜度麻辣香锅&quot;, &quot;address&quot;: &quot;长宁区淞虹路148号&quot; },
          { &quot;value&quot;: &quot;凡仔汉堡（老真北路店）&quot;, &quot;address&quot;: &quot;上海市普陀区老真北路160号&quot; },
          { &quot;value&quot;: &quot;港式小铺&quot;, &quot;address&quot;: &quot;上海市长宁区金钟路968号15楼15-105室&quot; },
          { &quot;value&quot;: &quot;蜀香源麻辣香锅（剑河路店）&quot;, &quot;address&quot;: &quot;剑河路443-1&quot; },
          { &quot;value&quot;: &quot;北京饺子馆&quot;, &quot;address&quot;: &quot;长宁区北新泾街道天山西路490-1号&quot; },
          { &quot;value&quot;: &quot;饭典*新简餐（凌空SOHO店）&quot;, &quot;address&quot;: &quot;上海市长宁区金钟路968号9号楼地下一层9-83室&quot; },
          { &quot;value&quot;: &quot;焦耳·川式快餐（金钟路店）&quot;, &quot;address&quot;: &quot;上海市金钟路633号地下一层甲部&quot; },
          { &quot;value&quot;: &quot;动力鸡车&quot;, &quot;address&quot;: &quot;长宁区仙霞西路299弄3号101B&quot; },
          { &quot;value&quot;: &quot;浏阳蒸菜&quot;, &quot;address&quot;: &quot;天山西路430号&quot; },
          { &quot;value&quot;: &quot;四海游龙（天山西路店）&quot;, &quot;address&quot;: &quot;上海市长宁区天山西路&quot; },
          { &quot;value&quot;: &quot;樱花食堂（凌空店）&quot;, &quot;address&quot;: &quot;上海市长宁区金钟路968号15楼15-105室&quot; },
          { &quot;value&quot;: &quot;壹分米客家传统调制米粉(天山店)&quot;, &quot;address&quot;: &quot;天山西路428号&quot; },
          { &quot;value&quot;: &quot;福荣祥烧腊（平溪路店）&quot;, &quot;address&quot;: &quot;上海市长宁区协和路福泉路255弄57-73号&quot; },
          { &quot;value&quot;: &quot;速记黄焖鸡米饭&quot;, &quot;address&quot;: &quot;上海市长宁区北新泾街道金钟路180号1层01号摊位&quot; },
          { &quot;value&quot;: &quot;红辣椒麻辣烫&quot;, &quot;address&quot;: &quot;上海市长宁区天山西路492号&quot; },
          { &quot;value&quot;: &quot;(小杨生煎)西郊百联餐厅&quot;, &quot;address&quot;: &quot;长宁区仙霞西路88号百联2楼&quot; },
          { &quot;value&quot;: &quot;阳阳麻辣烫&quot;, &quot;address&quot;: &quot;天山西路389号&quot; },
          { &quot;value&quot;: &quot;南拳妈妈龙虾盖浇饭&quot;, &quot;address&quot;: &quot;普陀区金沙江路1699号鑫乐惠美食广场A13&quot; }
        ];
      },
      handleSelect(item) {
        console.log(item);
      }
    },
    mounted() {
      this.restaurants = this.loadAll();
    }
  }
&lt;/script&gt;
</code></pre>
<h2 id="自定义模板"><a class="header" href="#自定义模板">自定义模板</a></h2>
<p>使用scoped slot自定义输入建议的模板。该 scope 的参数为item，表示当前输入建议对象。</p>
<pre><code class="language-vue">
&lt;el-autocomplete
  popper-class=&quot;my-autocomplete&quot;
  v-model=&quot;state&quot;
  :fetch-suggestions=&quot;querySearch&quot;
  placeholder=&quot;请输入内容&quot;
  @select=&quot;handleSelect&quot;&gt;
  &lt;i
    class=&quot;el-icon-edit el-input__icon&quot;
    slot=&quot;suffix&quot;
    @click=&quot;handleIconClick&quot;&gt;
  &lt;/i&gt;
  &lt;template slot-scope=&quot;{ item }&quot;&gt;
    &lt;div class=&quot;name&quot;&gt;{{ item.value }}&lt;/div&gt;
    &lt;span class=&quot;addr&quot;&gt;{{ item.address }}&lt;/span&gt;
  &lt;/template&gt;
&lt;/el-autocomplete&gt;

&lt;style&gt;
.my-autocomplete {
  li {
    line-height: normal;
    padding: 7px;

    .name {
      text-overflow: ellipsis;
      overflow: hidden;
    }
    .addr {
      font-size: 12px;
      color: #b4b4b4;
    }

    .highlighted .addr {
      color: #ddd;
    }
  }
}
&lt;/style&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        restaurants: [],
        state: ''
      };
    },
    methods: {
      querySearch(queryString, cb) {
        var restaurants = this.restaurants;
        var results = queryString ? restaurants.filter(this.createFilter(queryString)) : restaurants;
        // 调用 callback 返回建议列表的数据
        cb(results);
      },
      createFilter(queryString) {
        return (restaurant) =&gt; {
          return (restaurant.value.toLowerCase().indexOf(queryString.toLowerCase()) === 0);
        };
      },
      loadAll() {
        return [
          { &quot;value&quot;: &quot;三全鲜食（北新泾店）&quot;, &quot;address&quot;: &quot;长宁区新渔路144号&quot; },
          { &quot;value&quot;: &quot;Hot honey 首尔炸鸡（仙霞路）&quot;, &quot;address&quot;: &quot;上海市长宁区淞虹路661号&quot; },
          { &quot;value&quot;: &quot;新旺角茶餐厅&quot;, &quot;address&quot;: &quot;上海市普陀区真北路988号创邑金沙谷6号楼113&quot; },
          { &quot;value&quot;: &quot;泷千家(天山西路店)&quot;, &quot;address&quot;: &quot;天山西路438号&quot; },
          { &quot;value&quot;: &quot;胖仙女纸杯蛋糕（上海凌空店）&quot;, &quot;address&quot;: &quot;上海市长宁区金钟路968号1幢18号楼一层商铺18-101&quot; },
          { &quot;value&quot;: &quot;贡茶&quot;, &quot;address&quot;: &quot;上海市长宁区金钟路633号&quot; },
          { &quot;value&quot;: &quot;豪大大香鸡排超级奶爸&quot;, &quot;address&quot;: &quot;上海市嘉定区曹安公路曹安路1685号&quot; },
          { &quot;value&quot;: &quot;茶芝兰（奶茶，手抓饼）&quot;, &quot;address&quot;: &quot;上海市普陀区同普路1435号&quot; },
          { &quot;value&quot;: &quot;十二泷町&quot;, &quot;address&quot;: &quot;上海市北翟路1444弄81号B幢-107&quot; },
          { &quot;value&quot;: &quot;星移浓缩咖啡&quot;, &quot;address&quot;: &quot;上海市嘉定区新郁路817号&quot; },
          { &quot;value&quot;: &quot;阿姨奶茶/豪大大&quot;, &quot;address&quot;: &quot;嘉定区曹安路1611号&quot; },
          { &quot;value&quot;: &quot;新麦甜四季甜品炸鸡&quot;, &quot;address&quot;: &quot;嘉定区曹安公路2383弄55号&quot; },
          { &quot;value&quot;: &quot;Monica摩托主题咖啡店&quot;, &quot;address&quot;: &quot;嘉定区江桥镇曹安公路2409号1F，2383弄62号1F&quot; },
          { &quot;value&quot;: &quot;浮生若茶（凌空soho店）&quot;, &quot;address&quot;: &quot;上海长宁区金钟路968号9号楼地下一层&quot; },
          { &quot;value&quot;: &quot;NONO JUICE  鲜榨果汁&quot;, &quot;address&quot;: &quot;上海市长宁区天山西路119号&quot; },
          { &quot;value&quot;: &quot;CoCo都可(北新泾店）&quot;, &quot;address&quot;: &quot;上海市长宁区仙霞西路&quot; },
          { &quot;value&quot;: &quot;快乐柠檬（神州智慧店）&quot;, &quot;address&quot;: &quot;上海市长宁区天山西路567号1层R117号店铺&quot; },
          { &quot;value&quot;: &quot;Merci Paul cafe&quot;, &quot;address&quot;: &quot;上海市普陀区光复西路丹巴路28弄6号楼819&quot; },
          { &quot;value&quot;: &quot;猫山王（西郊百联店）&quot;, &quot;address&quot;: &quot;上海市长宁区仙霞西路88号第一层G05-F01-1-306&quot; },
          { &quot;value&quot;: &quot;枪会山&quot;, &quot;address&quot;: &quot;上海市普陀区棕榈路&quot; },
          { &quot;value&quot;: &quot;纵食&quot;, &quot;address&quot;: &quot;元丰天山花园(东门) 双流路267号&quot; },
          { &quot;value&quot;: &quot;钱记&quot;, &quot;address&quot;: &quot;上海市长宁区天山西路&quot; },
          { &quot;value&quot;: &quot;壹杯加&quot;, &quot;address&quot;: &quot;上海市长宁区通协路&quot; },
          { &quot;value&quot;: &quot;唦哇嘀咖&quot;, &quot;address&quot;: &quot;上海市长宁区新泾镇金钟路999号2幢（B幢）第01层第1-02A单元&quot; },
          { &quot;value&quot;: &quot;爱茜茜里(西郊百联)&quot;, &quot;address&quot;: &quot;长宁区仙霞西路88号1305室&quot; },
          { &quot;value&quot;: &quot;爱茜茜里(近铁广场)&quot;, &quot;address&quot;: &quot;上海市普陀区真北路818号近铁城市广场北区地下二楼N-B2-O2-C商铺&quot; },
          { &quot;value&quot;: &quot;鲜果榨汁（金沙江路和美广店）&quot;, &quot;address&quot;: &quot;普陀区金沙江路2239号金沙和美广场B1-10-6&quot; },
          { &quot;value&quot;: &quot;开心丽果（缤谷店）&quot;, &quot;address&quot;: &quot;上海市长宁区威宁路天山路341号&quot; },
          { &quot;value&quot;: &quot;超级鸡车（丰庄路店）&quot;, &quot;address&quot;: &quot;上海市嘉定区丰庄路240号&quot; },
          { &quot;value&quot;: &quot;妙生活果园（北新泾店）&quot;, &quot;address&quot;: &quot;长宁区新渔路144号&quot; },
          { &quot;value&quot;: &quot;香宜度麻辣香锅&quot;, &quot;address&quot;: &quot;长宁区淞虹路148号&quot; },
          { &quot;value&quot;: &quot;凡仔汉堡（老真北路店）&quot;, &quot;address&quot;: &quot;上海市普陀区老真北路160号&quot; },
          { &quot;value&quot;: &quot;港式小铺&quot;, &quot;address&quot;: &quot;上海市长宁区金钟路968号15楼15-105室&quot; },
          { &quot;value&quot;: &quot;蜀香源麻辣香锅（剑河路店）&quot;, &quot;address&quot;: &quot;剑河路443-1&quot; },
          { &quot;value&quot;: &quot;北京饺子馆&quot;, &quot;address&quot;: &quot;长宁区北新泾街道天山西路490-1号&quot; },
          { &quot;value&quot;: &quot;饭典*新简餐（凌空SOHO店）&quot;, &quot;address&quot;: &quot;上海市长宁区金钟路968号9号楼地下一层9-83室&quot; },
          { &quot;value&quot;: &quot;焦耳·川式快餐（金钟路店）&quot;, &quot;address&quot;: &quot;上海市金钟路633号地下一层甲部&quot; },
          { &quot;value&quot;: &quot;动力鸡车&quot;, &quot;address&quot;: &quot;长宁区仙霞西路299弄3号101B&quot; },
          { &quot;value&quot;: &quot;浏阳蒸菜&quot;, &quot;address&quot;: &quot;天山西路430号&quot; },
          { &quot;value&quot;: &quot;四海游龙（天山西路店）&quot;, &quot;address&quot;: &quot;上海市长宁区天山西路&quot; },
          { &quot;value&quot;: &quot;樱花食堂（凌空店）&quot;, &quot;address&quot;: &quot;上海市长宁区金钟路968号15楼15-105室&quot; },
          { &quot;value&quot;: &quot;壹分米客家传统调制米粉(天山店)&quot;, &quot;address&quot;: &quot;天山西路428号&quot; },
          { &quot;value&quot;: &quot;福荣祥烧腊（平溪路店）&quot;, &quot;address&quot;: &quot;上海市长宁区协和路福泉路255弄57-73号&quot; },
          { &quot;value&quot;: &quot;速记黄焖鸡米饭&quot;, &quot;address&quot;: &quot;上海市长宁区北新泾街道金钟路180号1层01号摊位&quot; },
          { &quot;value&quot;: &quot;红辣椒麻辣烫&quot;, &quot;address&quot;: &quot;上海市长宁区天山西路492号&quot; },
          { &quot;value&quot;: &quot;(小杨生煎)西郊百联餐厅&quot;, &quot;address&quot;: &quot;长宁区仙霞西路88号百联2楼&quot; },
          { &quot;value&quot;: &quot;阳阳麻辣烫&quot;, &quot;address&quot;: &quot;天山西路389号&quot; },
          { &quot;value&quot;: &quot;南拳妈妈龙虾盖浇饭&quot;, &quot;address&quot;: &quot;普陀区金沙江路1699号鑫乐惠美食广场A13&quot; }
        ];
      },
      handleSelect(item) {
        console.log(item);
      },
      handleIconClick(ev) {
        console.log(ev);
      }
    },
    mounted() {
      this.restaurants = this.loadAll();
    }
  }
&lt;/script&gt;
</code></pre>
<h2 id="输入长度限制"><a class="header" href="#输入长度限制">输入长度限制</a></h2>
<p><code>maxlength</code> 和 <code>minlength</code> 是原生属性，用来限制输入框的字符长度，其中字符长度是用 Javascript 的字符串长度统计的。对于类型为 <code>text</code> 或 <code>textarea</code> 的输入框，在使用 <code>maxlength</code> 属性限制最大输入长度的同时，可通过设置 <code>show-word-limit</code> 属性来展示字数统计。</p>
<pre><code class="language-vue">&lt;el-input
  type=&quot;text&quot;
  placeholder=&quot;请输入内容&quot;
  v-model=&quot;text&quot;
  maxlength=&quot;10&quot;
  show-word-limit
&gt;
&lt;/el-input&gt;
&lt;div style=&quot;margin: 20px 0;&quot;&gt;&lt;/div&gt;
&lt;el-input
  type=&quot;textarea&quot;
  placeholder=&quot;请输入内容&quot;
  v-model=&quot;textarea&quot;
  maxlength=&quot;30&quot;
  show-word-limit
&gt;
&lt;/el-input&gt;

&lt;script&gt;
export default {
  data() {
    return {
      text: '',
      textarea: ''
    }
  }
}
&lt;/script&gt;
</code></pre>
<h2 id="属性与事件"><a class="header" href="#属性与事件">属性与事件</a></h2>
<h3 id="input-attributes"><a class="header" href="#input-attributes">Input Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">type</td><td style="text-align: left">类型</td><td style="text-align: left">string</td><td style="text-align: left">text，textarea 和其他 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form__types">原生 input 的 type 值</a></td><td style="text-align: left">text</td></tr>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">string / number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">maxlength</td><td style="text-align: left">原生属性，最大输入长度</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">minlength</td><td style="text-align: left">原生属性，最小输入长度</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">show-word-limit</td><td style="text-align: left">是否显示输入字数统计，只在 <code>type = &quot;text&quot;</code> 或 <code>type = &quot;textarea&quot;</code> 时有效</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">placeholder</td><td style="text-align: left">输入框占位文本</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">clearable</td><td style="text-align: left">是否可清空</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">show-password</td><td style="text-align: left">是否显示切换密码图标</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">输入框尺寸，只在 <code>type!=&quot;textarea&quot;</code> 时有效</td><td style="text-align: left">string</td><td style="text-align: left">medium / small / mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">prefix-icon</td><td style="text-align: left">输入框头部图标</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">suffix-icon</td><td style="text-align: left">输入框尾部图标</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">rows</td><td style="text-align: left">输入框行数，只对 <code>type=&quot;textarea&quot;</code> 有效</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">2</td></tr>
<tr><td style="text-align: left">autosize</td><td style="text-align: left">自适应内容高度，只对 <code>type=&quot;textarea&quot;</code> 有效，可传入对象，如，{ minRows: 2, maxRows: 6 }</td><td style="text-align: left">boolean / object</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">autocomplete</td><td style="text-align: left">原生属性，自动补全</td><td style="text-align: left">string</td><td style="text-align: left">on, off</td><td style="text-align: left">off</td></tr>
<tr><td style="text-align: left">auto-complete</td><td style="text-align: left">下个主版本弃用</td><td style="text-align: left">string</td><td style="text-align: left">on, off</td><td style="text-align: left">off</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">原生属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">readonly</td><td style="text-align: left">原生属性，是否只读</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">max</td><td style="text-align: left">原生属性，设置最大值</td><td style="text-align: left">—</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">min</td><td style="text-align: left">原生属性，设置最小值</td><td style="text-align: left">—</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">step</td><td style="text-align: left">原生属性，设置输入字段的合法数字间隔</td><td style="text-align: left">—</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">resize</td><td style="text-align: left">控制是否能被用户缩放</td><td style="text-align: left">string</td><td style="text-align: left">none, both, horizontal, vertical</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">autofocus</td><td style="text-align: left">原生属性，自动获取焦点</td><td style="text-align: left">boolean</td><td style="text-align: left">true, false</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">form</td><td style="text-align: left">原生属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">label</td><td style="text-align: left">输入框关联的label文字</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">tabindex</td><td style="text-align: left">输入框的tabindex</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">validate-event</td><td style="text-align: left">输入时是否触发表单的校验</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">true</td></tr>
</tbody></table>
<h3 id="input-slots"><a class="header" href="#input-slots">Input Slots</a></h3>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">prefix</td><td style="text-align: left">输入框头部内容，只对 <code>type=&quot;text&quot;</code> 有效</td></tr>
<tr><td style="text-align: left">suffix</td><td style="text-align: left">输入框尾部内容，只对 <code>type=&quot;text&quot;</code> 有效</td></tr>
<tr><td style="text-align: left">prepend</td><td style="text-align: left">输入框前置内容，只对 <code>type=&quot;text&quot;</code> 有效</td></tr>
<tr><td style="text-align: left">append</td><td style="text-align: left">输入框后置内容，只对 <code>type=&quot;text&quot;</code> 有效</td></tr>
</tbody></table>
<h3 id="input-events"><a class="header" href="#input-events">Input Events</a></h3>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">blur</td><td style="text-align: left">在 Input 失去焦点时触发</td><td style="text-align: left">(event: Event)</td></tr>
<tr><td style="text-align: left">focus</td><td style="text-align: left">在 Input 获得焦点时触发</td><td style="text-align: left">(event: Event)</td></tr>
<tr><td style="text-align: left">change</td><td style="text-align: left">仅在输入框失去焦点或用户按下回车时触发</td><td style="text-align: left">(value: string | number)</td></tr>
<tr><td style="text-align: left">input</td><td style="text-align: left">在 Input 值改变时触发</td><td style="text-align: left">(value: string | number)</td></tr>
<tr><td style="text-align: left">clear</td><td style="text-align: left">在点击由 <code>clearable</code> 属性生成的清空按钮时触发</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h3 id="input-methods"><a class="header" href="#input-methods">Input Methods</a></h3>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">focus</td><td style="text-align: left">使 input 获取焦点</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">blur</td><td style="text-align: left">使 input 失去焦点</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">select</td><td style="text-align: left">选中 input 中的文字</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h3 id="autocomplete-attributes"><a class="header" href="#autocomplete-attributes">Autocomplete Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">placeholder</td><td style="text-align: left">输入框占位文本</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">value-key</td><td style="text-align: left">输入建议对象中用于显示的键名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">value</td></tr>
<tr><td style="text-align: left">value</td><td style="text-align: left">必填值，输入绑定值</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">debounce</td><td style="text-align: left">获取输入建议的去抖延时</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">300</td></tr>
<tr><td style="text-align: left">placement</td><td style="text-align: left">菜单弹出位置</td><td style="text-align: left">string</td><td style="text-align: left">top / top-start / top-end / bottom / bottom-start / bottom-end</td><td style="text-align: left">bottom-start</td></tr>
<tr><td style="text-align: left">fetch-suggestions</td><td style="text-align: left">返回输入建议的方法，仅当你的输入建议数据 resolve 时，通过调用 callback(data:[]) 来返回它</td><td style="text-align: left">Function(queryString, callback)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">popper-class</td><td style="text-align: left">Autocomplete 下拉列表的类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">trigger-on-focus</td><td style="text-align: left">是否在输入框 focus 时显示建议列表</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">原生属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">select-when-unmatched</td><td style="text-align: left">在输入没有任何匹配建议的情况下，按下回车是否触发 <code>select</code> 事件</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">label</td><td style="text-align: left">输入框关联的label文字</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">prefix-icon</td><td style="text-align: left">输入框头部图标</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">suffix-icon</td><td style="text-align: left">输入框尾部图标</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">hide-loading</td><td style="text-align: left">是否隐藏远程加载时的加载图标</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">popper-append-to-body</td><td style="text-align: left">是否将下拉列表插入至 body 元素。在下拉列表的定位出现问题时，可将该属性设置为 false</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">highlight-first-item</td><td style="text-align: left">是否默认突出显示远程搜索建议中的第一项</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
</tbody></table>
<h3 id="autocomplete-slots"><a class="header" href="#autocomplete-slots">Autocomplete Slots</a></h3>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">prefix</td><td style="text-align: left">输入框头部内容</td></tr>
<tr><td style="text-align: left">suffix</td><td style="text-align: left">输入框尾部内容</td></tr>
<tr><td style="text-align: left">prepend</td><td style="text-align: left">输入框前置内容</td></tr>
<tr><td style="text-align: left">append</td><td style="text-align: left">输入框后置内容</td></tr>
</tbody></table>
<h3 id="autocomplete-scoped-slot"><a class="header" href="#autocomplete-scoped-slot">Autocomplete Scoped Slot</a></h3>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">—</td><td style="text-align: left">自定义输入建议，参数为 { item }</td></tr>
</tbody></table>
<h3 id="autocomplete-methods"><a class="header" href="#autocomplete-methods">Autocomplete Methods</a></h3>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">focus</td><td style="text-align: left">使 input 获取焦点</td><td style="text-align: left">-</td></tr>
</tbody></table>
<h2 id="inputnumber-计数器"><a class="header" href="#inputnumber-计数器">InputNumber 计数器</a></h2>
<p>要使用它，只需要在<code>el-input-number</code>元素中使用<code>v-model</code>绑定变量即可，变量的初始值即为默认值。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-input-number v-model=&quot;num&quot; @change=&quot;handleChange&quot; :min=&quot;1&quot; :max=&quot;10&quot; label=&quot;描述文字&quot;&gt;&lt;/el-input-number&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        num: 1
      };
    },
    methods: {
      handleChange(value) {
        console.log(value);
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h2 id="禁用状态-4"><a class="header" href="#禁用状态-4">禁用状态</a></h2>
<p><code>disabled</code>属性接受一个<code>Boolean</code>，设置为<code>true</code>即可禁用整个组件，如果你只需要控制数值在某一范围内，可以设置<code>min</code>属性和<code>max</code>属性，不设置<code>min</code>和<code>max</code>时，最小值为 0。</p>
<pre><code class="language-vue"> &lt;el-input-number v-model=&quot;num&quot; :disabled=&quot;true&quot;&gt;&lt;/el-input-number&gt;
</code></pre>
<h2 id="步数"><a class="header" href="#步数">步数</a></h2>
<p>允许定义递增递减的步数控制,设置<code>step</code>属性可以控制步长，接受一个<code>Number</code>。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-input-number v-model=&quot;num&quot; :step=&quot;2&quot;&gt;&lt;/el-input-number&gt;
&lt;/template&gt;
</code></pre>
<h2 id="严格步数"><a class="header" href="#严格步数">严格步数</a></h2>
<p><code>step-strictly</code>属性接受一个<code>Boolean</code>。如果这个属性被设置为<code>true</code>，则只能输入步数的倍数。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-input-number v-model=&quot;num&quot; :step=&quot;2&quot; step-strictly&gt;&lt;/el-input-number&gt;
&lt;/template&gt;
</code></pre>
<h2 id="精度"><a class="header" href="#精度">精度</a></h2>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-input-number v-model=&quot;num&quot; :precision=&quot;2&quot; :step=&quot;0.1&quot; :max=&quot;10&quot;&gt;&lt;/el-input-number&gt;
&lt;/template&gt;
</code></pre>
<h2 id="尺寸-1"><a class="header" href="#尺寸-1">尺寸</a></h2>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-input-number v-model=&quot;num1&quot;&gt;&lt;/el-input-number&gt;
  &lt;el-input-number size=&quot;medium&quot; v-model=&quot;num2&quot;&gt;&lt;/el-input-number&gt;
  &lt;el-input-number size=&quot;small&quot; v-model=&quot;num3&quot;&gt;&lt;/el-input-number&gt;
  &lt;el-input-number size=&quot;mini&quot; v-model=&quot;num4&quot;&gt;&lt;/el-input-number&gt;
&lt;/template&gt;
</code></pre>
<h2 id="按钮位置"><a class="header" href="#按钮位置">按钮位置</a></h2>
<p>设置 <code>controls-position</code> 属性可以控制按钮位置。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-input-number v-model=&quot;num&quot; controls-position=&quot;right&quot; @change=&quot;handleChange&quot; :min=&quot;1&quot; :max=&quot;10&quot;&gt;&lt;/el-input-number&gt;
&lt;/template&gt;
</code></pre>
<h2 id="属性和事件"><a class="header" href="#属性和事件">属性和事件</a></h2>
<h3 id="attributes-17"><a class="header" href="#attributes-17">Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">min</td><td style="text-align: left">设置计数器允许的最小值</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">-Infinity</td></tr>
<tr><td style="text-align: left">max</td><td style="text-align: left">设置计数器允许的最大值</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">Infinity</td></tr>
<tr><td style="text-align: left">step</td><td style="text-align: left">计数器步长</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left">step-strictly</td><td style="text-align: left">是否只能输入 step 的倍数</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">precision</td><td style="text-align: left">数值精度</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">计数器尺寸</td><td style="text-align: left">string</td><td style="text-align: left">large, small</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用计数器</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">controls</td><td style="text-align: left">是否使用控制按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">controls-position</td><td style="text-align: left">控制按钮位置</td><td style="text-align: left">string</td><td style="text-align: left">right</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">原生属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">label</td><td style="text-align: left">输入框关联的label文字</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">placeholder</td><td style="text-align: left">输入框默认 placeholder</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">-</td></tr>
</tbody></table>
<h3 id="events-13"><a class="header" href="#events-13">Events</a></h3>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">绑定值被改变时触发</td><td style="text-align: left">currentValue, oldValue</td></tr>
<tr><td style="text-align: left">blur</td><td style="text-align: left">在组件 Input 失去焦点时触发</td><td style="text-align: left">(event: Event)</td></tr>
<tr><td style="text-align: left">focus</td><td style="text-align: left">在组件 Input 获得焦点时触发</td><td style="text-align: left">(event: Event)</td></tr>
</tbody></table>
<h3 id="methods-3"><a class="header" href="#methods-3">Methods</a></h3>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">focus</td><td style="text-align: left">使 input 获取焦点</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">select</td><td style="text-align: left">选中 input 中的文字</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h1 id="select-选择器"><a class="header" href="#select-选择器">Select 选择器</a></h1>
<p>当选项过多时，使用下拉菜单展示并选择内容。</p>
<h2 id="基础用法-20"><a class="header" href="#基础用法-20">基础用法</a></h2>
<p><code>v-model</code>的值为当前被选中的<code>el-option</code>的 value 属性值</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-select v-model=&quot;value&quot; placeholder=&quot;请选择&quot;&gt;
    &lt;el-option
      v-for=&quot;item in options&quot;
      :key=&quot;item.value&quot;
      :label=&quot;item.label&quot;
      :value=&quot;item.value&quot;&gt;
    &lt;/el-option&gt;
  &lt;/el-select&gt;
&lt;/template&gt;
</code></pre>
<h2 id="有禁用选项"><a class="header" href="#有禁用选项">有禁用选项</a></h2>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-select v-model=&quot;value&quot; disabled placeholder=&quot;请选择&quot;&gt;
    &lt;el-option
      v-for=&quot;item in options&quot;
      :key=&quot;item.value&quot;
      :label=&quot;item.label&quot;
      :value=&quot;item.value&quot;&gt;
    &lt;/el-option&gt;
  &lt;/el-select&gt;
&lt;/template&gt;
</code></pre>
<h2 id="可清空单选"><a class="header" href="#可清空单选">可清空单选</a></h2>
<pre><code class="language-vue">  &lt;el-select v-model=&quot;value&quot; clearable placeholder=&quot;请选择&quot;&gt;
      ......
  &lt;/el-select&gt;
</code></pre>
<h2 id="基础多选"><a class="header" href="#基础多选">基础多选</a></h2>
<p>为<code>el-select</code>设置<code>multiple</code>属性即可启用多选，此时<code>v-model</code>的值为当前选中值所组成的数组。</p>
<pre><code class="language-vue">&lt;el-select v-model=&quot;value1&quot; multiple placeholder=&quot;请选择&quot;&gt;
.....    
&lt;/el-select&gt;
</code></pre>
<p>默认情况下选中值会以 Tag 的形式展现，你也可以设置<code>collapse-tags</code>属性将它们合并为一段文字。</p>
<pre><code class="language-vue"> &lt;el-select
    v-model=&quot;value2&quot;
    multiple
    collapse-tags
    style=&quot;margin-left: 20px;&quot;
    placeholder=&quot;请选择&quot;&gt;
  &lt;/el-select&gt;
</code></pre>
<h2 id="自定义模板-1"><a class="header" href="#自定义模板-1">自定义模板</a></h2>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-select v-model=&quot;value&quot; placeholder=&quot;请选择&quot;&gt;
    &lt;el-option
      v-for=&quot;item in cities&quot;
      :key=&quot;item.value&quot;
      :label=&quot;item.label&quot;
      :value=&quot;item.value&quot;&gt;
      &lt;span style=&quot;float: left&quot;&gt;{{ item.label }}&lt;/span&gt;
      &lt;span style=&quot;float: right; color: #8492a6; font-size: 13px&quot;&gt;{{ item.value }}&lt;/span&gt;
    &lt;/el-option&gt;
  &lt;/el-select&gt;
&lt;/template&gt;
</code></pre>
<h2 id="分组"><a class="header" href="#分组">分组</a></h2>
<p>使用<code>el-option-group</code>对备选项进行分组，它的<code>label</code>属性为分组名</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-select v-model=&quot;value&quot; placeholder=&quot;请选择&quot;&gt;
    &lt;el-option-group
      v-for=&quot;group in options&quot;
      :key=&quot;group.label&quot;
      :label=&quot;group.label&quot;&gt;
      &lt;el-option
        v-for=&quot;item in group.options&quot;
        :key=&quot;item.value&quot;
        :label=&quot;item.label&quot;
        :value=&quot;item.value&quot;&gt;
      &lt;/el-option&gt;
    &lt;/el-option-group&gt;
  &lt;/el-select&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        options: [{
          label: '热门城市',
          options: [{
            value: 'Shanghai',
            label: '上海'
          }, {
            value: 'Beijing',
            label: '北京'
          }]
        }, {
          label: '城市名',
          options: [{
            value: 'Chengdu',
            label: '成都'
          }, {
            value: 'Shenzhen',
            label: '深圳'
          }, {
            value: 'Guangzhou',
            label: '广州'
          }, {
            value: 'Dalian',
            label: '大连'
          }]
        }],
        value: ''
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h2 id="可搜索-1"><a class="header" href="#可搜索-1">可搜索</a></h2>
<p>为<code>el-select</code>添加<code>filterable</code>属性即可启用搜索功能。默认情况下，Select 会找出所有<code>label</code>属性包含输入值的选项。如果希望使用其他的搜索逻辑，可以通过传入一个<code>filter-method</code>来实现。<code>filter-method</code>为一个<code>Function</code>，它会在输入值发生变化时调用，参数为当前输入值。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-select v-model=&quot;value&quot; filterable placeholder=&quot;请选择&quot;&gt;
    &lt;el-option
      v-for=&quot;item in options&quot;
      :key=&quot;item.value&quot;
      :label=&quot;item.label&quot;
      :value=&quot;item.value&quot;&gt;
    &lt;/el-option&gt;
  &lt;/el-select&gt;
&lt;/template&gt;

</code></pre>
<h2 id="远程搜索"><a class="header" href="#远程搜索">远程搜索</a></h2>
<p>为了启用远程搜索，需要将<code>filterable</code>和<code>remote</code>设置为<code>true</code>，同时传入一个<code>remote-method</code>。<code>remote-method</code>为一个<code>Function</code>，它会在输入值发生变化时调用，参数为当前输入值。需要注意的是，如果<code>el-option</code>是通过<code>v-for</code>指令渲染出来的，此时需要为<code>el-option</code>添加<code>key</code>属性，且其值需具有唯一性，比如此例中的<code>item.value</code>。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-select
    v-model=&quot;value&quot;
    multiple
    filterable
    remote
    reserve-keyword
    placeholder=&quot;请输入关键词&quot;
    :remote-method=&quot;remoteMethod&quot;
    :loading=&quot;loading&quot;&gt;
    &lt;el-option
      v-for=&quot;item in options&quot;
      :key=&quot;item.value&quot;
      :label=&quot;item.label&quot;
      :value=&quot;item.value&quot;&gt;
    &lt;/el-option&gt;
  &lt;/el-select&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        options: [],
        value: [],
        list: [],
        loading: false,
        states: [&quot;Alabama&quot;, &quot;Alaska&quot;, &quot;Arizona&quot;,
        &quot;Arkansas&quot;, &quot;California&quot;, &quot;Colorado&quot;,
        &quot;Connecticut&quot;, &quot;Delaware&quot;, &quot;Florida&quot;,
        &quot;Georgia&quot;, &quot;Hawaii&quot;, &quot;Idaho&quot;, &quot;Illinois&quot;,
        &quot;Indiana&quot;, &quot;Iowa&quot;, &quot;Kansas&quot;, &quot;Kentucky&quot;,
        &quot;Louisiana&quot;, &quot;Maine&quot;, &quot;Maryland&quot;,
        &quot;Massachusetts&quot;, &quot;Michigan&quot;, &quot;Minnesota&quot;,
        &quot;Mississippi&quot;, &quot;Missouri&quot;, &quot;Montana&quot;,
        &quot;Nebraska&quot;, &quot;Nevada&quot;, &quot;New Hampshire&quot;,
        &quot;New Jersey&quot;, &quot;New Mexico&quot;, &quot;New York&quot;,
        &quot;North Carolina&quot;, &quot;North Dakota&quot;, &quot;Ohio&quot;,
        &quot;Oklahoma&quot;, &quot;Oregon&quot;, &quot;Pennsylvania&quot;,
        &quot;Rhode Island&quot;, &quot;South Carolina&quot;,
        &quot;South Dakota&quot;, &quot;Tennessee&quot;, &quot;Texas&quot;,
        &quot;Utah&quot;, &quot;Vermont&quot;, &quot;Virginia&quot;,
        &quot;Washington&quot;, &quot;West Virginia&quot;, &quot;Wisconsin&quot;,
        &quot;Wyoming&quot;]
      }
    },
    mounted() {
      this.list = this.states.map(item =&gt; {
        return { value: `value:${item}`, label: `label:${item}` };
      });
    },
    methods: {
      remoteMethod(query) {
        if (query !== '') {
          this.loading = true;
          setTimeout(() =&gt; {
            this.loading = false;
            this.options = this.list.filter(item =&gt; {
              return item.label.toLowerCase()
                .indexOf(query.toLowerCase()) &gt; -1;
            });
          }, 200);
        } else {
          this.options = [];
        }
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h2 id="创建条目"><a class="header" href="#创建条目">创建条目</a></h2>
<p>使用<code>allow-create</code>属性即可通过在输入框中输入文字来创建新的条目。注意此时<code>filterable</code>必须为真。本例还使用了<code>default-first-option</code>属性，在该属性打开的情况下，按下回车就可以选中当前选项列表中的第一个选项，无需使用鼠标或键盘方向键进行定位。</p>
<pre><code class="language-vuie">&lt;template&gt;
  &lt;el-select
    v-model=&quot;value&quot;
    multiple
    filterable
    allow-create
    default-first-option
    placeholder=&quot;请选择文章标签&quot;&gt;
    &lt;el-option
      v-for=&quot;item in options&quot;
      :key=&quot;item.value&quot;
      :label=&quot;item.label&quot;
      :value=&quot;item.value&quot;&gt;
    &lt;/el-option&gt;
  &lt;/el-select&gt;
&lt;/template&gt;
</code></pre>
<blockquote>
<p>如果 Select 的绑定值为对象类型，请务必指定 <code>value-key</code> 作为它的唯一性标识。</p>
</blockquote>
<h2 id="属性和方法"><a class="header" href="#属性和方法">属性和方法</a></h2>
<h3 id="select-attributes"><a class="header" href="#select-attributes">Select Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">boolean / string / number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">multiple</td><td style="text-align: left">是否多选</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">value-key</td><td style="text-align: left">作为 value 唯一标识的键名，绑定值为对象类型时必填</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">value</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">输入框尺寸</td><td style="text-align: left">string</td><td style="text-align: left">medium/small/mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">clearable</td><td style="text-align: left">是否可以清空选项</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">collapse-tags</td><td style="text-align: left">多选时是否将选中值按文字的形式展示</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">multiple-limit</td><td style="text-align: left">多选时用户最多可以选择的项目数，为 0 则不限制</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">select input 的 name 属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">autocomplete</td><td style="text-align: left">select input 的 autocomplete 属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">off</td></tr>
<tr><td style="text-align: left">auto-complete</td><td style="text-align: left">下个主版本弃用</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">off</td></tr>
<tr><td style="text-align: left">placeholder</td><td style="text-align: left">占位符</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">请选择</td></tr>
<tr><td style="text-align: left">filterable</td><td style="text-align: left">是否可搜索</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">allow-create</td><td style="text-align: left">是否允许用户创建新条目，需配合 <code>filterable</code> 使用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">filter-method</td><td style="text-align: left">自定义搜索方法</td><td style="text-align: left">function</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">remote</td><td style="text-align: left">是否为远程搜索</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">remote-method</td><td style="text-align: left">远程搜索方法</td><td style="text-align: left">function</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">loading</td><td style="text-align: left">是否正在从远程获取数据</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">loading-text</td><td style="text-align: left">远程加载时显示的文字</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">加载中</td></tr>
<tr><td style="text-align: left">no-match-text</td><td style="text-align: left">搜索条件无匹配时显示的文字，也可以使用<code>slot=&quot;empty&quot;</code>设置</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">无匹配数据</td></tr>
<tr><td style="text-align: left">no-data-text</td><td style="text-align: left">选项为空时显示的文字，也可以使用<code>slot=&quot;empty&quot;</code>设置</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">无数据</td></tr>
<tr><td style="text-align: left">popper-class</td><td style="text-align: left">Select 下拉框的类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">reserve-keyword</td><td style="text-align: left">多选且可搜索时，是否在选中一个选项后保留当前的搜索关键词</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">default-first-option</td><td style="text-align: left">在输入框按下回车，选择第一个匹配项。需配合 <code>filterable</code> 或 <code>remote</code> 使用</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">popper-append-to-body</td><td style="text-align: left">是否将弹出框插入至 body 元素。在弹出框的定位出现问题时，可将该属性设置为 false</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">automatic-dropdown</td><td style="text-align: left">对于不可搜索的 Select，是否在输入框获得焦点后自动弹出选项菜单</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">false</td></tr>
</tbody></table>
<h3 id="select-events"><a class="header" href="#select-events"><a href="https://element.eleme.cn/#/zh-CN/component/select#select-events">¶</a>Select Events</a></h3>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">选中值发生变化时触发</td><td style="text-align: left">目前的选中值</td></tr>
<tr><td style="text-align: left">visible-change</td><td style="text-align: left">下拉框出现/隐藏时触发</td><td style="text-align: left">出现则为 true，隐藏则为 false</td></tr>
<tr><td style="text-align: left">remove-tag</td><td style="text-align: left">多选模式下移除tag时触发</td><td style="text-align: left">移除的tag值</td></tr>
<tr><td style="text-align: left">clear</td><td style="text-align: left">可清空的单选模式下用户点击清空按钮时触发</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">blur</td><td style="text-align: left">当 input 失去焦点时触发</td><td style="text-align: left">(event: Event)</td></tr>
<tr><td style="text-align: left">focus</td><td style="text-align: left">当 input 获得焦点时触发</td><td style="text-align: left">(event: Event)</td></tr>
</tbody></table>
<h3 id="select-slots"><a class="header" href="#select-slots"><a href="https://element.eleme.cn/#/zh-CN/component/select#select-slots">¶</a>Select Slots</a></h3>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">—</td><td style="text-align: left">Option 组件列表</td></tr>
<tr><td style="text-align: left">prefix</td><td style="text-align: left">Select 组件头部内容</td></tr>
<tr><td style="text-align: left">empty</td><td style="text-align: left">无选项时的列表</td></tr>
</tbody></table>
<h3 id="option-group-attributes"><a class="header" href="#option-group-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/select#option-group-attributes">¶</a>Option Group Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">label</td><td style="text-align: left">分组的组名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否将该分组下所有选项置为禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
</tbody></table>
<h3 id="option-attributes"><a class="header" href="#option-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/select#option-attributes">¶</a>Option Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value</td><td style="text-align: left">选项的值</td><td style="text-align: left">string/number/object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">label</td><td style="text-align: left">选项的标签，若不设置则默认与 <code>value</code> 相同</td><td style="text-align: left">string/number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用该选项</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
</tbody></table>
<h3 id="methods-4"><a class="header" href="#methods-4"><a href="https://element.eleme.cn/#/zh-CN/component/select#methods">¶</a>Methods</a></h3>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">focus</td><td style="text-align: left">使 input 获取焦点</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">blur</td><td style="text-align: left">使 input 失去焦点，并隐藏下拉框</td><td style="text-align: left">-</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collapse-折叠面板"><a class="header" href="#collapse-折叠面板">Collapse 折叠面板</a></h1>
<p>通过折叠面板收纳内容区域</p>
<h1 id="基础用法-21"><a class="header" href="#基础用法-21">基础用法</a></h1>
<p>可同时展开多个面板，面板之间不影响</p>
<pre><code class="language-vue">&lt;el-collapse v-model=&quot;activeNames&quot; @change=&quot;handleChange&quot;&gt;
  &lt;el-collapse-item title=&quot;一致性 Consistency&quot; name=&quot;1&quot;&gt;
    &lt;div&gt;与现实生活一致：与现实生活的流程、逻辑保持一致，遵循用户习惯的语言和概念；&lt;/div&gt;
    &lt;div&gt;在界面中一致：所有的元素和结构需保持一致，比如：设计样式、图标和文本、元素的位置等。&lt;/div&gt;
  &lt;/el-collapse-item&gt;
  &lt;el-collapse-item title=&quot;反馈 Feedback&quot; name=&quot;2&quot;&gt;
    &lt;div&gt;控制反馈：通过界面样式和交互动效让用户可以清晰的感知自己的操作；&lt;/div&gt;
    &lt;div&gt;页面反馈：操作后，通过页面元素的变化清晰地展现当前状态。&lt;/div&gt;
  &lt;/el-collapse-item&gt;
  &lt;el-collapse-item title=&quot;效率 Efficiency&quot; name=&quot;3&quot;&gt;
    &lt;div&gt;简化流程：设计简洁直观的操作流程；&lt;/div&gt;
    &lt;div&gt;清晰明确：语言表达清晰且表意明确，让用户快速理解进而作出决策；&lt;/div&gt;
    &lt;div&gt;帮助用户识别：界面简单直白，让用户快速识别而非回忆，减少用户记忆负担。&lt;/div&gt;
  &lt;/el-collapse-item&gt;
  &lt;el-collapse-item title=&quot;可控 Controllability&quot; name=&quot;4&quot;&gt;
    &lt;div&gt;用户决策：根据场景可给予用户操作建议或安全提示，但不能代替用户进行决策；&lt;/div&gt;
    &lt;div&gt;结果可控：用户可以自由的进行操作，包括撤销、回退和终止当前操作等。&lt;/div&gt;
  &lt;/el-collapse-item&gt;
&lt;/el-collapse&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        activeNames: ['1']
      };
    },
    methods: {
      handleChange(val) {
        console.log(val);
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="手风琴效果"><a class="header" href="#手风琴效果">手风琴效果</a></h1>
<p>每次只能展开一个面板</p>
<p>通过 <code>accordion</code> 属性来设置是否以手风琴模式显示。</p>
<pre><code class="language-vue">&lt;el-collapse v-model=&quot;activeName&quot; accordion&gt;
  &lt;el-collapse-item title=&quot;一致性 Consistency&quot; name=&quot;1&quot;&gt;
    &lt;div&gt;与现实生活一致：与现实生活的流程、逻辑保持一致，遵循用户习惯的语言和概念；&lt;/div&gt;
    &lt;div&gt;在界面中一致：所有的元素和结构需保持一致，比如：设计样式、图标和文本、元素的位置等。&lt;/div&gt;
  &lt;/el-collapse-item&gt;
  &lt;el-collapse-item title=&quot;反馈 Feedback&quot; name=&quot;2&quot;&gt;
    &lt;div&gt;控制反馈：通过界面样式和交互动效让用户可以清晰的感知自己的操作；&lt;/div&gt;
    &lt;div&gt;页面反馈：操作后，通过页面元素的变化清晰地展现当前状态。&lt;/div&gt;
  &lt;/el-collapse-item&gt;
  &lt;el-collapse-item title=&quot;效率 Efficiency&quot; name=&quot;3&quot;&gt;
    &lt;div&gt;简化流程：设计简洁直观的操作流程；&lt;/div&gt;
    &lt;div&gt;清晰明确：语言表达清晰且表意明确，让用户快速理解进而作出决策；&lt;/div&gt;
    &lt;div&gt;帮助用户识别：界面简单直白，让用户快速识别而非回忆，减少用户记忆负担。&lt;/div&gt;
  &lt;/el-collapse-item&gt;
  &lt;el-collapse-item title=&quot;可控 Controllability&quot; name=&quot;4&quot;&gt;
    &lt;div&gt;用户决策：根据场景可给予用户操作建议或安全提示，但不能代替用户进行决策；&lt;/div&gt;
    &lt;div&gt;结果可控：用户可以自由的进行操作，包括撤销、回退和终止当前操作等。&lt;/div&gt;
  &lt;/el-collapse-item&gt;
&lt;/el-collapse&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        activeName: '1'
      };
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="自定义面板标题"><a class="header" href="#自定义面板标题">自定义面板标题</a></h1>
<p>除了可以通过 <code>title</code> 属性以外，还可以通过具名 <code>slot</code> 来实现自定义面板的标题内容，以实现增加图标等效果。</p>
<pre><code class="language-vue">&lt;el-collapse accordion&gt;
  &lt;el-collapse-item&gt;
    &lt;template slot=&quot;title&quot;&gt;
      一致性 Consistency&lt;i class=&quot;header-icon el-icon-info&quot;&gt;&lt;/i&gt;
    &lt;/template&gt;
    &lt;div&gt;与现实生活一致：与现实生活的流程、逻辑保持一致，遵循用户习惯的语言和概念；&lt;/div&gt;
    &lt;div&gt;在界面中一致：所有的元素和结构需保持一致，比如：设计样式、图标和文本、元素的位置等。&lt;/div&gt;
  &lt;/el-collapse-item&gt;
  &lt;el-collapse-item title=&quot;反馈 Feedback&quot;&gt;
    &lt;div&gt;控制反馈：通过界面样式和交互动效让用户可以清晰的感知自己的操作；&lt;/div&gt;
    &lt;div&gt;页面反馈：操作后，通过页面元素的变化清晰地展现当前状态。&lt;/div&gt;
  &lt;/el-collapse-item&gt;
  &lt;el-collapse-item title=&quot;效率 Efficiency&quot;&gt;
    &lt;div&gt;简化流程：设计简洁直观的操作流程；&lt;/div&gt;
    &lt;div&gt;清晰明确：语言表达清晰且表意明确，让用户快速理解进而作出决策；&lt;/div&gt;
    &lt;div&gt;帮助用户识别：界面简单直白，让用户快速识别而非回忆，减少用户记忆负担。&lt;/div&gt;
  &lt;/el-collapse-item&gt;
  &lt;el-collapse-item title=&quot;可控 Controllability&quot;&gt;
    &lt;div&gt;用户决策：根据场景可给予用户操作建议或安全提示，但不能代替用户进行决策；&lt;/div&gt;
    &lt;div&gt;结果可控：用户可以自由的进行操作，包括撤销、回退和终止当前操作等。&lt;/div&gt;
  &lt;/el-collapse-item&gt;
&lt;/el-collapse&gt;
</code></pre>
<h1 id="属性事件和方法-22"><a class="header" href="#属性事件和方法-22">属性事件和方法</a></h1>
<h2 id="collapse-attributes"><a class="header" href="#collapse-attributes">Collapse Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">当前激活的面板(如果是手风琴模式，绑定值类型需要为<code>string</code>，否则为<code>array</code>)</td><td style="text-align: left">string / array</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">accordion</td><td style="text-align: left">是否手风琴模式</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
</tbody></table>
<h2 id="collapse-events"><a class="header" href="#collapse-events"><a href="https://element.eleme.cn/#/zh-CN/component/collapse#collapse-events">¶</a>Collapse Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">当前激活面板改变时触发(如果是手风琴模式，参数 <code>activeNames</code> 类型为<code>string</code>，否则为<code>array</code>)</td><td style="text-align: left">(activeNames: array / string)</td></tr>
</tbody></table>
<h2 id="collapse-item-attributes"><a class="header" href="#collapse-item-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/collapse#collapse-item-attributes">¶</a>Collapse Item Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">name</td><td style="text-align: left">唯一标志符</td><td style="text-align: left">string/number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">title</td><td style="text-align: left">面板标题</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="drawer-抽屉"><a class="header" href="#drawer-抽屉">Drawer 抽屉</a></h1>
<p>有些时候, <code>Dialog</code> 组件并不满足我们的需求, 比如你的表单很长, 亦或是你需要临时展示一些文档, <code>Drawer</code> 拥有和 <code>Dialog</code> 几乎相同的 API, 在 UI 上带来不一样的体验.</p>
<h1 id="基本用法-5"><a class="header" href="#基本用法-5">基本用法</a></h1>
<p>呼出一个临时的侧边栏, 可以从多个方向呼出</p>
<p>需要设置 <code>visible</code> 属性，它的<strong>类型</strong>是 <code>boolean</code>,当为 <strong>true</strong> 时显示 Drawer。Drawer 分为两个部分：<code>title</code> 和 <code>body</code>，<code>title</code> 需要具名为 <strong>title</strong> 的 <code>slot</code>, 也可以通过 <code>title</code> 属性来定义，默认值为空。需要注意的是, Drawer 默认是从右往左打开, 当然可以设置对应的 <code>direction</code>, 详细请参考 <code>direction</code> 用法 最后，本例还展示了 <code>before-close</code> 的用法</p>
<pre><code class="language-vue">&lt;el-radio-group v-model=&quot;direction&quot;&gt;
  &lt;el-radio label=&quot;ltr&quot;&gt;从左往右开&lt;/el-radio&gt;
  &lt;el-radio label=&quot;rtl&quot;&gt;从右往左开&lt;/el-radio&gt;
  &lt;el-radio label=&quot;ttb&quot;&gt;从上往下开&lt;/el-radio&gt;
  &lt;el-radio label=&quot;btt&quot;&gt;从下往上开&lt;/el-radio&gt;
&lt;/el-radio-group&gt;

&lt;el-button @click=&quot;drawer = true&quot; type=&quot;primary&quot; style=&quot;margin-left: 16px;&quot;&gt;
  点我打开
&lt;/el-button&gt;

&lt;el-drawer
  title=&quot;我是标题&quot;
  :visible.sync=&quot;drawer&quot;
  :direction=&quot;direction&quot;
  :before-close=&quot;handleClose&quot;
&gt;
  &lt;span&gt;我来啦!&lt;/span&gt;
&lt;/el-drawer&gt;

&lt;script&gt;
export default {
  data() {
    return {
      drawer: false,
      direction: &quot;rtl&quot;,
    };
  },
  methods: {
    handleClose(done) {
      this.$confirm(&quot;确认关闭？&quot;)
        .then((_) =&gt; {
          done();
        })
        .catch((_) =&gt; {});
    },
  },
};
&lt;/script&gt;
</code></pre>
<h1 id="不添加-title"><a class="header" href="#不添加-title">不添加 Title</a></h1>
<p>当你不需要标题到时候, 你还可以去掉标题</p>
<p>当遇到不需要 title 的场景时, 可以通过 <code>withHeader</code> 这个属性来关闭掉 title 的显示, 这样可以留出更大的空间给到用户, 为了用户的可访问性, 请务必设定 <code>title</code> 的值</p>
<pre><code class="language-vue">&lt;el-button @click=&quot;drawer = true&quot; type=&quot;primary&quot; style=&quot;margin-left: 16px;&quot;&gt;
  点我打开
&lt;/el-button&gt;

&lt;el-drawer title=&quot;我是标题&quot; :visible.sync=&quot;drawer&quot; :with-header=&quot;false&quot;&gt;
  &lt;span&gt;我来啦!&lt;/span&gt;
&lt;/el-drawer&gt;

&lt;script&gt;
export default {
  data() {
    return {
      drawer: false,
    };
  },
};
&lt;/script&gt;
</code></pre>
<h1 id="自定义内容-1"><a class="header" href="#自定义内容-1">自定义内容</a></h1>
<p>和 <code>Dialog</code> 组件一样, <code>Drawer</code> 同样可以在其内部嵌套各种丰富的操作</p>
<pre><code class="language-vue">&lt;el-button type=&quot;text&quot; @click=&quot;table = true&quot;&gt;打开嵌套表格的 Drawer&lt;/el-button&gt;
&lt;el-button
  type=&quot;text&quot;
  @click=&quot;dialog = true&quot;
&gt;打开嵌套 Form 的 Drawer&lt;/el-button&gt;
&lt;el-drawer
  title=&quot;我嵌套了表格!&quot;
  :visible.sync=&quot;table&quot;
  direction=&quot;rtl&quot;
  size=&quot;50%&quot;
&gt;
   &lt;el-table :data=&quot;gridData&quot;&gt;
      &lt;el-table-column property=&quot;date&quot; label=&quot;日期&quot; width=&quot;150&quot;&gt;&lt;/el-table-column&gt;
      &lt;el-table-column property=&quot;name&quot; label=&quot;姓名&quot; width=&quot;200&quot;&gt;&lt;/el-table-column&gt;
      &lt;el-table-column property=&quot;address&quot; label=&quot;地址&quot;&gt;&lt;/el-table-column&gt;
    &lt;/el-table&gt;
&lt;/el-drawer&gt;

&lt;el-drawer
  title=&quot;我嵌套了 Form !&quot;
  :before-close=&quot;handleClose&quot;
  :visible.sync=&quot;dialog&quot;
  direction=&quot;ltr&quot;
  custom-class=&quot;demo-drawer&quot;
  ref=&quot;drawer&quot;
&gt;
  &lt;div class=&quot;demo-drawer__content&quot;&gt;
    &lt;el-form :model=&quot;form&quot;&gt;
      &lt;el-form-item label=&quot;活动名称&quot; :label-width=&quot;formLabelWidth&quot;&gt;
        &lt;el-input v-model=&quot;form.name&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;活动区域&quot; :label-width=&quot;formLabelWidth&quot;&gt;
        &lt;el-select v-model=&quot;form.region&quot; placeholder=&quot;请选择活动区域&quot;&gt;
          &lt;el-option label=&quot;区域一&quot; value=&quot;shanghai&quot;&gt;&lt;/el-option&gt;
          &lt;el-option label=&quot;区域二&quot; value=&quot;beijing&quot;&gt;&lt;/el-option&gt;
        &lt;/el-select&gt;
      &lt;/el-form-item&gt;
    &lt;/el-form&gt;
    &lt;div class=&quot;demo-drawer__footer&quot;&gt;
      &lt;el-button @click=&quot;cancelForm&quot;&gt;取 消&lt;/el-button&gt;
      &lt;el-button type=&quot;primary&quot; @click=&quot;$refs.drawer.closeDrawer()&quot; :loading=&quot;loading&quot;&gt;{{ loading ? '提交中 ...' : '确 定' }}&lt;/el-button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/el-drawer&gt;

&lt;script&gt;
export default {
  data() {
    return {
      table: false,
      dialog: false,
      loading: false,
      gridData: [
        {
          date: &quot;2016-05-02&quot;,
          name: &quot;王小虎&quot;,
          address: &quot;上海市普陀区金沙江路 1518 弄&quot;,
        },
        {
          date: &quot;2016-05-04&quot;,
          name: &quot;王小虎&quot;,
          address: &quot;上海市普陀区金沙江路 1518 弄&quot;,
        },
        {
          date: &quot;2016-05-01&quot;,
          name: &quot;王小虎&quot;,
          address: &quot;上海市普陀区金沙江路 1518 弄&quot;,
        },
        {
          date: &quot;2016-05-03&quot;,
          name: &quot;王小虎&quot;,
          address: &quot;上海市普陀区金沙江路 1518 弄&quot;,
        },
      ],
      form: {
        name: &quot;&quot;,
        region: &quot;&quot;,
        date1: &quot;&quot;,
        date2: &quot;&quot;,
        delivery: false,
        type: [],
        resource: &quot;&quot;,
        desc: &quot;&quot;,
      },
      formLabelWidth: &quot;80px&quot;,
      timer: null,
    };
  },
  methods: {
    handleClose(done) {
      if (this.loading) {
        return;
      }
      this.$confirm(&quot;确定要提交表单吗？&quot;)
        .then((_) =&gt; {
          this.loading = true;
          this.timer = setTimeout(() =&gt; {
            done();
            // 动画关闭需要一定的时间
            setTimeout(() =&gt; {
              this.loading = false;
            }, 400);
          }, 2000);
        })
        .catch((_) =&gt; {});
    },
    cancelForm() {
      this.loading = false;
      this.dialog = false;
      clearTimeout(this.timer);
    },
  },
};
&lt;/script&gt;
</code></pre>
<h1 id="多层嵌套"><a class="header" href="#多层嵌套">多层嵌套</a></h1>
<p><code>Drawer</code> 组件也拥有多层嵌套的方法</p>
<p>同样, 如果你需要嵌套多层 <code>Drawer</code> 请一定要设置 <code>append-to-body</code> 属性为 <strong>true</strong></p>
<pre><code>&lt;el-button @click=&quot;drawer = true&quot; type=&quot;primary&quot; style=&quot;margin-left: 16px;&quot;&gt;
  点我打开
&lt;/el-button&gt;

&lt;el-drawer
  title=&quot;我是外面的 Drawer&quot;
  :visible.sync=&quot;drawer&quot;
  size=&quot;50%&quot;&gt;
  &lt;div&gt;
   &lt;el-button @click=&quot;innerDrawer = true&quot;&gt;打开里面的!&lt;/el-button&gt;
   &lt;el-drawer
     title=&quot;我是里面的&quot;
     :append-to-body=&quot;true&quot;
     :before-close=&quot;handleClose&quot;
     :visible.sync=&quot;innerDrawer&quot;&gt;
     &lt;p&gt;_(:зゝ∠)_&lt;/p&gt;
   &lt;/el-drawer&gt;
  &lt;/div&gt;
&lt;/el-drawer&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        drawer: false,
        innerDrawer: false,
      };
    },
    methods: {
      handleClose(done) {
        this.$confirm('还有未保存的工作哦确定关闭吗？')
          .then(_ =&gt; {
            done();
          })
          .catch(_ =&gt; {});
      }
    }
  };
&lt;/script&gt;
</code></pre>
<blockquote>
<p>Drawer 的内容是懒渲染的，即在第一次被打开之前，传入的默认 slot 不会被渲染到 DOM 上。因此，如果需要执行 DOM 操作，或通过 <code>ref</code> 获取相应组件，请在 <code>open</code> 事件回调中进行。</p>
</blockquote>
<blockquote>
<p>Drawer 提供一个 <code>destroyOnClose</code> API, 用来在关闭 Drawer 时销毁子组件内容, 例如清理表单内的状态, 在必要时可以将该属性设置为 <strong>true</strong> 用来保证初始状态的一致性</p>
</blockquote>
<blockquote>
<p>如果 <code>visible</code> 属性绑定的变量位于 Vuex 的 store 内，那么 <code>.sync</code> 不会正常工作。此时需要去除 <code>.sync</code> 修饰符，同时监听 Drawer 的 <code>open</code> 和 <code>close</code> 事件，在事件回调中执行 Vuex 中对应的 mutation 更新 <code>visible</code> 属性绑定的变量的值。</p>
</blockquote>
<h1 id="属性事件和方法-23"><a class="header" href="#属性事件和方法-23">属性事件和方法</a></h1>
<h2 id="drawer-attributes"><a class="header" href="#drawer-attributes">Drawer Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">append-to-body</td><td style="text-align: left">Drawer 自身是否插入至 body 元素上。嵌套的 Drawer 必须指定该属性并赋值为 true</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">before-close</td><td style="text-align: left">关闭前的回调，会暂停 Drawer 的关闭</td><td style="text-align: left">function(done)，done 用于关闭 Drawer</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">close-on-press-escape</td><td style="text-align: left">是否可以通过按下 ESC 关闭 Drawer</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">custom-class</td><td style="text-align: left">Drawer 的自定义类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">destroy-on-close</td><td style="text-align: left">控制是否在关闭 Drawer 之后将子元素全部销毁</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">modal</td><td style="text-align: left">是否需要遮罩层</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">modal-append-to-body</td><td style="text-align: left">遮罩层是否插入至 body 元素上，若为 false，则遮罩层会插入至 Drawer 的父元素上</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">direction</td><td style="text-align: left">Drawer 打开的方向</td><td style="text-align: left">Direction</td><td style="text-align: left">rtl / ltr / ttb / btt</td><td style="text-align: left">rtl</td></tr>
<tr><td style="text-align: left">show-close</td><td style="text-align: left">是否显示关闭按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">Drawer 窗体的大小, 当使用 <code>number</code> 类型时, 以像素为单位, 当使用 <code>string</code> 类型时, 请传入 'x%', 否则便会以 <code>number</code> 类型解释</td><td style="text-align: left">number / string</td><td style="text-align: left">-</td><td style="text-align: left">'30%'</td></tr>
<tr><td style="text-align: left">title</td><td style="text-align: left">Drawer 的标题，也可通过具名 slot （见下表）传入</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">visible</td><td style="text-align: left">是否显示 Drawer，支持 .sync 修饰符</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">wrapperClosable</td><td style="text-align: left">点击遮罩层是否可以关闭 Drawer</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">withHeader</td><td style="text-align: left">控制是否显示 header 栏, 默认为 true, 当此项为 false 时, title attribute 和 title slot 均不生效</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">true</td></tr>
</tbody></table>
<h2 id="drawer-slot"><a class="header" href="#drawer-slot"><a href="https://element.eleme.cn/#/zh-CN/component/drawer#drawer-slot">¶</a>Drawer Slot</a></h2>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">—</td><td style="text-align: left">Drawer 的内容</td></tr>
<tr><td style="text-align: left">title</td><td style="text-align: left">Drawer 标题区的内容</td></tr>
</tbody></table>
<h2 id="drawer-methods"><a class="header" href="#drawer-methods"><a href="https://element.eleme.cn/#/zh-CN/component/drawer#drawer-methods">¶</a>Drawer Methods</a></h2>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">closeDrawer</td><td style="text-align: left">用于关闭 Drawer, 该方法会调用传入的 <code>before-close</code> 方法</td></tr>
</tbody></table>
<h2 id="drawer-events"><a class="header" href="#drawer-events"><a href="https://element.eleme.cn/#/zh-CN/component/drawer#drawer-events">¶</a>Drawer Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">open</td><td style="text-align: left">Drawer 打开的回调</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">opened</td><td style="text-align: left">Drawer 打开动画结束时的回调</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">close</td><td style="text-align: left">Drawer 关闭的回调</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">closed</td><td style="text-align: left">Drawer 关闭动画结束时的回调</td><td style="text-align: left">—</td></tr>
</tbody></table>
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="infinitescroll-无限滚动"><a class="header" href="#infinitescroll-无限滚动">InfiniteScroll 无限滚动</a></h1>
<p>滚动至底部时，加载更多数据。</p>
<h1 id="基础用法-22"><a class="header" href="#基础用法-22">基础用法</a></h1>
<p>在要实现滚动加载的列表上上添加<code>v-infinite-scroll</code>，并赋值相应的加载方法，可实现滚动到底部时自动执行加载方法。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;ul class=&quot;infinite-list&quot; v-infinite-scroll=&quot;load&quot; style=&quot;overflow:auto&quot;&gt;
    &lt;li v-for=&quot;i in count&quot; class=&quot;infinite-list-item&quot;&gt;{{ i }}&lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        count: 0
      }
    },
    methods: {
      load () {
        this.count += 2
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="禁用加载"><a class="header" href="#禁用加载">禁用加载</a></h1>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;infinite-list-wrapper&quot; style=&quot;overflow:auto&quot;&gt;
    &lt;ul
      class=&quot;list&quot;
      v-infinite-scroll=&quot;load&quot;
      infinite-scroll-disabled=&quot;disabled&quot;&gt;
      &lt;li v-for=&quot;i in count&quot; class=&quot;list-item&quot;&gt;{{ i }}&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p v-if=&quot;loading&quot;&gt;加载中...&lt;/p&gt;
    &lt;p v-if=&quot;noMore&quot;&gt;没有更多了&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        count: 10,
        loading: false
      }
    },
    computed: {
      noMore () {
        return this.count &gt;= 20
      },
      disabled () {
        return this.loading || this.noMore
      }
    },
    methods: {
      load () {
        this.loading = true
        setTimeout(() =&gt; {
          this.count += 2
          this.loading = false
        }, 2000)
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="attributes-18"><a class="header" href="#attributes-18">Attributes</a></h1>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">infinite-scroll-disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">infinite-scroll-delay</td><td style="text-align: left">节流时延，单位为ms</td><td style="text-align: left">number</td><td style="text-align: left">-</td><td style="text-align: left">200</td></tr>
<tr><td style="text-align: left">infinite-scroll-distance</td><td style="text-align: left">触发加载的距离阈值，单位为px</td><td style="text-align: left">number</td><td style="text-align: left">-</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">infinite-scroll-immediate</td><td style="text-align: left">是否立即执行加载方法，以防初始状态下内容无法撑满容器。</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">true</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="基本"><a class="header" href="#基本">基本</a></h1>
<p>设置 <code>value</code> 来指定当前显示的月份。如果 <code>value</code> 未指定，则显示当月。<code>value</code> 支持 <code>v-model</code> 双向绑定。</p>
<pre><code class="language-vue">&lt;el-calendar v-model=&quot;value&quot;&gt;
&lt;/el-calendar&gt;

&lt;script&gt;
export default {
  data() {
    return {
      value: new Date(),
    };
  },
};
&lt;/script&gt;
</code></pre>
<h1 id="自定义内容-2"><a class="header" href="#自定义内容-2">自定义内容</a></h1>
<p>通过设置名为 <code>dateCell</code> 的 <code>scoped-slot</code> 来自定义日历单元格中显示的内容。在 <code>scoped-slot</code> 可以获取到 date（当前单元格的日期）, data（包括 type，isSelected，day 属性）。详情解释参考下方的 API 文档。</p>
<pre><code class="language-vue">&lt;el-calendar&gt;
  &lt;!-- 这里使用的是 2.5 slot 语法，对于新项目请使用 2.6 slot 语法--&gt;
  &lt;template
    slot=&quot;dateCell&quot;
    slot-scope=&quot;{date, data}&quot;&gt;
    &lt;p :class=&quot;data.isSelected ? 'is-selected' : ''&quot;&gt;
      {{ data.day.split('-').slice(1).join('-') }} {{ data.isSelected ? '✔️' : ''}}
    &lt;/p&gt;
  &lt;/template&gt;
&lt;/el-calendar&gt;
&lt;style&gt;
.is-selected {
  color: #1989fa;
}
&lt;/style&gt;
</code></pre>
<h1 id="自定义范围"><a class="header" href="#自定义范围">自定义范围</a></h1>
<p>设置 <code>range</code> 属性指定日历的显示范围。开始时间必须是周起始日，结束时间必须是周结束日，且时间跨度不能超过两个月。</p>
<pre><code class="language-vue">&lt;el-calendar :range=&quot;['2019-03-04', '2019-03-24']&quot;&gt;
&lt;/el-calendar&gt;
</code></pre>
<h2 id="attributes-19"><a class="header" href="#attributes-19">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">Date/string/number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">range</td><td style="text-align: left">时间范围，包括开始时间与结束时间。开始时间必须是周一，结束时间必须是周日，且时间跨度不能超过两个月。</td><td style="text-align: left">Array</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">first-day-of-week</td><td style="text-align: left">周起始日</td><td style="text-align: left">Number</td><td style="text-align: left">1 到 7</td><td style="text-align: left">1</td></tr>
</tbody></table>
<h2 id="datecell-scoped-slot-参数"><a class="header" href="#datecell-scoped-slot-参数"><a href="https://element.eleme.cn/#/zh-CN/component/calendar#datecell-scoped-slot-can-shu">¶</a>dateCell scoped slot 参数</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">date</td><td style="text-align: left">单元格代表的日期</td><td style="text-align: left">Date</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">data</td><td style="text-align: left">{ type, isSelected, day}，<code>type</code> 表示该日期的所属月份，可选值有 prev-month，current-month，next-month；<code>isSelected</code> 标明该日期是否被选中；<code>day</code> 是格式化的日期，格式为 yyyy-MM-dd</td><td style="text-align: left">Object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timepicker-时间选择器"><a class="header" href="#timepicker-时间选择器">TimePicker 时间选择器</a></h1>
<p>用于选择或输入日期</p>
<h2 id="固定时间点"><a class="header" href="#固定时间点">固定时间点</a></h2>
<pre><code class="language-vue">&lt;el-time-select
  v-model=&quot;value&quot;
  :picker-options=&quot;{
    start: '08:30',
    step: '00:15',
    end: '18:30'
  }&quot;
  placeholder=&quot;选择时间&quot;&gt;
&lt;/el-time-select&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value: ''
      };
    }
  }
&lt;/script&gt;
</code></pre>
<h2 id="任意时间点"><a class="header" href="#任意时间点">任意时间点</a></h2>
<p>使用 el-time-picker 标签，通过<code>selectableRange</code>限制可选时间范围。提供了两种交互方式：默认情况下通过鼠标滚轮进行选择，打开<code>arrow-control</code>属性则通过界面上的箭头进行选择。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-time-picker
    v-model=&quot;value1&quot;
    :picker-options=&quot;{
      selectableRange: '18:30:00 - 20:30:00'
    }&quot;
    placeholder=&quot;任意时间点&quot;&gt;
  &lt;/el-time-picker&gt;
  &lt;el-time-picker
    arrow-control
    v-model=&quot;value2&quot;
    :picker-options=&quot;{
      selectableRange: '18:30:00 - 20:30:00'
    }&quot;
    placeholder=&quot;任意时间点&quot;&gt;
  &lt;/el-time-picker&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        value1: new Date(2016, 9, 10, 18, 40),
        value2: new Date(2016, 9, 10, 18, 40)
      };
    }
  }
&lt;/script&gt;

</code></pre>
<h2 id="固定时间范围"><a class="header" href="#固定时间范围">固定时间范围</a></h2>
<p>若先选择开始时间，则结束时间内备选项的状态会随之改变</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-time-select
    placeholder=&quot;起始时间&quot;
    v-model=&quot;startTime&quot;
    :picker-options=&quot;{
      start: '08:30',
      step: '00:15',
      end: '18:30'
    }&quot;&gt;
  &lt;/el-time-select&gt;
  &lt;el-time-select
    placeholder=&quot;结束时间&quot;
    v-model=&quot;endTime&quot;
    :picker-options=&quot;{
      start: '08:30',
      step: '00:15',
      end: '18:30',
      minTime: startTime
    }&quot;&gt;
  &lt;/el-time-select&gt;
&lt;/template&gt;
</code></pre>
<h2 id="任意时间范围"><a class="header" href="#任意时间范围">任意时间范围</a></h2>
<p>添加<code>is-range</code>属性即可选择时间范围，同样支持<code>arrow-control</code>属性。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-time-picker
    is-range
    v-model=&quot;value1&quot;
    range-separator=&quot;至&quot;
    start-placeholder=&quot;开始时间&quot;
    end-placeholder=&quot;结束时间&quot;
    placeholder=&quot;选择时间范围&quot;&gt;
  &lt;/el-time-picker&gt;
  &lt;el-time-picker
    is-range
    arrow-control
    v-model=&quot;value2&quot;
    range-separator=&quot;至&quot;
    start-placeholder=&quot;开始时间&quot;
    end-placeholder=&quot;结束时间&quot;
    placeholder=&quot;选择时间范围&quot;&gt;
  &lt;/el-time-picker&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value1: [new Date(2016, 9, 10, 8, 40), new Date(2016, 9, 10, 9, 40)],
        value2: [new Date(2016, 9, 10, 8, 40), new Date(2016, 9, 10, 9, 40)]
      };
    }
  }
&lt;/script&gt;
</code></pre>
<h2 id="属性-事件和方法"><a class="header" href="#属性-事件和方法">属性 事件和方法</a></h2>
<h3 id="attributes-20"><a class="header" href="#attributes-20">Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">date(TimePicker) / string(TimeSelect)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">readonly</td><td style="text-align: left">完全只读</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">editable</td><td style="text-align: left">文本框可输入</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">clearable</td><td style="text-align: left">是否显示清除按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">输入框尺寸</td><td style="text-align: left">string</td><td style="text-align: left">medium / small / mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">placeholder</td><td style="text-align: left">非范围选择时的占位内容</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">start-placeholder</td><td style="text-align: left">范围选择时开始日期的占位内容</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">end-placeholder</td><td style="text-align: left">范围选择时开始日期的占位内容</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">is-range</td><td style="text-align: left">是否为时间范围选择，仅对<code>&lt;el-time-picker&gt;</code>有效</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">arrow-control</td><td style="text-align: left">是否使用箭头进行时间选择，仅对<code>&lt;el-time-picker&gt;</code>有效</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">align</td><td style="text-align: left">对齐方式</td><td style="text-align: left">string</td><td style="text-align: left">left / center / right</td><td style="text-align: left">left</td></tr>
<tr><td style="text-align: left">popper-class</td><td style="text-align: left">TimePicker 下拉框的类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">picker-options</td><td style="text-align: left">当前时间日期选择器特有的选项参考下表</td><td style="text-align: left">object</td><td style="text-align: left">—</td><td style="text-align: left">{}</td></tr>
<tr><td style="text-align: left">range-separator</td><td style="text-align: left">选择范围时的分隔符</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">'-'</td></tr>
<tr><td style="text-align: left">value-format</td><td style="text-align: left">可选，仅TimePicker时可用，绑定值的格式。不指定则绑定值为 Date 对象</td><td style="text-align: left">string</td><td style="text-align: left">见<a href="https://element.eleme.cn/#/zh-CN/component/date-picker#ri-qi-ge-shi">日期格式</a></td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">default-value</td><td style="text-align: left">可选，选择器打开时默认显示的时间</td><td style="text-align: left">Date(TimePicker) / string(TimeSelect)</td><td style="text-align: left">可被<code>new Date()</code>解析(TimePicker) / 可选值(TimeSelect)</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">原生属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">prefix-icon</td><td style="text-align: left">自定义头部图标的类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">el-icon-time</td></tr>
<tr><td style="text-align: left">clear-icon</td><td style="text-align: left">自定义清空图标的类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">el-icon-circle-close</td></tr>
</tbody></table>
<h3 id="time-select-options"><a class="header" href="#time-select-options"><a href="https://element.eleme.cn/#/zh-CN/component/time-picker#time-select-options">¶</a>Time Select Options</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">start</td><td style="text-align: left">开始时间</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">09:00</td></tr>
<tr><td style="text-align: left">end</td><td style="text-align: left">结束时间</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">18:00</td></tr>
<tr><td style="text-align: left">step</td><td style="text-align: left">间隔时间</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">00:30</td></tr>
<tr><td style="text-align: left">minTime</td><td style="text-align: left">最小时间，小于该时间的时间段将被禁用</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">00:00</td></tr>
<tr><td style="text-align: left">maxTime</td><td style="text-align: left">最大时间，大于该时间的时间段将被禁用</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h3 id="time-picker-options"><a class="header" href="#time-picker-options"><a href="https://element.eleme.cn/#/zh-CN/component/time-picker#time-picker-options">¶</a>Time Picker Options</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">selectableRange</td><td style="text-align: left">可选时间段，例如<code>'18:30:00 - 20:30:00'</code>或者传入数组<code>['09:30:00 - 12:00:00', '14:30:00 - 18:30:00']</code></td><td style="text-align: left">string / array</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">format</td><td style="text-align: left">时间格式化(TimePicker)</td><td style="text-align: left">string</td><td style="text-align: left">小时：<code>HH</code>，分：<code>mm</code>，秒：<code>ss</code>，AM/PM <code>A</code></td><td style="text-align: left">'HH:mm:ss'</td></tr>
</tbody></table>
<h3 id="events-14"><a class="header" href="#events-14"><a href="https://element.eleme.cn/#/zh-CN/component/time-picker#events">¶</a>Events</a></h3>
<table><thead><tr><th style="text-align: left">事件名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">用户确认选定的值时触发</td><td style="text-align: left">组件绑定值</td></tr>
<tr><td style="text-align: left">blur</td><td style="text-align: left">当 input 失去焦点时触发</td><td style="text-align: left">组件实例</td></tr>
<tr><td style="text-align: left">focus</td><td style="text-align: left">当 input 获得焦点时触发</td><td style="text-align: left">组件实例</td></tr>
</tbody></table>
<h3 id="methods-5"><a class="header" href="#methods-5"><a href="https://element.eleme.cn/#/zh-CN/component/time-picker#methods">¶</a>Methods</a></h3>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">focus</td><td style="text-align: left">使 input 获取焦点</td><td style="text-align: left">-</td></tr>
</tbody></table>
<h1 id="datepicker-日期选择器"><a class="header" href="#datepicker-日期选择器">DatePicker 日期选择器</a></h1>
<p>用于选择或输入日期</p>
<h2 id="选择日"><a class="header" href="#选择日">选择日</a></h2>
<p>以「日」为基本单位，基础的日期选择控件</p>
<p>基本单位由<code>type</code>属性指定。快捷选项需配置<code>picker-options</code>对象中的<code>shortcuts</code>，禁用日期通过 <code>disabledDate</code> 设置，传入函数</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;默认&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value1&quot;
      type=&quot;date&quot;
      placeholder=&quot;选择日期&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;带快捷选项&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value2&quot;
      align=&quot;right&quot;
      type=&quot;date&quot;
      placeholder=&quot;选择日期&quot;
      :picker-options=&quot;pickerOptions&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        pickerOptions: {
          disabledDate(time) {
            return time.getTime() &gt; Date.now();
          },
          shortcuts: [{
            text: '今天',
            onClick(picker) {
              picker.$emit('pick', new Date());
            }
          }, {
            text: '昨天',
            onClick(picker) {
              const date = new Date();
              date.setTime(date.getTime() - 3600 * 1000 * 24);
              picker.$emit('pick', date);
            }
          }, {
            text: '一周前',
            onClick(picker) {
              const date = new Date();
              date.setTime(date.getTime() - 3600 * 1000 * 24 * 7);
              picker.$emit('pick', date);
            }
          }]
        },
        value1: '',
        value2: '',
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h2 id="其他日期单位"><a class="header" href="#其他日期单位">其他日期单位</a></h2>
<p>通过扩展基础的日期选择，可以选择周、月、年或多个日期</p>
<pre><code class="language-vue">&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;周&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value1&quot;
      type=&quot;week&quot;
      format=&quot;yyyy 第 WW 周&quot;
      placeholder=&quot;选择周&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;月&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value2&quot;
      type=&quot;month&quot;
      placeholder=&quot;选择月&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;年&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value3&quot;
      type=&quot;year&quot;
      placeholder=&quot;选择年&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;多个日期&lt;/span&gt;
    &lt;el-date-picker
      type=&quot;dates&quot;
      v-model=&quot;value4&quot;
      placeholder=&quot;选择一个或多个日期&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value1: '',
        value2: '',
        value3: '',
        value4: ''
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h2 id="选择日期范围"><a class="header" href="#选择日期范围">选择日期范围</a></h2>
<p>可在一个选择器中便捷地选择一个时间范围</p>
<p>在选择日期范围时，默认情况下左右面板会联动。如果希望两个面板各自独立切换当前月份，可以使用<code>unlink-panels</code>属性解除联动。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;默认&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value1&quot;
      type=&quot;daterange&quot;
      range-separator=&quot;至&quot;
      start-placeholder=&quot;开始日期&quot;
      end-placeholder=&quot;结束日期&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;带快捷选项&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value2&quot;
      type=&quot;daterange&quot;
      align=&quot;right&quot;
      unlink-panels
      range-separator=&quot;至&quot;
      start-placeholder=&quot;开始日期&quot;
      end-placeholder=&quot;结束日期&quot;
      :picker-options=&quot;pickerOptions&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        pickerOptions: {
          shortcuts: [{
            text: '最近一周',
            onClick(picker) {
              const end = new Date();
              const start = new Date();
              start.setTime(start.getTime() - 3600 * 1000 * 24 * 7);
              picker.$emit('pick', [start, end]);
            }
          }, {
            text: '最近一个月',
            onClick(picker) {
              const end = new Date();
              const start = new Date();
              start.setTime(start.getTime() - 3600 * 1000 * 24 * 30);
              picker.$emit('pick', [start, end]);
            }
          }, {
            text: '最近三个月',
            onClick(picker) {
              const end = new Date();
              const start = new Date();
              start.setTime(start.getTime() - 3600 * 1000 * 24 * 90);
              picker.$emit('pick', [start, end]);
            }
          }]
        },
        value1: '',
        value2: ''
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h2 id="选择月份范围"><a class="header" href="#选择月份范围">选择月份范围</a></h2>
<p>可在一个选择器中便捷地选择一个月份范围</p>
<p>在选择月份范围时，默认情况下左右面板会联动。如果希望两个面板各自独立切换当前年份，可以使用<code>unlink-panels</code>属性解除联动。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;默认&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value1&quot;
      type=&quot;monthrange&quot;
      range-separator=&quot;至&quot;
      start-placeholder=&quot;开始月份&quot;
      end-placeholder=&quot;结束月份&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;带快捷选项&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value2&quot;
      type=&quot;monthrange&quot;
      align=&quot;right&quot;
      unlink-panels
      range-separator=&quot;至&quot;
      start-placeholder=&quot;开始月份&quot;
      end-placeholder=&quot;结束月份&quot;
      :picker-options=&quot;pickerOptions&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        pickerOptions: {
          shortcuts: [{
            text: '本月',
            onClick(picker) {
              picker.$emit('pick', [new Date(), new Date()]);
            }
          }, {
            text: '今年至今',
            onClick(picker) {
              const end = new Date();
              const start = new Date(new Date().getFullYear(), 0);
              picker.$emit('pick', [start, end]);
            }
          }, {
            text: '最近六个月',
            onClick(picker) {
              const end = new Date();
              const start = new Date();
              start.setMonth(start.getMonth() - 6);
              picker.$emit('pick', [start, end]);
            }
          }]
        },
        value1: '',
        value2: ''
      };
    }
  };
&lt;/script&gt;

</code></pre>
<h2 id="日期格式"><a class="header" href="#日期格式">日期格式</a></h2>
<pre><code>
使用format指定输入框的格式；使用value-format指定绑定值的格式。

默认情况下，组件接受并返回Date对象。以下为可用的格式化字串，以 UTC 2017年1月2日 03:04:05 为例：

请注意大小写

格式	含义	备注	举例
yyyy	年		2017
M	月	不补0	1
MM	月		01
W	周	仅周选择器的 format 可用；不补0	1
WW	周	仅周选择器的 format 可用	01
d	日	不补0	2
dd	日		02
H	小时	24小时制；不补0	3
HH	小时	24小时制	03
h	小时	12小时制，须和 A 或 a 使用；不补0	3
hh	小时	12小时制，须和 A 或 a 使用	03
m	分钟	不补0	4
mm	分钟		04
s	秒	不补0	5
ss	秒		05
A	AM/PM	仅 format 可用，大写	AM
a	am/pm	仅 format 可用，小写	am
timestamp	JS时间戳	仅 value-format 可用；组件绑定值为number类型	1483326245000
[MM]	不需要格式化字符	使用方括号标识不需要格式化的字符 (如 [A] [MM])	MM
</code></pre>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;默认为 Date 对象&lt;/span&gt;
    &lt;div class=&quot;demonstration&quot;&gt;值：{{ value1 }}&lt;/div&gt;
    &lt;el-date-picker
      v-model=&quot;value1&quot;
      type=&quot;date&quot;
      placeholder=&quot;选择日期&quot;
      format=&quot;yyyy 年 MM 月 dd 日&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;使用 value-format&lt;/span&gt;
    &lt;div class=&quot;demonstration&quot;&gt;值：{{ value2 }}&lt;/div&gt;
    &lt;el-date-picker
      v-model=&quot;value2&quot;
      type=&quot;date&quot;
      placeholder=&quot;选择日期&quot;
      format=&quot;yyyy 年 MM 月 dd 日&quot;
      value-format=&quot;yyyy-MM-dd&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;时间戳&lt;/span&gt;
    &lt;div class=&quot;demonstration&quot;&gt;值：{{ value3 }}&lt;/div&gt;
    &lt;el-date-picker
      v-model=&quot;value3&quot;
      type=&quot;date&quot;
      placeholder=&quot;选择日期&quot;
      format=&quot;yyyy 年 MM 月 dd 日&quot;
      value-format=&quot;timestamp&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value1: '',
        value2: '',
        value3: ''
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h2 id="默认显示日期"><a class="header" href="#默认显示日期">默认显示日期</a></h2>
<p>选择日期范围时，默认情况下，起始日期和结束日期的时间部分均为当天的 0 点 0 分 0 秒。通过<code>default-time</code>可以分别指定二者的具体时刻。<code>default-time</code>接受一个数组，其中的值为形如<code>12:00:00</code>的字符串，第一个值控制起始日期的时刻，第二个值控制结束日期的时刻。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;p&gt;组件值：{{ value }}&lt;/p&gt;
    &lt;el-date-picker
      v-model=&quot;value&quot;
      type=&quot;daterange&quot;
      start-placeholder=&quot;开始日期&quot;
      end-placeholder=&quot;结束日期&quot;
      :default-time=&quot;['00:00:00', '23:59:59']&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value: ''
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h2 id="属性事件和方法-24"><a class="header" href="#属性事件和方法-24">属性事件和方法</a></h2>
<h3 id="attributes-21"><a class="header" href="#attributes-21">Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">date(DatePicker) / array(DateRangePicker)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">readonly</td><td style="text-align: left">完全只读</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">editable</td><td style="text-align: left">文本框可输入</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">clearable</td><td style="text-align: left">是否显示清除按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">输入框尺寸</td><td style="text-align: left">string</td><td style="text-align: left">large, small, mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">placeholder</td><td style="text-align: left">非范围选择时的占位内容</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">start-placeholder</td><td style="text-align: left">范围选择时开始日期的占位内容</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">end-placeholder</td><td style="text-align: left">范围选择时结束日期的占位内容</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">type</td><td style="text-align: left">显示类型</td><td style="text-align: left">string</td><td style="text-align: left">year/month/date/dates/ week/datetime/datetimerange/ daterange/monthrange</td><td style="text-align: left">date</td></tr>
<tr><td style="text-align: left">format</td><td style="text-align: left">显示在输入框中的格式</td><td style="text-align: left">string</td><td style="text-align: left">见<a href="https://element.eleme.cn/#/zh-CN/component/date-picker#ri-qi-ge-shi">日期格式</a></td><td style="text-align: left">yyyy-MM-dd</td></tr>
<tr><td style="text-align: left">align</td><td style="text-align: left">对齐方式</td><td style="text-align: left">string</td><td style="text-align: left">left, center, right</td><td style="text-align: left">left</td></tr>
<tr><td style="text-align: left">popper-class</td><td style="text-align: left">DatePicker 下拉框的类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">picker-options</td><td style="text-align: left">当前时间日期选择器特有的选项参考下表</td><td style="text-align: left">object</td><td style="text-align: left">—</td><td style="text-align: left">{}</td></tr>
<tr><td style="text-align: left">range-separator</td><td style="text-align: left">选择范围时的分隔符</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">'-'</td></tr>
<tr><td style="text-align: left">default-value</td><td style="text-align: left">可选，选择器打开时默认显示的时间</td><td style="text-align: left">Date</td><td style="text-align: left">可被<code>new Date()</code>解析</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">default-time</td><td style="text-align: left">范围选择时选中日期所使用的当日内具体时刻</td><td style="text-align: left">string[]</td><td style="text-align: left">数组，长度为 2，每项值为字符串，形如<code>12:00:00</code>，第一项指定开始日期的时刻，第二项指定结束日期的时刻，不指定会使用时刻 <code>00:00:00</code></td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">value-format</td><td style="text-align: left">可选，绑定值的格式。不指定则绑定值为 Date 对象</td><td style="text-align: left">string</td><td style="text-align: left">见<a href="https://element.eleme.cn/#/zh-CN/component/date-picker#ri-qi-ge-shi">日期格式</a></td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">原生属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">unlink-panels</td><td style="text-align: left">在范围选择器里取消两个日期面板之间的联动</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">prefix-icon</td><td style="text-align: left">自定义头部图标的类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">el-icon-date</td></tr>
<tr><td style="text-align: left">clear-icon</td><td style="text-align: left">自定义清空图标的类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">el-icon-circle-close</td></tr>
<tr><td style="text-align: left">validate-event</td><td style="text-align: left">输入时是否触发表单的校验</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">true</td></tr>
</tbody></table>
<h3 id="picker-options"><a class="header" href="#picker-options"><a href="https://element.eleme.cn/#/zh-CN/component/date-picker#picker-options">¶</a>Picker Options</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">shortcuts</td><td style="text-align: left">设置快捷选项，需要传入 { text, onClick } 对象用法参考 demo 或下表</td><td style="text-align: left">Object[]</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabledDate</td><td style="text-align: left">设置禁用状态，参数为当前日期，要求返回 Boolean</td><td style="text-align: left">Function</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">cellClassName</td><td style="text-align: left">设置日期的 className</td><td style="text-align: left">Function(Date)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">firstDayOfWeek</td><td style="text-align: left">周起始日</td><td style="text-align: left">Number</td><td style="text-align: left">1 到 7</td><td style="text-align: left">7</td></tr>
<tr><td style="text-align: left">onPick</td><td style="text-align: left">选中日期后会执行的回调，只有当 <code>daterange</code> 或 <code>datetimerange</code> 才生效</td><td style="text-align: left">Function({ maxDate, minDate })</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h3 id="shortcuts"><a class="header" href="#shortcuts"><a href="https://element.eleme.cn/#/zh-CN/component/date-picker#shortcuts">¶</a>Shortcuts</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">text</td><td style="text-align: left">标题文本</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">onClick</td><td style="text-align: left">选中后的回调函数，参数是 vm，可通过触发 'pick' 事件设置选择器的值。例如 vm.$emit('pick', new Date())</td><td style="text-align: left">function</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h3 id="events-15"><a class="header" href="#events-15"><a href="https://element.eleme.cn/#/zh-CN/component/date-picker#events">¶</a>Events</a></h3>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">用户确认选定的值时触发</td><td style="text-align: left">组件绑定值。格式与绑定值一致，可受 <code>value-format</code> 控制</td></tr>
<tr><td style="text-align: left">blur</td><td style="text-align: left">当 input 失去焦点时触发</td><td style="text-align: left">组件实例</td></tr>
<tr><td style="text-align: left">focus</td><td style="text-align: left">当 input 获得焦点时触发</td><td style="text-align: left">组件实例</td></tr>
</tbody></table>
<h3 id="methods-6"><a class="header" href="#methods-6"><a href="https://element.eleme.cn/#/zh-CN/component/date-picker#methods">¶</a>Methods</a></h3>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">focus</td><td style="text-align: left">使 input 获取焦点</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h1 id="datetimepicker-日期时间选择器"><a class="header" href="#datetimepicker-日期时间选择器">DateTimePicker 日期时间选择器</a></h1>
<p>DateTimePicker 由 DatePicker 和 TimePicker 派生，<code>Picker Options</code> 或者其他选项可以参照 DatePicker 和 TimePicker。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;默认&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value1&quot;
      type=&quot;datetime&quot;
      placeholder=&quot;选择日期时间&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;带快捷选项&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value2&quot;
      type=&quot;datetime&quot;
      placeholder=&quot;选择日期时间&quot;
      align=&quot;right&quot;
      :picker-options=&quot;pickerOptions&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;设置默认时间&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value3&quot;
      type=&quot;datetime&quot;
      placeholder=&quot;选择日期时间&quot;
      default-time=&quot;12:00:00&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        pickerOptions: {
          shortcuts: [{
            text: '今天',
            onClick(picker) {
              picker.$emit('pick', new Date());
            }
          }, {
            text: '昨天',
            onClick(picker) {
              const date = new Date();
              date.setTime(date.getTime() - 3600 * 1000 * 24);
              picker.$emit('pick', date);
            }
          }, {
            text: '一周前',
            onClick(picker) {
              const date = new Date();
              date.setTime(date.getTime() - 3600 * 1000 * 24 * 7);
              picker.$emit('pick', date);
            }
          }]
        },
        value1: '',
        value2: '',
        value3: ''
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h2 id="日期和时间范围"><a class="header" href="#日期和时间范围">日期和时间范围</a></h2>
<p>设置<code>type</code>为<code>datetimerange</code>即可选择日期和时间范围</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;默认&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value1&quot;
      type=&quot;datetimerange&quot;
      range-separator=&quot;至&quot;
      start-placeholder=&quot;开始日期&quot;
      end-placeholder=&quot;结束日期&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;带快捷选项&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value2&quot;
      type=&quot;datetimerange&quot;
      :picker-options=&quot;pickerOptions&quot;
      range-separator=&quot;至&quot;
      start-placeholder=&quot;开始日期&quot;
      end-placeholder=&quot;结束日期&quot;
      align=&quot;right&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        pickerOptions: {
          shortcuts: [{
            text: '最近一周',
            onClick(picker) {
              const end = new Date();
              const start = new Date();
              start.setTime(start.getTime() - 3600 * 1000 * 24 * 7);
              picker.$emit('pick', [start, end]);
            }
          }, {
            text: '最近一个月',
            onClick(picker) {
              const end = new Date();
              const start = new Date();
              start.setTime(start.getTime() - 3600 * 1000 * 24 * 30);
              picker.$emit('pick', [start, end]);
            }
          }, {
            text: '最近三个月',
            onClick(picker) {
              const end = new Date();
              const start = new Date();
              start.setTime(start.getTime() - 3600 * 1000 * 24 * 90);
              picker.$emit('pick', [start, end]);
            }
          }]
        },
        value1: [new Date(2000, 10, 10, 10, 10), new Date(2000, 10, 11, 10, 10)],
        value2: ''
      };
    }
  };
&lt;/script&gt;

</code></pre>
<h2 id="默认的起始与结束时刻"><a class="header" href="#默认的起始与结束时刻">默认的起始与结束时刻</a></h2>
<p>​	使用<code>datetimerange</code>进行范围选择时，在日期选择面板中选定起始与结束的日期，默认会使用该日期的<code>00:00:00</code>作为起始与结束的时刻；通过选项<code>default-time</code>可以控制选中起始与结束日期时所使用的具体时刻。<code>default-time</code>接受一个数组，数组每项值为字符串，形如<code>12:00:00</code>，其中第一项控制起始日期的具体时刻，第二项控制结束日期的具体时刻。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;起始日期时刻为 12:00:00&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value1&quot;
      type=&quot;datetimerange&quot;
      start-placeholder=&quot;开始日期&quot;
      end-placeholder=&quot;结束日期&quot;
      :default-time=&quot;['12:00:00']&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;起始日期时刻为 12:00:00，结束日期时刻为 08:00:00&lt;/span&gt;
    &lt;el-date-picker
      v-model=&quot;value2&quot;
      type=&quot;datetimerange&quot;
      align=&quot;right&quot;
      start-placeholder=&quot;开始日期&quot;
      end-placeholder=&quot;结束日期&quot;
      :default-time=&quot;['12:00:00', '08:00:00']&quot;&gt;
    &lt;/el-date-picker&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value1: '',
        value2: ''
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h2 id="属性事件和方法-25"><a class="header" href="#属性事件和方法-25">属性事件和方法</a></h2>
<h3 id="attributes-22"><a class="header" href="#attributes-22">Attributes</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">date(DateTimePicker) / array(DateTimeRangePicker)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">readonly</td><td style="text-align: left">完全只读</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">editable</td><td style="text-align: left">文本框可输入</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">clearable</td><td style="text-align: left">是否显示清除按钮</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">输入框尺寸</td><td style="text-align: left">string</td><td style="text-align: left">large, small, mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">placeholder</td><td style="text-align: left">非范围选择时的占位内容</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">start-placeholder</td><td style="text-align: left">范围选择时开始日期的占位内容</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">end-placeholder</td><td style="text-align: left">范围选择时结束日期的占位内容</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">time-arrow-control</td><td style="text-align: left">是否使用箭头进行时间选择</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">type</td><td style="text-align: left">显示类型</td><td style="text-align: left">string</td><td style="text-align: left">year/month/date/week/ datetime/datetimerange/daterange</td><td style="text-align: left">date</td></tr>
<tr><td style="text-align: left">format</td><td style="text-align: left">显示在输入框中的格式</td><td style="text-align: left">string</td><td style="text-align: left">见<a href="https://element.eleme.cn/#/zh-CN/component/date-picker#ri-qi-ge-shi">日期格式</a></td><td style="text-align: left">yyyy-MM-dd HH:mm:ss</td></tr>
<tr><td style="text-align: left">align</td><td style="text-align: left">对齐方式</td><td style="text-align: left">string</td><td style="text-align: left">left, center, right</td><td style="text-align: left">left</td></tr>
<tr><td style="text-align: left">popper-class</td><td style="text-align: left">DateTimePicker 下拉框的类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">picker-options</td><td style="text-align: left">当前时间日期选择器特有的选项参考下表</td><td style="text-align: left">object</td><td style="text-align: left">—</td><td style="text-align: left">{}</td></tr>
<tr><td style="text-align: left">range-separator</td><td style="text-align: left">选择范围时的分隔符</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">'-'</td></tr>
<tr><td style="text-align: left">default-value</td><td style="text-align: left">可选，选择器打开时默认显示的时间</td><td style="text-align: left">Date</td><td style="text-align: left">可被<code>new Date()</code>解析</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">default-time</td><td style="text-align: left">选中日期后的默认具体时刻</td><td style="text-align: left">非范围选择时：string / 范围选择时：string[]</td><td style="text-align: left">非范围选择时：形如<code>12:00:00</code>的字符串；范围选择时：数组，长度为 2，每项值为字符串，形如<code>12:00:00</code>，第一项指定开始日期的时刻，第二项指定结束日期的时刻。不指定会使用时刻 <code>00:00:00</code></td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">value-format</td><td style="text-align: left">可选，绑定值的格式。不指定则绑定值为 Date 对象</td><td style="text-align: left">string</td><td style="text-align: left">见<a href="https://element.eleme.cn/#/zh-CN/component/date-picker#ri-qi-ge-shi">日期格式</a></td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">原生属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">unlink-panels</td><td style="text-align: left">在范围选择器里取消两个日期面板之间的联动</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">prefix-icon</td><td style="text-align: left">自定义头部图标的类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">el-icon-date</td></tr>
<tr><td style="text-align: left">clear-icon</td><td style="text-align: left">自定义清空图标的类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">el-icon-circle-close</td></tr>
</tbody></table>
<h3 id="picker-options-1"><a class="header" href="#picker-options-1"><a href="https://element.eleme.cn/#/zh-CN/component/datetime-picker#picker-options">¶</a>Picker Options</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">shortcuts</td><td style="text-align: left">设置快捷选项，需要传入 { text, onClick } 对象用法参考 demo 或下表</td><td style="text-align: left">Object[]</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabledDate</td><td style="text-align: left">设置禁用状态，参数为当前日期，要求返回 Boolean</td><td style="text-align: left">Function</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">cellClassName</td><td style="text-align: left">设置日期的 className</td><td style="text-align: left">Function(Date)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">firstDayOfWeek</td><td style="text-align: left">周起始日</td><td style="text-align: left">Number</td><td style="text-align: left">1 到 7</td><td style="text-align: left">7</td></tr>
</tbody></table>
<h3 id="shortcuts-1"><a class="header" href="#shortcuts-1"><a href="https://element.eleme.cn/#/zh-CN/component/datetime-picker#shortcuts">¶</a>Shortcuts</a></h3>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">text</td><td style="text-align: left">标题文本</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">onClick</td><td style="text-align: left">选中后的回调函数，参数是 vm，可通过触发 'pick' 事件设置选择器的值。例如 vm.$emit('pick', new Date())</td><td style="text-align: left">function</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h3 id="events-16"><a class="header" href="#events-16"><a href="https://element.eleme.cn/#/zh-CN/component/datetime-picker#events">¶</a>Events</a></h3>
<table><thead><tr><th style="text-align: left">Event Name</th><th style="text-align: left">Description</th><th style="text-align: left">Parameters</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">用户确认选定的值时触发</td><td style="text-align: left">组件绑定值。格式与绑定值一致，可受 <code>value-format</code> 控制</td></tr>
<tr><td style="text-align: left">blur</td><td style="text-align: left">当 input 失去焦点时触发</td><td style="text-align: left">组件实例</td></tr>
<tr><td style="text-align: left">focus</td><td style="text-align: left">当 input 获得焦点时触发</td><td style="text-align: left">组件实例</td></tr>
</tbody></table>
<h3 id="methods-7"><a class="header" href="#methods-7"><a href="https://element.eleme.cn/#/zh-CN/component/datetime-picker#methods">¶</a>Methods</a></h3>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">focus</td><td style="text-align: left">使 input 获取焦点</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h3 id="slots-2"><a class="header" href="#slots-2"><a href="https://element.eleme.cn/#/zh-CN/component/datetime-picker#slots">¶</a>Slots</a></h3>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">range-separator</td><td style="text-align: left">自定义分隔符</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tag-标签"><a class="header" href="#tag-标签">Tag 标签</a></h1>
<p>用于标记和选择。</p>
<h1 id="基础用法-23"><a class="header" href="#基础用法-23">基础用法</a></h1>
<p>由<code>type</code>属性来选择tag的类型，也可以通过<code>color</code>属性来自定义背景色。</p>
<pre><code>&lt;el-tag&gt;标签一&lt;/el-tag&gt;
&lt;el-tag type=&quot;success&quot;&gt;标签二&lt;/el-tag&gt;
&lt;el-tag type=&quot;info&quot;&gt;标签三&lt;/el-tag&gt;
&lt;el-tag type=&quot;warning&quot;&gt;标签四&lt;/el-tag&gt;
&lt;el-tag type=&quot;danger&quot;&gt;标签五&lt;/el-tag&gt;
</code></pre>
<h1 id="可移除标签"><a class="header" href="#可移除标签">可移除标签</a></h1>
<p>设置<code>closable</code>属性可以定义一个标签是否可移除。默认的标签移除时会附带渐变动画，如果不想使用，可以设置<code>disable-transitions</code>属性，它接受一个<code>Boolean</code>，true 为关闭。</p>
<pre><code class="language-vue">&lt;el-tag
  v-for=&quot;tag in tags&quot;
  :key=&quot;tag.name&quot;
  closable
  :type=&quot;tag.type&quot;&gt;
  {{tag.name}}
&lt;/el-tag&gt;

</code></pre>
<h1 id="动态编辑标签"><a class="header" href="#动态编辑标签">动态编辑标签</a></h1>
<p>动态编辑标签可以通过点击标签关闭按钮后触发的 <code>close</code> 事件来实现</p>
<pre><code class="language-vue">&lt;el-tag
  :key=&quot;tag&quot;
  v-for=&quot;tag in dynamicTags&quot;
  closable
  :disable-transitions=&quot;false&quot;
  @close=&quot;handleClose(tag)&quot;&gt;
  {{tag}}
&lt;/el-tag&gt;
&lt;el-input
  class=&quot;input-new-tag&quot;
  v-if=&quot;inputVisible&quot;
  v-model=&quot;inputValue&quot;
  ref=&quot;saveTagInput&quot;
  size=&quot;small&quot;
  @keyup.enter.native=&quot;handleInputConfirm&quot;
  @blur=&quot;handleInputConfirm&quot;
&gt;
&lt;/el-input&gt;
&lt;el-button v-else class=&quot;button-new-tag&quot; size=&quot;small&quot; @click=&quot;showInput&quot;&gt;+ New Tag&lt;/el-button&gt;

&lt;style&gt;
  .el-tag + .el-tag {
    margin-left: 10px;
  }
  .button-new-tag {
    margin-left: 10px;
    height: 32px;
    line-height: 30px;
    padding-top: 0;
    padding-bottom: 0;
  }
  .input-new-tag {
    width: 90px;
    margin-left: 10px;
    vertical-align: bottom;
  }
&lt;/style&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        dynamicTags: ['标签一', '标签二', '标签三'],
        inputVisible: false,
        inputValue: ''
      };
    },
    methods: {
      handleClose(tag) {
        this.dynamicTags.splice(this.dynamicTags.indexOf(tag), 1);
      },

      showInput() {
        this.inputVisible = true;
        this.$nextTick(_ =&gt; {
          this.$refs.saveTagInput.$refs.input.focus();
        });
      },

      handleInputConfirm() {
        let inputValue = this.inputValue;
        if (inputValue) {
          this.dynamicTags.push(inputValue);
        }
        this.inputVisible = false;
        this.inputValue = '';
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="不同尺寸"><a class="header" href="#不同尺寸">不同尺寸</a></h1>
<p>Tag 组件提供除了默认值以外的三种尺寸，可以在不同场景下选择合适的按钮尺寸。</p>
<p>额外的尺寸：<code>medium</code>、<code>small</code>、<code>mini</code>，通过设置<code>size</code>属性来配置它们。</p>
<pre><code class="language-vue">&lt;el-tag closable&gt;默认标签&lt;/el-tag&gt;
&lt;el-tag size=&quot;medium&quot; closable&gt;中等标签&lt;/el-tag&gt;
&lt;el-tag size=&quot;small&quot; closable&gt;小型标签&lt;/el-tag&gt;
&lt;el-tag size=&quot;mini&quot; closable&gt;超小标签&lt;/el-tag&gt;
</code></pre>
<h1 id="不同主题"><a class="header" href="#不同主题">不同主题</a></h1>
<p>通过设置<code>effect</code>属性来改变主题，默认为 <code>light</code></p>
<pre><code class="language-vue">&lt;div class=&quot;tag-group&quot;&gt;
  &lt;span class=&quot;tag-group__title&quot;&gt;Dark&lt;/span&gt;
  &lt;el-tag
    v-for=&quot;item in items&quot;
    :key=&quot;item.label&quot;
    :type=&quot;item.type&quot;
    effect=&quot;dark&quot;&gt;
    {{ item.label }}
  &lt;/el-tag&gt;
&lt;/div&gt;
&lt;div class=&quot;tag-group&quot;&gt;
  &lt;span class=&quot;tag-group__title&quot;&gt;Plain&lt;/span&gt;
  &lt;el-tag
    v-for=&quot;item in items&quot;
    :key=&quot;item.label&quot;
    :type=&quot;item.type&quot;
    effect=&quot;plain&quot;&gt;
    {{ item.label }}
  &lt;/el-tag&gt;
&lt;/div&gt;
</code></pre>
<h1 id="属性事件和方法-26"><a class="header" href="#属性事件和方法-26">属性事件和方法</a></h1>
<h2 id="attributes-23"><a class="header" href="#attributes-23">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">type</td><td style="text-align: left">类型</td><td style="text-align: left">string</td><td style="text-align: left">success/info/warning/danger</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">closable</td><td style="text-align: left">是否可关闭</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">disable-transitions</td><td style="text-align: left">是否禁用渐变动画</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">hit</td><td style="text-align: left">是否有边框描边</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">color</td><td style="text-align: left">背景色</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">尺寸</td><td style="text-align: left">string</td><td style="text-align: left">medium / small / mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">effect</td><td style="text-align: left">主题</td><td style="text-align: left">string</td><td style="text-align: left">dark / light / plain</td><td style="text-align: left">light</td></tr>
</tbody></table>
<h2 id="events-17"><a class="header" href="#events-17"><a href="https://element.eleme.cn/#/zh-CN/component/tag#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">click</td><td style="text-align: left">点击 Tag 时触发的事件</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">close</td><td style="text-align: left">关闭 Tag 时触发的事件</td><td style="text-align: left">—</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="badge-标记"><a class="header" href="#badge-标记">Badge 标记</a></h1>
<p>出现在按钮、图标旁的数字或状态标记。</p>
<h1 id="基础用法-24"><a class="header" href="#基础用法-24">基础用法</a></h1>
<p>定义<code>value</code>属性，它接受<code>Number</code>或者<code>String</code>。</p>
<pre><code class="language-vue">&lt;el-badge :value=&quot;12&quot; class=&quot;item&quot;&gt;
  &lt;el-button size=&quot;small&quot;&gt;评论&lt;/el-button&gt;
&lt;/el-badge&gt;
&lt;el-badge :value=&quot;3&quot; class=&quot;item&quot;&gt;
  &lt;el-button size=&quot;small&quot;&gt;回复&lt;/el-button&gt;
&lt;/el-badge&gt;
&lt;el-badge :value=&quot;1&quot; class=&quot;item&quot; type=&quot;primary&quot;&gt;
  &lt;el-button size=&quot;small&quot;&gt;评论&lt;/el-button&gt;
&lt;/el-badge&gt;
&lt;el-badge :value=&quot;2&quot; class=&quot;item&quot; type=&quot;warning&quot;&gt;
  &lt;el-button size=&quot;small&quot;&gt;回复&lt;/el-button&gt;
&lt;/el-badge&gt;

&lt;el-dropdown trigger=&quot;click&quot;&gt;
  &lt;span class=&quot;el-dropdown-link&quot;&gt;
    点我查看&lt;i class=&quot;el-icon-caret-bottom el-icon--right&quot;&gt;&lt;/i&gt;
  &lt;/span&gt;
  &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;
    &lt;el-dropdown-item class=&quot;clearfix&quot;&gt;
      评论
      &lt;el-badge class=&quot;mark&quot; :value=&quot;12&quot; /&gt;
    &lt;/el-dropdown-item&gt;
    &lt;el-dropdown-item class=&quot;clearfix&quot;&gt;
      回复
      &lt;el-badge class=&quot;mark&quot; :value=&quot;3&quot; /&gt;
    &lt;/el-dropdown-item&gt;
  &lt;/el-dropdown-menu&gt;
&lt;/el-dropdown&gt;

&lt;style&gt;
.item {
  margin-top: 10px;
  margin-right: 40px;
}
&lt;/style&gt;
</code></pre>
<h1 id="最大值"><a class="header" href="#最大值">最大值</a></h1>
<p>由<code>max</code>属性定义，它接受一个<code>Number</code>，需要注意的是，只有当<code>value</code>为<code>Number</code>时，它才会生效。</p>
<pre><code class="language-vue">&lt;el-badge :value=&quot;200&quot; :max=&quot;99&quot; class=&quot;item&quot;&gt;
  &lt;el-button size=&quot;small&quot;&gt;评论&lt;/el-button&gt;
&lt;/el-badge&gt;
&lt;el-badge :value=&quot;100&quot; :max=&quot;10&quot; class=&quot;item&quot;&gt;
  &lt;el-button size=&quot;small&quot;&gt;回复&lt;/el-button&gt;
&lt;/el-badge&gt;

&lt;style&gt;
.item {
  margin-top: 10px;
  margin-right: 40px;
}
&lt;/style&gt;
</code></pre>
<h1 id="自定义内容-3"><a class="header" href="#自定义内容-3">自定义内容</a></h1>
<pre><code class="language-vue">定义value为String类型是时可以用于显示自定义文本。

&lt;el-badge value=&quot;new&quot; class=&quot;item&quot;&gt;
  &lt;el-button size=&quot;small&quot;&gt;评论&lt;/el-button&gt;
&lt;/el-badge&gt;
&lt;el-badge value=&quot;hot&quot; class=&quot;item&quot;&gt;
  &lt;el-button size=&quot;small&quot;&gt;回复&lt;/el-button&gt;
&lt;/el-badge&gt;

&lt;style&gt;
.item {
  margin-top: 10px;
  margin-right: 40px;
}
&lt;/style&gt;
</code></pre>
<h1 id="小红点"><a class="header" href="#小红点">小红点</a></h1>
<p>除了数字外，设置<code>is-dot</code>属性，它接受一个<code>Boolean</code>。</p>
<pre><code class="language-vue">&lt;el-badge is-dot class=&quot;item&quot;&gt;数据查询&lt;/el-badge&gt;
&lt;el-badge is-dot class=&quot;item&quot;&gt;
  &lt;el-button class=&quot;share-button&quot; icon=&quot;el-icon-share&quot; type=&quot;primary&quot;&gt;&lt;/el-button&gt;
&lt;/el-badge&gt;

&lt;style&gt;
.item {
  margin-top: 10px;
  margin-right: 40px;
}
&lt;/style&gt;
</code></pre>
<h1 id="属性"><a class="header" href="#属性">属性</a></h1>
<h2 id="attributes-24"><a class="header" href="#attributes-24">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value</td><td style="text-align: left">显示值</td><td style="text-align: left">string, number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">max</td><td style="text-align: left">最大值，超过最大值会显示 '{max}+'，要求 value 是 Number 类型</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">is-dot</td><td style="text-align: left">小圆点</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">hidden</td><td style="text-align: left">隐藏 badge</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">type</td><td style="text-align: left">类型</td><td style="text-align: left">string</td><td style="text-align: left">primary / success / warning / danger / info</td><td style="text-align: left">—</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-4"><a class="header" href="#简介-4">简介</a></h1>
<p>当一个数据集合有清晰的层级结构时，可通过级联选择器逐级查看并选择。</p>
<h1 id="基础用法-25"><a class="header" href="#基础用法-25">基础用法</a></h1>
<p>只需为 Cascader 的<code>options</code>属性指定选项数组即可渲染出一个级联选择器。通过<code>props.expandTrigger</code>可以定义展开子级菜单的触发方式。</p>
<pre><code class="language-vue">&lt;div class=&quot;block&quot;&gt;
  &lt;span class=&quot;demonstration&quot;&gt;默认 click 触发子菜单&lt;/span&gt;
  &lt;el-cascader
    v-model=&quot;value&quot;
    :options=&quot;options&quot;
    @change=&quot;handleChange&quot;&gt;&lt;/el-cascader&gt;
&lt;/div&gt;
&lt;div class=&quot;block&quot;&gt;
  &lt;span class=&quot;demonstration&quot;&gt;hover 触发子菜单&lt;/span&gt;
  &lt;el-cascader
    v-model=&quot;value&quot;
    :options=&quot;options&quot;
    :props=&quot;{ expandTrigger: 'hover' }&quot;
    @change=&quot;handleChange&quot;&gt;&lt;/el-cascader&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value: [],
        options: [{
          value: 'zhinan',
          label: '指南',
          children: [{
            value: 'shejiyuanze',
            label: '设计原则',
            children: [{
              value: 'yizhi',
              label: '一致'
            }, {
              value: 'fankui',
              label: '反馈'
            }, {
              value: 'xiaolv',
              label: '效率'
            }, {
              value: 'kekong',
              label: '可控'
            }]
          }, {
            value: 'daohang',
            label: '导航',
            children: [{
              value: 'cexiangdaohang',
              label: '侧向导航'
            }, {
              value: 'dingbudaohang',
              label: '顶部导航'
            }]
          }]
        }, {
          value: 'zujian',
          label: '组件',
          children: [{
            value: 'basic',
            label: 'Basic',
            children: [{
              value: 'layout',
              label: 'Layout 布局'
            }, {
              value: 'color',
              label: 'Color 色彩'
            }, {
              value: 'typography',
              label: 'Typography 字体'
            }, {
              value: 'icon',
              label: 'Icon 图标'
            }, {
              value: 'button',
              label: 'Button 按钮'
            }]
          }, {
            value: 'form',
            label: 'Form',
            children: [{
              value: 'radio',
              label: 'Radio 单选框'
            }, {
              value: 'checkbox',
              label: 'Checkbox 多选框'
            }, {
              value: 'input',
              label: 'Input 输入框'
            }, {
              value: 'input-number',
              label: 'InputNumber 计数器'
            }, {
              value: 'select',
              label: 'Select 选择器'
            }, {
              value: 'cascader',
              label: 'Cascader 级联选择器'
            }, {
              value: 'switch',
              label: 'Switch 开关'
            }, {
              value: 'slider',
              label: 'Slider 滑块'
            }, {
              value: 'time-picker',
              label: 'TimePicker 时间选择器'
            }, {
              value: 'date-picker',
              label: 'DatePicker 日期选择器'
            }, {
              value: 'datetime-picker',
              label: 'DateTimePicker 日期时间选择器'
            }, {
              value: 'upload',
              label: 'Upload 上传'
            }, {
              value: 'rate',
              label: 'Rate 评分'
            }, {
              value: 'form',
              label: 'Form 表单'
            }]
          }, {
            value: 'data',
            label: 'Data',
            children: [{
              value: 'table',
              label: 'Table 表格'
            }, {
              value: 'tag',
              label: 'Tag 标签'
            }, {
              value: 'progress',
              label: 'Progress 进度条'
            }, {
              value: 'tree',
              label: 'Tree 树形控件'
            }, {
              value: 'pagination',
              label: 'Pagination 分页'
            }, {
              value: 'badge',
              label: 'Badge 标记'
            }]
          }, {
            value: 'notice',
            label: 'Notice',
            children: [{
              value: 'alert',
              label: 'Alert 警告'
            }, {
              value: 'loading',
              label: 'Loading 加载'
            }, {
              value: 'message',
              label: 'Message 消息提示'
            }, {
              value: 'message-box',
              label: 'MessageBox 弹框'
            }, {
              value: 'notification',
              label: 'Notification 通知'
            }]
          }, {
            value: 'navigation',
            label: 'Navigation',
            children: [{
              value: 'menu',
              label: 'NavMenu 导航菜单'
            }, {
              value: 'tabs',
              label: 'Tabs 标签页'
            }, {
              value: 'breadcrumb',
              label: 'Breadcrumb 面包屑'
            }, {
              value: 'dropdown',
              label: 'Dropdown 下拉菜单'
            }, {
              value: 'steps',
              label: 'Steps 步骤条'
            }]
          }, {
            value: 'others',
            label: 'Others',
            children: [{
              value: 'dialog',
              label: 'Dialog 对话框'
            }, {
              value: 'tooltip',
              label: 'Tooltip 文字提示'
            }, {
              value: 'popover',
              label: 'Popover 弹出框'
            }, {
              value: 'card',
              label: 'Card 卡片'
            }, {
              value: 'carousel',
              label: 'Carousel 走马灯'
            }, {
              value: 'collapse',
              label: 'Collapse 折叠面板'
            }]
          }]
        }, {
          value: 'ziyuan',
          label: '资源',
          children: [{
            value: 'axure',
            label: 'Axure Components'
          }, {
            value: 'sketch',
            label: 'Sketch Templates'
          }, {
            value: 'jiaohu',
            label: '组件交互文档'
          }]
        }]
      };
    },
    methods: {
      handleChange(value) {
        console.log(value);
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="禁用选项"><a class="header" href="#禁用选项">禁用选项</a></h1>
<p>本例中，<code>options</code>指定的数组中的第一个元素含有<code>disabled: true</code>键值对，因此是禁用的。在默认情况下，Cascader 会检查数据中每一项的<code>disabled</code>字段是否为<code>true</code>，如果你的数据中表示禁用含义的字段名不为<code>disabled</code>，可以通过<code>props.disabled</code>属性来指定（详见下方 API 表格）。当然，<code>value</code>、<code>label</code>和<code>children</code>这三个字段名也可以通过同样的方式指定。</p>
<pre><code class="language-vue">  options: [{
          value: 'zhinan',
          label: '指南',
          disabled: true,
          children: [{
            value: 'shejiyuanze',
.,.....
</code></pre>
<h1 id="可清空"><a class="header" href="#可清空">可清空</a></h1>
<pre><code class="language-vue">&lt;el-cascader :options=&quot;options&quot; clearable&gt;&lt;/el-cascader&gt;
</code></pre>
<h1 id="仅显示最后一级"><a class="header" href="#仅显示最后一级">仅显示最后一级</a></h1>
<p>属性<code>show-all-levels</code>定义了是否显示完整的路径，将其赋值为<code>false</code>则仅显示最后一级</p>
<pre><code class="language-vue">&lt;el-cascader :options=&quot;options&quot; :show-all-levels=&quot;false&quot;&gt;&lt;/el-cascader&gt;
</code></pre>
<h1 id="多选"><a class="header" href="#多选">多选</a></h1>
<p>可通过 <code>props.multiple = true</code> 来开启多选模式</p>
<h2 id="默认显示所有tag"><a class="header" href="#默认显示所有tag">默认显示所有Tag</a></h2>
<pre><code class="language-vue">  &lt;el-cascader
    :options=&quot;options&quot;
    :props=&quot;props&quot;
    clearable&gt;&lt;/el-cascader&gt;
props: { multiple: true }
</code></pre>
<h2 id="折叠展示tag"><a class="header" href="#折叠展示tag">折叠展示Tag</a></h2>
<pre><code class="language-vue">  &lt;el-cascader
    :options=&quot;options&quot;
    :props=&quot;props&quot;
    collapse-tags
    clearable&gt;&lt;/el-cascader&gt;
props: { multiple: true }
</code></pre>
<h1 id="选择任意一级选项"><a class="header" href="#选择任意一级选项">选择任意一级选项</a></h1>
<pre><code class="language-vue">单选
&lt;el-cascader
    :options=&quot;options&quot;
    :props=&quot;{ checkStrictly: true }&quot;
    clearable&gt;&lt;/el-cascader&gt;
多选
 &lt;el-cascader
    :options=&quot;options&quot;
    :props=&quot;{ multiple: true, checkStrictly: true }&quot;
    clearable&gt;&lt;/el-cascader&gt;
</code></pre>
<h1 id="动态加载"><a class="header" href="#动态加载">动态加载</a></h1>
<p>通过<code>lazy</code>开启动态加载，并通过<code>lazyload</code>来设置加载数据源的方法。<code>lazyload</code>方法有两个参数，第一个参数<code>node</code>为当前点击的节点，第二个<code>resolve</code>为数据加载完成的回调(必须调用)。为了更准确的显示节点的状态，还可以对节点数据添加是否为叶子节点的标志位 (默认字段为<code>leaf</code>，可通过<code>props.leaf</code>修改)，否则会简单的以有无子节点来判断是否为叶子节点。</p>
<pre><code class="language-vue">&lt;el-cascader :props=&quot;props&quot;&gt;&lt;/el-cascader&gt;

&lt;script&gt;
  let id = 0;

  export default {
    data() {
      return {
        props: {
          lazy: true,
          lazyLoad (node, resolve) {
            const { level } = node;
            setTimeout(() =&gt; {
              const nodes = Array.from({ length: level + 1 })
                .map(item =&gt; ({
                  value: ++id,
                  label: `选项${id}`,
                  leaf: level &gt;= 2
                }));
              // 通过调用resolve将子节点数据返回，通知组件数据加载完成
              resolve(nodes);
            }, 1000);
          }
        }
      };
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="可搜索-2"><a class="header" href="#可搜索-2">可搜索</a></h1>
<p>将<code>filterable</code>赋值为<code>true</code>即可打开搜索功能，默认会匹配节点的<code>label</code>或所有父节点的<code>label</code>(由<code>show-all-levels</code>决定)中包含输入值的选项。你也可以用<code>filter-method</code>自定义搜索逻辑，接受一个函数，第一个参数是节点<code>node</code>，第二个参数是搜索关键词<code>keyword</code>，通过返回布尔值表示是否命中。</p>
<pre><code class="language-vue">&lt;div class=&quot;block&quot;&gt;
  &lt;span class=&quot;demonstration&quot;&gt;单选可搜索&lt;/span&gt;
  &lt;el-cascader
    placeholder=&quot;试试搜索：指南&quot;
    :options=&quot;options&quot;
    filterable&gt;&lt;/el-cascader&gt;
&lt;/div&gt;
&lt;div class=&quot;block&quot;&gt;
  &lt;span class=&quot;demonstration&quot;&gt;多选可搜索&lt;/span&gt;
  &lt;el-cascader
    placeholder=&quot;试试搜索：指南&quot;
    :options=&quot;options&quot;
    :props=&quot;{ multiple: true }&quot;
    filterable&gt;&lt;/el-cascader&gt;
&lt;/div&gt;
</code></pre>
<h1 id="自定义节点内容-1"><a class="header" href="#自定义节点内容-1">自定义节点内容</a></h1>
<p>可以通过<code>scoped slot</code>对级联选择器的备选项的节点内容进行自定义，scoped slot会传入两个字段 <code>node</code> 和 <code>data</code>，分别表示当前节点的 Node 对象和数据。</p>
<pre><code class="language-vue">&lt;el-cascader :options=&quot;options&quot;&gt;
  &lt;template slot-scope=&quot;{ node, data }&quot;&gt;
    &lt;span&gt;{{ data.label }}&lt;/span&gt;
    &lt;span v-if=&quot;!node.isLeaf&quot;&gt; ({{ data.children.length }}) &lt;/span&gt;
  &lt;/template&gt;
&lt;/el-cascader&gt;
</code></pre>
<h1 id="级联面板"><a class="header" href="#级联面板">级联面板</a></h1>
<p>级联面板是级联选择器的核心组件，与级联选择器一样，有单选、多选、动态加载等多种功能。</p>
<pre><code class="language-vue">&lt;el-cascader-panel :options=&quot;options&quot;&gt;&lt;/el-cascader-panel&gt;
</code></pre>
<h1 id="属性-事件-和方法"><a class="header" href="#属性-事件-和方法">属性 事件 和方法</a></h1>
<h2 id="cascader-attributes"><a class="header" href="#cascader-attributes">Cascader Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">选中项绑定值</td><td style="text-align: left">-</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">options</td><td style="text-align: left">可选项数据源，键名可通过 <code>Props</code> 属性配置</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">props</td><td style="text-align: left">配置选项，具体见下表</td><td style="text-align: left">object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">尺寸</td><td style="text-align: left">string</td><td style="text-align: left">medium / small / mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">placeholder</td><td style="text-align: left">输入框占位文本</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">请选择</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">clearable</td><td style="text-align: left">是否支持清空选项</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">show-all-levels</td><td style="text-align: left">输入框中是否显示选中值的完整路径</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">collapse-tags</td><td style="text-align: left">多选模式下是否折叠Tag</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">separator</td><td style="text-align: left">选项分隔符</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">斜杠' / '</td></tr>
<tr><td style="text-align: left">filterable</td><td style="text-align: left">是否可搜索选项</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">filter-method</td><td style="text-align: left">自定义搜索逻辑，第一个参数是节点<code>node</code>，第二个参数是搜索关键词<code>keyword</code>，通过返回布尔值表示是否命中</td><td style="text-align: left">function(node, keyword)</td><td style="text-align: left">-</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">debounce</td><td style="text-align: left">搜索关键词输入的去抖延迟，毫秒</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">300</td></tr>
<tr><td style="text-align: left">before-filter</td><td style="text-align: left">筛选之前的钩子，参数为输入的值，若返回 false 或者返回 Promise 且被 reject，则停止筛选</td><td style="text-align: left">function(value)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">popper-class</td><td style="text-align: left">自定义浮层类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h2 id="cascader-events"><a class="header" href="#cascader-events">Cascader Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">当选中节点变化时触发</td><td style="text-align: left">选中节点的值</td></tr>
<tr><td style="text-align: left">expand-change</td><td style="text-align: left">当展开节点发生变化时触发</td><td style="text-align: left">各父级选项值组成的数组</td></tr>
<tr><td style="text-align: left">blur</td><td style="text-align: left">当失去焦点时触发</td><td style="text-align: left">(event: Event)</td></tr>
<tr><td style="text-align: left">focus</td><td style="text-align: left">当获得焦点时触发</td><td style="text-align: left">(event: Event)</td></tr>
<tr><td style="text-align: left">visible-change</td><td style="text-align: left">下拉框出现/隐藏时触发</td><td style="text-align: left">出现则为 true，隐藏则为 false</td></tr>
<tr><td style="text-align: left">remove-tag</td><td style="text-align: left">在多选模式下，移除Tag时触发</td><td style="text-align: left">移除的Tag对应的节点的值</td></tr>
</tbody></table>
<h2 id="cascader-methods"><a class="header" href="#cascader-methods"><a href="https://element.eleme.cn/#/zh-CN/component/cascader#cascader-methods">¶</a>Cascader Methods</a></h2>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">getCheckedNodes</td><td style="text-align: left">获取选中的节点</td><td style="text-align: left">(leafOnly) 是否只是叶子节点，默认值为 <code>false</code></td></tr>
</tbody></table>
<h2 id="cascader-slots"><a class="header" href="#cascader-slots"><a href="https://element.eleme.cn/#/zh-CN/component/cascader#cascader-slots">¶</a>Cascader Slots</a></h2>
<table><thead><tr><th style="text-align: left">名称</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">-</td><td style="text-align: left">自定义备选项的节点内容，参数为 { node, data }，分别为当前节点的 Node 对象和数据</td></tr>
<tr><td style="text-align: left">empty</td><td style="text-align: left">无匹配选项时的内容</td></tr>
</tbody></table>
<h2 id="cascaderpanel-attributes"><a class="header" href="#cascaderpanel-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/cascader#cascaderpanel-attributes">¶</a>CascaderPanel Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">选中项绑定值</td><td style="text-align: left">-</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">options</td><td style="text-align: left">可选项数据源，键名可通过 <code>Props</code> 属性配置</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">props</td><td style="text-align: left">配置选项，具体见下表</td><td style="text-align: left">object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h2 id="cascaderpanel-events"><a class="header" href="#cascaderpanel-events"><a href="https://element.eleme.cn/#/zh-CN/component/cascader#cascaderpanel-events">¶</a>CascaderPanel Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">当选中节点变化时触发</td><td style="text-align: left">选中节点的值</td></tr>
<tr><td style="text-align: left">expand-change</td><td style="text-align: left">当展开节点发生变化时触发</td><td style="text-align: left">各父级选项值组成的数组</td></tr>
</tbody></table>
<h2 id="cascaderpanel-methods"><a class="header" href="#cascaderpanel-methods"><a href="https://element.eleme.cn/#/zh-CN/component/cascader#cascaderpanel-methods">¶</a>CascaderPanel Methods</a></h2>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">getCheckedNodes</td><td style="text-align: left">获取选中的节点数组</td><td style="text-align: left">(leafOnly) 是否只是叶子节点，默认值为 <code>false</code></td></tr>
<tr><td style="text-align: left">clearCheckedNodes</td><td style="text-align: left">清空选中的节点</td><td style="text-align: left">-</td></tr>
</tbody></table>
<h2 id="cascaderpanel-slots"><a class="header" href="#cascaderpanel-slots"><a href="https://element.eleme.cn/#/zh-CN/component/cascader#cascaderpanel-slots">¶</a>CascaderPanel Slots</a></h2>
<table><thead><tr><th style="text-align: left">名称</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">-</td><td style="text-align: left">自定义备选项的节点内容，参数为 { node, data }，分别为当前节点的 Node 对象和数据</td></tr>
</tbody></table>
<h2 id="props-1"><a class="header" href="#props-1">Props</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">expandTrigger</td><td style="text-align: left">次级菜单的展开方式</td><td style="text-align: left">string</td><td style="text-align: left">click / hover</td><td style="text-align: left">'click'</td></tr>
<tr><td style="text-align: left">multiple</td><td style="text-align: left">是否多选</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">checkStrictly</td><td style="text-align: left">是否严格的遵守父子节点不互相关联</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">emitPath</td><td style="text-align: left">在选中节点改变时，是否返回由该节点所在的各级菜单的值所组成的数组，若设置 false，则只返回该节点的值</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">lazy</td><td style="text-align: left">是否动态加载子节点，需与 lazyLoad 方法结合使用</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">lazyLoad</td><td style="text-align: left">加载动态数据的方法，仅在 lazy 为 true 时有效</td><td style="text-align: left">function(node, resolve)，<code>node</code>为当前点击的节点，<code>resolve</code>为数据加载完成的回调(必须调用)</td><td style="text-align: left">-</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">value</td><td style="text-align: left">指定选项的值为选项对象的某个属性值</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">'value'</td></tr>
<tr><td style="text-align: left">label</td><td style="text-align: left">指定选项标签为选项对象的某个属性值</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">'label'</td></tr>
<tr><td style="text-align: left">children</td><td style="text-align: left">指定选项的子选项为选项对象的某个属性值</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">'children'</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">指定选项的禁用为选项对象的某个属性值</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">'disabled'</td></tr>
<tr><td style="text-align: left">leaf</td><td style="text-align: left">指定选项的叶子节点的标志位为选项对象的某个属性值</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">'leaf'</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-表格"><a class="header" href="#table-表格">Table 表格</a></h1>
<p>用于展示多条结构类似的数据，可对数据进行排序、筛选、对比或其他自定义操作。</p>
<h1 id="基础表格"><a class="header" href="#基础表格">基础表格</a></h1>
<p>当<code>el-table</code>元素中注入<code>data</code>对象数组后，在<code>el-table-column</code>中用<code>prop</code>属性来对应对象中的键名即可填入数据，用<code>label</code>属性来定义表格的列名。可以使用<code>width</code>属性来定义列宽。</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;el-table
      :data=&quot;tableData&quot;
      style=&quot;width: 100%&quot;&gt;
      &lt;el-table-column
        prop=&quot;date&quot;
        label=&quot;日期&quot;
        width=&quot;180&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
        prop=&quot;name&quot;
        label=&quot;姓名&quot;
        width=&quot;180&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
        prop=&quot;address&quot;
        label=&quot;地址&quot;&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table&gt;
  &lt;/template&gt;

  &lt;script&gt;
    export default {
      data() {
        return {
          tableData: [{
            date: '2016-05-02',
            name: '王小虎',
            address: '上海市普陀区金沙江路 1518 弄'
          }, {
            date: '2016-05-04',
            name: '王小虎',
            address: '上海市普陀区金沙江路 1517 弄'
          }, {
            date: '2016-05-01',
            name: '王小虎',
            address: '上海市普陀区金沙江路 1519 弄'
          }, {
            date: '2016-05-03',
            name: '王小虎',
            address: '上海市普陀区金沙江路 1516 弄'
          }]
        }
      }
    }
  &lt;/script&gt;
</code></pre>
<h1 id="带斑马纹表格"><a class="header" href="#带斑马纹表格">带斑马纹表格</a></h1>
<p><code>stripe</code>属性可以创建带斑马纹的表格。它接受一个<code>Boolean</code>，默认为<code>false</code>，设置为<code>true</code>即为启用。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    :data=&quot;tableData&quot;
    stripe
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column
      prop=&quot;date&quot;
      label=&quot;日期&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;address&quot;
      label=&quot;地址&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;
</code></pre>
<h1 id="带边框表格"><a class="header" href="#带边框表格">带边框表格</a></h1>
<p>默认情况下，Table 组件是不具有竖直方向的边框的，如果需要，可以使用<code>border</code>属性，它接受一个<code>Boolean</code>，设置为<code>true</code>即可启用。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    :data=&quot;tableData&quot;
    border
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column
      prop=&quot;date&quot;
      label=&quot;日期&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;address&quot;
      label=&quot;地址&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;
</code></pre>
<h1 id="带状态表格"><a class="header" href="#带状态表格">带状态表格</a></h1>
<p>可将表格内容 highlight 显示，方便区分「成功、信息、警告、危险」等内容。</p>
<p>可以通过指定 Table 组件的 <code>row-class-name</code> 属性来为 Table 中的某一行添加 class，表明该行处于某种状态。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    :data=&quot;tableData&quot;
    style=&quot;width: 100%&quot;
    :row-class-name=&quot;tableRowClassName&quot;&gt;
    &lt;el-table-column
      prop=&quot;date&quot;
      label=&quot;日期&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;address&quot;
      label=&quot;地址&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;

&lt;style&gt;
  .el-table .warning-row {
    background: oldlace;
  }

  .el-table .success-row {
    background: #f0f9eb;
  }
&lt;/style&gt;

&lt;script&gt;
  export default {
    methods: {
      tableRowClassName({row, rowIndex}) {
        if (rowIndex === 1) {
          return 'warning-row';
        } else if (rowIndex === 3) {
          return 'success-row';
        }
        return '';
      }
    },
    data() {
      return {
        tableData: [{
          date: '2016-05-02',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄',
        }, {
          date: '2016-05-04',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }, {
          date: '2016-05-01',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄',
        }, {
          date: '2016-05-03',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }]
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="固定表头"><a class="header" href="#固定表头">固定表头</a></h1>
<p>纵向内容过多时，可选择固定表头。</p>
<p>只要在<code>el-table</code>元素中定义了<code>height</code>属性，即可实现固定表头的表格，而不需要额外的代码。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    :data=&quot;tableData&quot;
    height=&quot;250&quot;
    border
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column
      prop=&quot;date&quot;
      label=&quot;日期&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;address&quot;
      label=&quot;地址&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;

</code></pre>
<h1 id="固定列"><a class="header" href="#固定列">固定列</a></h1>
<p>固定列需要使用<code>fixed</code>属性，它接受 Boolean 值或者<code>left``right</code>，表示左边固定还是右边固定。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    :data=&quot;tableData&quot;
    border
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column
      fixed
      prop=&quot;date&quot;
      label=&quot;日期&quot;
      width=&quot;150&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;
      width=&quot;120&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;province&quot;
      label=&quot;省份&quot;
      width=&quot;120&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;city&quot;
      label=&quot;市区&quot;
      width=&quot;120&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;address&quot;
      label=&quot;地址&quot;
      width=&quot;300&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;zip&quot;
      label=&quot;邮编&quot;
      width=&quot;120&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      fixed=&quot;right&quot;
      label=&quot;操作&quot;
      width=&quot;100&quot;&gt;
      &lt;template slot-scope=&quot;scope&quot;&gt;
        &lt;el-button @click=&quot;handleClick(scope.row)&quot; type=&quot;text&quot; size=&quot;small&quot;&gt;查看&lt;/el-button&gt;
        &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;编辑&lt;/el-button&gt;
      &lt;/template&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;

</code></pre>
<h1 id="固定列和表头"><a class="header" href="#固定列和表头">固定列和表头</a></h1>
<p>固定列和表头可以同时使用，只需要将上述两个属性分别设置好即可。</p>
<h1 id="流体高度"><a class="header" href="#流体高度">流体高度</a></h1>
<p>当数据量动态变化时，可以为 Table 设置一个最大高度。</p>
<p>通过设置<code>max-height</code>属性为 Table 指定最大高度。此时若表格所需的高度大于最大高度，则会显示一个滚动条。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    :data=&quot;tableData&quot;
    style=&quot;width: 100%&quot;
    max-height=&quot;250&quot;&gt;
    &lt;el-table-column
      fixed
      prop=&quot;date&quot;
      label=&quot;日期&quot;
      width=&quot;150&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;
      width=&quot;120&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;province&quot;
      label=&quot;省份&quot;
      width=&quot;120&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;city&quot;
      label=&quot;市区&quot;
      width=&quot;120&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;address&quot;
      label=&quot;地址&quot;
      width=&quot;300&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;zip&quot;
      label=&quot;邮编&quot;
      width=&quot;120&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      fixed=&quot;right&quot;
      label=&quot;操作&quot;
      width=&quot;120&quot;&gt;
      &lt;template slot-scope=&quot;scope&quot;&gt;
        &lt;el-button
          @click.native.prevent=&quot;deleteRow(scope.$index, tableData)&quot;
          type=&quot;text&quot;
          size=&quot;small&quot;&gt;
          移除
        &lt;/el-button&gt;
      &lt;/template&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;
</code></pre>
<h1 id="多级表头"><a class="header" href="#多级表头">多级表头</a></h1>
<p>数据结构比较复杂的时候，可使用多级表头来展现数据的层次关系。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    :data=&quot;tableData&quot;
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column
      prop=&quot;date&quot;
      label=&quot;日期&quot;
      width=&quot;150&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column label=&quot;配送信息&quot;&gt;
      &lt;el-table-column
        prop=&quot;name&quot;
        label=&quot;姓名&quot;
        width=&quot;120&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column label=&quot;地址&quot;&gt;
        &lt;el-table-column
          prop=&quot;province&quot;
          label=&quot;省份&quot;
          width=&quot;120&quot;&gt;
        &lt;/el-table-column&gt;
        &lt;el-table-column
          prop=&quot;city&quot;
          label=&quot;市区&quot;
          width=&quot;120&quot;&gt;
        &lt;/el-table-column&gt;
        &lt;el-table-column
          prop=&quot;address&quot;
          label=&quot;地址&quot;
          width=&quot;300&quot;&gt;
        &lt;/el-table-column&gt;
        &lt;el-table-column
          prop=&quot;zip&quot;
          label=&quot;邮编&quot;
          width=&quot;120&quot;&gt;
        &lt;/el-table-column&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;
</code></pre>
<h1 id="单选"><a class="header" href="#单选">单选</a></h1>
<p>Table 组件提供了单选的支持，只需要配置<code>highlight-current-row</code>属性即可实现单选。之后由<code>current-change</code>事件来管理选中时触发的事件，它会传入<code>currentRow</code>，<code>oldCurrentRow</code>。如果需要显示索引，可以增加一列<code>el-table-column</code>，设置<code>type</code>属性为<code>index</code>即可显示从 1 开始的索引号。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    ref=&quot;singleTable&quot;
    :data=&quot;tableData&quot;
    highlight-current-row
    @current-change=&quot;handleCurrentChange&quot;
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column
      type=&quot;index&quot;
      width=&quot;50&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      property=&quot;date&quot;
      label=&quot;日期&quot;
      width=&quot;120&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      property=&quot;name&quot;
      label=&quot;姓名&quot;
      width=&quot;120&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      property=&quot;address&quot;
      label=&quot;地址&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
  &lt;div style=&quot;margin-top: 20px&quot;&gt;
    &lt;el-button @click=&quot;setCurrent(tableData[1])&quot;&gt;选中第二行&lt;/el-button&gt;
    &lt;el-button @click=&quot;setCurrent()&quot;&gt;取消选择&lt;/el-button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        tableData: [{
          date: '2016-05-02',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }, {
          date: '2016-05-04',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1517 弄'
        }, {
          date: '2016-05-01',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1519 弄'
        }, {
          date: '2016-05-03',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1516 弄'
        }],
        currentRow: null
      }
    },

    methods: {
      setCurrent(row) {
        this.$refs.singleTable.setCurrentRow(row);
      },
      handleCurrentChange(val) {
        this.currentRow = val;
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="多选-1"><a class="header" href="#多选-1">多选</a></h1>
<p>实现多选非常简单: 手动添加一个<code>el-table-column</code>，设<code>type</code>属性为<code>selection</code>即可；默认情况下若内容过多会折行显示，若需要单行显示可以使用<code>show-overflow-tooltip</code>属性，它接受一个<code>Boolean</code>，为<code>true</code>时多余的内容会在 hover 时以 tooltip 的形式显示出来。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    ref=&quot;multipleTable&quot;
    :data=&quot;tableData&quot;
    tooltip-effect=&quot;dark&quot;
    style=&quot;width: 100%&quot;
    @selection-change=&quot;handleSelectionChange&quot;&gt;
    &lt;el-table-column
      type=&quot;selection&quot;
      width=&quot;55&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      label=&quot;日期&quot;
      width=&quot;120&quot;&gt;
      &lt;template slot-scope=&quot;scope&quot;&gt;{{ scope.row.date }}&lt;/template&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;
      width=&quot;120&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;address&quot;
      label=&quot;地址&quot;
      show-overflow-tooltip&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
  &lt;div style=&quot;margin-top: 20px&quot;&gt;
    &lt;el-button @click=&quot;toggleSelection([tableData[1], tableData[2]])&quot;&gt;切换第二、第三行的选中状态&lt;/el-button&gt;
    &lt;el-button @click=&quot;toggleSelection()&quot;&gt;取消选择&lt;/el-button&gt;
  &lt;/div&gt;
&lt;/template&gt;

  methods: {
      toggleSelection(rows) {
        if (rows) {
          rows.forEach(row =&gt; {
            this.$refs.multipleTable.toggleRowSelection(row);
          });
        } else {
          this.$refs.multipleTable.clearSelection();
        }
      },
      handleSelectionChange(val) {
        this.multipleSelection = val;
      }
    }
</code></pre>
<h1 id="排序"><a class="header" href="#排序">排序</a></h1>
<p>在列中设置<code>sortable</code>属性即可实现以该列为基准的排序，接受一个<code>Boolean</code>，默认为<code>false</code>。可以通过 Table 的<code>default-sort</code>属性设置默认的排序列和排序顺序。可以使用<code>sort-method</code>或者<code>sort-by</code>使用自定义的排序规则。如果需要后端排序，需将<code>sortable</code>设置为<code>custom</code>，同时在 Table 上监听<code>sort-change</code>事件，在事件回调中可以获取当前排序的字段名和排序顺序，从而向接口请求排序后的表格数据。在本例中，我们还使用了<code>formatter</code>属性，它用于格式化指定列的值，接受一个<code>Function</code>，会传入两个参数：<code>row</code>和<code>column</code>，可以根据自己的需求进行处理。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    :data=&quot;tableData&quot;
    style=&quot;width: 100%&quot;
    :default-sort = &quot;{prop: 'date', order: 'descending'}&quot;
    &gt;
    &lt;el-table-column
      prop=&quot;date&quot;
      label=&quot;日期&quot;
      sortable
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;
      sortable
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;address&quot;
      label=&quot;地址&quot;
      :formatter=&quot;formatter&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;

  methods: {
      formatter(row, column) {
        return row.address;
      }
</code></pre>
<h1 id="筛选"><a class="header" href="#筛选">筛选</a></h1>
<p>对表格进行筛选，可快速查找到自己想看的数据。</p>
<p>在列中设置<code>filters``filter-method</code>属性即可开启该列的筛选，filters 是一个数组，<code>filter-method</code>是一个方法，它用于决定某些数据是否显示，会传入三个参数：<code>value</code>, <code>row</code> 和 <code>column</code>。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-button @click=&quot;resetDateFilter&quot;&gt;清除日期过滤器&lt;/el-button&gt;
  &lt;el-button @click=&quot;clearFilter&quot;&gt;清除所有过滤器&lt;/el-button&gt;
  &lt;el-table
    ref=&quot;filterTable&quot;
    :data=&quot;tableData&quot;
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column
      prop=&quot;date&quot;
      label=&quot;日期&quot;
      sortable
      width=&quot;180&quot;
      column-key=&quot;date&quot;
      :filters=&quot;[{text: '2016-05-01', value: '2016-05-01'}, {text: '2016-05-02', value: '2016-05-02'}, {text: '2016-05-03', value: '2016-05-03'}, {text: '2016-05-04', value: '2016-05-04'}]&quot;
      :filter-method=&quot;filterHandler&quot;
    &gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;address&quot;
      label=&quot;地址&quot;
      :formatter=&quot;formatter&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;tag&quot;
      label=&quot;标签&quot;
      width=&quot;100&quot;
      :filters=&quot;[{ text: '家', value: '家' }, { text: '公司', value: '公司' }]&quot;
      :filter-method=&quot;filterTag&quot;
      filter-placement=&quot;bottom-end&quot;&gt;
      &lt;template slot-scope=&quot;scope&quot;&gt;
        &lt;el-tag
          :type=&quot;scope.row.tag === '家' ? 'primary' : 'success'&quot;
          disable-transitions&gt;{{scope.row.tag}}&lt;/el-tag&gt;
      &lt;/template&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        tableData: [{
          date: '2016-05-02',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄',
          tag: '家'
        }, {
          date: '2016-05-04',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1517 弄',
          tag: '公司'
        }, {
          date: '2016-05-01',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1519 弄',
          tag: '家'
        }, {
          date: '2016-05-03',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1516 弄',
          tag: '公司'
        }]
      }
    },
    methods: {
      resetDateFilter() {
        this.$refs.filterTable.clearFilter('date');
      },
      clearFilter() {
        this.$refs.filterTable.clearFilter();
      },
      formatter(row, column) {
        return row.address;
      },
      filterTag(value, row) {
        return row.tag === value;
      },
      filterHandler(value, row, column) {
        const property = column['property'];
        return row[property] === value;
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="自定义列模板"><a class="header" href="#自定义列模板">自定义列模板</a></h1>
<p>通过 <code>Scoped slot</code> 可以获取到 row, column, $index 和 store（table 内部的状态管理）的数据，用法参考 demo。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    :data=&quot;tableData&quot;
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column
      label=&quot;日期&quot;
      width=&quot;180&quot;&gt;
      &lt;template slot-scope=&quot;scope&quot;&gt;
        &lt;i class=&quot;el-icon-time&quot;&gt;&lt;/i&gt;
        &lt;span style=&quot;margin-left: 10px&quot;&gt;{{ scope.row.date }}&lt;/span&gt;
      &lt;/template&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      label=&quot;姓名&quot;
      width=&quot;180&quot;&gt;
      &lt;template slot-scope=&quot;scope&quot;&gt;
        &lt;el-popover trigger=&quot;hover&quot; placement=&quot;top&quot;&gt;
          &lt;p&gt;姓名: {{ scope.row.name }}&lt;/p&gt;
          &lt;p&gt;住址: {{ scope.row.address }}&lt;/p&gt;
          &lt;div slot=&quot;reference&quot; class=&quot;name-wrapper&quot;&gt;
            &lt;el-tag size=&quot;medium&quot;&gt;{{ scope.row.name }}&lt;/el-tag&gt;
          &lt;/div&gt;
        &lt;/el-popover&gt;
      &lt;/template&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column label=&quot;操作&quot;&gt;
      &lt;template slot-scope=&quot;scope&quot;&gt;
        &lt;el-button
          size=&quot;mini&quot;
          @click=&quot;handleEdit(scope.$index, scope.row)&quot;&gt;编辑&lt;/el-button&gt;
        &lt;el-button
          size=&quot;mini&quot;
          type=&quot;danger&quot;
          @click=&quot;handleDelete(scope.$index, scope.row)&quot;&gt;删除&lt;/el-button&gt;
      &lt;/template&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        tableData: [{
          date: '2016-05-02',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1518 弄'
        }, {
          date: '2016-05-04',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1517 弄'
        }, {
          date: '2016-05-01',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1519 弄'
        }, {
          date: '2016-05-03',
          name: '王小虎',
          address: '上海市普陀区金沙江路 1516 弄'
        }]
      }
    },
    methods: {
      handleEdit(index, row) {
        console.log(index, row);
      },
      handleDelete(index, row) {
        console.log(index, row);
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="展开行"><a class="header" href="#展开行">展开行</a></h1>
<p>通过设置 type=&quot;expand&quot; 和 <code>Scoped slot</code> 可以开启展开行功能，<code>el-table-column</code> 的模板会被渲染成为展开行的内容，展开行可访问的属性与使用自定义列模板时的 <code>Scoped slot</code> 相同。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    :data=&quot;tableData&quot;
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column type=&quot;expand&quot;&gt;
      &lt;template slot-scope=&quot;props&quot;&gt;
        &lt;el-form label-position=&quot;left&quot; inline class=&quot;demo-table-expand&quot;&gt;
          &lt;el-form-item label=&quot;商品名称&quot;&gt;
            &lt;span&gt;{{ props.row.name }}&lt;/span&gt;
          &lt;/el-form-item&gt;
          &lt;el-form-item label=&quot;所属店铺&quot;&gt;
            &lt;span&gt;{{ props.row.shop }}&lt;/span&gt;
          &lt;/el-form-item&gt;
          &lt;el-form-item label=&quot;商品 ID&quot;&gt;
            &lt;span&gt;{{ props.row.id }}&lt;/span&gt;
          &lt;/el-form-item&gt;
          &lt;el-form-item label=&quot;店铺 ID&quot;&gt;
            &lt;span&gt;{{ props.row.shopId }}&lt;/span&gt;
          &lt;/el-form-item&gt;
          &lt;el-form-item label=&quot;商品分类&quot;&gt;
            &lt;span&gt;{{ props.row.category }}&lt;/span&gt;
          &lt;/el-form-item&gt;
          &lt;el-form-item label=&quot;店铺地址&quot;&gt;
            &lt;span&gt;{{ props.row.address }}&lt;/span&gt;
          &lt;/el-form-item&gt;
          &lt;el-form-item label=&quot;商品描述&quot;&gt;
            &lt;span&gt;{{ props.row.desc }}&lt;/span&gt;
          &lt;/el-form-item&gt;
        &lt;/el-form&gt;
      &lt;/template&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      label=&quot;商品 ID&quot;
      prop=&quot;id&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      label=&quot;商品名称&quot;
      prop=&quot;name&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      label=&quot;描述&quot;
      prop=&quot;desc&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;
</code></pre>
<h1 id="树形数据与懒加载"><a class="header" href="#树形数据与懒加载">树形数据与懒加载</a></h1>
<p>支持树类型的数据的显示。当 row 中包含 <code>children</code> 字段时，被视为树形数据。渲染树形数据时，必须要指定 <code>row-key</code>。支持子节点数据异步加载。设置 Table 的 <code>lazy</code> 属性为 true 与加载函数 <code>load</code> 。通过指定 row 中的 <code>hasChildren</code> 字段来指定哪些行是包含子节点。<code>children</code> 与 <code>hasChildren</code> 都可以通过 <code>tree-props</code> 配置。</p>
<pre><code class="language-vue">&lt;template&gt;
&lt;div&gt;
  &lt;el-table
    :data=&quot;tableData&quot;
    style=&quot;width: 100%;margin-bottom: 20px;&quot;
    row-key=&quot;id&quot;
    border
    default-expand-all
    :tree-props=&quot;{children: 'children', hasChildren: 'hasChildren'}&quot;&gt;
    &lt;el-table-column
      prop=&quot;date&quot;
      label=&quot;日期&quot;
      sortable
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;
      sortable
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;address&quot;
      label=&quot;地址&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;

  &lt;el-table
    :data=&quot;tableData1&quot;
    style=&quot;width: 100%&quot;
    row-key=&quot;id&quot;
    border
    lazy
    :load=&quot;load&quot;
    :tree-props=&quot;{children: 'children', hasChildren: 'hasChildren'}&quot;&gt;
    &lt;el-table-column
      prop=&quot;date&quot;
      label=&quot;日期&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;address&quot;
      label=&quot;地址&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/div&gt;
&lt;/template&gt;


 load(tree, treeNode, resolve) {
        setTimeout(() =&gt; {
          resolve([
            {
              id: 31,
              date: '2016-05-01',
              name: '王小虎',
              address: '上海市普陀区金沙江路 1519 弄'
            }, {
              id: 32,
              date: '2016-05-01',
              name: '王小虎',
              address: '上海市普陀区金沙江路 1519 弄'
            }
          ])
        }, 1000)
</code></pre>
<h1 id="自定义表头"><a class="header" href="#自定义表头">自定义表头</a></h1>
<p>通过设置 <a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">Scoped slot</a> 来自定义表头。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    :data=&quot;tableData.filter(data =&gt; !search || data.name.toLowerCase().includes(search.toLowerCase()))&quot;
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column
      label=&quot;Date&quot;
      prop=&quot;date&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      label=&quot;Name&quot;
      prop=&quot;name&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      align=&quot;right&quot;&gt;
      &lt;template slot=&quot;header&quot; slot-scope=&quot;scope&quot;&gt;
        &lt;el-input
          v-model=&quot;search&quot;
          size=&quot;mini&quot;
          placeholder=&quot;输入关键字搜索&quot;/&gt;
      &lt;/template&gt;
      &lt;template slot-scope=&quot;scope&quot;&gt;
        &lt;el-button
          size=&quot;mini&quot;
          @click=&quot;handleEdit(scope.$index, scope.row)&quot;&gt;Edit&lt;/el-button&gt;
        &lt;el-button
          size=&quot;mini&quot;
          type=&quot;danger&quot;
          @click=&quot;handleDelete(scope.$index, scope.row)&quot;&gt;Delete&lt;/el-button&gt;
      &lt;/template&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;

</code></pre>
<h1 id="表尾合计行"><a class="header" href="#表尾合计行">表尾合计行</a></h1>
<p>将<code>show-summary</code>设置为<code>true</code>就会在表格尾部展示合计行。默认情况下，对于合计行，第一列不进行数据求合操作，而是显示「合计」二字（可通过<code>sum-text</code>配置），其余列会将本列所有数值进行求合操作，并显示出来。当然，你也可以定义自己的合计逻辑。使用<code>summary-method</code>并传入一个方法，返回一个数组，这个数组中的各项就会显示在合计行的各列中，具体可以参考本例中的第二个表格。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    :data=&quot;tableData&quot;
    border
    show-summary
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column
      prop=&quot;id&quot;
      label=&quot;ID&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;amount1&quot;
      sortable
      label=&quot;数值 1&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;amount2&quot;
      sortable
      label=&quot;数值 2&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;amount3&quot;
      sortable
      label=&quot;数值 3&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;

  &lt;el-table
    :data=&quot;tableData&quot;
    border
    height=&quot;200&quot;
    :summary-method=&quot;getSummaries&quot;
    show-summary
    style=&quot;width: 100%; margin-top: 20px&quot;&gt;
    &lt;el-table-column
      prop=&quot;id&quot;
      label=&quot;ID&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;amount1&quot;
      label=&quot;数值 1（元）&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;amount2&quot;
      label=&quot;数值 2（元）&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;amount3&quot;
      label=&quot;数值 3（元）&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;

 methods: {
      getSummaries(param) {
        const { columns, data } = param;
        const sums = [];
        columns.forEach((column, index) =&gt; {
          if (index === 0) {
            sums[index] = '总价';
            return;
          }
          const values = data.map(item =&gt; Number(item[column.property]));
          if (!values.every(value =&gt; isNaN(value))) {
            sums[index] = values.reduce((prev, curr) =&gt; {
              const value = Number(curr);
              if (!isNaN(value)) {
                return prev + curr;
              } else {
                return prev;
              }
            }, 0);
            sums[index] += ' 元';
          } else {
            sums[index] = 'N/A';
          }
        });

        return sums;
      }
    }
</code></pre>
<h1 id="合并行或列"><a class="header" href="#合并行或列">合并行或列</a></h1>
<p>通过给<code>table</code>传入<code>span-method</code>方法可以实现合并行或列，方法的参数是一个对象，里面包含当前行<code>row</code>、当前列<code>column</code>、当前行号<code>rowIndex</code>、当前列号<code>columnIndex</code>四个属性。该函数可以返回一个包含两个元素的数组，第一个元素代表<code>rowspan</code>，第二个元素代表<code>colspan</code>。 也可以返回一个键名为<code>rowspan</code>和<code>colspan</code>的对象。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;el-table
      :data=&quot;tableData&quot;
      :span-method=&quot;arraySpanMethod&quot;
      border
      style=&quot;width: 100%&quot;&gt;
      &lt;el-table-column
        prop=&quot;id&quot;
        label=&quot;ID&quot;
        width=&quot;180&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
        prop=&quot;name&quot;
        label=&quot;姓名&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
        prop=&quot;amount1&quot;
        sortable
        label=&quot;数值 1&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
        prop=&quot;amount2&quot;
        sortable
        label=&quot;数值 2&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
        prop=&quot;amount3&quot;
        sortable
        label=&quot;数值 3&quot;&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table&gt;

    &lt;el-table
      :data=&quot;tableData&quot;
      :span-method=&quot;objectSpanMethod&quot;
      border
      style=&quot;width: 100%; margin-top: 20px&quot;&gt;
      &lt;el-table-column
        prop=&quot;id&quot;
        label=&quot;ID&quot;
        width=&quot;180&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
        prop=&quot;name&quot;
        label=&quot;姓名&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
        prop=&quot;amount1&quot;
        label=&quot;数值 1（元）&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
        prop=&quot;amount2&quot;
        label=&quot;数值 2（元）&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
        prop=&quot;amount3&quot;
        label=&quot;数值 3（元）&quot;&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table&gt;
  &lt;/div&gt;
&lt;/template&gt;

   methods: {
      arraySpanMethod({ row, column, rowIndex, columnIndex }) {
        if (rowIndex % 2 === 0) {
          if (columnIndex === 0) {
            return [1, 2];
          } else if (columnIndex === 1) {
            return [0, 0];
          }
        }
      },

      objectSpanMethod({ row, column, rowIndex, columnIndex }) {
        if (columnIndex === 0) {
          if (rowIndex % 2 === 0) {
            return {
              rowspan: 2,
              colspan: 1
            };
          } else {
            return {
              rowspan: 0,
              colspan: 0
            };
          }
        }
      }
</code></pre>
<h1 id="自定义索引"><a class="header" href="#自定义索引">自定义索引</a></h1>
<p>通过给 <code>type=index</code> 的列传入 <code>index</code> 属性，可以自定义索引。该属性传入数字时，将作为索引的起始值。也可以传入一个方法，它提供当前行的行号（从 <code>0</code> 开始）作为参数，返回值将作为索引展示。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-table
    :data=&quot;tableData&quot;
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column
      type=&quot;index&quot;
      :index=&quot;indexMethod&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;date&quot;
      label=&quot;日期&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;name&quot;
      label=&quot;姓名&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
      prop=&quot;address&quot;
      label=&quot;地址&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/template&gt;
  methods: {
      indexMethod(index) {
        return index * 2;
      }
    }
</code></pre>
<h1 id="属性事件和方法-27"><a class="header" href="#属性事件和方法-27">属性事件和方法</a></h1>
<h2 id="table-attributes"><a class="header" href="#table-attributes">Table Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">data</td><td style="text-align: left">显示的数据</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">height</td><td style="text-align: left">Table 的高度，默认为自动高度。如果 height 为 number 类型，单位 px；如果 height 为 string 类型，则这个高度会设置为 Table 的 style.height 的值，Table 的高度会受控于外部样式。</td><td style="text-align: left">string/number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">max-height</td><td style="text-align: left">Table 的最大高度。合法的值为数字或者单位为 px 的高度。</td><td style="text-align: left">string/number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">stripe</td><td style="text-align: left">是否为斑马纹 table</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">border</td><td style="text-align: left">是否带有纵向边框</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">Table 的尺寸</td><td style="text-align: left">string</td><td style="text-align: left">medium / small / mini</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">fit</td><td style="text-align: left">列的宽度是否自撑开</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">show-header</td><td style="text-align: left">是否显示表头</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">highlight-current-row</td><td style="text-align: left">是否要高亮当前行</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">current-row-key</td><td style="text-align: left">当前行的 key，只写属性</td><td style="text-align: left">String,Number</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">row-class-name</td><td style="text-align: left">行的 className 的回调方法，也可以使用字符串为所有行设置一个固定的 className。</td><td style="text-align: left">Function({row, rowIndex})/String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">row-style</td><td style="text-align: left">行的 style 的回调方法，也可以使用一个固定的 Object 为所有行设置一样的 Style。</td><td style="text-align: left">Function({row, rowIndex})/Object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">cell-class-name</td><td style="text-align: left">单元格的 className 的回调方法，也可以使用字符串为所有单元格设置一个固定的 className。</td><td style="text-align: left">Function({row, column, rowIndex, columnIndex})/String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">cell-style</td><td style="text-align: left">单元格的 style 的回调方法，也可以使用一个固定的 Object 为所有单元格设置一样的 Style。</td><td style="text-align: left">Function({row, column, rowIndex, columnIndex})/Object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">header-row-class-name</td><td style="text-align: left">表头行的 className 的回调方法，也可以使用字符串为所有表头行设置一个固定的 className。</td><td style="text-align: left">Function({row, rowIndex})/String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">header-row-style</td><td style="text-align: left">表头行的 style 的回调方法，也可以使用一个固定的 Object 为所有表头行设置一样的 Style。</td><td style="text-align: left">Function({row, rowIndex})/Object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">header-cell-class-name</td><td style="text-align: left">表头单元格的 className 的回调方法，也可以使用字符串为所有表头单元格设置一个固定的 className。</td><td style="text-align: left">Function({row, column, rowIndex, columnIndex})/String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">header-cell-style</td><td style="text-align: left">表头单元格的 style 的回调方法，也可以使用一个固定的 Object 为所有表头单元格设置一样的 Style。</td><td style="text-align: left">Function({row, column, rowIndex, columnIndex})/Object</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">row-key</td><td style="text-align: left">行数据的 Key，用来优化 Table 的渲染；在使用 reserve-selection 功能与显示树形数据时，该属性是必填的。类型为 String 时，支持多层访问：<code>user.info.id</code>，但不支持 <code>user.info[0].id</code>，此种情况请使用 <code>Function</code>。</td><td style="text-align: left">Function(row)/String</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">empty-text</td><td style="text-align: left">空数据时显示的文本内容，也可以通过 <code>slot=&quot;empty&quot;</code> 设置</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">暂无数据</td></tr>
<tr><td style="text-align: left">default-expand-all</td><td style="text-align: left">是否默认展开所有行，当 Table 包含展开行存在或者为树形表格时有效</td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">expand-row-keys</td><td style="text-align: left">可以通过该属性设置 Table 目前的展开行，需要设置 row-key 属性才能使用，该属性为展开行的 keys 数组。</td><td style="text-align: left">Array</td><td style="text-align: left">—</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">default-sort</td><td style="text-align: left">默认的排序列的 prop 和顺序。它的<code>prop</code>属性指定默认的排序的列，<code>order</code>指定默认排序的顺序</td><td style="text-align: left">Object</td><td style="text-align: left"><code>order</code>: ascending, descending</td><td style="text-align: left">如果只指定了<code>prop</code>, 没有指定<code>order</code>, 则默认顺序是ascending</td></tr>
<tr><td style="text-align: left">tooltip-effect</td><td style="text-align: left">tooltip <code>effect</code> 属性</td><td style="text-align: left">String</td><td style="text-align: left">dark/light</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">show-summary</td><td style="text-align: left">是否在表尾显示合计行</td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">sum-text</td><td style="text-align: left">合计行第一列的文本</td><td style="text-align: left">String</td><td style="text-align: left">—</td><td style="text-align: left">合计</td></tr>
<tr><td style="text-align: left">summary-method</td><td style="text-align: left">自定义的合计计算方法</td><td style="text-align: left">Function({ columns, data })</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">span-method</td><td style="text-align: left">合并行或列的计算方法</td><td style="text-align: left">Function({ row, column, rowIndex, columnIndex })</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">select-on-indeterminate</td><td style="text-align: left">在多选表格中，当仅有部分行被选中时，点击表头的多选框时的行为。若为 true，则选中所有行；若为 false，则取消选择所有行</td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">indent</td><td style="text-align: left">展示树形数据时，树节点的缩进</td><td style="text-align: left">Number</td><td style="text-align: left">—</td><td style="text-align: left">16</td></tr>
<tr><td style="text-align: left">lazy</td><td style="text-align: left">是否懒加载子节点数据</td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">load</td><td style="text-align: left">加载子节点数据的函数，lazy 为 true 时生效，函数第二个参数包含了节点的层级信息</td><td style="text-align: left">Function(row, treeNode, resolve)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">tree-props</td><td style="text-align: left">渲染嵌套数据的配置选项</td><td style="text-align: left">Object</td><td style="text-align: left">—</td><td style="text-align: left">{ hasChildren: 'hasChildren', children: 'children' }</td></tr>
</tbody></table>
<h2 id="table-events"><a class="header" href="#table-events"><a href="https://element.eleme.cn/#/zh-CN/component/table#table-events">¶</a>Table Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">select</td><td style="text-align: left">当用户手动勾选数据行的 Checkbox 时触发的事件</td><td style="text-align: left">selection, row</td></tr>
<tr><td style="text-align: left">select-all</td><td style="text-align: left">当用户手动勾选全选 Checkbox 时触发的事件</td><td style="text-align: left">selection</td></tr>
<tr><td style="text-align: left">selection-change</td><td style="text-align: left">当选择项发生变化时会触发该事件</td><td style="text-align: left">selection</td></tr>
<tr><td style="text-align: left">cell-mouse-enter</td><td style="text-align: left">当单元格 hover 进入时会触发该事件</td><td style="text-align: left">row, column, cell, event</td></tr>
<tr><td style="text-align: left">cell-mouse-leave</td><td style="text-align: left">当单元格 hover 退出时会触发该事件</td><td style="text-align: left">row, column, cell, event</td></tr>
<tr><td style="text-align: left">cell-click</td><td style="text-align: left">当某个单元格被点击时会触发该事件</td><td style="text-align: left">row, column, cell, event</td></tr>
<tr><td style="text-align: left">cell-dblclick</td><td style="text-align: left">当某个单元格被双击击时会触发该事件</td><td style="text-align: left">row, column, cell, event</td></tr>
<tr><td style="text-align: left">row-click</td><td style="text-align: left">当某一行被点击时会触发该事件</td><td style="text-align: left">row, column, event</td></tr>
<tr><td style="text-align: left">row-contextmenu</td><td style="text-align: left">当某一行被鼠标右键点击时会触发该事件</td><td style="text-align: left">row, column, event</td></tr>
<tr><td style="text-align: left">row-dblclick</td><td style="text-align: left">当某一行被双击时会触发该事件</td><td style="text-align: left">row, column, event</td></tr>
<tr><td style="text-align: left">header-click</td><td style="text-align: left">当某一列的表头被点击时会触发该事件</td><td style="text-align: left">column, event</td></tr>
<tr><td style="text-align: left">header-contextmenu</td><td style="text-align: left">当某一列的表头被鼠标右键点击时触发该事件</td><td style="text-align: left">column, event</td></tr>
<tr><td style="text-align: left">sort-change</td><td style="text-align: left">当表格的排序条件发生变化的时候会触发该事件</td><td style="text-align: left">{ column, prop, order }</td></tr>
<tr><td style="text-align: left">filter-change</td><td style="text-align: left">当表格的筛选条件发生变化的时候会触发该事件，参数的值是一个对象，对象的 key 是 column 的 columnKey，对应的 value 为用户选择的筛选条件的数组。</td><td style="text-align: left">filters</td></tr>
<tr><td style="text-align: left">current-change</td><td style="text-align: left">当表格的当前行发生变化的时候会触发该事件，如果要高亮当前行，请打开表格的 highlight-current-row 属性</td><td style="text-align: left">currentRow, oldCurrentRow</td></tr>
<tr><td style="text-align: left">header-dragend</td><td style="text-align: left">当拖动表头改变了列的宽度的时候会触发该事件</td><td style="text-align: left">newWidth, oldWidth, column, event</td></tr>
<tr><td style="text-align: left">expand-change</td><td style="text-align: left">当用户对某一行展开或者关闭的时候会触发该事件（展开行时，回调的第二个参数为 expandedRows；树形表格时第二参数为 expanded）</td><td style="text-align: left">row, (expandedRows | expanded)</td></tr>
</tbody></table>
<h2 id="table-methods"><a class="header" href="#table-methods"><a href="https://element.eleme.cn/#/zh-CN/component/table#table-methods">¶</a>Table Methods</a></h2>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">clearSelection</td><td style="text-align: left">用于多选表格，清空用户的选择</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">toggleRowSelection</td><td style="text-align: left">用于多选表格，切换某一行的选中状态，如果使用了第二个参数，则是设置这一行选中与否（selected 为 true 则选中）</td><td style="text-align: left">row, selected</td></tr>
<tr><td style="text-align: left">toggleAllSelection</td><td style="text-align: left">用于多选表格，切换所有行的选中状态</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">toggleRowExpansion</td><td style="text-align: left">用于可展开表格与树形表格，切换某一行的展开状态，如果使用了第二个参数，则是设置这一行展开与否（expanded 为 true 则展开）</td><td style="text-align: left">row, expanded</td></tr>
<tr><td style="text-align: left">setCurrentRow</td><td style="text-align: left">用于单选表格，设定某一行为选中行，如果调用时不加参数，则会取消目前高亮行的选中状态。</td><td style="text-align: left">row</td></tr>
<tr><td style="text-align: left">clearSort</td><td style="text-align: left">用于清空排序条件，数据会恢复成未排序的状态</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">clearFilter</td><td style="text-align: left">不传入参数时用于清空所有过滤条件，数据会恢复成未过滤的状态，也可传入由columnKey组成的数组以清除指定列的过滤条件</td><td style="text-align: left">columnKey</td></tr>
<tr><td style="text-align: left">doLayout</td><td style="text-align: left">对 Table 进行重新布局。当 Table 或其祖先元素由隐藏切换为显示时，可能需要调用此方法</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">sort</td><td style="text-align: left">手动对 Table 进行排序。参数<code>prop</code>属性指定排序列，<code>order</code>指定排序顺序。</td><td style="text-align: left">prop: string, order: string</td></tr>
</tbody></table>
<h2 id="table-slot"><a class="header" href="#table-slot"><a href="https://element.eleme.cn/#/zh-CN/component/table#table-slot">¶</a>Table Slot</a></h2>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">append</td><td style="text-align: left">插入至表格最后一行之后的内容，如果需要对表格的内容进行无限滚动操作，可能需要用到这个 slot。若表格有合计行，该 slot 会位于合计行之上。</td></tr>
</tbody></table>
<h2 id="table-column-attributes"><a class="header" href="#table-column-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/table#table-column-attributes">¶</a>Table-column Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">type</td><td style="text-align: left">对应列的类型。如果设置了 <code>selection</code> 则显示多选框；如果设置了 <code>index</code> 则显示该行的索引（从 1 开始计算）；如果设置了 <code>expand</code> 则显示为一个可展开的按钮</td><td style="text-align: left">string</td><td style="text-align: left">selection/index/expand</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">index</td><td style="text-align: left">如果设置了 <code>type=index</code>，可以通过传递 <code>index</code> 属性来自定义索引</td><td style="text-align: left">number, Function(index)</td><td style="text-align: left">-</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">column-key</td><td style="text-align: left">column 的 key，如果需要使用 filter-change 事件，则需要此属性标识是哪个 column 的筛选条件</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">label</td><td style="text-align: left">显示的标题</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">prop</td><td style="text-align: left">对应列内容的字段名，也可以使用 property 属性</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">width</td><td style="text-align: left">对应列的宽度</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">min-width</td><td style="text-align: left">对应列的最小宽度，与 width 的区别是 width 是固定的，min-width 会把剩余宽度按比例分配给设置了 min-width 的列</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">fixed</td><td style="text-align: left">列是否固定在左侧或者右侧，true 表示固定在左侧</td><td style="text-align: left">string, boolean</td><td style="text-align: left">true, left, right</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">render-header</td><td style="text-align: left">列标题 Label 区域渲染使用的 Function</td><td style="text-align: left">Function(h, { column, $index })</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">sortable</td><td style="text-align: left">对应列是否可以排序，如果设置为 'custom'，则代表用户希望远程排序，需要监听 Table 的 sort-change 事件</td><td style="text-align: left">boolean, string</td><td style="text-align: left">true, false, 'custom'</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">sort-method</td><td style="text-align: left">对数据进行排序的时候使用的方法，仅当 sortable 设置为 true 的时候有效，需返回一个数字，和 Array.sort 表现一致</td><td style="text-align: left">Function(a, b)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">sort-by</td><td style="text-align: left">指定数据按照哪个属性进行排序，仅当 sortable 设置为 true 且没有设置 sort-method 的时候有效。如果 sort-by 为数组，则先按照第 1 个属性排序，如果第 1 个相等，再按照第 2 个排序，以此类推</td><td style="text-align: left">String/Array/Function(row, index)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">sort-orders</td><td style="text-align: left">数据在排序时所使用排序策略的轮转顺序，仅当 sortable 为 true 时有效。需传入一个数组，随着用户点击表头，该列依次按照数组中元素的顺序进行排序</td><td style="text-align: left">array</td><td style="text-align: left">数组中的元素需为以下三者之一：<code>ascending</code> 表示升序，<code>descending</code> 表示降序，<code>null</code> 表示还原为原始顺序</td><td style="text-align: left">['ascending', 'descending', null]</td></tr>
<tr><td style="text-align: left">resizable</td><td style="text-align: left">对应列是否可以通过拖动改变宽度（需要在 el-table 上设置 border 属性为真）</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">formatter</td><td style="text-align: left">用来格式化内容</td><td style="text-align: left">Function(row, column, cellValue, index)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">show-overflow-tooltip</td><td style="text-align: left">当内容过长被隐藏时显示 tooltip</td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">align</td><td style="text-align: left">对齐方式</td><td style="text-align: left">String</td><td style="text-align: left">left/center/right</td><td style="text-align: left">left</td></tr>
<tr><td style="text-align: left">header-align</td><td style="text-align: left">表头对齐方式，若不设置该项，则使用表格的对齐方式</td><td style="text-align: left">String</td><td style="text-align: left">left/center/right</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">class-name</td><td style="text-align: left">列的 className</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">label-class-name</td><td style="text-align: left">当前列标题的自定义类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">selectable</td><td style="text-align: left">仅对 type=selection 的列有效，类型为 Function，Function 的返回值用来决定这一行的 CheckBox 是否可以勾选</td><td style="text-align: left">Function(row, index)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">reserve-selection</td><td style="text-align: left">仅对 type=selection 的列有效，类型为 Boolean，为 true 则会在数据更新之后保留之前选中的数据（需指定 <code>row-key</code>）</td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">filters</td><td style="text-align: left">数据过滤的选项，数组格式，数组中的元素需要有 text 和 value 属性。</td><td style="text-align: left">Array[{ text, value }]</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">filter-placement</td><td style="text-align: left">过滤弹出框的定位</td><td style="text-align: left">String</td><td style="text-align: left">与 Tooltip 的 <code>placement</code> 属性相同</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">filter-multiple</td><td style="text-align: left">数据过滤的选项是否多选</td><td style="text-align: left">Boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">filter-method</td><td style="text-align: left">数据过滤使用的方法，如果是多选的筛选项，对每一条数据会执行多次，任意一次返回 true 就会显示。</td><td style="text-align: left">Function(value, row, column)</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">filtered-value</td><td style="text-align: left">选中的数据过滤项，如果需要自定义表头过滤的渲染方式，可能会需要此属性。</td><td style="text-align: left">Array</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h2 id="table-column-scoped-slot"><a class="header" href="#table-column-scoped-slot"><a href="https://element.eleme.cn/#/zh-CN/component/table#table-column-scoped-slot">¶</a>Table-column Scoped Slot</a></h2>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">—</td><td style="text-align: left">自定义列的内容，参数为 { row, column, $index }</td></tr>
<tr><td style="text-align: left">header</td><td style="text-align: left">自定义表头的内容. 参数为 { column, $index }</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础用法-26"><a class="header" href="#基础用法-26">基础用法</a></h1>
<p>评分默认被分为三个等级，可以利用颜色数组对分数及情感倾向进行分级（默认情况下不区分颜色）。三个等级所对应的颜色用<code>colors</code>属性设置，而它们对应的两个阈值则通过 <code>low-threshold</code> 和 <code>high-threshold</code> 设定。你也可以通过传入颜色对象来自定义分段，键名为分段的界限值，键值为对应的颜色。</p>
<pre><code class="language-vue">&lt;div class=&quot;block&quot;&gt;
  &lt;span class=&quot;demonstration&quot;&gt;默认不区分颜色&lt;/span&gt;
  &lt;el-rate v-model=&quot;value1&quot;&gt;&lt;/el-rate&gt;
&lt;/div&gt;
&lt;div class=&quot;block&quot;&gt;
  &lt;span class=&quot;demonstration&quot;&gt;区分颜色&lt;/span&gt;
  &lt;el-rate
    v-model=&quot;value2&quot;
    :colors=&quot;colors&quot;&gt;
  &lt;/el-rate&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value1: null,
        value2: null,
        colors: ['#99A9BF', '#F7BA2A', '#FF9900']  // 等同于 { 2: '#99A9BF', 4: { value: '#F7BA2A', excluded: true }, 5: '#FF9900' }
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="辅助文字"><a class="header" href="#辅助文字">辅助文字</a></h1>
<p>用辅助文字直接地表达对应分数</p>
<p>为组件设置 <code>show-text</code> 属性会在右侧显示辅助文字。通过设置 <code>texts</code> 可以为每一个分值指定对应的辅助文字。<code>texts</code> 为一个数组，长度应等于最大值 <code>max</code>。</p>
<pre><code class="language-vue">&lt;el-rate
  v-model=&quot;value&quot;
  show-text&gt;
&lt;/el-rate&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value: null
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="其它-icon"><a class="header" href="#其它-icon">其它 icon</a></h1>
<p>设置<code>icon-classes</code>属性可以自定义不同分段的图标。若传入数组，共有 3 个元素，为 3 个分段所对应的类名；若传入对象，可自定义分段，键名为分段的界限值，键值为对应的类名。本例还使用<code>void-icon-class</code>指定了未选中时的图标类名。</p>
<pre><code class="language-vue">&lt;el-rate
  v-model=&quot;value&quot;
  :icon-classes=&quot;iconClasses&quot;
  void-icon-class=&quot;icon-rate-face-off&quot;
  :colors=&quot;['#99A9BF', '#F7BA2A', '#FF9900']&quot;&gt;
&lt;/el-rate&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value: null,
        iconClasses: ['icon-rate-face-1', 'icon-rate-face-2', 'icon-rate-face-3'] // 等同于 { 2: 'icon-rate-face-1', 4: { value: 'icon-rate-face-2', excluded: true }, 5: 'icon-rate-face-3' }
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="只读"><a class="header" href="#只读">只读</a></h1>
<p>只读的评分用来展示分数，允许出现半星</p>
<p>为组件设置 <code>disabled</code> 属性表示组件为只读，支持小数分值。此时若设置 <code>show-score</code>，则会在右侧显示目前的分值。可以提供 <code>score-template</code> 作为显示模板，模板为一个包含了 <code>{value}</code> 的字符串，<code>{value}</code> 会被解析为分值。</p>
<pre><code class="language-vue">&lt;el-rate
  v-model=&quot;value&quot;
  disabled
  show-score
  text-color=&quot;#ff9900&quot;
  score-template=&quot;{value}&quot;&gt;
&lt;/el-rate&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        value: 3.7
      }
    }
  }
&lt;/script&gt;

</code></pre>
<h1 id="属性事件和方法-28"><a class="header" href="#属性事件和方法-28">属性事件和方法</a></h1>
<h2 id="attributes-25"><a class="header" href="#attributes-25">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">max</td><td style="text-align: left">最大分值</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">5</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否为只读</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">allow-half</td><td style="text-align: left">是否允许半选</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">low-threshold</td><td style="text-align: left">低分和中等分数的界限值，值本身被划分在低分中</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">2</td></tr>
<tr><td style="text-align: left">high-threshold</td><td style="text-align: left">高分和中等分数的界限值，值本身被划分在高分中</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">4</td></tr>
<tr><td style="text-align: left">colors</td><td style="text-align: left">icon 的颜色。若传入数组，共有 3 个元素，为 3 个分段所对应的颜色；若传入对象，可自定义分段，键名为分段的界限值，键值为对应的颜色</td><td style="text-align: left">array/object</td><td style="text-align: left">—</td><td style="text-align: left">['#F7BA2A', '#F7BA2A', '#F7BA2A']</td></tr>
<tr><td style="text-align: left">void-color</td><td style="text-align: left">未选中 icon 的颜色</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">#C6D1DE</td></tr>
<tr><td style="text-align: left">disabled-void-color</td><td style="text-align: left">只读时未选中 icon 的颜色</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">#EFF2F7</td></tr>
<tr><td style="text-align: left">icon-classes</td><td style="text-align: left">icon 的类名。若传入数组，共有 3 个元素，为 3 个分段所对应的类名；若传入对象，可自定义分段，键名为分段的界限值，键值为对应的类名</td><td style="text-align: left">array/object</td><td style="text-align: left">—</td><td style="text-align: left">['el-icon-star-on', 'el-icon-star-on','el-icon-star-on']</td></tr>
<tr><td style="text-align: left">void-icon-class</td><td style="text-align: left">未选中 icon 的类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">el-icon-star-off</td></tr>
<tr><td style="text-align: left">disabled-void-icon-class</td><td style="text-align: left">只读时未选中 icon 的类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">el-icon-star-on</td></tr>
<tr><td style="text-align: left">show-text</td><td style="text-align: left">是否显示辅助文字，若为真，则会从 texts 数组中选取当前分数对应的文字内容</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">show-score</td><td style="text-align: left">是否显示当前分数，show-score 和 show-text 不能同时为真</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">text-color</td><td style="text-align: left">辅助文字的颜色</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">#1F2D3D</td></tr>
<tr><td style="text-align: left">texts</td><td style="text-align: left">辅助文字数组</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">['极差', '失望', '一般', '满意', '惊喜']</td></tr>
<tr><td style="text-align: left">score-template</td><td style="text-align: left">分数显示模板</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">{value}</td></tr>
</tbody></table>
<h2 id="events-18"><a class="header" href="#events-18"><a href="https://element.eleme.cn/#/zh-CN/component/rate#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">分值改变时触发</td><td style="text-align: left">改变后的分值</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carousel-走马灯"><a class="header" href="#carousel-走马灯">Carousel 走马灯</a></h1>
<p>在有限空间内，循环播放同一类型的图片、文字等内容</p>
<h1 id="基础用法-27"><a class="header" href="#基础用法-27">基础用法</a></h1>
<p>结合使用<code>el-carousel</code>和<code>el-carousel-item</code>标签就得到了一个走马灯。幻灯片的内容是任意的，需要放在<code>el-carousel-item</code>标签中。默认情况下，在鼠标 hover 底部的指示器时就会触发切换。通过设置<code>trigger</code>属性为<code>click</code>，可以达到点击触发的效果。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;默认 Hover 指示器触发&lt;/span&gt;
    &lt;el-carousel height=&quot;150px&quot;&gt;
      &lt;el-carousel-item v-for=&quot;item in 4&quot; :key=&quot;item&quot;&gt;
        &lt;h3 class=&quot;small&quot;&gt;{{ item }}&lt;/h3&gt;
      &lt;/el-carousel-item&gt;
    &lt;/el-carousel&gt;
  &lt;/div&gt;
  &lt;div class=&quot;block&quot;&gt;
    &lt;span class=&quot;demonstration&quot;&gt;Click 指示器触发&lt;/span&gt;
    &lt;el-carousel trigger=&quot;click&quot; height=&quot;150px&quot;&gt;
      &lt;el-carousel-item v-for=&quot;item in 4&quot; :key=&quot;item&quot;&gt;
        &lt;h3 class=&quot;small&quot;&gt;{{ item }}&lt;/h3&gt;
      &lt;/el-carousel-item&gt;
    &lt;/el-carousel&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style&gt;
  .el-carousel__item h3 {
    color: #475669;
    font-size: 14px;
    opacity: 0.75;
    line-height: 150px;
    margin: 0;
  }

  .el-carousel__item:nth-child(2n) {
     background-color: #99a9bf;
  }
  
  .el-carousel__item:nth-child(2n+1) {
     background-color: #d3dce6;
  }
&lt;/style&gt;
</code></pre>
<h1 id="指示器"><a class="header" href="#指示器">指示器</a></h1>
<p>可以将指示器的显示位置设置在容器外部</p>
<p><code>indicator-position</code>属性定义了指示器的位置。默认情况下，它会显示在走马灯内部，设置为<code>outside</code>则会显示在外部；设置为<code>none</code>则不会显示指示器。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-carousel indicator-position=&quot;outside&quot;&gt;
    &lt;el-carousel-item v-for=&quot;item in 4&quot; :key=&quot;item&quot;&gt;
      &lt;h3&gt;{{ item }}&lt;/h3&gt;
    &lt;/el-carousel-item&gt;
  &lt;/el-carousel&gt;
&lt;/template&gt;

&lt;style&gt;
  .el-carousel__item h3 {
    color: #475669;
    font-size: 18px;
    opacity: 0.75;
    line-height: 300px;
    margin: 0;
  }
  
  .el-carousel__item:nth-child(2n) {
    background-color: #99a9bf;
  }
  
  .el-carousel__item:nth-child(2n+1) {
    background-color: #d3dce6;
  }
&lt;/style&gt;
</code></pre>
<h1 id="切换箭头"><a class="header" href="#切换箭头">切换箭头</a></h1>
<p>可以设置切换箭头的显示时机</p>
<p><code>arrow</code>属性定义了切换箭头的显示时机。默认情况下，切换箭头只有在鼠标 hover 到走马灯上时才会显示；若将<code>arrow</code>设置为<code>always</code>，则会一直显示；设置为<code>never</code>，则会一直隐藏。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-carousel :interval=&quot;5000&quot; arrow=&quot;always&quot;&gt;
    &lt;el-carousel-item v-for=&quot;item in 4&quot; :key=&quot;item&quot;&gt;
      &lt;h3&gt;{{ item }}&lt;/h3&gt;
    &lt;/el-carousel-item&gt;
  &lt;/el-carousel&gt;
&lt;/template&gt;

&lt;style&gt;
  .el-carousel__item h3 {
    color: #475669;
    font-size: 18px;
    opacity: 0.75;
    line-height: 300px;
    margin: 0;
  }
  
  .el-carousel__item:nth-child(2n) {
    background-color: #99a9bf;
  }
  
  .el-carousel__item:nth-child(2n+1) {
    background-color: #d3dce6;
  }
&lt;/style&gt;
</code></pre>
<h1 id="卡片化-1"><a class="header" href="#卡片化-1">卡片化</a></h1>
<p>将<code>type</code>属性设置为<code>card</code>即可启用卡片模式。从交互上来说，卡片模式和一般模式的最大区别在于，可以通过直接点击两侧的幻灯片进行切换。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-carousel :interval=&quot;4000&quot; type=&quot;card&quot; height=&quot;200px&quot;&gt;
    &lt;el-carousel-item v-for=&quot;item in 6&quot; :key=&quot;item&quot;&gt;
      &lt;h3 class=&quot;medium&quot;&gt;{{ item }}&lt;/h3&gt;
    &lt;/el-carousel-item&gt;
  &lt;/el-carousel&gt;
&lt;/template&gt;

&lt;style&gt;
  .el-carousel__item h3 {
    color: #475669;
    font-size: 14px;
    opacity: 0.75;
    line-height: 200px;
    margin: 0;
  }
  
  .el-carousel__item:nth-child(2n) {
    background-color: #99a9bf;
  }
  
  .el-carousel__item:nth-child(2n+1) {
    background-color: #d3dce6;
  }
&lt;/style&gt;
</code></pre>
<h1 id="方向"><a class="header" href="#方向">方向</a></h1>
<p>默认情况下，<code>direction</code> 为 <code>horizontal</code>。通过设置 <code>direction</code> 为 <code>vertical</code> 来让走马灯在垂直方向上显示。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;el-carousel height=&quot;200px&quot; direction=&quot;vertical&quot; :autoplay=&quot;false&quot;&gt;
    &lt;el-carousel-item v-for=&quot;item in 3&quot; :key=&quot;item&quot;&gt;
      &lt;h3 class=&quot;medium&quot;&gt;{{ item }}&lt;/h3&gt;
    &lt;/el-carousel-item&gt;
  &lt;/el-carousel&gt;
&lt;/template&gt;

&lt;style&gt;
  .el-carousel__item h3 {
    color: #475669;
    font-size: 14px;
    opacity: 0.75;
    line-height: 200px;
    margin: 0;
  }
  
  .el-carousel__item:nth-child(2n) {
    background-color: #99a9bf;
  }
  
  .el-carousel__item:nth-child(2n+1) {
    background-color: #d3dce6;
  }
&lt;/style&gt;
</code></pre>
<h1 id="属性事件和方法-29"><a class="header" href="#属性事件和方法-29">属性事件和方法</a></h1>
<h2 id="carousel-attributes"><a class="header" href="#carousel-attributes">Carousel Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">height</td><td style="text-align: left">走马灯的高度</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">initial-index</td><td style="text-align: left">初始状态激活的幻灯片的索引，从 0 开始</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">trigger</td><td style="text-align: left">指示器的触发方式</td><td style="text-align: left">string</td><td style="text-align: left">click</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">autoplay</td><td style="text-align: left">是否自动切换</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">interval</td><td style="text-align: left">自动切换的时间间隔，单位为毫秒</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">3000</td></tr>
<tr><td style="text-align: left">indicator-position</td><td style="text-align: left">指示器的位置</td><td style="text-align: left">string</td><td style="text-align: left">outside/none</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">arrow</td><td style="text-align: left">切换箭头的显示时机</td><td style="text-align: left">string</td><td style="text-align: left">always/hover/never</td><td style="text-align: left">hover</td></tr>
<tr><td style="text-align: left">type</td><td style="text-align: left">走马灯的类型</td><td style="text-align: left">string</td><td style="text-align: left">card</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">loop</td><td style="text-align: left">是否循环显示</td><td style="text-align: left">boolean</td><td style="text-align: left">-</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">direction</td><td style="text-align: left">走马灯展示的方向</td><td style="text-align: left">string</td><td style="text-align: left">horizontal/vertical</td><td style="text-align: left">horizontal</td></tr>
</tbody></table>
<h2 id="carousel-events"><a class="header" href="#carousel-events"><a href="https://element.eleme.cn/#/zh-CN/component/carousel#carousel-events">¶</a>Carousel Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">幻灯片切换时触发</td><td style="text-align: left">目前激活的幻灯片的索引，原幻灯片的索引</td></tr>
</tbody></table>
<h2 id="carousel-methods"><a class="header" href="#carousel-methods"><a href="https://element.eleme.cn/#/zh-CN/component/carousel#carousel-methods">¶</a>Carousel Methods</a></h2>
<table><thead><tr><th style="text-align: left">方法名</th><th style="text-align: left">说明</th><th style="text-align: left">参数</th></tr></thead><tbody>
<tr><td style="text-align: left">setActiveItem</td><td style="text-align: left">手动切换幻灯片</td><td style="text-align: left">需要切换的幻灯片的索引，从 0 开始；或相应 <code>el-carousel-item</code> 的 <code>name</code> 属性值</td></tr>
<tr><td style="text-align: left">prev</td><td style="text-align: left">切换至上一张幻灯片</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">next</td><td style="text-align: left">切换至下一张幻灯片</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h2 id="carousel-item-attributes"><a class="header" href="#carousel-item-attributes"><a href="https://element.eleme.cn/#/zh-CN/component/carousel#carousel-item-attributes">¶</a>Carousel-Item Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">name</td><td style="text-align: left">幻灯片的名字，可用作 <code>setActiveItem</code> 的参数</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">label</td><td style="text-align: left">该幻灯片所对应指示器的文本</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="progress-进度条"><a class="header" href="#progress-进度条">Progress 进度条</a></h1>
<p>用于展示操作进度，告知用户当前状态和预期。</p>
<h1 id="线形进度条"><a class="header" href="#线形进度条">线形进度条</a></h1>
<p>Progress 组件设置<code>percentage</code>属性即可，表示进度条对应的百分比，<strong>必填</strong>，必须在 0-100。通过 <code>format</code> 属性来指定进度条文字内容。</p>
<pre><code class="language-vue">&lt;el-progress :percentage=&quot;50&quot;&gt;&lt;/el-progress&gt;
&lt;el-progress :percentage=&quot;100&quot; :format=&quot;format&quot;&gt;&lt;/el-progress&gt;
&lt;el-progress :percentage=&quot;100&quot; status=&quot;success&quot;&gt;&lt;/el-progress&gt;
&lt;el-progress :percentage=&quot;100&quot; status=&quot;warning&quot;&gt;&lt;/el-progress&gt;
&lt;el-progress :percentage=&quot;50&quot; status=&quot;exception&quot;&gt;&lt;/el-progress&gt;

&lt;script&gt;
  export default {
    methods: {
      format(percentage) {
        return percentage === 100 ? '满' : `${percentage}%`;
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="百分比内显"><a class="header" href="#百分比内显">百分比内显</a></h1>
<p>Progress 组件可通过 <code>stroke-width</code> 属性更改进度条的高度，并可通过 <code>text-inside</code> 属性来将进度条描述置于进度条内部。</p>
<pre><code class="language-vue">&lt;el-progress :text-inside=&quot;true&quot; :stroke-width=&quot;26&quot; :percentage=&quot;70&quot;&gt;&lt;/el-progress&gt;
&lt;el-progress :text-inside=&quot;true&quot; :stroke-width=&quot;24&quot; :percentage=&quot;100&quot; status=&quot;success&quot;&gt;&lt;/el-progress&gt;
&lt;el-progress :text-inside=&quot;true&quot; :stroke-width=&quot;22&quot; :percentage=&quot;80&quot; status=&quot;warning&quot;&gt;&lt;/el-progress&gt;
&lt;el-progress :text-inside=&quot;true&quot; :stroke-width=&quot;20&quot; :percentage=&quot;50&quot; status=&quot;exception&quot;&gt;&lt;/el-progress
</code></pre>
<h1 id="自定义颜色"><a class="header" href="#自定义颜色">自定义颜色</a></h1>
<pre><code class="language-vue">el-progress :percentage=&quot;percentage&quot; :color=&quot;customColor&quot;&gt;&lt;/el-progress&gt;

&lt;el-progress :percentage=&quot;percentage&quot; :color=&quot;customColorMethod&quot;&gt;&lt;/el-progress&gt;

&lt;el-progress :percentage=&quot;percentage&quot; :color=&quot;customColors&quot;&gt;&lt;/el-progress&gt;
&lt;div&gt;
  &lt;el-button-group&gt;
    &lt;el-button icon=&quot;el-icon-minus&quot; @click=&quot;decrease&quot;&gt;&lt;/el-button&gt;
    &lt;el-button icon=&quot;el-icon-plus&quot; @click=&quot;increase&quot;&gt;&lt;/el-button&gt;
  &lt;/el-button-group&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        percentage: 20,
        customColor: '#409eff',
        customColors: [
          {color: '#f56c6c', percentage: 20},
          {color: '#e6a23c', percentage: 40},
          {color: '#5cb87a', percentage: 60},
          {color: '#1989fa', percentage: 80},
          {color: '#6f7ad3', percentage: 100}
        ]
      };
    },
    methods: {
      customColorMethod(percentage) {
        if (percentage &lt; 30) {
          return '#909399';
        } else if (percentage &lt; 70) {
          return '#e6a23c';
        } else {
          return '#67c23a';
        }
      },
      increase() {
        this.percentage += 10;
        if (this.percentage &gt; 100) {
          this.percentage = 100;
        }
      },
      decrease() {
        this.percentage -= 10;
        if (this.percentage &lt; 0) {
          this.percentage = 0;
        }
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="环形进度条"><a class="header" href="#环形进度条">环形进度条</a></h1>
<p>Progress 组件可通过 <code>type</code> 属性来指定使用环形进度条，在环形进度条中，还可以通过 <code>width</code> 属性来设置其大小。</p>
<pre><code class="language-vue">&lt;el-progress type=&quot;circle&quot; :percentage=&quot;0&quot;&gt;&lt;/el-progress&gt;
&lt;el-progress type=&quot;circle&quot; :percentage=&quot;25&quot;&gt;&lt;/el-progress&gt;
&lt;el-progress type=&quot;circle&quot; :percentage=&quot;100&quot; status=&quot;success&quot;&gt;&lt;/el-progress&gt;
&lt;el-progress type=&quot;circle&quot; :percentage=&quot;70&quot; status=&quot;warning&quot;&gt;&lt;/el-progress&gt;
&lt;el-progress type=&quot;circle&quot; :percentage=&quot;50&quot; status=&quot;exception&quot;&gt;&lt;/el-progress&gt;
</code></pre>
<h1 id="仪表盘形进度条"><a class="header" href="#仪表盘形进度条">仪表盘形进度条</a></h1>
<p>通过 <code>type</code> 属性来指定使用仪表盘形进度条。</p>
<pre><code class="language-vue">&lt;el-progress type=&quot;dashboard&quot; :percentage=&quot;percentage&quot; :color=&quot;colors&quot;&gt;&lt;/el-progress&gt;
&lt;div&gt;
  &lt;el-button-group&gt;
    &lt;el-button icon=&quot;el-icon-minus&quot; @click=&quot;decrease&quot;&gt;&lt;/el-button&gt;
    &lt;el-button icon=&quot;el-icon-plus&quot; @click=&quot;increase&quot;&gt;&lt;/el-button&gt;
  &lt;/el-button-group&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        percentage: 10,
        colors: [
          {color: '#f56c6c', percentage: 20},
          {color: '#e6a23c', percentage: 40},
          {color: '#5cb87a', percentage: 60},
          {color: '#1989fa', percentage: 80},
          {color: '#6f7ad3', percentage: 100}
        ]
      };
    },
    methods: {
      increase() {
        this.percentage += 10;
        if (this.percentage &gt; 100) {
          this.percentage = 100;
        }
      },
      decrease() {
        this.percentage -= 10;
        if (this.percentage &lt; 0) {
          this.percentage = 0;
        }
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h1 id="属性事件和方法-30"><a class="header" href="#属性事件和方法-30">属性事件和方法</a></h1>
<h2 id="attributes-26"><a class="header" href="#attributes-26">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>percentage</strong></td><td style="text-align: left"><strong>百分比（必填）</strong></td><td style="text-align: left">number</td><td style="text-align: left">0-100</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">type</td><td style="text-align: left">进度条类型</td><td style="text-align: left">string</td><td style="text-align: left">line/circle/dashboard</td><td style="text-align: left">line</td></tr>
<tr><td style="text-align: left">stroke-width</td><td style="text-align: left">进度条的宽度，单位 px</td><td style="text-align: left">number</td><td style="text-align: left">—</td><td style="text-align: left">6</td></tr>
<tr><td style="text-align: left">text-inside</td><td style="text-align: left">进度条显示文字内置在进度条内（只在 type=line 时可用）</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">status</td><td style="text-align: left">进度条当前状态</td><td style="text-align: left">string</td><td style="text-align: left">success/exception/warning</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">color</td><td style="text-align: left">进度条背景色（会覆盖 status 状态颜色）</td><td style="text-align: left">string/function/array</td><td style="text-align: left">—</td><td style="text-align: left">''</td></tr>
<tr><td style="text-align: left">width</td><td style="text-align: left">环形进度条画布宽度（只在 type 为 circle 或 dashboard 时可用）</td><td style="text-align: left">number</td><td style="text-align: left"></td><td style="text-align: left">126</td></tr>
<tr><td style="text-align: left">show-text</td><td style="text-align: left">是否显示进度条文字内容</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">stroke-linecap</td><td style="text-align: left">circle/dashboard 类型路径两端的形状</td><td style="text-align: left">string</td><td style="text-align: left">butt/round/square</td><td style="text-align: left">round</td></tr>
</tbody></table>
<h1 id=""><a class="header" href="#"></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="colorpicker-颜色选择器"><a class="header" href="#colorpicker-颜色选择器">ColorPicker 颜色选择器</a></h2>
<p>用于颜色选择，支持多种格式。</p>
<h1 id="基础用法-28"><a class="header" href="#基础用法-28">基础用法</a></h1>
<pre><code class="language-vue">&lt;div class=&quot;block&quot;&gt;
  &lt;span class=&quot;demonstration&quot;&gt;有默认值&lt;/span&gt;
  &lt;el-color-picker v-model=&quot;color1&quot;&gt;&lt;/el-color-picker&gt;
&lt;/div&gt;
&lt;div class=&quot;block&quot;&gt;
  &lt;span class=&quot;demonstration&quot;&gt;无默认值&lt;/span&gt;
  &lt;el-color-picker v-model=&quot;color2&quot;&gt;&lt;/el-color-picker&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        color1: '#409EFF',
        color2: null
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="选择透明度"><a class="header" href="#选择透明度">选择透明度</a></h1>
<p>ColorPicker 支持普通颜色，也支持带 Alpha 通道的颜色，通过<code>show-alpha</code>属性即可控制是否支持透明度的选择。</p>
<pre><code class="language-vue">&lt;el-color-picker v-model=&quot;color&quot; show-alpha&gt;&lt;/el-color-picker&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        color: 'rgba(19, 206, 102, 0.8)'
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="预定义颜色"><a class="header" href="#预定义颜色">预定义颜色</a></h1>
<pre><code class="language-vue">&lt;el-color-picker
  v-model=&quot;color&quot;
  show-alpha
  :predefine=&quot;predefineColors&quot;&gt;
&lt;/el-color-picker&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        color: 'rgba(255, 69, 0, 0.68)',
        predefineColors: [
          '#ff4500',
          '#ff8c00',
          '#ffd700',
          '#90ee90',
          '#00ced1',
          '#1e90ff',
          '#c71585',
          'rgba(255, 69, 0, 0.68)',
          'rgb(255, 120, 0)',
          'hsv(51, 100, 98)',
          'hsva(120, 40, 94, 0.5)',
          'hsl(181, 100%, 37%)',
          'hsla(209, 100%, 56%, 0.73)',
          '#c7158577'
        ]
      }
    }
  };
&lt;/script&gt;

</code></pre>
<h1 id="不同尺寸-1"><a class="header" href="#不同尺寸-1">不同尺寸</a></h1>
<pre><code class="language-vue">&lt;el-color-picker v-model=&quot;color&quot;&gt;&lt;/el-color-picker&gt;
&lt;el-color-picker v-model=&quot;color&quot; size=&quot;medium&quot;&gt;&lt;/el-color-picker&gt;
&lt;el-color-picker v-model=&quot;color&quot; size=&quot;small&quot;&gt;&lt;/el-color-picker&gt;
&lt;el-color-picker v-model=&quot;color&quot; size=&quot;mini&quot;&gt;&lt;/el-color-picker&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        color: '#409EFF'
      }
    }
  };
&lt;/script&gt;
</code></pre>
<h1 id="属性事件和方法-31"><a class="header" href="#属性事件和方法-31">属性事件和方法</a></h1>
<h2 id="attributes-27"><a class="header" href="#attributes-27">Attributes</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th><th style="text-align: left">类型</th><th style="text-align: left">可选值</th><th style="text-align: left">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">value / v-model</td><td style="text-align: left">绑定值</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">disabled</td><td style="text-align: left">是否禁用</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">size</td><td style="text-align: left">尺寸</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">medium / small / mini</td></tr>
<tr><td style="text-align: left">show-alpha</td><td style="text-align: left">是否支持透明度选择</td><td style="text-align: left">boolean</td><td style="text-align: left">—</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">color-format</td><td style="text-align: left">写入 v-model 的颜色的格式</td><td style="text-align: left">string</td><td style="text-align: left">hsl / hsv / hex / rgb</td><td style="text-align: left">hex（show-alpha 为 false）/ rgb（show-alpha 为 true）</td></tr>
<tr><td style="text-align: left">popper-class</td><td style="text-align: left">ColorPicker 下拉框的类名</td><td style="text-align: left">string</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
<tr><td style="text-align: left">predefine</td><td style="text-align: left">预定义颜色</td><td style="text-align: left">array</td><td style="text-align: left">—</td><td style="text-align: left">—</td></tr>
</tbody></table>
<h2 id="events-19"><a class="header" href="#events-19"><a href="https://element.eleme.cn/#/zh-CN/component/color-picker#events">¶</a>Events</a></h2>
<table><thead><tr><th style="text-align: left">事件名称</th><th style="text-align: left">说明</th><th style="text-align: left">回调参数</th></tr></thead><tbody>
<tr><td style="text-align: left">change</td><td style="text-align: left">当绑定值变化时触发</td><td style="text-align: left">当前值</td></tr>
<tr><td style="text-align: left">active-change</td><td style="text-align: left">面板中当前显示的颜色发生改变时触发</td><td style="text-align: left">当前显示的颜色值</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="html5"><a class="header" href="#html5">Html5</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="css3"><a class="header" href="#css3"><code>CSS3</code></a></h1>
<h2 id="css3的模块化"><a class="header" href="#css3的模块化"><code>CSS3的模块化</code></a></h2>
<h3 id="详细模块表格"><a class="header" href="#详细模块表格"><code>详细模块表格</code></a></h3>
<table><thead><tr><th><code>模块名称</code></th><th><code>功能描述</code></th></tr></thead><tbody>
<tr><td><code>basic box model</code></td><td><code>盒相关样式</code></td></tr>
<tr><td><code>line</code></td><td><code>直线相关样式</code></td></tr>
<tr><td><code>lists</code></td><td><code>列表相关样式</code></td></tr>
<tr><td><code>hyperlinkPresentation</code></td><td><code>超链接,锚的显示方式,视觉效果</code></td></tr>
<tr><td><code>presentationLevel</code></td><td><code>元素不同的样式级别</code></td></tr>
<tr><td><code>speech</code></td><td><code>语言相关样式,音量,音速,间歇时间</code></td></tr>
<tr><td><code>background and border</code></td><td><code>背景和边框</code></td></tr>
<tr><td><code>text</code></td><td><code>文字</code></td></tr>
<tr><td><code>color</code></td><td><code>颜色</code></td></tr>
<tr><td><code>font</code></td><td><code>字体</code></td></tr>
<tr><td><code>pagedMedia</code></td><td><code>页眉页脚页数</code></td></tr>
<tr><td><code>cascadingand inheritance</code></td><td><code>属性赋值</code></td></tr>
<tr><td><code>value units</code></td><td><code>值与单位</code></td></tr>
<tr><td><code>imageValue</code></td><td><code>imgae元素赋值方式</code></td></tr>
<tr><td><code>2DTransforms</code></td><td><code>2维空间变形</code></td></tr>
<tr><td><code>3DTransforms</code></td><td><code>3维空间变形</code></td></tr>
<tr><td><code>transitions</code></td><td><code>平滑过渡视觉效果</code></td></tr>
<tr><td><code>animations</code></td><td><code>动画</code></td></tr>
<tr><td><code>cssOM view</code></td><td><code>查看管理页面或页面视觉效果,处理元素的位置信息</code></td></tr>
<tr><td><code>syntax</code></td><td><code>CSS样式表的基本结构,样式表语法细节</code></td></tr>
<tr><td><code>generated and replaced content</code></td><td><code>怎么插入内容</code></td></tr>
<tr><td><code>marquee</code></td><td><code>怎样显示溢出部分</code></td></tr>
<tr><td><code>ruby</code></td><td><code>定义ruby元素(用于显示拼音文字)</code></td></tr>
<tr><td><code>writing modes</code></td><td><code>文本数据的布局方式</code></td></tr>
<tr><td><code>basic user interface</code></td><td><code>定义在屏幕 纸张上进行输出时页面的渲染方式</code></td></tr>
<tr><td><code>namespaces</code></td><td><code>使用命名空间的语法</code></td></tr>
<tr><td><code>media queries</code></td><td><code>根据媒体类型来 实现不同样式</code></td></tr>
<tr><td><code>'reader' media type</code></td><td><code>屏幕阅读器之类的阅读程序 时的样式</code></td></tr>
<tr><td><code>multi-column layout</code></td><td><code>多栏布局方式</code></td></tr>
<tr><td><code>template layout</code></td><td><code>特殊布局方式</code></td></tr>
<tr><td><code>flexiblebox layout</code></td><td><code>自适应浏览器窗口的流动布局</code></td></tr>
<tr><td><code>grid position</code></td><td><code>网格布局</code></td></tr>
<tr><td><code>generated content for paged media</code></td><td><code>印刷时使用的布局方式</code></td></tr>
</tbody></table>
<h2 id="选择器"><a class="header" href="#选择器"><code>选择器</code></a></h2>
<h3 id="属性选择器"><a class="header" href="#属性选择器"><code>属性选择器</code></a></h3>
<ol>
<li><code>[attr=val]{...} :普通属性选择器</code></li>
<li><code>[attr*=val]:包含:属性名包含val值的属性</code></li>
<li><code>[attr^=val]:开头:以val开头的属性名</code></li>
<li><code>[attr$=val]:结尾:以val结尾的属性名</code></li>
</ol>
<h3 id="结构型伪类选择器"><a class="header" href="#结构型伪类选择器"><code>结构型伪类选择器</code></a></h3>
<ol>
<li>
<p><code>a标签上的伪类选择器</code></p>
<ol>
<li><code>a:link{...}</code></li>
<li><code>a:visited</code></li>
<li><code>a:hover</code></li>
<li><code>a:active</code></li>
</ol>
</li>
<li>
<p><code>伪元素选择器:针对CSS中已经定义好的元素选择器</code></p>
<ol>
<li>
<p><code>语法: 选择器 类名:伪元素{属性:值}</code></p>
</li>
<li>
<p><code>伪元素</code></p>
<ol>
<li><code>first-line :选定的某个元素的 内容的第一行</code></li>
<li><code>first-letter:选定的某个元素的 内容的第一个字</code></li>
<li><code>before:选定的某个元素的 内容的前面插入一些内容,配合content使用</code></li>
<li><code>after:选定的某个元素的 内容的后面插入一些内容,配合content使用</code></li>
</ol>
</li>
<li>
<p><code>content插入的元素</code></p>
<ol>
<li>
<p><code>插入文本 content = &quot;&quot;</code></p>
</li>
<li>
<p><code>插入图像 content:url(imgurl)</code></p>
</li>
<li>
<p><code>插入项目编号</code></p>
<ol>
<li>
<p><code>content:counter(计数器名[,编号器样式list-style-type])</code></p>
</li>
<li>
<p><code>list-style-type</code></p>
<ol>
<li><code>upper-alpha</code></li>
<li><code>upper-roman</code></li>
</ol>
</li>
<li>
<p><code>example</code></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;UTF-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style type=&quot;text/css&quot;&gt;
			h1:before{
				content: '第'counter(mycounter,upper-roman)'章节';
				color: blue;
				font-size: 42px;
				
			}
			h1{
				counter-increment: mycounter;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;标题&lt;/h1&gt;
		&lt;p&gt;文字&lt;/p&gt;
		&lt;h1&gt;标题&lt;/h1&gt;
		&lt;p&gt;文字&lt;/p&gt;
		&lt;h1&gt;标题&lt;/h1&gt;
		&lt;p&gt;文字&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li>
<p><code>编号嵌套</code></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;UTF-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style type=&quot;text/css&quot;&gt;
			h1:before{
				content: counter(counter1) '. ';
			}
			h1{
				counter-increment: counter1;
			}
			h2:before{
				content: counter(counter1)'-'counter(counter2) '. ';
			}
			h2{
				counter-increment: counter2;
				margin-left: 40px;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;大标题&lt;/h1&gt;
		&lt;h2&gt;小标题&lt;/h2&gt;
		&lt;h2&gt;小标题&lt;/h2&gt;
		&lt;h2&gt;小标题&lt;/h2&gt;
		&lt;h1&gt;大标题&lt;/h1&gt;
		&lt;h2&gt;小标题&lt;/h2&gt;
		&lt;h2&gt;小标题&lt;/h2&gt;
		&lt;h2&gt;小标题&lt;/h2&gt;
		&lt;h1&gt;大标题&lt;/h1&gt;
		&lt;h2&gt;小标题&lt;/h2&gt;
		&lt;h2&gt;小标题&lt;/h2&gt;
		&lt;h2&gt;小标题&lt;/h2&gt;
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
</li>
<li>
<p><code>插入编号</code></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;UTF-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style type=&quot;text/css&quot;&gt;
			/*选择元素 插入quotes*/
			h1:before{
				content: open-quote;
			}
			h1:after{
				content: close-quote;
			}
			/*定义quotes*/
			h1{
				quotes: &quot;&lt;&lt;&quot; &quot;&gt;&gt;&quot;;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;标题&lt;/h1&gt;
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p><code>结构型伪类选择器</code></p>
</li>
<li>
<p><code>root根选择器:设定 html整个样式</code></p>
<p><code>:root{background-color:yellow}</code></p>
</li>
<li>
<p><code>not选择器:排除某个元素</code></p>
<p><code>body *:not(h1){ background-color:yellow}</code></p>
</li>
<li>
<p><code>empty:单内容为空白时,指定的元素</code></p>
<p><code>:empty{background-color:yellow}</code></p>
</li>
<li>
<p><code>target:对于具有超链接的a标签,只有在跳转之后,才会呈现样式</code></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;UTF-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style type=&quot;text/css&quot;&gt;
			:target {
				background-color: yellow;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;a href=&quot;#text1&quot;&gt;示例1&lt;/a&gt;
		&lt;a href=&quot;#text2&quot;&gt;示例2&lt;/a&gt;

		&lt;div id=&quot;text1&quot;&gt;
			&lt;h2&gt;示例文本&lt;/h2&gt;
			&lt;p&gt;此处省去&lt;/p&gt;
		&lt;/div&gt;
		&lt;div id=&quot;text2&quot;&gt;
			&lt;h2&gt;示例文本&lt;/h2&gt;
			&lt;p&gt;此处省去&lt;/p&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li>
<p><code>子元素选择器</code></p>
<ol>
<li><code>first-child</code></li>
<li><code>last-child</code></li>
<li><code>nth-child(n), n=odd,基数,even偶数</code></li>
<li><code>nth-last-child(n)</code></li>
</ol>
</li>
<li>
<p><code>类型选择器:在nth-child选择时,不同元素类型也会被计数</code></p>
<ol>
<li>
<p><code>nth-of-type(n), nth-last-of-type(n)</code></p>
</li>
<li>
<p><code>在计算子元素类型的时候就 只计算同类元素</code></p>
</li>
<li>
<p><code>循环使用样式</code></p>
<p><code>li:nth-child(4n+1) 4表示样式的种类,1表示循环的位置</code></p>
</li>
</ol>
</li>
<li>
<p><code>only-child,only-of-type</code></p>
<ol>
<li><code>只针对只有一个子元素生效</code></li>
</ol>
</li>
</ol>
<h3 id="ui元素状态伪类选择器"><a class="header" href="#ui元素状态伪类选择器"><code>UI元素状态伪类选择器</code></a></h3>
<ol>
<li><code>E:hover</code></li>
<li><code>E:avtive</code></li>
<li><code>E:focus</code></li>
<li><code>E:enabled</code></li>
<li><code>E:disabled</code></li>
<li><code>E:read-only</code></li>
<li><code>E:read-write</code></li>
<li><code>E:checked</code></li>
<li><code>E:default</code></li>
<li><code>E:indeterminate</code></li>
<li><code>E::selection</code></li>
</ol>
<h3 id="通用兄弟元素选择器"><a class="header" href="#通用兄弟元素选择器"><code>通用兄弟元素选择器</code></a></h3>
<ol>
<li>
<p><code>语法</code></p>
<pre><code class="language-css">    span~p{
        background: green;
    }
</code></pre>
</li>
<li>
<p><code>解析</code></p>
<p><code>寻找span标签后,所有的的兄弟标签 ,且该标签为 p标签</code></p>
</li>
</ol>
<h2 id="文字与字体相关样式"><a class="header" href="#文字与字体相关样式"><code>文字与字体相关样式</code></a></h2>
<h3 id="文字添加阴影"><a class="header" href="#文字添加阴影"><code>文字添加阴影</code></a></h3>
<ol>
<li><code>text-shadow: xlength ylength zlength color[,xlength ylength zlength color]</code></li>
<li><code>解释: 阴影离开横向方向,纵向方向,模糊半径,阴影颜色</code></li>
<li><code>可以指定多组</code></li>
</ol>
<h3 id="文本自动换行"><a class="header" href="#文本自动换行"><code>文本自动换行</code></a></h3>
<ol>
<li><code>word-break:wordbreak-style;</code>
<ol>
<li><code>normal:使用浏览器默认规则</code></li>
<li><code>keep-all:半角空格或连字符处换行</code></li>
<li><code>break-all:单词内换行</code></li>
</ol>
</li>
</ol>
<h3 id="长单词与url地址自动换行"><a class="header" href="#长单词与url地址自动换行"><code>长单词与URL地址自动换行</code></a></h3>
<ol>
<li><code>word-wrap:break-word</code></li>
</ol>
<h3 id="使用服务端字体"><a class="header" href="#使用服务端字体"><code>使用服务端字体</code></a></h3>
<ol>
<li>
<p><code>使用服务端字体的语法</code></p>
<pre><code class="language-css">//声明使用web字体
@font-face{
    font-family:webFont;
	src:url('font/Fontin_Sans_R_45b.otf') format(&quot;opentype&quot;)
    font -weight:normal
}
//使用web字体
h1{
    font-family:webFont
}
</code></pre>
</li>
<li>
<p><code>使用本地字体</code></p>
<pre><code class="language-css">@font-face{
    font-famioly:Arial;
    src:local('Arial')
}
</code></pre>
</li>
<li>
<p><code>@font-face可以指定的属性</code></p>
<table><thead><tr><th><code>属性值</code></th><th><code>说明</code></th><th><code>取值</code></th></tr></thead><tbody>
<tr><td><code>font-family</code></td><td><code>设置字体系列名称</code></td><td></td></tr>
<tr><td><code>font-style</code></td><td><code>字体样式</code></td><td><code>normal:不使用斜体&lt;br /&gt;italic:斜体&lt;br /&gt;oblique:倾斜体&lt;br /&gt;inherit:从父元素继承</code></td></tr>
<tr><td><code>font-variant</code></td><td><code>设置字体大小</code></td><td><code>normal:浏览器默认值&lt;br /&gt;small-caps:小型大小字母&lt;br /&gt;inherit:父元素继承</code></td></tr>
<tr><td><code>font-weight</code></td><td><code>设置字体的粗细</code></td><td><code>normal:浏览器默认值&lt;br /&gt;bold:使用粗体字符&lt;br /&gt;bolder:更粗&lt;br /&gt;lighter:更细字符&lt;br /&gt;100-900:从细到粗,必须为100的整数倍</code></td></tr>
<tr><td><code>font-stretch</code></td><td><code>字体是否变形伸缩</code></td><td><code>normal&lt;br /&gt;wider&lt;br /&gt;narrower&lt;br /&gt;ultra-condensed&lt;br /&gt;extra-condensed&lt;br /&gt;condensed&lt;br /&gt;semi-condensed&lt;br /&gt;semi-expanded&lt;br /&gt;extra-expanded&lt;br /&gt;ultra-expanded:最宽的</code></td></tr>
<tr><td><code>font-size</code></td><td><code>字体大小</code></td><td></td></tr>
<tr><td><code>src</code></td><td><code>字体文件路径</code></td><td></td></tr>
</tbody></table>
</li>
</ol>
<h3 id="修改字体种类而保持字体大小尺寸不变"><a class="header" href="#修改字体种类而保持字体大小尺寸不变"><code>修改字体种类而保持字体大小尺寸不变</code></a></h3>
<ol>
<li>
<p><code>改变字体的种类很可能会因为文字大小的变化而导致原来的页面布局产生混乱</code></p>
</li>
<li>
<p><code>font-size-adjust:0.49(aspect值)</code></p>
<p><code>font-size-adjust 的大小 = x-length / 字体像素大小</code></p>
</li>
<li>
<p><code>c = (a/b) * s , a是 新字体的 aspect值, b是旧字体的aspect得值,s是指定的尺寸</code></p>
</li>
</ol>
<h2 id="盒相关样式"><a class="header" href="#盒相关样式"><code>盒相关样式</code></a></h2>
<h3 id="盒的类型"><a class="header" href="#盒的类型"><code>盒的类型</code></a></h3>
<ol>
<li>
<p><code>盒的基本类型</code></p>
<ol>
<li>
<p><code>inline: a,span,每行可容纳多个标签</code></p>
</li>
<li>
<p><code>block</code></p>
</li>
<li>
<p><code>inline-block</code></p>
<table><thead><tr><th><code>类型</code></th><th><code>说明</code></th><th><code>典型标签</code></th></tr></thead><tbody>
<tr><td><code>inline</code></td><td><code>1.inline元素的宽度始终等于其内容的宽度&lt;br /&gt;指定宽度的样式对inline元素无效&lt;br /&gt;2. 可以允许多个inline元素</code></td><td><code>a,span,input</code></td></tr>
<tr><td><code>block</code></td><td><code>1. block元素的宽度 充满整行&lt;br /&gt;2.高度 = getOrdefault(指定宽度,内容宽度)</code></td><td><code>div,p</code></td></tr>
<tr><td><code>inline-block</code></td><td><code>1.该元素的宽度 =  getOrdefault(指定宽度,内容宽度)</code></td><td></td></tr>
</tbody></table>
</li>
</ol>
</li>
<li>
<p><code>inline-table类型 :针对表格使用的inline</code></p>
</li>
<li>
<p><code>list-item:列表显示</code></p>
<pre><code class="language-css">		div{
			display: list-item;
			list-style-type: circle;
			margin-left: 30px;
		}
</code></pre>
</li>
<li>
<p><code>表格相关类型</code></p>
<table><thead><tr><th><code>元素</code></th><th><code>所属类型</code></th><th><code>说明</code></th></tr></thead><tbody>
<tr><td><code>table</code></td><td><code>inline-table</code></td><td><code>整个表格</code></td></tr>
<tr><td><code>tr</code></td><td><code>table-row</code></td><td><code>表格中的一行</code></td></tr>
<tr><td><code>td</code></td><td><code>table-cell</code></td><td><code>单元格</code></td></tr>
<tr><td><code>th</code></td><td><code>table-header</code></td><td><code>列标题</code></td></tr>
<tr><td><code>tbody</code></td><td><code>table-row-group</code></td><td><code>表格所有行</code></td></tr>
<tr><td><code>thead</code></td><td><code>table-header-group</code></td><td><code>表格表头部分</code></td></tr>
<tr><td><code>tfoot</code></td><td><code>table-footer-group</code></td><td><code>脚注部分</code></td></tr>
<tr><td><code>col</code></td><td><code>table-column</code></td><td><code>一列</code></td></tr>
<tr><td><code>colgroup</code></td><td><code>table-column-group</code></td><td><code>所有列</code></td></tr>
<tr><td><code>caption</code></td><td><code>table-caption</code></td><td><code>表格标题</code></td></tr>
</tbody></table>
</li>
<li>
<p><code>none类型 , 隐藏元素</code></p>
</li>
</ol>
<h3 id="盒中容纳不下的内容显示"><a class="header" href="#盒中容纳不下的内容显示"><code>盒中容纳不下的内容显示</code></a></h3>
<ol>
<li><code>指定 overflow属性指定盒容纳不下的内容的处理方式\</code></li>
<li><code>overflow,overflow-x,overflow-y,text-overflow</code></li>
<li><code>取值范围</code>
<ol>
<li><code>scroll 滚动条</code></li>
<li><code>visible:超出容纳范围文字原样显示</code></li>
<li><code>hidden:隐藏</code></li>
</ol>
</li>
</ol>
<h3 id="盒阴影"><a class="header" href="#盒阴影"><code>盒阴影</code></a></h3>
<ol>
<li>
<p><code>box-shadow:lengthx legnthy lengthz color</code></p>
<p><code>阴影离开文字很想,纵向,阴影模糊半径,颜色</code></p>
</li>
<li>
<p><code>将参数设定为0:将绘制不向外模糊的阴影</code></p>
</li>
<li>
<p><code>对盒内子元素使用阴影</code></p>
</li>
<li>
<p><code>对第一个文字或者第一行使用阴影 div:first-letter</code></p>
</li>
<li>
<p><code>对表格单元格使用阴影</code></p>
</li>
</ol>
<h3 id="指定-针对元素宽度与高度的-计算方法"><a class="header" href="#指定-针对元素宽度与高度的-计算方法"><code>指定 针对元素宽度与高度的 计算方法</code></a></h3>
<ol>
<li><code>使用box-sizing属性可选值</code>
<ol>
<li><code>content-box:用width,height指定的宽度与高度 不包括 内部留白(padding),边框的厚度</code></li>
<li><code>border-box:用width,height指定的宽度与高度包括 内部留白(padding),边框的厚度</code> </li>
</ol>
</li>
</ol>
<h2 id="与背景边框相关样式"><a class="header" href="#与背景边框相关样式"><code>与背景边框相关样式</code></a></h2>
<h3 id="与背景相关的-新增属性"><a class="header" href="#与背景相关的-新增属性"><code>与背景相关的 新增属性</code></a></h3>
<ol>
<li>
<p><code>backgroup-clip:背景默认显示的范围包括边框与内部留白</code></p>
<ol>
<li>
<p><code>border: 包括边框区域(如果边框为虚线的话)</code></p>
</li>
<li>
<p><code>padding:不包括边框区域</code></p>
</li>
<li>
<p><code>example</code></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;UTF-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style type=&quot;text/css&quot;&gt;
			div{
				background-color: red;
				border: dashed 15px ;
				/*padding: 30px;
				color: white;
				font-size: 30px;
				font-weight: bold;*/
			}
			div#a1{
				background-clip: border-box;
			}
			div#a2{
				background-clip: padding-box;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id=&quot;a1&quot;&gt;示例文字1&lt;/div&gt;
		&lt;div id=&quot;a2&quot;&gt;示例文字2&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
</li>
</ol>
</li>
<li>
<p><code>background-origin:图像的绘制起点</code></p>
<ol>
<li>
<p><code>默认是从内部留白区域的左上角开始</code></p>
</li>
<li>
<p><code>显示级别: 背景颜色 &lt;  背景图片 &lt; 边框,内容</code></p>
</li>
<li>
<p><code>可选值为</code></p>
<ol>
<li><code>border:边框左上角开始,(边框会把背景覆盖)</code></li>
<li><code>padding:内部留白左上角</code></li>
<li><code>content:内容左上角</code></li>
</ol>
</li>
<li>
<p><code>example</code></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;UTF-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style type=&quot;text/css&quot;&gt;
			div{
				background-color: black;
				background-image: url(img/下载.jpg);
				background-repeat: no-repeat;
				border: dashed 15px green;
				padding: 30px;
				color: white;
				font-size:  2em;
				font-weight: bold;
			}
			
			div#div1{
				background-origin: border-box;
			}
			div#div2{
				background-origin: content-box;
			}
			div#div3{
				background-origin: padding-box;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id=&quot;div1&quot;&gt;示例文字1&lt;/div&gt;
		&lt;div id=&quot;div2&quot;&gt;示例文字2&lt;/div&gt;
		&lt;div id=&quot;div3&quot;&gt;示例文字3&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
</li>
</ol>
</li>
<li>
<p><code>background-size:指定背景图像的大小</code></p>
<ol>
<li>
<p><code>background-size width height  or background-size auto(auto维持 纵横比)</code></p>
</li>
<li>
<p><code>example</code></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;UTF-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style type=&quot;text/css&quot;&gt;
			div{
				background-color: black;
				background-image: url(img/下载.jpg);
				padding: 30px;
				color:white;
				font-size :2em;
				font-weight: bold;
				/*background-size: 40px 20px;*/
				background-size: auto;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
			&lt;div&gt;示例文字&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
</li>
</ol>
</li>
<li>
<p><code>background-break:指定内联元素背景图像进行平铺时的循环方式</code></p>
<ol>
<li><code>bounding-box:在整个内联元素中平铺</code></li>
<li><code>each-box:在每一行中平铺</code></li>
<li><code>continuous:下一行紧接着上一行图像继续平铺</code></li>
</ol>
</li>
</ol>
<h3 id="在一个元素中显示多个背景图像"><a class="header" href="#在一个元素中显示多个背景图像"><code>在一个元素中显示多个背景图像</code></a></h3>
<ol>
<li><code>通过 background-image:url(1),url(2)</code></li>
<li><code>通过 background-repeat: repeat-y,repeat-x;指定每个图片的平铺方式</code></li>
<li><code>最先指定的图片优先级最高</code></li>
<li><code>允许多重指定配合使用的属性有</code>
<ol>
<li><code>background-image</code></li>
<li><code>background-repeat</code></li>
<li><code>background-position</code></li>
<li><code>background-clip</code></li>
<li><code>background-origin</code></li>
<li><code>background-size</code></li>
</ol>
</li>
</ol>
<h3 id="圆角边框的绘制"><a class="header" href="#圆角边框的绘制"><code>圆角边框的绘制</code></a></h3>
<ol>
<li><code>使用 border-radius:x y</code></li>
<li><code>指定两个半径有两种处理方式</code>
<ol>
<li><code>Firefox:第一个半径为边框左上角,右下角 的圆半径</code></li>
<li><code>chrome:第一个半径为椭圆的 水平半径, 第二个为 垂直半径</code></li>
</ol>
</li>
<li><code>可以 矩形四个角半径各不相同的边框</code>
<ol>
<li><code>border-top-left-radius</code></li>
</ol>
</li>
</ol>
<h3 id="使用图像边框"><a class="header" href="#使用图像边框"><code>使用图像边框</code></a></h3>
<ol>
<li><code>border-image url(path) a b c d</code>
<ol>
<li><code>ABCD四个参数表示 当浏览器 自动把边框使用到的图像进行分成九分</code></li>
<li><code>A上 B右 C下 D左</code></li>
</ol>
</li>
<li><code>使用border-image指定边框宽度</code>
<ol>
<li><code>border-image url(path) a b c d/border-width</code></li>
</ol>
</li>
<li><code>图像显示方式</code>
<ol>
<li><code>border-image url(path) a b c d/border-width topbottom-type leftright-type</code></li>
<li><code>type</code>
<ol>
<li><code>stretch:拉伸</code></li>
<li><code>round</code>:平铺
<ol>
<li>与重复类似,区别在于</li>
<li>最后一张图如果 不能铺满一半,则将上张图拉伸处理,</li>
<li>如果能铺满一半,则将该图拉伸处理</li>
</ol>
</li>
<li><code>repeat</code>:重复</li>
</ol>
</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="h5canvas图形绘制"><a class="header" href="#h5canvas图形绘制">H5canvas图形绘制</a></h1>
<h2 id="基本使用"><a class="header" href="#基本使用">基本使用</a></h2>
<ol>
<li>
<p><canvas id="tutorial" width="300" height="300"></canvas></p>
</li>
<li>
<p>检测支持性: <canvas>    你的浏览器不支持canvas,请升级你的浏览器 </canvas></p>
<ol>
<li>支持的浏览器会只渲染标签，而忽略其中的替代内容。不支持 的浏览器则 会直接渲染替代内容。</li>
</ol>
</li>
<li>
<p>渲染上下文</p>
<pre><code class="language-html">if (canvas.getContext){
  var ctx = canvas.getContext('2d');
  // drawing code here
} else {
  // canvas-unsupported code here
}
</code></pre>
</li>
</ol>
<h2 id="绘图示例"><a class="header" href="#绘图示例">绘图示例</a></h2>
<pre><code class="language-html">&lt;html&gt;

&lt;head&gt;
&lt;/head&gt;
&lt;script&gt;
    function init() {
        var canvas = document.getElementById('canvas');
        if(canvas == null){
            return false
        }
        var context = canvas.getContext('2d');
        context.fillStyle = 'red';
        context.fillRect(0,0,50,50);
        context.strokeStyle='green';
        context.lineWidth= 1;
        context.strokeRect(50,50,400,300);
    }
&lt;/script&gt;
&lt;body onload=&quot;init()&quot;&gt;
    &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;300&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;		
</code></pre>
<h2 id="路径绘制步骤"><a class="header" href="#路径绘制步骤">路径绘制步骤</a></h2>
<ol>
<li>
<p>获取canvas对象 </p>
<ol>
<li>document.getElementById('canvas');</li>
</ol>
</li>
<li>
<p>得到 上下文</p>
<pre><code>canvas.getContext('2d');
</code></pre>
</li>
<li>
<p>填充与绘制边框</p>
<ol>
<li>
<p>开始绘制 </p>
<pre><code>context.beginPath();	
</code></pre>
</li>
<li>
<p>以特定方式绘制形状 :以弧形为例</p>
<pre><code>context.arc(i*25,i*25,i*10,0,Math.PI*2,true);
</code></pre>
</li>
<li>
<p>关闭路径</p>
<pre><code>context.closePath() 路径闭合后会自动将终点与起点相连
</code></pre>
</li>
<li>
<p>开始绘制</p>
<pre><code>context.fill() 填充
context.stroke() 绘制边框
</code></pre>
</li>
<li>
<pre><code class="language-html">&lt;html&gt;

&lt;head&gt;
&lt;/head&gt;
&lt;script&gt;
    function init() {
        var canvas = document.getElementById('canvas');
        if(canvas == null){
            return false
        }
        var context = canvas.getContext('2d');
        draw_circle(context);
    }
    function draw_circle(c){
        for(var i=0;i&lt;10;i++){
            c.beginPath();
            c.arc(i*25,i*25,i*10,0,Math.PI*2,true);
            c.closePath();
            c.fillStyle='rgba(255,0,0,0.25)';
            c.fill();
        }
    }
&lt;/script&gt;
&lt;body onload=&quot;init()&quot;&gt;
    &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;300&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="绘制图形方式"><a class="header" href="#绘制图形方式">绘制图形方式</a></h2>
<table><thead><tr><th>函数名</th><th>说明</th><th>参数解析</th></tr></thead><tbody>
<tr><td>arc(x,y,radius,startAngle,endAngle,anticlockwise)</td><td>绘制弧形</td><td>x,y圆心,start,end,开始角度结束角度,是否顺时针</td></tr>
<tr><td>arcTo(x1,y1,x2,y2,radius)</td><td>根据给定的控制点和半径画一段圆弧，最后再以直线连接两个控制点</td><td>x1,y1为控制点1,x2,y2为控制点2,radius为半径</td></tr>
<tr><td>moveTo(x,y),lineTo(x,y)</td><td>绘制直线</td><td>move:x,y起点,line:x,y终点</td></tr>
<tr><td>bezierCurveTo(cplx,cply,cp2x,cp2y,x,y)</td><td>贝济埃曲线</td><td>cp1x , y 第一个控制点横坐标;cp2x,y第二个控制点横坐标;x,y终点坐标</td></tr>
<tr><td>quadraticCurveTo(cp1x, cp1y, x, y)</td><td>二次贝塞尔曲线</td><td>控制点坐标,结束点坐标</td></tr>
<tr><td>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</td><td>三次贝塞尔曲线</td><td>控制点坐标,控制点坐标,结束点坐标</td></tr>
</tbody></table>
<h2 id="添加样式和颜色"><a class="header" href="#添加样式和颜色">添加样式和颜色</a></h2>
<ol>
<li>
<p>fillStyle 填充颜色, strokeStyle  边框颜色</p>
</li>
<li>
<p>透明度</p>
<ol>
<li>globalAlpha = transparencyValue 全局设置图形透明度</li>
</ol>
</li>
<li>
<p>line style 线条样式</p>
<ol>
<li>
<p>线宽:<code>lineWidth</code> = value </p>
</li>
<li>
<p>线条末端样式 <code>lineCap</code> = type,有三个值</p>
<ol>
<li><code>butt</code>：线段末端以方形结束</li>
<li><code>round</code>：线段末端以圆形结束</li>
<li><code>square</code>：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域</li>
</ol>
</li>
<li>
<p>线条与线条间接合处的样式</p>
<ol>
<li>
<p><code>round</code></p>
<p>通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。 圆角的半径是线段的宽度</p>
</li>
<li>
<p><code>bevel</code></p>
<p>在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角。</p>
</li>
<li>
<p><code>miter</code></p>
<p>通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。</p>
</li>
</ol>
</li>
<li>
<p>虚线</p>
<ol>
<li><code>setLineDash</code>(实线长度,间隙长度)</li>
<li><code>lineDashOffset</code>设置起始偏移量</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="绘制文本"><a class="header" href="#绘制文本">绘制文本</a></h2>
<h3 id="渲染文本方式"><a class="header" href="#渲染文本方式">渲染文本方式</a></h3>
<ol>
<li><code>fillText(text, x, y [, maxWidth])</code>
<ol>
<li>在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的</li>
</ol>
</li>
<li><code>strokeText(text, x, y [, maxWidth])</code>
<ol>
<li>在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的.</li>
</ol>
</li>
</ol>
<h3 id="给文本添加样式"><a class="header" href="#给文本添加样式">给文本添加样式</a></h3>
<ol>
<li>字体:<code>font = value</code></li>
<li>文本对齐:textAlign = value
<ol>
<li><code>start</code>, <code>end</code>, <code>left</code>, <code>right</code> ,<code>center</code></li>
</ol>
</li>
<li>基线对齐
<ol>
<li>textBaseline = value</li>
</ol>
</li>
<li>方向对齐
<ol>
<li>direction = value</li>
<li><code>ltr</code>, <code>rtl</code>, <code>inherit</code></li>
</ol>
</li>
</ol>
<h2 id="绘制图片"><a class="header" href="#绘制图片">绘制图片</a></h2>
<h3 id="绘制步骤"><a class="header" href="#绘制步骤">绘制步骤</a></h3>
<ol>
<li>
<p>创建<code>&lt;img&gt;</code>元素</p>
<p><code>var img = new Image();   *// 创建一个元素* img.src = 'myImage.png'; *// 设置图片源地址*</code></p>
</li>
<li>
<p>绘制img</p>
<p><code>ctx.drawImage(img,0,0);</code> //参数1：要绘制的img  参数2、3：绘制的img在canvas中的坐标</p>
</li>
<li>
<p><code>img</code> 可以 <code>new</code> 也可以来源于我们页面的 ``标签</p>
</li>
<li>
<p>如果 <code>drawImage</code> 的时候图片还没有完全加载完成，则什么都不做，个别浏览器会抛异常。所以我们应该保证在 <code>img</code> 绘制完成之后再 <code>drawImage</code>。</p>
</li>
</ol>
<h3 id="缩放图片"><a class="header" href="#缩放图片">缩放图片</a></h3>
<ol>
<li>函数 <code>drawImage(image, x, y, width, height)</code></li>
</ol>
<h3 id="切片"><a class="header" href="#切片">切片</a></h3>
<ol>
<li><code>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</code></li>
<li>第一个参数是 图像, sx,sy,swidth,sheight 是源图像的切片, 后面是目标图像的切片</li>
</ol>
<h2 id="状态的保存和恢复"><a class="header" href="#状态的保存和恢复">状态的保存和恢复</a></h2>
<ol>
<li>save()
<ol>
<li>Canvas状态存储在栈中，每当<code>save()</code>方法被调用后，当前的状态就被推送到栈中保存</li>
<li>一个绘画状态包括：
<ol>
<li>当前应用的变形（即移动，旋转和缩放）</li>
<li>各种样式</li>
<li>当前的裁切路径（<code>clipping path</code>）</li>
</ol>
</li>
<li>可以调用任意多次 <code>save</code>方法。(类似数组的<code>push()</code>)</li>
</ol>
</li>
<li>restore()
<ol>
<li>每一次调用 <code>restore</code> 方法，上一个保存的状态就从栈中弹出，所有设定都恢复</li>
</ol>
</li>
</ol>
<h2 id="变形"><a class="header" href="#变形">变形</a></h2>
<ol>
<li>
<p>移动</p>
<ol>
<li>
<p><code>translate(x, y)</code></p>
</li>
<li>
<p>用来移动 <code>canvas</code> 的<strong>原点</strong>到指定的位置</p>
</li>
</ol>
</li>
<li>
<p>旋转坐标系</p>
<ol>
<li><code>rotate(angle)</code></li>
<li>旋转的中心是坐标原点。</li>
<li>它是顺时针方向的，以弧度为单位的值。</li>
</ol>
</li>
<li>
<p>缩放</p>
<ol>
<li><code>scale(x, y)</code></li>
<li><code>x,y</code>分别是横轴和纵轴的缩放因子</li>
<li>它们都必须是正值。值比 1.0 小表示缩 小，比 1.0 大则表示放大</li>
</ol>
</li>
<li>
<p>变形矩阵</p>
</li>
<li>
<p>合成</p>
<ol>
<li>globalCompositeOperation = type</li>
<li>type `是下面 13 种字符串值之一：
<ol>
<li><code>source-over(default)</code> : 默认设置，新图像会覆盖在原有图像</li>
<li><code>source-in</code>:仅仅会出现新图像与原来图像重叠的部分，其他区域都变成透明的。(包括其他的老图像区域也会透明)</li>
<li><code>source-out</code>:仅仅显示新图像与老图像没有重叠的部分，其余部分全部透明。(老图像也不显示)</li>
<li><code>source-atop</code>:新图像仅仅显示与老图像重叠区域。老图像仍然可以显示。</li>
<li><code>destination-over</code>:新图像会在老图像的下面</li>
<li><code>destination-in</code>:仅仅新老图像重叠部分的老图像被显示，其他区域全部透明。</li>
<li><code>destination-out</code>:仅仅老图像与新图像没有重叠的部分。 注意显示的是老图像的部分区域。</li>
<li><code>destination-atop</code>:老图像仅仅仅仅显示重叠部分，新图像会显示在老图像的下面。</li>
<li><code>lighter</code>:新老图像都显示，但是重叠区域的颜色做加处理</li>
<li><code>darken</code>:保留重叠部分最黑的像素。(每个颜色位进行比较，得到最小的)</li>
<li><code>lighten</code>:保证重叠部分最量的像素。(每个颜色位进行比较，得到最大的)</li>
<li><code>xor</code>:重叠部分会变成透明</li>
<li><code>copy</code>只有新图像会被保留，其余的全部被清除(边透明)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="裁剪路径"><a class="header" href="#裁剪路径">裁剪路径</a></h2>
<ol>
<li><code>clip()</code>把已经创建的路径转换成裁剪路径。</li>
<li>裁剪路径的作用是遮罩。只显示裁剪路径内的区域，裁剪路径外的区域会被隐藏</li>
<li><code>clip()</code>只能遮罩在这个方法调用之后绘制的图像，如果是<code>clip()</code>方法调用之前绘制的图像，则无法实现遮罩。</li>
</ol>
<h2 id="动画"><a class="header" href="#动画">动画</a></h2>
<h3 id="动画的基本步骤"><a class="header" href="#动画的基本步骤">动画的基本步骤</a></h3>
<ol>
<li>
<p>清空<code>canvas</code></p>
</li>
<li>
<p>保存<code>canvas</code>状态</p>
<p>如果在绘制的过程中会更改<code>canvas</code>的状态(颜色、移动了坐标原点等),又在绘制每一帧时都是原始状态的话，则最好保存下<code>canvas</code>的状态</p>
</li>
<li>
<p>绘制动画图形</p>
</li>
<li>
<p>恢复<code>canvas</code>状态</p>
</li>
</ol>
<h3 id="控制动画"><a class="header" href="#控制动画">控制动画</a></h3>
<ol>
<li><code>setInterval()</code></li>
<li><code>setTimeout()</code></li>
<li><code>requestAnimationFrame()</code></li>
</ol>
<h1 id="example"><a class="header" href="#example">example</a></h1>
<h2 id="1绘制五角星"><a class="header" href="#1绘制五角星">1.绘制五角星</a></h2>
<pre><code class="language-html"> c.beginPath(); 
 c.fillStyle='rgba(255,0,0,0.25)';
 var x=200,y=200;
 var r1 = 60;
  var r2 = 120;
 for(var i=0;i&lt;5;i++){
  c.lineTo(x+r1*Math.cos( Math.PI*((54-i*72)/180)),y-r1*Math.sin(Math.PI*((54-i*72)/180)));
  c.lineTo(x+r2*Math.cos( Math.PI*((18-i*72)/180)),y-r2*Math.sin(Math.PI*((18-i*72)/180)));
}
 c.closePath();
 c.stroke();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="html5的组成"><a class="header" href="#html5的组成">HTML5的组成</a></h2>
<pre><code class="language-txt">1.文档声明
    &lt;!DOCTYPE html&gt;
    
2.html头,页面属性&lt;head&gt;&lt;/head&gt;
    1.标题
        &lt;title&gt;&lt;/title&gt;
    2.字符编码
        &lt;meta charset=&quot;UTF-8&quot;&gt;
    3.页面语言
        1.如果整个页面只有一种语言,则使用
        &lt;html lang=&quot;en&quot;&gt;
        2.如果出现多个语言 则用 &lt;div&gt;包裹

    4.添加样式表
        &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; &gt;
        CSS语言是网页中唯一可用的样式语言

    5.添加JavaScript &lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;
        1.不用写 language=javascript
        2.必须加 &lt;/script&gt;

3.html体 &lt;body&gt;&lt;/body&gt;

4.&lt;html&gt;&lt;/html&gt; 用html标签包裹上述
</code></pre>
<h2 id="h5语法与风格"><a class="header" href="#h5语法与风格">H5语法与风格</a></h2>
<h3 id="语法"><a class="header" href="#语法">语法</a></h3>
<ol>
<li>标签名不区分大小写</li>
<li>允许省略关闭空元素 &lt;br \&gt; &lt;br\&gt;  &lt;br&gt;</li>
<li>属性值中不包含受限的值可以不使用 &quot;&quot;, &lt;img src=a.jpg&gt;</li>
<li>可以省略属性名 &lt;input type=&quot;checkbox&quot; checked&gt;</li>
</ol>
<h3 id="h5风格"><a class="header" href="#h5风格">H5风格</a></h3>
<ol>
<li>包含html,head,body,标签,能将页面内容与页面属性分离</li>
<li>标签全部小写</li>
<li>位属性值加引号</li>
</ol>
<h2 id="html5的改变"><a class="header" href="#html5的改变">HTML5的改变</a></h2>
<h3 id="新增的元素"><a class="header" href="#新增的元素">新增的元素</a></h3>
<table><thead><tr><th>类别</th><th>元素</th></tr></thead><tbody>
<tr><td>用于构建页面的结构语义元素</td><td>article,aside,figcaption,figure,footer,header,hgroup,nav,section,details,summary</td></tr>
<tr><td>表示文本的语义元素</td><td>mark,time,wbr</td></tr>
<tr><td>表单交互</td><td>input,datalist,keygen,meter,progress,command,menu,output</td></tr>
<tr><td>音视频及插件</td><td>audio,video,source,embed</td></tr>
<tr><td>canvas(画布)</td><td>canvas</td></tr>
<tr><td>非英语支持</td><td>bdo,rp,rt,ruby</td></tr>
</tbody></table>
<h3 id="删除的元素"><a class="header" href="#删除的元素">删除的元素</a></h3>
<ol>
<li>H5不欢迎 表现型元素的思想,所谓表现型即 仅为网页添加样式的元素(例如:big,center,font,tt,strike)</li>
<li>同样表现型属性 也不推荐使用</li>
<li>不在使用frame框架</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="html5的结构"><a class="header" href="#html5的结构">HTML5的结构</a></h1>
<h3 id="新增的主体结构元素"><a class="header" href="#新增的主体结构元素">新增的主体结构元素</a></h3>
<table><thead><tr><th>元素名</th><th>作用说明</th></tr></thead><tbody>
<tr><td>article</td><td>用于文章博客</td></tr>
<tr><td>section</td><td>用于对段落之间分区</td></tr>
<tr><td>nav</td><td>一组链接的集合</td></tr>
<tr><td>aside</td><td>侧边栏,广告,附属信息,名词解释</td></tr>
<tr><td>time元素与pubdate属性</td><td>标识时间,pubdate表示发布日期</td></tr>
</tbody></table>
<h3 id="新增的非主机结构元素逻辑结构附加信息"><a class="header" href="#新增的非主机结构元素逻辑结构附加信息">新增的非主机结构元素(逻辑结构,附加信息)</a></h3>
<table><thead><tr><th>元素名</th><th>作用说明</th></tr></thead><tbody>
<tr><td>header</td><td>article的标题,网页标题,一个header至少包含一个h1~h6</td></tr>
<tr><td>hgroup</td><td>标题的组合</td></tr>
<tr><td>footer</td><td>脚注</td></tr>
<tr><td>address</td><td>文档作者,链接,电子邮箱等联系信息</td></tr>
</tbody></table>
<h3 id="h5大纲"><a class="header" href="#h5大纲">H5大纲</a></h3>
<ol>
<li>什么是大纲:综合运用各级内容区块的标题创建好文档的目录</li>
<li>大纲内容编排方式
<ol>
<li>显示编排内容区块:明确使用section等元素创建文档结构,每个内容区块内使用标题</li>
<li>隐式编排:不明确使用section元素,根据页面的各级标题自动创建内容区块</li>
</ol>
</li>
<li>标题分级:不同标题有不同级别,h1最高,h6最低,隐式编排时按照如下规则自动生成内容区块
<ol>
<li>新出现的标题 级别比 上级低 则生成下级内容区块</li>
<li>新出现的标题 级别比 上级高或者相等,则生成新的内容区块</li>
<li>不同内容区块可以使用相同级别的标题</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="html5表单"><a class="header" href="#html5表单">HTML5表单</a></h1>
<h2 id="新增元素与属性"><a class="header" href="#新增元素与属性">新增元素与属性</a></h2>
<h4 id="新增表单相关属性"><a class="header" href="#新增表单相关属性">新增表单相关属性</a></h4>
<table><thead><tr><th>属性名</th><th>作用的元素</th><th>取值</th><th>作用</th></tr></thead><tbody>
<tr><td>form</td><td>一般作用于input元素上</td><td>取form表单ID</td><td>可以把form表单的元素不写在form内部</td></tr>
<tr><td>formaction</td><td>input type=submit</td><td>URL</td><td>使得提交到不同URL</td></tr>
<tr><td>formmethod</td><td>input type=submit</td><td>get,post</td><td>以不同方法提交</td></tr>
<tr><td>placeholder</td><td>input type=text,area</td><td>string</td><td>提示文字</td></tr>
<tr><td>autofocus</td><td>文本框,选择框,按钮</td><td>boolean</td><td>画面打开时自动获得焦点</td></tr>
<tr><td>list</td><td>input type=text</td><td>datalist标签ID</td><td>可供选择条目</td></tr>
<tr><td>autocomplete</td><td>input type=text</td><td>on off</td><td>自动填充</td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<h4 id="新增input元素类型"><a class="header" href="#新增input元素类型">新增input元素类型</a></h4>
<table><thead><tr><th>新增input元素类型</th><th>说明</th></tr></thead><tbody>
<tr><td>email</td><td>邮箱地址输入</td></tr>
<tr><td>url</td><td>url输入</td></tr>
<tr><td>number</td><td>数值类型输入</td></tr>
<tr><td>range</td><td>范围类型</td></tr>
<tr><td>日期选择类型:date</td><td>选择年月日</td></tr>
<tr><td>日期选择类型:month</td><td>选择月年</td></tr>
<tr><td>日期选择类型:week</td><td>选择周,年</td></tr>
<tr><td>日期选择类型:time</td><td>选取时间,小时分钟</td></tr>
<tr><td>日期选择类型:datetime</td><td>选取日月年,时间(UTC时间)</td></tr>
<tr><td>日期选择类型:datetime-local</td><td>选取日月年,时间(本地时间)</td></tr>
<tr><td>color</td><td>颜色选择</td></tr>
<tr><td>search</td><td>搜索框</td></tr>
</tbody></table>
<h4 id="output元素"><a class="header" href="#output元素">output元素</a></h4>
<ol>
<li>&lt;output onforminput=&quot;value=range1.value&quot;&gt;</output></li>
</ol>
<h2 id="表单验证-1"><a class="header" href="#表单验证-1">表单验证</a></h2>
<h4 id="自动验证属性"><a class="header" href="#自动验证属性">自动验证属性</a></h4>
<table><thead><tr><th>属性名</th><th>作用</th><th>举例</th></tr></thead><tbody>
<tr><td>required</td><td>必输项</td><td><input type=text required></td></tr>
<tr><td>pattern</td><td>满足正则</td><td><input type=text pattern="[0-9][A-Z]{3}"></td></tr>
<tr><td>min,max</td><td>限制最小值,最大值</td><td><input type=number min=1 max=100></td></tr>
<tr><td>step</td><td>步进,值位5的倍数</td><td><input type=text step=5 ></td></tr>
</tbody></table>
<h4 id="显示验证取消验证自定义错误"><a class="header" href="#显示验证取消验证自定义错误">显示验证,取消验证,自定义错误</a></h4>
<ol>
<li>手动验证方法:checkValidity()</li>
<li>取消验证:<input type=submit formnovalidate></li>
<li>自定义错误:setCustomValidity</li>
</ol>
<h2 id="增强页面元素"><a class="header" href="#增强页面元素">增强页面元素</a></h2>
<table><thead><tr><th>元素名</th><th>作用</th><th>例子</th></tr></thead><tbody>
<tr><td>figure,figcaption</td><td>figuration:独立的内容,不是很相关,可以是图片;figcaption:从属于figure,为它的标题</td><td>none</td></tr>
<tr><td>details,summary</td><td>详细展开</td><td><details><summary>这是总结</summary><p>HelloWorld</p></details></td></tr>
<tr><td>progress</td><td>进度条</td><td>none</td></tr>
<tr><td>meter</td><td>范围内的数量值,value,min,max,low,high,optimum</td><td>none</td></tr>
<tr><td>改良的ol</td><td>增加start,reversed属性</td><td>none</td></tr>
<tr><td>改良的dl</td><td>配合dt,dd进行术语定义,名词解释</td><td>none</td></tr>
<tr><td>cite</td><td>用于书名,电影名等</td><td>none</td></tr>
<tr><td>small</td><td>小字印刷体</td><td>none</td></tr>
</tbody></table>
<h2 id="文件api"><a class="header" href="#文件api">文件API</a></h2>
<ol>
<li>fileList与file对象</li>
</ol>
<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;
    &lt;/head&gt;
    &lt;script&gt;
        function showfilename(){
            var file;
            for(var i=0;i&lt;document.getElementById('file').files.length;i++){
                file= document.getElementById('file').files[i];
                alert(file.name);
            }
        }
    &lt;/script&gt;
    &lt;body&gt;
        &lt;input type=&quot;file&quot; multiple id=file size=80&gt;
        &lt;input type=&quot;button&quot; onclick=&quot;showfilename()&quot; value=&quot;文件上传&quot;&gt;
    &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<ol start="2">
<li>blob对象的属性与方法
<ol>
<li>size</li>
<li>type:以 image/jgp 样式</li>
</ol>
</li>
<li>accept</li>
</ol>
<pre><code class="language-html">        &lt;input type=&quot;file&quot; multiple id=file size=80 accept=&quot;image/*&quot;&gt;
        &lt;input type=&quot;button&quot; onclick=&quot;showfilename()&quot; value=&quot;文件上传&quot; &gt;
</code></pre>
<ol start="4">
<li>filereader对象</li>
</ol>
<table><thead><tr><th>方法名</th><th>参数描述</th></tr></thead><tbody>
<tr><td>readAsBinaryString</td><td>file,读二进制</td></tr>
<tr><td>readAsText</td><td>file,encoding:文本</td></tr>
<tr><td>readAsDataURL</td><td>file:读作DataURL</td></tr>
<tr><td>abort</td><td>none,中断读取操作</td></tr>
</tbody></table>
<table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody>
<tr><td>obabort</td><td>中断</td></tr>
<tr><td>onerror</td><td>出错</td></tr>
<tr><td>onloadstart</td><td>开始读取</td></tr>
<tr><td>onprogress</td><td>正在读取</td></tr>
<tr><td>onload</td><td>读取成功完成</td></tr>
<tr><td>onloadend</td><td>读取完成,无论成功或失败</td></tr>
</tbody></table>
<p>基本使用</p>
<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;
    &lt;/head&gt;
    &lt;script&gt;
      if(typeof FileReader == 'undefined'){
          result.innerHTML =&quot;&lt;p&gt;浏览器不支持fileReader&lt;/p&gt;&quot;
      }
      function readAsDataURL(){
          var file = document.getElementById('file').files[0];

          if(!/image\/\w+/.test(file.type)){
              alert('图像文件格式不对');
              return false;
          }
          var reader = new FileReader();
          reader.readAsDataURL(file);
          reader.onload= function(e){
            var result = document.getElementById('result');
            result.innerHTML='&lt;img src=&quot;'+this.result+'&quot;/&gt;'
          }
      }
      function readAsBinaryString(){
        var file = document.getElementById('file').files[0];
        var reader = new FileReader();
        reader.readAsBinaryString(file);
        reader.onload = function(f) {
            var result = document.getElementById('result');
            result.innerHTML=this.result
        }
      }
      function readAsText(){
        var file = document.getElementById('file').files[0];
        var reader = new FileReader();
        reader.readAsText(file);
        reader.onload=function (f) {
            var result = document.getElementById('result');
            result.innerHTML=this.result
        }
      }
    &lt;/script&gt;
    &lt;body&gt;
        &lt;p&gt;
            &lt;label&gt;请选择一个文件&lt;/label&gt;
            &lt;input type=&quot;file&quot;  id=&quot;file&quot;&gt;
            &lt;input type=&quot;button&quot; value=&quot;读取图像&quot; onclick=&quot;readAsDataURL()&quot;&gt;
            &lt;input type=&quot;button&quot; value=&quot;读取二进制数据&quot; onclick=&quot;readAsBinaryString()&quot;&gt;
            &lt;input type=&quot;button&quot; value=&quot;读取文本&quot; onclick=&quot;readAsText()&quot;&gt;
        &lt;/p&gt;
        
        &lt;output id=result &gt;

        &lt;/output&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="拖放api"><a class="header" href="#拖放api">拖放API</a></h2>
<h3 id="实现拖放的步骤"><a class="header" href="#实现拖放的步骤">实现拖放的步骤</a></h3>
<ol>
<li>设置draggable 属性(img a标签默认可拖放)</li>
<li>编写拖放事件代码</li>
</ol>
<table><thead><tr><th>事件</th><th>产生事件的元素</th><th>描述</th></tr></thead><tbody>
<tr><td>dragstart</td><td>被拖放的元素</td><td>开始拖放操作</td></tr>
<tr><td>drag</td><td>被拖放的元素</td><td>拖放过程中</td></tr>
<tr><td>dragenter</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素开始进入本元素的范围内</td></tr>
<tr><td>drgaover</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素开始在本元素的范围内移动</td></tr>
<tr><td>dragleave</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素开始离开本元素的范围</td></tr>
<tr><td>drop</td><td>拖放的目标元素</td><td>有其他元素被拖放到了本元素中</td></tr>
<tr><td>dragend</td><td>拖放的对象元素</td><td>拖放操作结束</td></tr>
</tbody></table>
<pre><code class="language-html">&lt;html&gt;
&lt;head&gt;
&lt;/head&gt;
&lt;script&gt;
    function init(){
        var source = document.getElementById('dragme');
        var dest = document.getElementById('text');
        source.addEventListener(&quot;dragstart&quot;,function (ev) {
            var dt = ev.dataTransfer;
            dt.effectAllowed = 'move';
            dt.setData(&quot;text/plain&quot;,'你好');

        },false);

        dest.addEventListener('dragend',function (ev) {
            ev.preventDefault();
        },false);

        dest.addEventListener('drop',function (ev) {
            var dt = ev.dataTransfer;
            var text = dt.getData(&quot;text/plain&quot;);
            dest.innerHTML='&lt;img src=222.jpg&gt;'
            ev.preventDefault();
            ev.stopPropagation();
        },false);
    }
   document.ondragover = function(e){e.preventDefault();}
   document.ondrop = function(e){e.preventDefault();}
&lt;/script&gt;

&lt;body onload=&quot;init()&quot;&gt;
    &lt;div id=&quot;dragme&quot; draggable=&quot;true&quot; style=&quot;width:200px;border :1px solid gray;&quot;&gt;
        请拖放
    &lt;/div&gt;
    &lt;div id=&quot;text&quot; style=&quot;width: 200px; height: 200px; border: 1px solid gray;&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="datatransfer对象的属性与方法"><a class="header" href="#datatransfer对象的属性与方法">DataTransfer对象的属性与方法</a></h3>
<table><thead><tr><th>属性/方法</th><th>描述</th></tr></thead><tbody>
<tr><td>dropeffect属性</td><td>拖放操作的视觉效果,指定的值在effectAllowed范围内</td></tr>
<tr><td>effectAllowed属性</td><td>指定元素被拖放时所允许的效果</td></tr>
<tr><td>types属性</td><td>存入数据的种类,伪数组</td></tr>
<tr><td>clearData(DOMString format)</td><td>清楚DataTransfer对象存放的数据,省略参数清除全部</td></tr>
<tr><td>setData(DOMString format,DOMSttring data)</td><td>向DataTransfer对象中存数据</td></tr>
<tr><td>getData(DOMString firmat)</td><td>从DT取数据</td></tr>
<tr><td>setDragImage(Element image,long x,long  y)</td><td>用img元素来设置拖放图标</td></tr>
</tbody></table>
<h3 id="自定义拖放icon"><a class="header" href="#自定义拖放icon">自定义拖放ICON</a></h3>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;/head&gt;
&lt;script&gt;
    var dragIcon = document.createElement('img');
    dragIcon.src = '222.jpg';

    function init(){
        var source = document.getElementById('dragme');
        var dest = document.getElementById('text');

        source.addEventListener(&quot;dragstart&quot;,function (ev) {
            var dt = ev.dataTransfer;
            dt.effectAllowed = 'all';
            dt.dropEffect = 'copyMove';
            dt.setDragImage(dragIcon,120,150);
            dt.setData(&quot;text/plain&quot;,'你好');

        },false);

        dest.addEventListener('dragend',function (ev) {
            ev.preventDefault();
        },false);

        dest.addEventListener('drop',function (ev) {
            var dt = ev.dataTransfer;
            var text = dt.getData(&quot;text/plain&quot;);
            dest.innerHTML='&lt;img src=222.jpg&gt;'
            ev.preventDefault();
            ev.stopPropagation();
        },false);
    }
   document.ondragover = function(e){e.preventDefault();}
   document.ondrop = function(e){e.preventDefault();}
&lt;/script&gt;

&lt;body onload=&quot;init()&quot;&gt;
    &lt;div id=&quot;dragme&quot; draggable=&quot;true&quot; style=&quot;width:200px;border :1px solid gray;&quot;&gt;
        请拖放
    &lt;/div&gt;
    &lt;div id=&quot;text&quot; style=&quot;width: 200px; height: 200px; border: 1px solid gray;&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webworkers出现线程"><a class="header" href="#webworkers出现线程">WebWorkers出现线程</a></h1>
<h2 id="webworker简介"><a class="header" href="#webworker简介">webworker简介</a></h2>
<ol>
<li>
<p>创建后台运行线程API</p>
</li>
<li>
<p>webwork对象创建</p>
<p><code>var worker = new Worker(&quot;worker.js&quot;)</code></p>
</li>
<li>
<p>后台线程不能访问 窗口和页面对象,所有不能使用 document,window对象</p>
</li>
<li>
<p>接收发送消息</p>
<p><code>worker.onmessage=function(event){....}</code></p>
<p><code>worker.postMessage(message);</code></p>
</li>
<li>
<p>线程中可以在创建线程, 嵌套</p>
</li>
<li>
<p>线程中可用的变量函数类</p>
<ol>
<li>self:本线程范围的作用域</li>
<li>postMessage(message):向线程创建者发送消息</li>
<li>onmessage:接收消息的句柄</li>
<li>importScripts(urls):导入其他JavaScript脚本文件,可以导入多个</li>
<li>navigator对象:具有appName,platform,userAgent,appVersion属性</li>
<li>sessionStorage/localStorage</li>
<li>XMLHttpRequest</li>
<li>setTimeout()/setInterval()</li>
<li>close:结束本线程</li>
<li>eval(),isNaN(),escape()</li>
<li>object</li>
<li>websockets</li>
</ol>
</li>
<li>
<p>示例</p>
</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;UTF-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script type=&quot;text/javascript&quot;&gt;
			var worker = new Worker(&quot;sumcalculator.js&quot;);
			worker.onmessage = function(event){
				alert(&quot;合计为:&quot;+event.data)
			}
			function calculate(){
				var num = parseInt(document.getElementById('num').value,10);
				worker.postMessage(num);
			}
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;从1到给定数值的和&lt;/h1&gt;
		&lt;input type=&quot;number&quot;  id=&quot;num&quot; &gt;
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;计算&quot; onclick=&quot;calculate()&quot; /&gt;
	&lt;/body&gt;
&lt;/html&gt;

/*sumcalculator.js*/
onmessage = function(event){
	var num = event.data;
	var result = 0;
	for (var i=0;i&lt;num;i++) {
		result+=i;
	}
	postMessage(result);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多媒体播放"><a class="header" href="#多媒体播放">多媒体播放</a></h1>
<h2 id="video元素与audio元素"><a class="header" href="#video元素与audio元素">video元素与audio元素</a></h2>
<ol>
<li><code>&lt;audio&gt;你的浏览器不支持audio标签&lt;/audio&gt;</code></li>
<li><code>&lt;video&gt;你的浏览器不支持video标签&lt;/video&gt;</code></li>
</ol>
<h2 id="属性-1"><a class="header" href="#属性-1">属性</a></h2>
<p>audio与video元素所具有的属性大致相同</p>
<ol>
<li>
<p><code>src</code> 资源地址</p>
</li>
<li>
<p><code>autoplay</code>是否自动播放</p>
</li>
<li>
<p><code>preload</code>是否预加载</p>
<ol>
<li><code>none</code>不预加载</li>
<li><code>metadata</code>:只预加载元素数据(媒体字节数,第一帧,播放列表,持续时间)</li>
<li><code>auto</code>:全部预加载</li>
</ol>
</li>
<li>
<p><code>poster</code>(video独有属性)</p>
<p>但视频不可用时,可以使用该元素向用户展示一幅替代图片</p>
</li>
<li>
<p><code>loop</code>:循环播放</p>
</li>
<li>
<p><code>error</code>:正常为null,出现错误时.返回MediaError对象,中的code可选值</p>
<ol>
<li>MEDIA_ERR_AABORTED(1):用户操作取消</li>
<li>MEDIA_ERR_NETWORK(2):网络错误</li>
<li>MEDIA_ERR_DECODE(3);编码错误</li>
<li>MEDIA_ERR_SRC_NOT_SUPPORTED(4):媒体格式不支持</li>
</ol>
</li>
<li>
<p><code>networkstate</code>:读取当前网络状态</p>
<ol>
<li>NETWORK_EMPTY(0):元素处于初始状态</li>
<li>NETWORK_IDLE(1):浏览器已准备好,尚未建立网络连接</li>
<li>NETWORK_NO_SOURCE(3):没有支持的编码格式</li>
</ol>
</li>
<li>
<p><code>currentSrc</code>:当前url地址,只读属性</p>
</li>
<li>
<p><code>buffered</code>:返回一个timeRanges对象,以确认浏览器是否已缓存媒体数据</p>
<ol>
<li><code>TimeRanges.length</code> 存在时间范围的个数</li>
<li><code>TimeRanges.start(index)</code>:表示第几个缓存区开始时间</li>
<li><code>TimeRanges.end(index)</code>:第几个缓存区结束时间</li>
</ol>
</li>
<li>
<p><code>readyState</code>:返回媒体当前播放位置的就绪状态</p>
<ol>
<li>HAVE_NOTHING(0):没有取到媒体任务信息</li>
<li>HAVE_METADATA(1):已经获取到足够的元数据,但当前播放位置没有有效的媒体数据</li>
<li>HAVE_CURRENT_DATA(2):已经有数据可以播放,但下一帧还没有获得</li>
<li>HAVE_FUTURE_DATA(3):已经有数据,也获取到了下一帧</li>
<li>HAVE_ENOUGH_DATA(4):已经有数据,也获取到了下一帧,且能以某一速率加载</li>
</ol>
</li>
<li>
<p><code>seeking</code>与 <code>seekable</code></p>
<ol>
<li><code>seeking</code>表示浏览器是否正在请求数据</li>
<li><code>seekable</code>:表示浏览器请求到的数据的时间范围,<code>TimeRanges</code></li>
</ol>
</li>
<li>
<p><code>currentTime,startTime,duartion</code></p>
<ol>
<li><code>currentTime</code>当前播放时间,可修改</li>
<li><code>startTime</code>:媒体开始时间,一般为0</li>
<li><code>duration</code>:时长</li>
</ol>
</li>
<li>
<p><code>played,paused,ended</code></p>
<ol>
<li><code>played</code>:表示已播放的时间段,<code>TimeRanges</code>对象</li>
<li><code>paused</code>:是否暂停播放</li>
<li><code>ended</code>:是否播放完毕</li>
</ol>
</li>
<li>
<p><code>defaultPlaybackRate</code>与<code>playbackRate</code></p>
<p>默认播放速度,与播放速度,可修改</p>
</li>
<li>
<p><code>volume</code>与 <code>muted</code></p>
<ol>
<li><code>volume</code>修改音量</li>
<li><code>muted</code>静音,可修改</li>
</ol>
</li>
</ol>
<h2 id="方法-3"><a class="header" href="#方法-3">方法</a></h2>
<table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody>
<tr><td>play()</td><td>播放,将paused属性设置为false</td></tr>
<tr><td>pause()</td><td>暂停,将paused属性设置为false</td></tr>
<tr><td>load()</td><td>重载媒体播放</td></tr>
<tr><td>canPlayType(type)</td><td>测试浏览器是否支持指定的媒体类型,可选:maybe,probably,空串(不支持)</td></tr>
</tbody></table>
<h2 id="事件"><a class="header" href="#事件">事件</a></h2>
<ol>
<li>
<p>给媒体元素添加事件</p>
<p><code>videoElement.addEventListener(type,listener,useCapture)</code></p>
<ol>
<li>type事件名称</li>
<li>listener事件处理句柄</li>
<li>useCapture:true采用capture,false采用bubbling,事件捕获机制,一般用false</li>
</ol>
</li>
<li>
<p>媒体事件</p>
<table><thead><tr><th>时间名</th><th>描述</th></tr></thead><tbody>
<tr><td>loadstart</td><td>开始网上寻找媒体数据</td></tr>
<tr><td>progress</td><td>正在获取媒体数据</td></tr>
<tr><td>suspend</td><td>暂停获取媒体数据,下载过程并没有正常结束</td></tr>
<tr><td>abort</td><td>用于手动取消</td></tr>
<tr><td>error</td><td>获取媒体出错</td></tr>
<tr><td>emptied</td><td>网络突然变为未初始化状态 1.载入媒体突然发生致命错误,2,浏览器调用了load</td></tr>
<tr><td>stalled</td><td>尝试获取媒体数据失败</td></tr>
<tr><td>play</td><td>即将开始播放,执行了play方法触发</td></tr>
<tr><td>pause</td><td>执行pause方法触发</td></tr>
<tr><td>loadedmetadata</td><td>浏览器获取完毕媒体的时间长和字节数</td></tr>
<tr><td>loadeddata</td><td>浏览器已加载完毕当前播放位置的媒体数据,准备播放</td></tr>
<tr><td>waiting</td><td>由于得不到下一帧而暂停播放,但很快就能得到下一帧</td></tr>
<tr><td>playing</td><td>正在播放</td></tr>
<tr><td>canplay</td><td>浏览器能播放媒体,估计以当前播放速率不能直接播放完毕媒体,需求缓冲</td></tr>
<tr><td>canplaythrough</td><td>浏览器能够播放媒体,以当前的播放速率能将媒体播放完毕</td></tr>
<tr><td>seeking</td><td>seeking属性变为true,浏览器正在请求数据</td></tr>
<tr><td>seeked</td><td>seeking属性变为false,浏览器停止请求数据</td></tr>
<tr><td>timeupdate</td><td>当前播放位置改变,可能是自然改变,也可能时人为改变,或由于播放不能连续发生跳变</td></tr>
<tr><td>ended</td><td>播放结束后停止播放</td></tr>
<tr><td>ratechange</td><td>默认播放速率或者播放速率被改变</td></tr>
<tr><td>durationchange</td><td>播放时长改变</td></tr>
<tr><td>volumechange</td><td>声音音量改变或者静音</td></tr>
</tbody></table>
</li>
</ol>
<h1 id="example-1"><a class="header" href="#example-1">example</a></h1>
<ol>
<li>
<p>简陋的播放器</p>
<pre><code class="language-html">&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;视频播放器&lt;/title&gt;
&lt;/head&gt;
&lt;script&gt;
    function playOrPauseVideo() {
        var videoUrl = document.getElementById('videoUrl').value;
        var video = document.getElementById('video');
        video.addEventListener('timeupdate',function(){
            var timeDisplay = document.getElementById('time');
            timeDisplay.innerHTML=Math.floor(video.currentTime)+&quot;/&quot;+Math.floor(video.duration)+&quot; (秒)&quot;
        },false)

        if(video.paused){
            if(videoUrl != video.src){
                video.src = videoUrl;
                video.load();
                document.getElementById('playButton').value='播放'
            }else{
                video.play();
                document.getElementById('playButton').value='播放'
            }
        }else{
            video.pause();
            document.getElementById('playButton').value='暂停'
        }
    }
&lt;/script&gt;
&lt;body&gt;
    &lt;video id=&quot;video&quot; width=&quot;400&quot; height=&quot;300&quot; autoplay &gt;&lt;/video&gt;
    &lt;br&gt;
    视频地址:&lt;input type=&quot;text&quot; id=&quot;videoUrl&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;playButton&quot; onclick=&quot;playOrPauseVideo()&quot; value=&quot;播放&quot; &gt;
    &lt;span id=&quot;time&quot;&gt;&lt;/span&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="本地存储"><a class="header" href="#本地存储">本地存储</a></h1>
<h2 id="webstorage"><a class="header" href="#webstorage">WebStorage</a></h2>
<h3 id="什么是webstorage"><a class="header" href="#什么是webstorage">什么是webStorage</a></h3>
<p>在客户端本地存储数据</p>
<h3 id="分类"><a class="header" href="#分类">分类</a></h3>
<ol>
<li>sessionStorage:用户浏览某个网站,从进入到关闭经过的这段时间所保存的任何数据</li>
<li>localStorage:保存在客户端本地中,即使浏览器关闭了数据仍然存在</li>
</ol>
<h3 id="localstoragesessionstorage方法"><a class="header" href="#localstoragesessionstorage方法">localStorage,sessionStorage方法</a></h3>
<ol>
<li><code>getitem(key)</code></li>
<li><code>setItem(key,value)</code></li>
<li><code>removeItem(key)</code></li>
<li><code>key(int index)</code></li>
<li><code>clear()</code></li>
</ol>
<h2 id="本地数据库"><a class="header" href="#本地数据库">本地数据库</a></h2>
<h3 id="sqllite数据库的使用"><a class="header" href="#sqllite数据库的使用"><code>'sqllite'</code>数据库的使用</a></h3>
<ol>
<li>
<p>创建访问数据库</p>
<ol>
<li>
<p><code>var db = openDatabase('mydb','1.0','TestDB',2*1024*1024)</code></p>
</li>
<li>
<p>数据库名,版本号,数据库描述,数据库大小</p>
</li>
<li>
<p>如果数据库不存在则创建新的</p>
</li>
</ol>
</li>
<li>
<p>使用事物处理</p>
<ol>
<li>示例</li>
</ol>
<pre><code class="language-javascript">db.transaction(function(tx){
	tx.executeSql('create table if not exists logs (id unique,log)');
});
</code></pre>
<ol start="2">
<li><code>transaction.executeSql(sqlquery,[],dataHandler,errorHandler)</code>
<ol>
<li>[] 为sqlquery语句中? 的参数</li>
<li>datahandler(transaction,results)
<ol>
<li>results.rows[index]</li>
<li>results.rows.item(index)</li>
</ol>
</li>
<li>errorhandler(transaction,errmsg</li>
</ol>
</li>
</ol>
<h2 id="example-2"><a class="header" href="#example-2">example</a></h2>
<ol>
<li>
<p>sessionStorage,localStorage简单使用</p>
<pre><code class="language-html">&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;/head&gt;
&lt;script&gt;
  function saveStorage(id) {
       var target = document.getElementById(id);
       var str = target.value;
       sessionStorage.setItem(&quot;message&quot;,str);
  }

  function loadStorage(id) {
      var target = document.getElementById(id);
      var msg = sessionStorage.getItem('message');
      target.innerHTML = msg;
  }

  function saveStorage_l(id) {
       var target = document.getElementById(id);
       var str = target.value;
       localStorage.setItem(&quot;message&quot;,str);
  }

  function loadStorage_l(id) {
      var target = document.getElementById(id);
      var msg = localStorage.getItem('message');
      localStorage.
      target.innerHTML = msg;
  }

&lt;/script&gt;
&lt;body&gt;
    &lt;p id=&quot;msg&quot;&gt;&lt;/p&gt;
    &lt;input type=&quot;text&quot; id=&quot;text&quot; &gt;
    &lt;input type=&quot;button&quot; value=&quot;保存数据&quot; onclick=&quot;saveStorage_l('text')&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;读取数据&quot; onclick=&quot;loadStorage_l('msg')&quot;&gt;

&lt;/body&gt;
&lt;/html&gt;

</code></pre>
</li>
<li>
<p>web留言本界面</p>
<pre><code class="language-html">&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;/head&gt;
&lt;script&gt;
    var datatable = null;
    var db = openDatabase('mydata','','mydatabase',102400);
    function init() {
        datatable= document.getElementById('datatable');
        showAllData();
    }

    function removeAllData() {
        for(var i=datatable.childNodes.length-1;i&gt;=0;i--){
            datatable.removeChild(datatable.childNodes[i]);
        }
        var tr = document.createElement('tr');
        var th1 = document.createElement('th');
        var th2 = document.createElement('th');
        var th3 = document.createElement('th');
        th1.innerHTML='姓名'
        th2.innerHTML='留言'
        th3.innerHTML='时间'
        tr.appendChild(th1);
        tr.appendChild(th2);
        tr.appendChild(th3);
        datatable.appendChild(tr);
    }

    function showData(row) {
        var tr =document.createElement('tr');
        var td1 = document.createElement('td');
        td1.innerHTML = row.name;
        var td2 = document.createElement('td');
        td2.innerHTML = row.message;
        var td3 = document.createElement('td');
        var t = new Date();
        t.setTime(row.time);
        td3.innerHTML = t.toLocaleDateString()+&quot; &quot;+t.toLocaleTimeString();
        tr.appendChild(td1);
        tr.appendChild(td2);
        tr.appendChild(td3);
        datatable.appendChild(tr);
    }

    function showAllData(){
        db.transaction(function(tx){
            tx.executeSql('create table if not exists MsgData(name TEXT,message Text,time Integer)',[]);
            tx.executeSql('select * from MsgData',[],function(tx,rs){
                removeAllData();
                for(var i=0;i&lt;rs.rows.length;i++){
                    showData(rs.rows[i]);
                }
            })
        })
    }
    
    function addData(name,message,time) {
        db.transaction(function(tx) {
            tx.executeSql('insert into MsgData values(?,?,?)',[name,message,time],
            function(tx,rs) {
                alert('数据保存成功!')
            },
            function (tx,error) {
                alert(error.source+&quot;::&quot;+error.message)
            }
            )
        })
    }

    function saveData() {
        var name = document.getElementById('name').value;
        var memo = document.getElementById('memo').value;
        var time = new Date().getTime();
        addData(name,memo,time);
        showAllData();
    }
&lt;/script&gt;
&lt;body onload=&quot;init();&quot;&gt;
    &lt;table&gt;
        &lt;tr&gt;&lt;td&gt;姓名:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot;  id=&quot;name&quot;&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;留言:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot;  id=&quot;memo&quot;&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;button&quot; value=&quot;保存&quot; onclick=&quot;saveData()&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
    &lt;hr&gt;
    &lt;table id=&quot;datatable&quot; border=&quot;1&quot;&gt;&lt;/table&gt;
    &lt;p id=&quot;msg&quot;&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="离线应用程序"><a class="header" href="#离线应用程序">离线应用程序</a></h1>
<h2 id="本地缓存"><a class="header" href="#本地缓存">本地缓存</a></h2>
<ol>
<li>
<p>什么是本地缓存</p>
<p>为了让web应用程序在离线状态也能正常工作,就必须要把所有构成web应用程序得资源文件放在本地缓存中,</p>
</li>
<li>
<p>本地缓存与浏览器网页缓存得区别</p>
<ol>
<li>
<p>服务对象</p>
<ol>
<li>本地缓存时为整个web应用服务的,</li>
<li>浏览器的网页缓存只服务于单个网页</li>
</ol>
</li>
<li>
<p>本地缓存只缓存你指定的网页</p>
</li>
<li>
<p>网页缓存不可靠,不安全,而本地缓存是可靠,可控的</p>
<p>可以通过编程 控制缓存的更新,利用缓存对象的各种属性,状态,事件</p>
</li>
</ol>
</li>
</ol>
<h2 id="manifest文件"><a class="header" href="#manifest文件">manifest文件</a></h2>
<ol>
<li>
<p>什么是manifest文件</p>
<ol>
<li>是一个以清单的形式 列举需要缓存 不需要缓存的资源文件的名称及路径</li>
<li>可以为单网页指定一个manifest,可以对整个web应用指定总的manifest</li>
</ol>
</li>
<li>
<p>书写格式</p>
<ol>
<li>
<p>example</p>
<pre><code>cache manifest #文件开头必须写

#version 7 #版本号

cache

other.html

hello.js

images/myphoto.jpg

network

http://dfsdf/sdfsdf/df.asp

*

fallback

online.js locale.js

cache

newhello.js
</code></pre>
</li>
<li>
<p>资源文件分三类</p>
<ol>
<li><code>cache</code>:需要被缓存的文件</li>
<li><code>network</code>:不进行本地缓存的文件</li>
<li><code>fallback</code>:指定两个资源文件,第二个资源文件为不能在线时使用的备用资源文件</li>
</ol>
</li>
</ol>
</li>
<li>
<p>manifest 浏览器与服务器的交互过程</p>
<ol>
<li>
<p>UML 时序图</p>
<pre><code class="language-txt">@startuml manifest下的BS交互图

participant 浏览器 as a

participant 服务器 as b

== 初次请求 ==
a-&gt;b:请求www.baidu.com
b-&gt;a:返回index.html页面
a-&gt;b:请求资源文件包括manifest文件
b-&gt;a:返回请求的文件
a-&gt;b:解析并请求manifest文件中需要缓存的文件\n假设index.html文件需要被缓存
b-&gt;a:返回相应文件
== 请求 服务器端没有修改过的本地缓存 ==
a-&gt;a:重新请求index.html,发现本地有缓存
a-&gt;b:请求manifest文件
b-&gt;a:返回403,表示没有更新

== 请求 服务器端已经修改过的本地缓存 ==
a-&gt;a:重新请求index.html,发现本地有缓存
a-&gt;b:请求manifest文件
b-&gt;a:返回manifest文件
a-&gt;b:发现manifest已更新,重新请求文件中需要缓存的文件
b-&gt;a:返回请求的文件
[&lt;-a:更新本地缓存,触发相应事件
@enduml
</code></pre>
<p><img src="Html5/C:%5CUsers%5CAdministrator%5CDesktop%5CUntitled-1%5Cmanifest%E4%B8%8B%E7%9A%84BS%E4%BA%A4%E4%BA%92%E5%9B%BE.png" alt="manifest下的BS交互图" /></p>
</li>
</ol>
</li>
</ol>
<h2 id="applicationcache对象"><a class="header" href="#applicationcache对象">applicationCache对象</a></h2>
<ol>
<li>
<p>applicationCache简介</p>
<ol>
<li>代表了本地缓存</li>
<li>通知用户本地缓存已被更新:<code>onUpdateReady</code></li>
<li>也允许用户手动更新本地缓存:<code>swapCache</code></li>
</ol>
</li>
<li>
<p>applicationCache对象的事件</p>
<table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody>
<tr><td>checking</td><td>浏览器发现该网页有manifest属性,触发该事件,检查manifest文件是否存在,不存在触发error事件,表示manifest文件未找到</td></tr>
<tr><td>noupdate</td><td>浏览器检查服务器manifest有没有更新,没有更新则触发该事件</td></tr>
<tr><td>downloading</td><td>开始下载manifest中指定的文件,并周期性的触发progress</td></tr>
<tr><td>cached</td><td>下载结束后触发cached事件,首次缓存成功</td></tr>
<tr><td>updateready</td><td>manifest文件有更新,更新完毕后触发</td></tr>
<tr><td>obsolete</td><td>请求文件404,410时 触发</td></tr>
<tr><td>error</td><td>任何与本地缓存有关的处理中发生错误,都会触发error事件</td></tr>
</tbody></table>
<pre><code>@startuml manifest下的BS交互图
participant 浏览器 as a order 2
participant 服务器 as b order 3
participant 事件处理 as c order 1

== 初次请求 ==
a-&gt;b:请求www.baidu.com
b-&gt;a:返回index.html页面
a-&gt;b:请求资源文件包括manifest文件
c&lt;-a:触发checking事件
b-&gt;a:返回请求的文件

a-&gt;b:解析并请求manifest文件中需要缓存的文件\n假设index.html文件需要被缓存
c&lt;-a:触发downing事件
c&lt;-a:触发progress事件
c&lt;-a:若文件不存在404,410,触发obsolete事件
c&lt;-a:下载过程中发生错误,错误error事件
b-&gt;a:返回相应文件
c&lt;-a:触发cached事件
== 请求 服务器端没有修改过的本地缓存 ==
a-&gt;a:重新请求index.html,发现本地有缓存
a-&gt;b:请求manifest文件
b-&gt;a:返回403,表示没有更新
c&lt;-a:触发noupdate事件

== 请求 服务器端已经修改过的本地缓存 ==
a-&gt;a:重新请求index.html,发现本地有缓存
a-&gt;b:请求manifest文件
b-&gt;a:返回manifest文件
a-&gt;b:发现manifest已更新,重新请求文件中需要缓存的文件
c&lt;-a:触发downing事件
c&lt;-a:触发progress事件
b-&gt;a:返回请求的文件
c&lt;-a:更新本地缓存,触发updateReady事件
@enduml
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="获取地址位置信息"><a class="header" href="#获取地址位置信息">获取地址位置信息</a></h1>
<h2 id="获取当前地理位置"><a class="header" href="#获取当前地理位置">获取当前地理位置</a></h2>
<ol>
<li><code>void getCurrentPosition(onSuccess,onError,options)</code></li>
<li>onError中的code取值
<ol>
<li>1:用户拒绝位置服务</li>
<li>2:获取不到位置信息</li>
<li>3:获取信息超时</li>
</ol>
</li>
<li>options属性可选
<ol>
<li>enableHighAccuracy:高精度定位</li>
<li>timeout:超时事件</li>
<li>maximumAge(单位毫秒):地理位置信息缓存有效时间</li>
</ol>
</li>
</ol>
<h2 id="监视当前地理位置"><a class="header" href="#监视当前地理位置">监视当前地理位置</a></h2>
<pre><code>1. int watchCurrentPosition(onSuccess,onError,options)
2. 停止监视:void clearWatch(watchId)
</code></pre>
<h2 id="position对象"><a class="header" href="#position对象">position对象</a></h2>
<ol>
<li>属性
<ol>
<li>latitude 纬度</li>
<li>longitude:精度</li>
<li>altitude:海拔高度</li>
<li>accuracy:经纬精度,米为单位</li>
<li>altitudeAccuracy:海拔高度的精度</li>
<li>heading:设备前进方向,面朝正北方向的顺时针旋转角度表示</li>
<li>speed:设备前进速度,米为单位</li>
<li>timestamp:地理位置的获取时间</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通信api"><a class="header" href="#通信api">通信API</a></h1>
<h2 id="跨文档消息传输"><a class="header" href="#跨文档消息传输">跨文档消息传输</a></h2>
<ol>
<li>
<p>什么是跨文档消息传输?</p>
<ol>
<li>H5提供在网页文档之间互相接收与发送消息的功能</li>
<li>只要获取到网页所在窗口对象的实例,不仅同源(域+端口号) 的web网页之间可以互相通信</li>
<li>甚至可以跨域通信</li>
</ol>
</li>
<li>
<p>流程</p>
<ol>
<li>
<p>从其他窗口接收消息</p>
<p><code>window.addEventListener(&quot;message&quot;,function(){...},false);</code></p>
</li>
<li>
<p>使用window对象发送消息</p>
<p><code>window.postMessage(message,targetOrigin)</code></p>
<p>targetOrigin:为对象窗口的URL地址例如:http://localhost:8080</p>
</li>
</ol>
</li>
</ol>
<h2 id="websocket通信"><a class="header" href="#websocket通信">webSocket通信</a></h2>
<ol>
<li>
<p>使用方式</p>
<ol>
<li>
<p>创建对象</p>
<p><code>var webSocket = new WebSocket(&quot;ws://localhost:8005&quot;)</code></p>
</li>
<li>
<p>发送数据</p>
<p><code>websocket.send(String)</code></p>
</li>
<li>
<p>主动关闭</p>
<p><code>websocket.close()</code></p>
</li>
</ol>
</li>
<li>
<p>事件</p>
<ol>
<li>onmessage</li>
<li>onopen</li>
<li>onclose</li>
</ol>
</li>
<li>
<p>readyState的状态</p>
<ol>
<li>
<p>CONNECTING(0):正在连接</p>
</li>
<li>
<p>OPEN(1):已建立连接</p>
</li>
<li>
<p>CLOSING(数值为2):正在关闭连接</p>
</li>
<li>
<p>CLOSED(数值为3):已关闭连接</p>
</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="学好css四大要素缺一不可"><a class="header" href="#学好css四大要素缺一不可"><strong>学好css四大要素缺一不可</strong></a></h2>
<ol>
<li><strong>基础知识</strong></li>
<li><strong>模块化思维</strong></li>
<li><strong>布局思维</strong></li>
<li><strong>用户体验思维</strong></li>
</ol>
<h2 id="基础知识"><a class="header" href="#基础知识"><strong>基础知识</strong></a></h2>
<p>css 和 html 的基本语法和常用的属性和标签</p>
<h2 id="模块化思维"><a class="header" href="#模块化思维"><strong>模块化思维</strong></a></h2>
<p>模块化是一种拆解思维，无论多么复杂的页面，都是多个模块组成的</p>
<p><strong>大概常用的模块如下</strong></p>
<ol>
<li>列表：图片列表，新闻列表，产品列表等</li>
<li>导航：侧边导航，主导航，子导航</li>
<li>头部</li>
<li>底部</li>
<li>轮播图</li>
<li>选项卡</li>
<li>表单：文本框，按钮，复选框</li>
</ol>
<h2 id="布局思维"><a class="header" href="#布局思维"><strong>布局思维</strong></a></h2>
<p>布局的核心就是把零碎的模块排版起来，每个模块放在应该在的位置，形成一个完整的页面。</p>
<p>布局的基础知识核心</p>
<p>浮动float ，定位 positon</p>
<p>布局的形式</p>
<ol>
<li>上中下</li>
<li>左中右</li>
<li>多列</li>
<li>固定宽度列+自适应列</li>
</ol>
<p>布局的顺序</p>
<ol>
<li>从上到下</li>
<li>从左到右</li>
<li>从外到里</li>
</ol>
<h2 id="用户体验思维"><a class="header" href="#用户体验思维"><strong>用户体验思维</strong></a></h2>
<p>学习的时候，基础是核心，能决定你能走多远的是用户体验。</p>
<p><strong>学习模式是顺时针</strong>：基础-&gt;模块化-&gt;布局-&gt;用户体验</p>
<p><strong>工作模式是逆时针</strong>：用户体验-&gt;布局-&gt;模块化-&gt;基础</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bfc块级格式化上下文"><a class="header" href="#bfc块级格式化上下文">BFC(块级格式化上下文)</a></h1>
<blockquote>
<p>BlockingFormatContext</p>
</blockquote>
<h2 id="bfc是什么"><a class="header" href="#bfc是什么">BFC是什么？</a></h2>
<p>在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。</p>
<h3 id="box-css布局的基本单位"><a class="header" href="#box-css布局的基本单位">Box: CSS布局的基本单位</a></h3>
<p>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。
　　让我们看看有哪些盒子：</p>
<h4 id="block-level-box"><a class="header" href="#block-level-box"><strong>block-level box</strong></a></h4>
<p>display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</p>
<h4 id="inline-level-box"><a class="header" href="#inline-level-box"><strong>inline-level box</strong></a></h4>
<p>display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</p>
<h4 id="run-in-box"><a class="header" href="#run-in-box"><strong>run-in box</strong></a></h4>
<p>css3 中才有， 这儿先不讲了。</p>
<h3 id="formatting-context"><a class="header" href="#formatting-context">Formatting context</a></h3>
<p>Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</p>
<p>CSS2.1 中只有 BFC 和 IFC, CSS3 中还增加了 GFC 和 FFC。</p>
<h3 id="bfc-定义"><a class="header" href="#bfc-定义">BFC 定义</a></h3>
<p>BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<h3 id="bfc布局规则"><a class="header" href="#bfc布局规则">BFC布局规则</a></h3>
<ol>
<li>内部的Box会在垂直方向，一个接一个地放置。（BFC内部元素布局）</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠（外边距重叠）</li>
<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如 此。（与包含块 左边相邻）</li>
<li>BFC的区域不会与float box重叠。（不与浮动元素重叠）</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。（隔离性）</li>
<li>计算BFC的高度时，浮动元素也参与计算</li>
</ol>
<h2 id="哪些元素会生成bfc"><a class="header" href="#哪些元素会生成bfc">哪些元素会生成BFC?</a></h2>
<ul>
<li>根元素</li>
<li>float属性不为none</li>
<li>position为absolute或fixed</li>
<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>
<li>overflow不为visible( hidden,scroll,auto, )</li>
</ul>
<h2 id="bfc的作用及原理"><a class="header" href="#bfc的作用及原理">BFC的作用及原理</a></h2>
<h3 id="自适应两栏布局"><a class="header" href="#自适应两栏布局">自适应两栏布局</a></h3>
<pre><code class="language-css">body {
        width: 300px;
        position: relative;
    }
    .aside {
        width: 100px;
        height: 150px;
        float: left;
        background: #f66;
    }
    .main {
        height: 200px;
        background: #fcc;
    }
</code></pre>
<pre><code class="language-html"> &lt;body&gt;
        &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;/body&gt;
</code></pre>
<p>根据BFC布局规则第3条：</p>
<p>每个元素的margin box的左边， 与包含块border box的左边相接触，即使存在浮动也是如此。</p>
<p>因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。</p>
<p>根据BFC布局规则第四条：</p>
<blockquote>
<p>BFC区域不会与float box重叠。</p>
</blockquote>
<p>我们可以通过通过触发main生成BFC， 来实现自适应两栏布局。</p>
<pre><code class="language-css">.main {
    overflow: hidden;
}
</code></pre>
<h3 id="高度塌陷问题"><a class="header" href="#高度塌陷问题">高度塌陷问题</a></h3>
<pre><code class="language-css">.par {
    border: 5px solid #fcc;
    width: 300px;
 }
 
.child {
    border: 5px solid #f66;
    width: 100px;
    height: 100px;
    float: left;
}
</code></pre>
<pre><code class="language-html">&lt;body&gt;
    &lt;div class=&quot;par&quot;&gt;
        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>根据BFC布局规则第六条：</p>
<blockquote>
<p>计算BFC的高度时，浮动元素也参与计算</p>
</blockquote>
<p>为达到清除内部浮动，我们可以触发par生成BFC，那么par在计算高度时，par内部的浮动元素child也会参与计算。</p>
<pre><code class="language-css">.par {
    overflow: hidden;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="css语法"><a class="header" href="#css语法">CSS语法</a></h2>
<p>css语法=选择器 {申明块}
声明块=属性名:属性值;</p>
<h2 id="值匹配选择器"><a class="header" href="#值匹配选择器">值匹配选择器</a></h2>
<p>元素选择器
选择器分组
声明块分组
选择器与声明块结合的分组
类选择器
ID选择器
简单属性选择器
具体属性选择器
完整属性匹配选择器
部分属性匹配选择器
子串属性匹匹配选择器
前缀属性匹配选择器
后缀属性匹配选择器</p>
<h2 id="结构匹配选择器"><a class="header" href="#结构匹配选择器">结构匹配选择器</a></h2>
<p>后代选择器
儿子选择器
相邻兄弟选择器</p>
<h2 id="伪类选择器"><a class="header" href="#伪类选择器">伪类选择器</a></h2>
<p><strong>静态伪类</strong>
超链接伪类：已访问、是一个超链接
<strong>动态伪类</strong></p>
<ul>
<li>拥有输入焦点</li>
<li>鼠标指针停留</li>
<li>被用户输入激活</li>
</ul>
<p><strong>伪类顺序</strong>
[[结构与层叠#LVHA伪元素顺序]]</p>
<p><strong>伪类的理解</strong>
可以认为是 css默认给特定位置、特定状态的元素加上的类</p>
<p><strong>伪类的结合</strong>
伪类之间可以相互结合 但是互斥的伪类不能结合</p>
<h2 id="伪元素选择器"><a class="header" href="#伪元素选择器">伪元素选择器</a></h2>
<p>首字母、首行</p>
<h2 id="生成内容的选择器"><a class="header" href="#生成内容的选择器">生成内容的选择器</a></h2>
<p>元素前、元素后</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="line-height-方式"><a class="header" href="#line-height-方式"><strong>line-height 方式</strong></a></h1>
<p>line-height 设置行高，多用于控制多行文本之间的间隔大小。但利用它的特性也可以控制垂直居中。</p>
<p>内联元素无法设置固定高度 height ，如果设置了 line-height 即为该元素所属行的高度，但其中的文本是垂直居中的。</p>
<p>块级元素需要转为内联块级元素 inline-block ，并且需要定高，对其中文本需设值 <strong>vertical-align</strong> 垂直居中属性**。**</p>
<h1 id="定高图片--vertical-align-方式"><a class="header" href="#定高图片--vertical-align-方式"><strong>定高图片 + vertical-align 方式</strong></a></h1>
<p>上例中已经提到了 <strong>vertical-align</strong> 属性，应该注意到它需要和 line-height 一同使用才有效果。</p>
<p>隐藏块参照定位</p>
<pre><code class="language-html">  &lt;style&gt;
    .box {
      width: 400px;
      height: 400px;
      background-color: #bfa;

      text-align: center;
    }

    .iblock {
      display: inline-block;
      height: 100%;
      width: 0;
      vertical-align: middle;
    }

    .img {
      vertical-align: middle;
    }
  &lt;/style&gt;
  &lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;
      &lt;a href=&quot;#&quot; class=&quot;box1&quot;&gt;
        &lt;img src=&quot;/mi_mall/images/mi_qr_code.png&quot; alt=&quot;&quot; class=&quot;img&quot; /&gt;
        &lt;i class=&quot;iblock&quot;&gt;&lt;/i&gt;
      &lt;/a&gt;
    &lt;/div&gt;
  &lt;/body&gt;
</code></pre>
<h1 id="table-方式"><a class="header" href="#table-方式"><strong>table 方式</strong></a></h1>
<p>通过设置父类元素的布局为 table，然后将子元素的布局设置为 table-cell 单元格方式，最后通过 vertical-align 使元素垂直居中。</p>
<pre><code class="language-css">    .tableBox {
      width: 400px;
      height: 400px;
      background-color: #bfa;
      display: table;
    }
    .childBox {
      display: table-cell;
      vertical-align: middle;
      text-align: center;
    }
</code></pre>
<pre><code class="language-html">    &lt;div class=&quot;tableBox&quot;&gt;
      &lt;div class=&quot;childBox&quot;&gt;
        &lt;img src=&quot;/mi_mall/images/mi_qr_code.png&quot; alt=&quot;&quot; /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
</code></pre>
<h1 id="position--margin-auto-方式"><a class="header" href="#position--margin-auto-方式"><strong>position + margin auto 方式</strong></a></h1>
<p>设置子元素绝对定位(注意，这将不关心当前元素是否块级还是内联元素)，然后将该元素的定位位置调为置顶和置底，将 margin 设置为 auto 达到最后效果。</p>
<h1 id="position--transform-方式"><a class="header" href="#position--transform-方式"><strong>position + transform 方式</strong></a></h1>
<p>和水平居中一样，先设置为绝对布局，并设置 top 50%、bottom 50%，最后通过 transform 设置 x 轴、y 轴的偏移量来调整子元素的定位。</p>
<h1 id="flex-方式"><a class="header" href="#flex-方式"><strong>flex 方式</strong></a></h1>
<p>弹性布局，最简单的方式。一个 <strong>align-items</strong> 搞定。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="basic-boxes"><a class="header" href="#basic-boxes">Basic Boxes</a></h2>
<ol>
<li>
<p><strong>CSS 的核心是假设每个元素都生成一个或多个矩形框，称为元素框</strong>。（该规范的未来版本可能允许使用非矩形框，并且确实有人提议更改此内容，但目前所有内容都是矩形的)</p>
</li>
<li>
<p>每个元素框的中心都有一个内容区。</p>
</li>
<li>
<p>此内容区域由可选数量的padding（填充）、borders（边框）、outlines（轮廓）和外边距（margins）包围。</p>
</li>
<li>
<p>这些区域是可选的，因为它们都可以设置为零的宽度，从而将它们从元素框中删除。</p>
</li>
<li>
<p><em>margins</em>, <em>borders</em>,  <em>padding</em> 可以使用 特定于 某一边的 属性设置值 例如 <em>margin-left</em> <em>border-bottom</em></p>
</li>
<li>
<p><em>outline</em>没有 特定于某一边的 属性</p>
</li>
<li>
<p>默认情况下，内容的背景（例如彩色或平铺图像）包含 <em>padding</em>部分</p>
</li>
<li>
<p><em>margins</em> 始终是 透明的 ，以使得 父元素的背景可见</p>
</li>
<li>
<p><em>padding</em> 不能有负长度，<em>margins</em> 可以</p>
</li>
<li>
<p><em>border</em> </p>
<ol>
<li>需要定义 颜色 跟 宽度。</li>
<li>如果没有定义颜色 则取元素的前景色作为颜色，</li>
<li>如果边框有某种间隙的样式，则默认在 间隙之间会 显示 元素的背景色</li>
<li>边框的宽度不能为负值</li>
</ol>
</li>
</ol>
<h2 id="a-quick-refresher"><a class="header" href="#a-quick-refresher">A Quick Refresher</a></h2>
<p>Let’s quickly review the kinds of boxes we’ll be discussing, </p>
<p>让我们快速回顾一下我们将要讨论的盒子种类，以及一些需要解释的重要术语</p>
<h3 id="normal-flow"><a class="header" href="#normal-flow">Normal flow</a></h3>
<p>这是西方语言中文本的从左到右，从上到下的渲染方式，以及传统HTML文档熟悉的文本布局。.</p>
<blockquote>
<p>请注意，在非西方语言中，流向可能会改变。</p>
</blockquote>
<p>大多数元素都处于 <em>normal flow</em>  中，元素离开  <em>normal flow</em>  的唯一方法是浮动、定位或成为弹性盒子或者成为网格布局元素。</p>
<p>请记住，本章中的讨论仅涵盖 <em>normal flow</em> 中的元素。</p>
<h3 id="nonreplaced-element"><a class="header" href="#nonreplaced-element">Nonreplaced element</a></h3>
<p>内容即元素 这是其内容包含在文档中的元素。</p>
<p>例如：段落 （p） 是非替换元素，因为它的文本内容位于元素本身内</p>
<h3 id="replaced-element"><a class="header" href="#replaced-element">Replaced element</a></h3>
<p>占位符元素，会被渲染成其他内容</p>
<p>例如：<em>img</em>标签，只是简单的 指向 一个图像文件，然后在图片文件被找到时插入文档流中,大多数表单元素也是替换元素</p>
<h3 id="root-element"><a class="header" href="#root-element">Root element</a></h3>
<p>文档的根元素，在HTML文档中是 <em>html</em>，在<em>xml</em>中是任何元素</p>
<h3 id="block-box"><a class="header" href="#block-box">Block box</a></h3>
<p>这是一个框，由元素（如paragraph(段落)、heading(标题)或 div）生成</p>
<ol>
<li>这些元素在 <em>normal flow</em> 中  在它本身前面、后面产生新行，这使得 <em>normal flow</em> 中 的块盒一个接一个地垂直堆叠。</li>
<li>任何元素可以 通过声明 <em>display: block</em> 使之产生 <em>block box</em></li>
<li>支持全部的样式</li>
<li>如果没有设置宽度，默认的宽度为父级宽度100%</li>
<li>盒子占据一行、即使设置了宽度</li>
</ol>
<h3 id="inline-box"><a class="header" href="#inline-box">Inline box</a></h3>
<p>这是 <em>strong</em> 或 <em>span</em> 等元素生成的框。</p>
<ol>
<li>不产生换行</li>
<li>Any element can be made to generate an inline box by declaring. </li>
<li>任何元素都可以通过声明  <em>display: inline</em> 来生成</li>
<li>内联元素只能容纳文本或者其他内联元素</li>
<li>如果包含了块元素，则块元素会将该内联元素分割成好几部分</li>
<li>宽高由内容决定</li>
<li>代码换行，盒子之间会产生间距</li>
<li>子元素是内联元素，父元素可以用text-align属性设置子元素水平对齐方式</li>
</ol>
<h4 id="内联元素的间隙问题"><a class="header" href="#内联元素的间隙问题">内联元素的间隙问题</a></h4>
<p><strong>内联元素之间有空白区域</strong></p>
<p>空白区域的形成是因为<code>&lt;span&gt;</code>之间有回车，在html中，空格、制表符、回车都属于空白符，多个空白符都会视为一个空格，</p>
<p>空格的大小由父级<code>&lt;div&gt;</code>的font-size决定。
注意：只有内联(内联块)与内联(内联块)之间的空白符才会形成一个空格，文本元素(除空白符)也是属于内联元素</p>
<p><strong>解决办法</strong></p>
<ul>
<li>给<code>&lt;div&gt;</code>设置<code>font-size: 0;</code>，在<code>&lt;span&gt;</code>上把<code>font-size</code>设置回去</li>
<li>将空白符注释掉</li>
<li>把span排列在同一行，并紧贴在一起</li>
<li>使用浮动<code>float</code></li>
</ul>
<h3 id="inline-block"><a class="header" href="#inline-block">Inline-block</a></h3>
<p>这是一个在内部类似于 block box ，但在外部充当内联框。</p>
<p>它的作用类似于替换的元素，但并不完全相同。</p>
<p>想象一下，拿起一个div并将其粘贴到一行文本中，就好像它是内联图像一样，您就明白了。</p>
<p>还有几种其他类型的盒子，例如表格单元格盒子，但由于各种原因，它们不会在本书中介绍 - 其中最重要的是它们的复杂性需要单独开一本书来讲</p>
<h2 id="the-containing-block"><a class="header" href="#the-containing-block">The Containing Block</a></h2>
<p>包含块 很重要，需要重点讲</p>
<p>Every element’s box is laid out with respect to its containing block;</p>
<p>每个元素的盒子都相对于其包含块进行布局</p>
<p>以非常真实的方式（ in a very real way,），包含块是盒的&quot;布局上下文&quot;。</p>
<p>CSS 定义了一系列用于确定盒的包含块的规则</p>
<p>我们将只介绍与本书中涵盖的概念相关的规则，以保持我们的重点。</p>
<pre><code> For an element in the normal, Western-style flow of text, the containing block forms from the content edge of the nearest ancestor that generated a list item or block box, which includes all table-related boxes (e.g., those generated by table cells)
</code></pre>
<p>对于普通西式文本流中的元素，包含块从生成列表项或块框的最近祖先的内容边缘形成，其中包括所有与表相关的框</p>
<pre><code>This is a paragraph.
</code></pre>
<ul>
<li>
<p>在这个非常简单的标记中，p 元素的块框的包含块是 div 元素的块框，因为这是最接近的祖先元素框，它是块或列表项（在本例中，它是一个块框）。</p>
</li>
<li>
<p>同样，div的包含块是 body。因此，p 的布局依赖于 div 的布局，而 div 又依赖于 body 元素的布局。</p>
</li>
<li>
<p>在此之上，body 元素的布局取决于 html 元素的布局，html元素框创建了所谓的初始包含块（initial containing block）。</p>
</li>
<li>
<p>html的独特之处在于，视口（屏幕媒体中的浏览器窗口或打印媒体中页面的可打印区域）决定了其尺寸，而不是根元素内容的大小。这是一个微妙的区别，通常不是一个非常重要的区别，但它确实存在。</p>
</li>
</ul>
<h2 id="altering-element-display"><a class="header" href="#altering-element-display">Altering Element Display</a></h2>
<h3 id="display"><a class="header" href="#display">DISPLAY</a></h3>
<p><strong>Values</strong></p>
<pre><code>[ &lt;display-outside&gt; ǁ &lt;display-inside&gt; ] | &lt;display-listitem&gt; | &lt;displayinternal&gt; | &lt;display-box&gt; | &lt;display-legacy&gt;
</code></pre>
<p><strong>Initial value</strong> </p>
<p>inline</p>
<p><strong>Applies to All</strong> </p>
<p>elements</p>
<p><strong>Computed value</strong> </p>
<p>As specified</p>
<p><strong>Inherited</strong></p>
<p>No</p>
<p><strong>Animatable</strong> </p>
<p>No</p>
<p><strong>Definitions</strong></p>
<p><code>&lt;display-outside&gt;</code></p>
<p><em>block | inline | run-in</em></p>
<p><code>&lt;display-inside&gt;</code></p>
<p><em>flow | flow-root | table | flex | grid | ruby</em> </p>
<p><code>&lt;display-listitem&gt;</code></p>
<p><em>list-item &amp;&amp; <code>&lt;display-outside&gt;</code> ? &amp;&amp; [ flow | flow-root ]?</em> </p>
<p><code>&lt;display-internal&gt;</code></p>
<p><em>table-row-group | table-header-group | table-footer-group | table-row | table- cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container</em></p>
<p><code>&lt;display-box&gt;</code></p>
<p><em>contents | none</em> </p>
<p><code>&lt;display-legacy&gt;</code></p>
<p><em>inline-block | inline-list-item | inline-table | inline-flex | inline-grid</em></p>
<p>我们将忽略与  <em>ruby- and table-related</em>相 关的值，因为它们对于本章来说太复杂了，我们也会忽略值 <em>list-item</em> 项，因为它与块框非常相似。我们已经花了相当多的时间来讨论块和内联框，但在我们查看内联块之前，让我们花点时间讨论一下 如何通过更改元素的显示角色 来改变布局。</p>
<h3 id="changing-roles"><a class="header" href="#changing-roles">Changing Roles</a></h3>
<p>在设置文档样式时，能够更改元素生成的框的类型非常方便。例如，假设导航中有一系列链接，我们希望将其布局为垂直侧边栏：</p>
<pre><code>[WidgetCo Home](index.html) [Products](products.html) [Services](services.html) [Widgety Fun!](fun.html) [Support](support.html) [About Us](about.html) [Contact](contact.html)
</code></pre>
<p>We could put all the links into table cells, or wrap each one in its own nav—or we could just make them all block-level elements, like this: nav a {display: block;} </p>
<p>This will make every a element within the navigation nav a block-level element.</p>
<p>Changing display roles can be useful in cases where you want non-CSS browsers to get the navigation links as inline elements but to lay out the same links as block-level elements. </p>
<p>如果希望非 CSS 浏览器将导航链接作为内联元素获取，但将链接布局为块级元素，则更改显示角色可能很有用。将链接作为块使用时，您可以像使用 div 或 p 元素一样设置它们的样式，其优点是整个元素框将成为链接的一部分。因此，如果用户的鼠标指针悬停在元素框中的任意位置，她就可以单击该链接。</p>
<p>您可能还想获取元素并使其内联。假设我们有一个无序的名称列表</p>
<pre><code class="language-html">&lt;ul id=&quot;rollcall&quot;&gt;
    &lt;li&gt;Bob C.&lt;/li&gt;
    &lt;li&gt;Marcio G.&lt;/li&gt;
    &lt;li&gt;Eric M.&lt;/li&gt;
    &lt;li&gt;Kat M.&lt;/li&gt;
    &lt;li&gt;Tristan N.&lt;/li&gt;
    &lt;li&gt;Arun R.&lt;/li&gt;
    &lt;li&gt;Doron R.&lt;/li&gt;
    &lt;li&gt;Susie W.&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>给定此标记，假设我们要将这些名称制作成一系列内联名称，并在它们之间（以及列表的每一端）使用竖线。执行此操作的唯一方法是更改其显示角色</p>
<pre><code class="language-css">#rollcall li 
	{display: inline; border-right: 1px solid; padding: 0 0.33em;}
#rollcall li:first-child {border-left: 1px solid;}
</code></pre>
<p>你正在更改元素的显示角色，而不是更改其固有性质（ inherent nature）。</p>
<p>换言之，使段落生成内联框不会将该段落转换为内联元素。</p>
<p>例如，在 HTML 中，某些元素是块元素，而其他元素是内联的。（还有一些是&quot;流动&quot;元素，但我们现在先忽略它们）。</p>
<p>内联元素可以是块元素的后代，但反之通常不行。</p>
<p>虽然 <em>span</em> 可以放在段落内，但 span 不能环绕 <em>paragraph</em>。  无论您如何设置相关元素的样式，这都适用。</p>
<p>请考虑以下标记：</p>
<pre><code class="language-html">&lt;span style=&quot;display: block;&quot;&gt;
&lt;p style=&quot;display: inline;&quot;&gt;this is wrong!&lt;/p&gt;
&lt;/span&gt;
</code></pre>
<p>这个标记不合法，因为块元素 （p） 嵌套在内联元素 （span） </p>
<p>The changing of display roles does nothing to change this.</p>
<p>更改显示角色不会改变这一点。</p>
<p>display 之所以有它的名字，是因为它会影响元素的显示方式，而不是因为它改变了元素的类型</p>
<p>话虽如此，让我们深入了解不同类型框的详细信息：块框，内联框，内联块框和列表项框（<em>block boxes, inline boxes, inline-block boxes, and list-item boxes</em>）</p>
<h3 id="block-boxes"><a class="header" href="#block-boxes">Block Boxes</a></h3>
<blockquote>
<p>块框</p>
</blockquote>
<p>块框的行为有时是可预测的，有时是令人惊讶的。</p>
<p>沿水平轴和垂直轴放置块框的处理方式不同，</p>
<p>例如。为了充分了解块框的处理方式，您必须清楚地了解许多边界和区域。完整盒模型示意图如下</p>
<p><img src="css/....%5Cimages%5Ccomplete_box_model.png" alt="image-20220308004504113" /></p>
<p>​	默认情况下，块框的宽度定义为从左内边到右内边的距离，高度是从内顶到内底的距离。这两个属性都可以应用于生成块框的元素。我们也可以使用属性来改变这些属性的处理方式。</p>
<h4 id="box-sizing"><a class="header" href="#box-sizing">BOX-SIZING</a></h4>
<p><strong>Values</strong></p>
<p><em>content-box | padding-box | border-box</em></p>
<p><strong>Initial value</strong></p>
<p><em>content-box</em></p>
<p><strong>Applies</strong></p>
<p><em>to All elements that accept width or height values</em></p>
<p><strong>Computed value</strong></p>
<p>As specified</p>
<p><strong>Inherited</strong></p>
<p>No</p>
<p><strong>Animatable</strong> </p>
<p>No</p>
<p>此属性是更改宽度和高度值实际执行的操作的方式。</p>
<ul>
<li>
<p>如果您声明宽度：400px并且没有声明为 <em>box-sizing</em>，则元素的内容框就是400像素宽;任何填充，边框等都将添加到其中使其实际大小大于400</p>
</li>
<li>
<p>另一方面，如果您声明了  <em>box-sizing</em>：<em>border-box</em>，则元素框将从左外边框边缘到右外边框边缘为400像素;任何边框或填充都将放置在该距离内，从而缩小内容区域的宽度。</p>
</li>
</ul>
<p>我们在这里谈论 <em>box-size</em> 属性，因为如前所述，它适用于&quot;接受宽度或高度值的所有元素。</p>
<p>这通常是生成块框的元素，尽管它也适用于替换的内联元素（如图像）以及内联块框。</p>
<p>各种宽度、高度、填充和边距都组合在一起，以确定文档的布局方式。在大多数情况下，文档的高度和宽度由浏览器自动确定，基于可用的显示区域以及其他因素。使用 CSS，您可以断言对元素大小和显示方式的更直接的控制</p>
<h3 id="horizontal-formatting"><a class="header" href="#horizontal-formatting">Horizontal Formatting</a></h3>
<p>水平格式通常比您想象的要复杂得多。部分复杂性与框大小的默认行为有关。</p>
<p>使用默认值 <em>content-box</em> 时，宽度指定的是 内容区的宽度，而不是整个可见元素框</p>
<p><strong>可视区</strong></p>
<p>不包括边框的以外的区域，包括 <em>content area+padding</em></p>
<p><strong>整体区域</strong></p>
<p>可视区+外边距</p>
<p><strong>example1</strong></p>
<pre><code>&lt;p style=&quot;width: 200px;&quot;&gt;wideness?&lt;/p&gt;
</code></pre>
<ul>
<li>可视区的宽度是200px</li>
<li>整体区域的宽度是 200px</li>
</ul>
<p><strong>example2</strong></p>
<pre><code>&lt;p style=&quot;width: 200px; padding: 10px; margin: 20px;&quot;&gt;wideness?&lt;/p&gt;
</code></pre>
<ul>
<li>可视区的宽度是 220px</li>
<li>整体区域的宽度是 260px</li>
</ul>
<p><strong>example3</strong></p>
<p>如果改变example2的 <em>border-box:box-sizing</em> </p>
<ul>
<li>则可视区的内容始终为200px</li>
<li>内容宽度为180px</li>
<li>整体区域宽度为 260px</li>
</ul>
<p>有一个恒定的规则：</p>
<p><strong>在正常流中， 块框的 水平分量的总和始终等于 包含块的宽度</strong></p>
<pre><code class="language-html">&lt;head&gt;
	&lt;style&gt;
        div p {
            margin:1em;
        }
        div{
            width:30em;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;div&gt;
    &lt;p&gt;1&lt;/p&gt;
    &lt;p&gt;2&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<h3 id="horizontal-properties"><a class="header" href="#horizontal-properties">Horizontal Properties</a></h3>
<p>水平格式化的七个属性是： <em>margin-left, border-left, padding-left, width, padding-right, border-right, and margin-right.</em> </p>
<p>这些属性与块框的水平布局相关，如图 7-9 所示。这七个属性的值必须加起来等于元素的包含块的宽度，这通常是块元素父元素的宽度值（因为块级元素几乎总是具有父级的块级元素）。在这七个属性中，只有三个可以设置为自动：<strong>元素内容的宽度以及左右边距</strong>。<strong>其余属性必须设置为特定值或默认为零的宽度</strong>。下图显示了盒子的哪些部分可以采用 auto 值，哪些部分不能。</p>
<p><img src="css/....%5Cimages%5Chorizonal_auto_properties.png" alt="image-20220308203310216" /></p>
<p>width 必须设置为 auto 或某种类型的非负值。</p>
<p>在水平格式中使用 auto 时，可能会出现不同的效果</p>
<h3 id="using-auto"><a class="header" href="#using-auto">Using auto</a></h3>
<h4 id="0个atuo"><a class="header" href="#0个atuo">0个atuo</a></h4>
<p>在CSS术语中 称之为 ：<em>overconstrained</em></p>
<p><em>margin-right</em>会强制成为 <em>auto</em></p>
<h4 id="一个auto"><a class="header" href="#一个auto">一个auto</a></h4>
<p>如果 <em>width</em> 、<em>margin-left</em>、<em>margin-right</em> 三者有一个是<em>auto</em> 其他是精确值 那么auto会自适应 使之 等于 包含快的宽度</p>
<h4 id="margin二个auto"><a class="header" href="#margin二个auto">margin二个auto</a></h4>
<p>如果<em>margin</em> 属性都是 <em>auto</em>  width是指定宽度。则 左右两个 会平分 宽度</p>
<h4 id="一个margin-auto一个-内容区auto"><a class="header" href="#一个margin-auto一个-内容区auto">一个margin auto一个 内容区auto</a></h4>
<p>则 margin auto那个 会被设置成 0。内容区宽度会尽可能大</p>
<h4 id="三个都是auto"><a class="header" href="#三个都是auto">三个都是auto</a></h4>
<p>默认的表现形式，如果没有指定，则全部是auto</p>
<p>此时 外边距会全部归0，内容区宽度尽可能大</p>
<h3 id="negative-margins"><a class="header" href="#negative-margins">Negative Margins</a></h3>
<p>可以为边距设置负值。设置负边距可能会导致一些有趣的效果。请记住，七个水平属性的总和始终等于父元素的宽度。只要所有属性都为零或更大，元素就永远不能大于其父级的内容区域</p>
<p>如果七个属性和 大于了 包含块的宽度 则 调整 <em>margin-right</em> 甚至为负值</p>
<h3 id="percentages"><a class="header" href="#percentages">Percentages</a></h3>
<p>百分比跟 指定宽度值没什么区别</p>
<p>边界不能接受百分比值，只能接受长度值。</p>
<h3 id="replaced-elements"><a class="header" href="#replaced-elements">Replaced Elements</a></h3>
<p>到目前为止，我们一直在处理正常文本流中非替换块框的水平格式。</p>
<p>块级替换元素更易于管理，适用于 非替换块 提供的所有规则都成立，但有一个例外：</p>
<ul>
<li><em>width</em> 为 <em>auto</em> 时，则元素的宽度是内容的固有宽度。</li>
<li>以下示例中的图像宽度为 20 像素，因为这是原始图像的宽度：</li>
</ul>
<pre><code class="language-html">&lt;img src=&quot;smile.svg&quot; style=&quot;display: block; width: auto; margin: 0;&quot;&gt;

</code></pre>
<p>可以手动指定 宽度值</p>
<pre><code class="language-html">&lt;img src=&quot;smile.svg&quot; style=&quot;display: block; width: 25px; margin: 0;&quot;&gt;
&lt;img src=&quot;smile.svg&quot; style=&quot;display: block; width: 50px; margin: 0;&quot;&gt;
&lt;img src=&quot;smile.svg&quot; style=&quot;display: block; width: 100px; margin: 0;&quot;&gt;
</code></pre>
<p>请注意，元素的高度也会增加</p>
<p>当替换元素的宽度从其固有宽度更改时，高度值将缩放以匹配，除非高度其自身 已设置为显式值</p>
<p>反之亦然：如果设置了高度，但宽度保留为自动，则宽度将按比例缩放到高度的变化中。</p>
<h3 id="vertical-formatting"><a class="header" href="#vertical-formatting">Vertical Formatting</a></h3>
<p>元素的内容决定了 元素的默认宽度</p>
<p>内容的宽度也会影响高度</p>
<p>例如，段落越窄，它必须越高才能包含其中的所有内联内容。</p>
<p>在CSS中，可以在任何块级元素上设置显式高度。如果这样做，则结果行为取决于其他几个因素。</p>
<p>假定指定的高度大于显示内容所需的高度：</p>
<pre><code>&lt;p style=&quot;height: 10em;&quot;&gt;
</code></pre>
<p>在这种情况下，额外的高度具有类似于额外padding 的视觉效果</p>
<p>但假设高度小于显示内容所需的高度</p>
<pre><code class="language-html">&lt;p style=&quot;height: 3.33em;&quot;&gt;
</code></pre>
<p>浏览器应该提供一种在不增加元素框高度的情况下查看所有内容的方法。</p>
<p>如果元素的内容高于其框的高度，则用户代理的实际行为将取决于 <em>overflow</em>属性</p>
<p>在 CSS1 下，如果元素不是替换的元素（如图像），则用户代理可以忽略除 auto 以外的任何高度值。</p>
<p>在 CSS2 及更高版本中，不能忽略高度值，除非在涉及特定百分比值的情况下。</p>
<p>.我们稍后会讨论这个问题。与宽度一样，默认情况下，高度定义内容区域的高度，而不是可见元素框的高度。元素框顶部或底部的任何填充、边框或边距都将添加到高度值中，除非 <em>box-sizing</em> 的值不是 <em>content-box</em></p>
<h3 id="vertical-properties"><a class="header" href="#vertical-properties">Vertical Properties</a></h3>
<p>和水平格式化属性一样，垂直格式化属性也有同样的属性: <em>margin-top, border-top, padding-top, height, padding-bottom, borderbottom, and margin-bottom</em>. </p>
<p>这些属性的值的总和 必须等于 块框包含快的 高度</p>
<p>这通常是块元素的 父元素（因为块级元素最近的 父级元素总是  块级元素）</p>
<p>只有 三个属性能被设置为 <em>auto</em>:  the height of the element, and the top and bottom margins. </p>
<p>If border-style has been set, then the thickness of the borders is set to be the vaguely defined value medium. </p>
<p>有趣的是，如果将正常流中的 将上边距或下边距设置为 <em>auto</em>，则它们都会自动计算为 0。</p>
<p>这也意味着，如果将元素的上边距和下边距设置为 <em>auto</em>，则它们实际上会重置为 0 并从元素框中删除。</p>
<h3 id="percentage-heights"><a class="header" href="#percentage-heights">Percentage Heights</a></h3>
<p>您已经了解了如何处理高度的长度值，因此让我们花点时间讨论一下百分比。如果正常流块框的高度设置为百分比值，则该值被设置为 块框包含块的高度的百分比。给定以下标记，生成的段落将是 3 em 高</p>
<pre><code>&lt;div style=&quot;height: 6em;&quot;&gt;
&lt;p style=&quot;height: 50%;&quot;&gt;Half as tall&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>由于将上边距和下边距设置为 <em>auto</em> 会使它们具有零高度，因此在这种特殊情况下，<strong>垂直居中元素的唯一方法是将它们都设置为 25%</strong>，即使这样，框也会居中，而不是其中的内容。</p>
<p>但是，如果未显式声明包含块的高度，则百分比高度将重置为 <em>auto</em>。</p>
<p>如果我们更改了前面的示例，使 div 的高度是自动的，则该段落现在将与 div 本身一样高：</p>
<pre><code class="language-html">&lt;div style=&quot;height: auto;&quot;&gt;
&lt;p style=&quot;height: 50%;&quot;&gt;NOT half as tall; height reset to auto&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>在我们继续前进之前，仔细看下 half-as-tall段落 ，它不是垂直居中的。因为 包含块的高度 是 6em 段落高度是3em 存在 上下 1em的<em>margin</em> 所以它的整体 框的高度是 <em>5em</em> 这意味着 还有  在段落可视区 到 div底部 还有 2em的 空白 </p>
<h3 id="auto-heights"><a class="header" href="#auto-heights">Auto Heights</a></h3>
<p><strong>块级子元素外边距合并</strong></p>
<p>在最简单的情况下，具有高度的正常流动块框：&quot;auto&quot; 被呈现得刚好足够高，以包含其内联内容（包括文本）的行框。</p>
<p>如果  <em>auto-height,</em>、正常流的块框只有块级子级，则其默认高度将是从最顶层块级子级外边框边缘的顶部到最底部子级的外底边界边缘的底部的距离。因此，子元素的边距将&quot;突出&quot;包含它们的元素。</p>
<p>但是，如果块级元素具有顶部或底部<em>padding</em>，或者具有顶部或底部边框，则其高度将是其最上层子元素的上边距边缘的顶部与其最底部子元素的外下边距边缘的距离：</p>
<pre><code class="language-html">&lt;div style=&quot;height: auto;
background: silver;&quot;&gt;
&lt;p style=&quot;margin-top: 2em; margin-bottom: 2em;&quot;&gt;A paragraph!&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&quot;height: auto; border-top: 1px solid; border-bottom: 1px solid;
background: silver;&quot;&gt;
&lt;p style=&quot;margin-top: 2em; margin-bottom: 2em;&quot;&gt;Another paragraph!&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>If we changed the borders in the previous example to padding, the effect on the height of the div would be the same: it would still enclose the paragraph’s margins within it</p>
<p>如果我们将上一示例中的边框更改为填充，则对 div 高度的影响将是相同的：它仍将段落的边距包含在其中</p>
<h1 id="块布局"><a class="header" href="#块布局">块布局</a></h1>
<h2 id="水平格式化"><a class="header" href="#水平格式化"><strong>水平格式化</strong></a></h2>
<p><strong>水平格式化七大属性</strong></p>
<p>水平格式化的“7大属性”是：<code>margin-left</code>、<code>border-left</code>, <code>padding-left</code>、<code>width</code>、 <code>padding-right</code>、<code>border-right</code>和<code>margin-right</code></p>
<p>这7个属性的值加在一起<strong>必须是元素包含块的宽度</strong>，这往往是块元素的父元素的width 值（因为块级元素的父元素几乎都是块级元素。</p>
<p><strong>三大属性使用auto</strong></p>
<ul>
<li>
<p>只有<strong>width</strong>、<strong>margin-left</strong>或<strong>margin-right</strong>值可以设置为auto，而余下两个属性指定为特定的值，那么设置为auto的属性会确定所需的长度，从而使元素框的宽度等于父元素的width</p>
</li>
<li>
<p>auto使用规则表</p>
<ul>
<li>固定值 的优先级 &gt; auto</li>
<li>都为固定值时 ,  margin-right 最小优先级</li>
<li>width的auto总是把自己撑到最大,  且优先级大于 &gt; lr的auto</li>
</ul>
</li>
<li>
<p>如果七大属性的值 大于了父元素的宽度 </p>
</li>
</ul>
<h2 id="垂直格式化"><a class="header" href="#垂直格式化"><strong>垂直格式化</strong></a></h2>
<p><strong>垂直格式化七大属性</strong></p>
<p><code>margin-top</code>、<code>border-top</code>, <code>padding-top</code>、<code>height</code>、 <code>padding-bottmon</code>、<code>border-bottmon</code>和<code>margin-bottom</code></p>
<ul>
<li>
<p>没有显示的申明 <code>包含块</code> (父元素)的 <em>height</em>  那么 子元素的百分数高度 会被重置为<em>auto</em></p>
</li>
<li>
<p>使子元素 垂直居中的唯一方式是 使 上下外边距 25%</p>
</li>
<li>
<p>默认情况下, 上下外边距 <em>height</em> 均为auto, 且 元素的高度为 内容的高度</p>
</li>
</ul>
<p><strong>合并垂直外边距</strong></p>
<ul>
<li>
<p>邻块元素垂直方向上的外边距会合并,  取其中的最大的一个</p>
</li>
<li>
<p><strong>因为外边距的目的是为了防止 不让元素间的边框 相接触, 而外边距是可以重合的</strong></p>
</li>
<li>
<p>负的外边距会把元素拉近</p>
</li>
</ul>
<h1 id="行布局"><a class="header" href="#行布局">行布局</a></h1>
<h2 id="基本术语"><a class="header" href="#基本术语"><strong>基本术语</strong></a></h2>
<p><strong>匿名文本</strong></p>
<p>HTML中的不含标签的文本内容</p>
<p><strong>em框</strong>(字符框)</p>
<p>字体定义的大小</p>
<p><strong>内容区</strong></p>
<p>元素中各个字符的EM框构成的框</p>
<p><strong>在替换元素中, 内容区就是 元素的固有高度, 加上 内外边距,边框等</strong></p>
<p><strong>行间距</strong></p>
<p>(<em>half-leading</em>) <em>font-size</em> 和<em>line-height</em> 值只差 除以2</p>
<p><strong>行内框</strong></p>
<p>内容区的高度 + 行间距 的高度  = 行高 <em>line-heigh</em></p>
<p><strong>行框</strong></p>
<p>该行中出现的行 的最高点 和最低点的 最小框</p>
<h2 id="行为定义"><a class="header" href="#行为定义">行为定义</a></h2>
<ul>
<li>内容区类似于一个块级元素的 内容框</li>
<li>行内元素的背景 应用于 内容区+ 内边距</li>
<li>行内元素的边框 要包围内容区及内边距</li>
<li>非替换元素的内边距,边框,外边距 不会影响行内框的高度</li>
</ul>
<h3 id="块状元素与内联行内元素的嵌套规则"><a class="header" href="#块状元素与内联行内元素的嵌套规则">块状元素与内联（行内）元素的嵌套规则</a></h3>
<p><strong>什么是嵌套规则</strong></p>
<p>如果不按照HTML规则书写代码时，浏览器就不会正确解析，会将<strong>不符合嵌套规则的节点放到目标节点的下面</strong>，或者变成纯文本HTML存在许多种类型的标签，有的标签下面只允许特定的标签存在，这就是HTML嵌套规则。</p>
<p><strong>具体规则</strong></p>
<ul>
<li>内联元素不可包含块元素，只能包含内联元素，块状元素没有这些限制</li>
<li>有几个特殊块级元素只能包含内联元素，不能包含块级元素。这几个特殊标签是 <code>h1~h6、p、dt</code></li>
<li><em>li</em> 内可包含 div 标签</li>
<li>块级元素与块级元素并列、内联元素与内联元素并列</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="折叠垂直边距"><a class="header" href="#折叠垂直边距">折叠垂直边距</a></h2>
<p>当多个外边距相遇时会折叠</p>
<h3 id="元素间外边距折叠"><a class="header" href="#元素间外边距折叠">元素间外边距折叠</a></h3>
<p>垂直格式化另一个重要的点是 相邻垂直外边距 重叠，重叠只针对外边绝，不会应用于 padding、borders</p>
<p>无序列表是一个很好地垂直外边距折叠案例</p>
<pre><code class="language-css">li {margin-top: 10px; margin-bottom: 15px;}
</code></pre>
<pre><code>每个list列表，有10px marigin-top,15pxm,margin-bottom
实际上  每个邻接的列表质检的距离是15px
</code></pre>
<p>这是因为 垂直方向上，邻接外边距被折叠。倾向选择外边距较大的一个</p>
<p>你可以想象下，外边距折叠的场景</p>
<p>想象一下，每个元素，比如一个段落，都是一张小纸片，上面写着
写在上面的元素的内容。每张纸周围都有一定数量的
透明塑料，代表边缘。第一张纸 (叫h1)
放在画布上。第二个 (一个段落) 放在它下面，然后滑上去
直到其中一张塑料的边缘接触到另一张纸的边缘。</p>
<p>例如：第一张纸的底部边缘有半英寸的塑料，第二个沿其顶部有三分之一英寸，然后当它们一起滑动时，第一张纸的塑料将接触到第二张纸的顶部边缘。</p>
<h3 id="父子间外边距折叠"><a class="header" href="#父子间外边距折叠">父子间外边距折叠</a></h3>
<pre><code class="language-css">ul {margin-bottom: 15px;}
li {margin-top: 10px; margin-bottom: 20px;}
h1 {margin-top: 28px;}
</code></pre>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;ddd&lt;/li&gt;
  &lt;li&gt;dddddd&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;
&lt;/h1&gt;
</code></pre>
<p><em>H1</em>标签顶部离 UL底部之间的距离 是 <em>28px</em></p>
<h3 id="设置border或padding阻止父子间外边距折叠"><a class="header" href="#设置border或padding阻止父子间外边距折叠">设置border或padding阻止父子间外边距折叠</a></h3>
<p>通过指定 父元素的边框 或者 内边距 可以阻止 父子间的外边距折叠</p>
<h3 id="负的垂直外边距-与重叠"><a class="header" href="#负的垂直外边距-与重叠">负的垂直外边距 与重叠</a></h3>
<p>垂直方向上的负外边距 会将元素拉向彼此</p>
<p>如果元素之间相互重叠，则 后出现的元素会覆盖先出现的元素</p>
<h2 id="list-item"><a class="header" href="#list-item">List Item</a></h2>
<p>List items 元素前面 会 追加  标记符</p>
<p>CSS1很少谈到这些标记的位置和效果相对于 文档的布局。</p>
<p>CSS2引入了一些属性 例如： <em>marker-offset</em>f，然而，缺乏实现和思维的变化导致这一点从CSS2.1中删除</p>
<p>因此 标记的位置 对于开发者来说  在写此文时，还不可用</p>
<p>附加到列表项元素的标记可以在列表的内容之外 或在内容的开头被视为内联标记，具体取决于<em>list-style-position</em>属性</p>
<p><em>list-style-type</em>: 指定<em>marker</em>的形式</p>
<p><em>list-style-position</em>： 指定 marker是否与在元素内容的外面或里面</p>
<h2 id="inline-elements"><a class="header" href="#inline-elements">Inline Elements</a></h2>
<p>首先，您需要了解内联内容是如何布局的。</p>
<p>这并不像块级元素，块级元素只是生成块框，通常不允许任何与他们共存的东西。</p>
<p>相比之下，请查看块级元素的内部，例如 段落。您可能会问，</p>
<ol>
<li>
<p>所有这些文字行是如何到达那里的？</p>
</li>
<li>
<p>什么控制他们的安排？</p>
</li>
<li>
<p>我如何影响它？</p>
</li>
</ol>
<h3 id="基本术语-1"><a class="header" href="#基本术语-1">基本术语</a></h3>
<h4 id="匿名文本"><a class="header" href="#匿名文本">匿名文本</a></h4>
<p>普通字符串</p>
<h4 id="em-box"><a class="header" href="#em-box">Em box</a></h4>
<p>字体框，这是在给定的字体中定义的，也称为字符框。实际字形可以比其em框更高或更短。在CSS中，font-size的值确定每个em盒的高度。</p>
<h4 id="content-area"><a class="header" href="#content-area">Content area</a></h4>
<p>在非替换元素中，内容区 可以是 以下两者之一，CSS规范允许 UA 选择其一</p>
<ol>
<li>内容区域可以是由元素中每个字符的em框描述的框，</li>
<li>也可以是元素中字符字形描述的框。</li>
</ol>
<p>在替换元素中
内容区域是元素的固有高度加上任何边距、边框或填充。</p>
<h4 id="leading"><a class="header" href="#leading">Leading</a></h4>
<blockquote>
<p>行间距</p>
</blockquote>
<p>字体大小与行高之间的差值</p>
<p>这个差异实际上被分成两半，并平等地应用于顶部和底部内容区域</p>
<p>这些对内容区域的添加 被称作  <em>half-leading</em>。<em>leading</em>仅适用于非替换的元素</p>
<h4 id="inline-box-1"><a class="header" href="#inline-box-1">Inline box</a></h4>
<blockquote>
<p>内联框</p>
</blockquote>
<p>这个框被 描述为 在内容区域 添加 <em>leading</em> 而形成的框</p>
<ol>
<li>在非替换元素中，内联元素产生的内联框的高度 等于 行高</li>
<li>对于替换元素，内联框的高度 等于 元素内容区,因为 <em>leading</em> 不应用于替换元素</li>
</ol>
<h4 id="line-box"><a class="header" href="#line-box">Line box</a></h4>
<p>这是限制内联的最高点和最低点的最短框
行中找到的框。换句话说，线框的顶部边缘是
沿着最高的内联框顶部和线框底部放置
沿着最低的内联盒底部的底部放置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-5"><a class="header" href="#简介-5">简介</a></h1>
<ul>
<li>flex(弹性盒、伸缩盒) 是 CSS 中的有一种布局手段 它主要用于代替浮动来完成页面的布局</li>
<li>flex可以使页面具有弹性、让元素可以跟随页面的大小改变而改变</li>
</ul>
<h1 id="概念介绍"><a class="header" href="#概念介绍">概念介绍</a></h1>
<h2 id="弹性容器"><a class="header" href="#弹性容器">弹性容器</a></h2>
<p>要使用 弹性盒，必须先将一个元素设置为一个弹性容器</p>
<ul>
<li>通过 <code>display:flex</code> 来设置 块级弹性容器</li>
<li><code>display:inline-flex</code> 设置为行内的弹性容器</li>
</ul>
<h2 id="弹性元素"><a class="header" href="#弹性元素">弹性元素</a></h2>
<ul>
<li>弹性容器的直接子元素 会自动成为弹性元素</li>
<li>一个元素 既可以是弹性容器 也可使 弹性元素</li>
</ul>
<h2 id="主轴与侧轴"><a class="header" href="#主轴与侧轴">主轴与侧轴</a></h2>
<h3 id="主轴"><a class="header" href="#主轴">主轴</a></h3>
<p><strong>主轴</strong>：弹性元素的排列方向 称为 主轴</p>
<p><strong>侧轴</strong>： 与主轴垂直的方向称为 侧轴</p>
<h1 id="弹性容器样式"><a class="header" href="#弹性容器样式">弹性容器样式</a></h1>
<table><thead><tr><th>样式</th><th>key</th><th>说明</th><th>默认值</th><th>可选值</th></tr></thead><tbody>
<tr><td>容器中元素的排列方向</td><td><code>flex-diection</code></td><td></td><td><code>row</code></td><td>row：水平排列，主轴为从 左到右<br />row-reverse：水平排列，主轴为从 右到左<br />column：纵向排列，主轴为从上到下<br />column-reverse：纵向反向排列，主轴为从下到上</td></tr>
<tr><td>自动换行</td><td><code>flex-wrap</code></td><td>设置弹性元素是否自动换行</td><td>nowrap</td><td>nowrap：不换行<br />wrap：元素沿着辅轴方向自动换行<br />wrap-reverse：辅轴反向换行</td></tr>
<tr><td>简写属性</td><td><code>flex-flow</code></td><td>direction与 wrap的简写属性</td><td></td><td></td></tr>
<tr><td>主轴上的元素如何分布</td><td><code>justify-content</code></td><td>如何分配主轴上的 空白空间</td><td>flex-start</td><td>flex-start：主轴起边排列<br />flex-end：主轴终边排列<br />center：元素居中排列<br />space-around 空白均与分布在元素两侧<br />space-evenly:空白均与分布在元素的单侧<br />space-bewteen：空白分布到元素的间</td></tr>
<tr><td>辅轴对齐</td><td><code>aligin-items</code></td><td>元素在辅轴上如何对齐</td><td>stretch</td><td>stretch:默认将元素的长度设置为相同的值<br />flex-start:元素不会拉伸，沿着辅轴起边对齐<br />flex-end：沿着辅轴 终边对齐<br />center：沿着辅轴中点对齐<br />baseLine:元素的基线对齐</td></tr>
<tr><td>辅轴空白分布</td><td>align-content</td><td>辅轴空白空间的分布</td><td>flex-start</td><td>同 justify-content</td></tr>
</tbody></table>
<h1 id="弹性元素样式"><a class="header" href="#弹性元素样式">弹性元素样式</a></h1>
<table><thead><tr><th>样式</th><th>key</th><th>说明</th><th>默认值</th><th>可选值</th></tr></thead><tbody>
<tr><td>弹性元素的伸展系数</td><td><code>flex-grow</code></td><td>但父元素有多余空间时，<strong>子元素之间</strong>的伸展<strong>比列</strong></td><td>0</td><td></td></tr>
<tr><td>收缩系数</td><td><code>flex-shrink</code></td><td>但父元素没有足够空间时，子元素之间的收缩比例</td><td>默认为1</td><td></td></tr>
<tr><td></td><td><code>flex-basis</code></td><td>元素在主轴上的基础长度，如果是主轴是横向的 则 指定的元素宽度，如果主轴是纵向的则指定元素的高度</td><td>auto</td><td>auto：参考元素自身的高度或宽度</td></tr>
<tr><td></td><td>flex</td><td>设置三个样式，grow,shrink,basis</td><td>0 1 atuo</td><td>不能增，可以等比例缩减，参考自身的高度或宽度</td></tr>
<tr><td>元素间的排序</td><td>order</td><td>指定元素间的顺序</td><td></td><td></td></tr>
<tr><td>辅轴对齐</td><td>align-self</td><td>覆盖当前弹性元素上的<code>align-items</code></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h3 id="继承"><a class="header" href="#继承">继承</a></h3>
<p>继承是一个元素向其后代元素所传递的属性值 所采用的 机制</p>
<h3 id="层叠"><a class="header" href="#层叠">层叠</a></h3>
<p>当 UA 要考虑 对某个元素 应用哪些样式时：不仅要考虑 继承、还要考虑 声明的特殊性、声明的来源、这个过程就称之为  <strong>层叠</strong></p>
<h3 id="特殊性"><a class="header" href="#特殊性">特殊性</a></h3>
<p>选择器的特殊性决定了UA对元素应用哪种样式</p>
<p>CSS通过对 选择器 附加权重，从而决定了选择器的特殊性</p>
<ul>
<li>内联样式选择器 权重为 <code>1000</code></li>
<li>ID选择器的权重为 <code>0100</code></li>
<li>类、伪类、属性选择器的 权重为 <code>0010</code></li>
<li>元素、伪元素选择器的 权重为：<code>0001</code></li>
<li>组合符、通配符选择器权重为 <code>0000</code></li>
</ul>
<p><strong>比较原则</strong>
值可累加，但是不会超过左边值</p>
<h3 id="声明解组"><a class="header" href="#声明解组">声明解组</a></h3>
<p>一旦确立一个 选择器的权重。UA则会将 匹配了n多个元素的选择器&quot; 解组&quot; 为 单独的规则，最小的单位：即：单元素，如果多个规则，匹配到同一个元素，且声明相互冲突，则权重就会被考虑在内</p>
<h3 id="重要声明"><a class="header" href="#重要声明">重要声明</a></h3>
<p>通过 <code>!import</code>关键字 放在样式声明的后面，标识其声明为 一个 重要声明</p>
<ul>
<li>如果一个重要声明与非重要声明 冲突时，总是重要声明胜出</li>
<li>重要声明之间冲突 则 使用权重 来区分</li>
</ul>
<h3 id="继承-1"><a class="header" href="#继承-1">继承</a></h3>
<p>样式不仅应用于当前元素、还应用于 它的后代元素</p>
<ul>
<li>应用的样式会传播到所有后代元素</li>
<li>样式不会向上传递。但是有一个例外，应用于<em>body</em>的样式会传递到 <em>html</em></li>
<li>有些属性不能继承：大多数框模型，例如外边距、内边距、背景和边框，都不能继承</li>
<li>继承的值没有特殊性、或者为0特殊性</li>
</ul>
<h3 id="层叠-1"><a class="header" href="#层叠-1">层叠</a></h3>
<p>如果特殊性相等的两个 规则 应用到同一个元素 会怎么样？</p>
<p>CSS给定了样式的 覆盖规则，也称之为 <strong>样式层叠</strong></p>
<ol>
<li><code>!important</code> 显示权重 </li>
<li>CSS来源：创作人员、UA、用户
<ol>
<li>读者的重要声明</li>
<li>创作人员的重要声明</li>
<li>创作人员的正常声明</li>
<li>读者的正常声明</li>
<li>用户代理声明</li>
</ol>
</li>
<li>特殊性，也是上文讨论的权重</li>
<li>声明顺序：越靠后、权重越大，导入的样式表 声明在前</li>
</ol>
<h4 id="lvha伪元素顺序"><a class="header" href="#lvha伪元素顺序">LVHA伪元素顺序</a></h4>
<p>正是由于这种按顺序排序，所以才有了推荐的伪类样式声明顺序：<code>LVHA</code>
因为伪类的 权重都是 0010，所以声明在后的伪类权重越大</p>
<p>当然：可以通过 组合不同的伪类 来解决 权重冲突的问题</p>
<pre><code class="language-css">:link (color: blue;}

:visited {color: purple;}

:link:hover {color: red;}

:visited:hover {color: gray;}
</code></pre>
<p>上述规则可以以任何顺序列出，而不影响权重</p>
<pre><code class="language-css">:link {color: blue;}

:visited {color: purple;}

:link:hover {color: red;}

:visited:hover {color: gray;}

:link:active {color: orange;}

:visited:active {color: silver;}
</code></pre>
<p>上述规则增加了激活的样式</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="两栏布局"><a class="header" href="#两栏布局">两栏布局</a></h2>
<p>两栏布局主要有两种方式</p>
<p>第一种是左列定宽 右列自适应</p>
<p>第二种是左列不定宽 右列自适应</p>
<h2 id="左列定宽-右列自适应"><a class="header" href="#左列定宽-右列自适应">左列定宽 右列自适应</a></h2>
<h3 id="浮动margin"><a class="header" href="#浮动margin"><strong>浮动+margin</strong></a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;两栏布局之：左列定宽-右列自适应-浮动加外边距&lt;/title&gt;
    &lt;style&gt;
      .container {
        height: 400px;
        background-color: rgb(197, 201, 219);
      }
      .left {
        width: 100px;
        height: 400px;
        background-color: rgb(165, 146, 146);
        float: left;
      }

      .right {
        background-color: green;
        height: 400px;
        margin-left: 100px;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;
      &lt;div class=&quot;right&quot;&gt;4&lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h3 id="浮动触发bfc"><a class="header" href="#浮动触发bfc">浮动+触发BFC</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;两栏布局之：左列定宽-右列自适应-浮动加外边距&lt;/title&gt;
    &lt;style&gt;
      .container {
        height: 400px;
        background-color: rgb(197, 201, 219);
      }
      .left {
        width: 100px;
        height: 400px;
        background-color: rgb(165, 146, 146);
        float: left;
      }

      .right {
        background-color: green;
        height: 400px;
        /* overflow: hidden; */
        display: flow-root;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;
      &lt;div class=&quot;right&quot;&gt;4&lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h3 id="绝对定位"><a class="header" href="#绝对定位">绝对定位</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;两栏布局之：左列定宽-右列自适应-浮动加外边距&lt;/title&gt;
    &lt;style&gt;
      .container {
        background-color: rgb(236, 18, 36);
        height: 400px;
        position: relative;
      }

      .left {
        width: 100px;
        background-color: rgb(165, 146, 146);
        position: absolute;
        top: 0;
        bottom: 0;
      }

      .right {
        position: absolute;
        background-color: green;
        left: 100px;
        right: 0;
        top: 0;
        bottom: 0;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;
      &lt;div class=&quot;right&quot;&gt;4&lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h3 id="flex布局"><a class="header" href="#flex布局">flex布局</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;两栏布局之：左列定宽-右列自适应-flex布局&lt;/title&gt;
    &lt;style&gt;
      .container {
        height: 400px;
        background-color: rgb(197, 201, 219);
        display: flex;
      }
      .left {
        background-color: rgb(165, 146, 146);
        flex: 0 0 100px;
      }
      .right {
        background-color: green;
        flex: 1;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;
      &lt;div class=&quot;right&quot;&gt;4&lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="表格布局"><a class="header" href="#表格布局">表格布局</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;table布局实现&lt;/title&gt;
    &lt;style&gt;
      .container {
        width: 100%;
        height: 200px;
        background-color: #fff;
        display: table;
      }
      .left {
        width: 100px;
        background-color: antiquewhite;
        display: table-cell;
      }
      .right {
        background-color: beige;
        display: table-cell;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;
      &lt;div class=&quot;right&quot;&gt;2&lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="左列不定宽-右列自适应"><a class="header" href="#左列不定宽-右列自适应">左列不定宽 右列自适应</a></h2>
<h3 id="浮动触发bfc-1"><a class="header" href="#浮动触发bfc-1">浮动+触发BFC</a></h3>
<p>去掉左列的宽度。则宽度可根据内容自适应</p>
<p>可以设定最小宽度 防止元素过窄</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;两栏布局之：左列定宽-右列自适应-浮动加外边距&lt;/title&gt;
    &lt;style&gt;
      .container {
        height: 400px;
        background-color: rgb(197, 201, 219);
      }
      .left {
          min-width: 30px;
        height: 400px;
        background-color: rgb(165, 146, 146);
        float: left;
      }

      .right {
        background-color: green;
        height: 400px;
        /* overflow: hidden; */
        display: flow-root;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;
      &lt;div class=&quot;right&quot;&gt;4&lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="容器属性"><a class="header" href="#容器属性">容器属性</a></h2>
<h3 id="displaygrid"><a class="header" href="#displaygrid"><em>display:grid</em></a></h3>
<p>对容器开启<em>grid</em>布局。使其子元素按grid布局</p>
<h3 id="grid-template-columns"><a class="header" href="#grid-template-columns"><em>grid-template-columns</em></a></h3>
<blockquote>
<p>指定栏数布局</p>
</blockquote>
<blockquote>
<p>grid-template-columns: 100px 100px 100px 100px;</p>
</blockquote>
<ol>
<li>设定容器的有多少列。以及每列的宽度</li>
<li>可以设定 固定宽度 也可以是 百分比宽度 还可以是 fr </li>
<li>fr 会根据所有元素的 fr值计算百分比</li>
<li>百分比宽度 会优先分配前面的元素。后面的元素可能会分配不到指定的宽度</li>
</ol>
<h3 id="column-gap"><a class="header" href="#column-gap"><em>column-gap</em></a></h3>
<blockquote>
<p>列间距</p>
</blockquote>
<p>设定元素列之间的间距</p>
<h3 id="row-gap"><a class="header" href="#row-gap"><em>row-gap</em></a></h3>
<blockquote>
<p>行间距</p>
</blockquote>
<p>设定元素行之间的间距</p>
<h3 id="gap"><a class="header" href="#gap"><em>gap</em></a></h3>
<blockquote>
<p>设定行列间距</p>
</blockquote>
<h3 id="grid-template-area"><a class="header" href="#grid-template-area"><em>grid-template-area</em></a></h3>
<blockquote>
<p>排布方式。命名排布</p>
</blockquote>
<p><strong>示例</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;布局方式&lt;/title&gt;
    &lt;style&gt;
      .layout {
        display: grid;
        grid-template-areas:
          &quot;header header header&quot;
          &quot;siderbar content content&quot;
          &quot;footer footer footer&quot;;
      }
      header {
        grid-area: header;
      }
      aside {
        grid-area: siderbar;
      }
      main {
        grid-area: content;
      }
      footer {
        grid-area: footer;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;layout&quot;&gt;
      &lt;header&gt;头部&lt;/header&gt;
      &lt;aside&gt;侧边栏&lt;/aside&gt;
      &lt;main&gt;主体区域&lt;/main&gt;
      &lt;footer&gt;尾部&lt;/footer&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h3 id="justify-content"><a class="header" href="#justify-content"><em>justify-content</em></a></h3>
<blockquote>
<p>元素沿着主轴对齐方式</p>
</blockquote>
<p><em>center</em></p>
<ol>
<li>沿着主轴居中对齐</li>
<li>如果没有指定宽高 元素大小会由内容撑开</li>
</ol>
<p><em>flex-start</em></p>
<p>沿着主轴开始的地方对齐</p>
<p><em>flex-end</em></p>
<p>沿着主轴结束的地方对齐</p>
<p><em>space-between</em></p>
<p>每行的元素都会沿着主轴方向分散对齐。首尾元素与容器边缘不存在间隙</p>
<p><em>space-around</em></p>
<p>每行的元素沿着主轴方向分散对齐。首尾元素与容器边缘存在间隙，且其间隙是 元素之间间隙的1/2</p>
<p><em>space-evenly</em></p>
<p>每行的元素沿着主轴方向分散对齐。首尾元素与容器边缘存在间隙，且其间隙与 元素之间间隙的相等</p>
<p><em>stretch</em></p>
<p>默认值。撑满容器</p>
<h3 id="align-items"><a class="header" href="#align-items"><em>align-items</em></a></h3>
<blockquote>
<p>元素沿着交叉轴对齐方式</p>
</blockquote>
<p><em>center</em></p>
<p>沿着交叉轴居中对齐</p>
<p><em>flex-start</em></p>
<p>沿着交叉轴开始的地方对齐</p>
<p><em>flex-end</em></p>
<p>沿着交叉轴结束的地方对齐</p>
<p><em>start</em></p>
<p>固定左边或者上边，与交叉轴方向无关</p>
<p><em>end</em></p>
<p>固定右边或者下边，与交叉轴方向无关</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<p><img src="css/CSS%E6%A0%B7%E5%BC%8F%E8%AF%A6%E8%A7%A3/......%5Cimages%5Cimage-20220327162151064.png" alt="image-20220327162151064" /></p>
<ul>
<li>
<p>水平主轴： <em>main-axis</em></p>
</li>
<li>
<p>交叉轴：<em>cross-axis</em></p>
</li>
<li>
<p>主轴方向是元素排列的方向</p>
</li>
<li>
<p>元素沿着 主轴方向开始 排列的， 出发的位置叫做 <em>main start</em>，另一端叫做 <em>main end</em></p>
</li>
</ul>
<h2 id="容器属性-1"><a class="header" href="#容器属性-1">容器属性</a></h2>
<h3 id="justify-content-1"><a class="header" href="#justify-content-1"><em>justify-content</em></a></h3>
<blockquote>
<p>元素沿着主轴对齐方式</p>
</blockquote>
<p><em>center</em></p>
<p>沿着主轴居中对齐</p>
<p><em>flex-start</em></p>
<p>沿着主轴开始的地方对齐</p>
<p><em>flex-end</em></p>
<p>沿着主轴结束的地方对齐</p>
<p><em>space-between</em></p>
<p>沿着主轴方向分散对齐。首尾元素与容器边缘不存在间隙</p>
<p><em>space-around</em></p>
<p>沿着主轴方向分散对齐。首尾元素与容器边缘存在间隙，且其间隙是 元素之间间隙的1/2</p>
<p><em>space-evenly</em></p>
<p>沿着主轴方向分散对齐。首尾元素与容器边缘存在间隙，且其间隙与 元素之间间隙的相等</p>
<h3 id="align-items-1"><a class="header" href="#align-items-1"><em>align-items</em></a></h3>
<blockquote>
<p>元素沿着交叉轴对齐方式</p>
</blockquote>
<p><em>center</em></p>
<p>沿着交叉轴居中对齐</p>
<p><em>flex-start</em></p>
<p>沿着交叉轴开始的地方对齐</p>
<p><em>flex-end</em></p>
<p>沿着交叉轴结束的地方对齐</p>
<p><em>start</em></p>
<p>固定左边或者上边，与交叉轴方向无关</p>
<p><em>end</em></p>
<p>固定右边或者下边，与交叉轴方向无关</p>
<h3 id="flex-direction"><a class="header" href="#flex-direction"><em>flex-direction</em></a></h3>
<blockquote>
<p>设置主轴方向</p>
</blockquote>
<p><em>row</em></p>
<blockquote>
<p>默认值 按行排列。即主轴方向为 从左到右的水平方向</p>
</blockquote>
<p><em>row-reverse</em></p>
<blockquote>
<p>行逆向排列。即主轴方向为 从右到左的水平方向</p>
</blockquote>
<p><em>column</em></p>
<blockquote>
<p>按列排列。即主轴方向为 从上到下的垂直方向</p>
</blockquote>
<p><em>column-reverse</em></p>
<blockquote>
<p>按列排列。即主轴方向为 从下到上的垂直方向</p>
</blockquote>
<h3 id="flex-wrap"><a class="header" href="#flex-wrap"><em>flex-wrap</em></a></h3>
<blockquote>
<p>元素主轴方向大小超出了 容器本身大小</p>
</blockquote>
<p><em>wrap</em></p>
<ul>
<li>根据元素自身宽度排列</li>
<li>超出的元素自动换行</li>
</ul>
<p><em>no-wrap</em></p>
<ul>
<li>元素本身自适应，等分容器宽度。</li>
<li>此时元素设置的宽度无效</li>
</ul>
<h2 id="元素属性"><a class="header" href="#元素属性">元素属性</a></h2>
<h4 id="order"><a class="header" href="#order"><em>order</em></a></h4>
<blockquote>
<p>元素之间的排序</p>
</blockquote>
<p>越小越靠前</p>
<h3 id="align-self"><a class="header" href="#align-self"><em>align-self</em></a></h3>
<blockquote>
<p>元素沿着交叉轴的对齐方式</p>
</blockquote>
<p><em>center</em></p>
<p>沿着交叉轴居中对齐自身</p>
<p><em>flex-start</em></p>
<p>沿着交叉轴开始的地方对齐自身</p>
<p><em>flex-end</em></p>
<p>沿着交叉轴结束的地方对齐自身</p>
<p><em>stretch</em></p>
<p>默认值，拉伸元素大小</p>
<h3 id="flex-grow"><a class="header" href="#flex-grow"><em>flex-grow</em></a></h3>
<blockquote>
<p>当容器在主轴方向有剩余空间时，决定了元素如何增长</p>
</blockquote>
<ol>
<li>默认为0 表示等比大小增长</li>
<li>元素会优先增长大小。然后在确定 周围间隙</li>
</ol>
<h3 id="flex-shrink"><a class="header" href="#flex-shrink"><em>flex-shrink</em></a></h3>
<blockquote>
<p>当容器在主轴方向有剩余空间时，决定元素如何缩小</p>
</blockquote>
<p>默认为1。空间不足时。大家一起等比例缩小</p>
<h3 id="flex-basis"><a class="header" href="#flex-basis"><em>flex-basis</em></a></h3>
<p>设置元素宽度。优先级比<em>width</em> 高</p>
<h3 id="flex"><a class="header" href="#flex"><em>flex</em></a></h3>
<p>等价于 <em>flex-grow</em> <em>flow-shrink</em> <em>flex-basis</em></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="定位"><a class="header" href="#定位">定位</a></h2>
<p>CSS 中的 position 属性用来设置元素在页面中的位置，。position 属性有 5 个可选值</p>
<table><thead><tr><th>取值</th><th>说明</th><th>是否脱离文档流</th></tr></thead><tbody>
<tr><td>static</td><td>默认值，静态定位，表示没有定位，元素会按照正常的位置显示，此时 top、bottom、left 和 right 4 个定位属性也不会被应用。</td><td>no</td></tr>
<tr><td>relative</td><td>相对定位，<strong>即相对于元素的正常位置进行定位</strong>，您可以通过 top、right、bottom、left 这 4 个属性来设置元素相对于正常位置的偏移量，在此过程中不会对其它元素造成影响。</td><td>no</td></tr>
<tr><td>absolute</td><td>绝对定位**，相对于第一个非 static 定位的父级元素进行定位**，可以通过 top、right、bottom、left 这 4 个属性来设置元素相对于父级元素位置的偏移量。如果没有满足条件的父级元素，则会相对于浏览器窗口来进行定位。使用绝对定位的元素不会对其它元素造成影响。</td><td>yes</td></tr>
<tr><td>fixed</td><td>固定定位，相对于浏览器的创建进行定位，可以使用 top、right、bottom、left 这 4 个属性来定义元素相对于浏览器窗口的位置。使用固定定位的元素无论如何滚动浏览器窗口元素的位置都是固定不变的。</td><td>yes</td></tr>
<tr><td>sticky</td><td>粘性定位，它是 relative 和 fixed 的结合体，能够实线类似吸附的效果，当滚动页面时它的效果与 relative 相同，当要滚动到屏幕之外时则会自动变成 fixed 的效果。</td><td>yes</td></tr>
</tbody></table>
<p>当一个绝对定位元素，其对立定位方向属性同时有具体定位数值的时候，流体特性就发生了</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装-3"><a class="header" href="#安装-3">安装</a></h1>
<h2 id="script引入"><a class="header" href="#script引入">script引入</a></h2>
<p><code>Vue</code> 会被注册为一个全局变量。</p>
<p><a href="https://cn.vuejs.org/js/vue.js">开发版本</a>:包含完整的警告和调试模式</p>
<p><a href="https://cn.vuejs.org/js/vue.min.js">生产版本</a>:删除了警告，33.30KB min+gzip</p>
<h3 id="使用cdn"><a class="header" href="#使用cdn">使用CDN</a></h3>
<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>指定版本号</p>
<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&gt;&lt;/script&gt;
</code></pre>
<h3 id="兼容esmodule的构建文件"><a class="header" href="#兼容esmodule的构建文件">兼容ESModule的构建文件</a></h3>
<pre><code>&lt;script type=&quot;module&quot;&gt;   import Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.11/dist/vue.esm.browser.js' &lt;/script&gt;
</code></pre>
<h3 id="npm安装"><a class="header" href="#npm安装">NPM安装</a></h3>
<pre><code class="language-shell">npm install vue
</code></pre>
<h2 id="对不同构建版本的解析"><a class="header" href="#对不同构建版本的解析">对不同构建版本的解析</a></h2>
<p><a href="https://cdn.jsdelivr.net/npm/vue/dist/">NPM 包的 <code>dist/</code> 目录</a>你将会找到很多不同的 Vue.js 构建版本</p>
<table><thead><tr><th style="text-align: left"></th><th style="text-align: left">UMD</th><th style="text-align: left">CommonJS</th><th style="text-align: left">ES Module (基于构建工具使用)</th><th>ES Module (直接用于浏览器)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>完整版</strong></td><td style="text-align: left">vue.js</td><td style="text-align: left">vue.common.js</td><td style="text-align: left">vue.esm.js</td><td>vue.esm.browser.js</td></tr>
<tr><td style="text-align: left"><strong>只包含运行时版</strong></td><td style="text-align: left">vue.runtime.js</td><td style="text-align: left">vue.runtime.common.js</td><td style="text-align: left">vue.runtime.esm.js</td><td>-</td></tr>
<tr><td style="text-align: left"><strong>完整版 (生产环境)</strong></td><td style="text-align: left">vue.min.js</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td>vue.esm.browser.min.js</td></tr>
<tr><td style="text-align: left"><strong>只包含运行时版 (生产环境)</strong></td><td style="text-align: left">vue.runtime.min.js</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td>-</td></tr>
</tbody></table>
<h1 id="入门"><a class="header" href="#入门">入门</a></h1>
<h2 id="声明式渲染"><a class="header" href="#声明式渲染">声明式渲染</a></h2>
<p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统</p>
<pre><code class="language-js">&lt;div id=&quot;app&quot;&gt;   {{ message }} &lt;/div&gt;

var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
</code></pre>
<h2 id="动态绑定"><a class="header" href="#动态绑定">动态绑定</a></h2>
<p>语法:v-bind:attributename</p>
<pre><code class="language-js">var app2 = new Vue({
		  el: '#app-2',
		  data: {
		    message: '页面加载于 ' + new Date().toLocaleString()
		  }
		})
		
		&lt;div id=&quot;app-2&quot;&gt;
		  &lt;span v-bind:title=&quot;message&quot;&gt;
		    鼠标悬停几秒钟查看此处动态绑定的提示信息！
		  &lt;/span&gt;
		&lt;/div&gt;
</code></pre>
<h2 id="条件"><a class="header" href="#条件">条件</a></h2>
<pre><code class="language-js">&lt;div id=&quot;app-3&quot;&gt;
  &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;
&lt;/div&gt;
var app3 = new Vue({
  el: '#app-3',
  data: {
    seen: true
  }
})
</code></pre>
<h2 id="循环"><a class="header" href="#循环">循环</a></h2>
<pre><code class="language-js">div id=&quot;app-4&quot;&gt;
  &lt;ol&gt;
    &lt;li v-for=&quot;todo in todos&quot;&gt;
      {{ todo.text }}
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
var app4 = new Vue({
  el: '#app-4',
  data: {
    todos: [
      { text: '学习 JavaScript' },
      { text: '学习 Vue' },
      { text: '整个牛项目' }
    ]
  }
})
</code></pre>
<h2 id="处理用户输入"><a class="header" href="#处理用户输入">处理用户输入</a></h2>
<pre><code class="language-html">&lt;div id=&quot;app-5&quot;&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;button v-on:click=&quot;reverseMessage&quot;&gt;反转消息&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var app5 = new Vue({
  el: '#app-5',
  data: {
    message: 'Hello Vue.js!'
  },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split('').reverse().join('')
    }
  }
})
</code></pre>
<h2 id="双向绑定"><a class="header" href="#双向绑定">双向绑定</a></h2>
<pre><code class="language-html">&lt;div id=&quot;app-6&quot;&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;input v-model=&quot;message&quot;&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var app6 = new Vue({
  el: '#app-6',
  data: {
    message: 'Hello Vue!'
  }
})
</code></pre>
<h2 id="组件化应用构建"><a class="header" href="#组件化应用构建">组件化应用构建</a></h2>
<p>一个组件本质上是一个拥有预定义选项的一个 Vue 实例</p>
<p>人话:自定义标签</p>
<p>自定义todoItem</p>
<pre><code class="language-js">// 定义名为 todo-item 的新组件
Vue.component('todo-item', {
  template: '&lt;li&gt;这是个待办项&lt;/li&gt;'
})

var app = new Vue(...)
</code></pre>
<pre><code class="language-html">		&lt;div id=&quot;app&quot;&gt;
			&lt;todo-item/&gt;
		&lt;/div&gt;
</code></pre>
<p>todoitem 自定义文本</p>
<pre><code class="language-js">Vue.component('todo-item', {
  props: ['todo'],
  template: '&lt;li&gt;{{ todo.text }}&lt;/li&gt;'
})

var app7 = new Vue({
  el: '#app-7',
  data: {
    groceryList: [
      { id: 0, text: '蔬菜' },
      { id: 1, text: '奶酪' },
      { id: 2, text: '随便其它什么人吃的东西' }
    ]
  }
})
</code></pre>
<pre><code class="language-html">&lt;div id=&quot;app-7&quot;&gt;
  &lt;ol&gt;
    &lt;!--
      现在我们为每个 todo-item 提供 todo 对象
      todo 对象是变量，即其内容可以是动态的。
      我们也需要为每个组件提供一个“key”，稍后再
      作详细解释。
    --&gt;
    &lt;todo-item
      v-for=&quot;item in groceryList&quot;
      v-bind:todo=&quot;item&quot;
      v-bind:key=&quot;item.id&quot;
    &gt;&lt;/todo-item&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</code></pre>
<h1 id="vue实例"><a class="header" href="#vue实例">VUE实例</a></h1>
<pre><code class="language-js">var vm = new Vue({
  // 选项
})
</code></pre>
<h2 id="vue-root实例"><a class="header" href="#vue-root实例">VUE root实例</a></h2>
<p>​	上述代码创建了一个VUE实例,一个 Vue 应用由一个通过 new Vue 创建的</p>
<ul>
<li><strong>根 Vue 实例</strong></li>
<li>以及可选的嵌套的、可复用的组件树组成。</li>
</ul>
<p>一个 todo 应用的组件树可以是这样的：</p>
<pre><code>根实例
└─ TodoList
   ├─ TodoItem
   │  ├─ DeleteTodoButton
   │  └─ EditTodoButton
   └─ TodoListFooter
      ├─ ClearTodosButton
      └─ TodoListStatistics
</code></pre>
<h2 id="数据与方法"><a class="header" href="#数据与方法">数据与方法</a></h2>
<p>​	当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的 property 加入到 Vue 的<strong>响应式系统</strong>中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p>
<pre><code class="language-js">// 我们的数据对象
var data = { a: 1 }

// 该对象被加入到一个 Vue 实例中
var vm = new Vue({
  data: data
})

// 获得这个实例上的 property
// 返回源数据中对应的字段
vm.a == data.a // =&gt; true

// 设置 property 也会影响到原始数据
vm.a = 2
data.a // =&gt; 2

// ……反之亦然
data.a = 3
vm.a // =&gt; 3
</code></pre>
<p>​	只有当实例被创建时就已经存在于 <code>data</code> 中的 property 才是<strong>响应式</strong>的</p>
<pre><code class="language-js">data: {
  newTodoText: '',
  visitCount: 0,
  hideCompletedTodos: false,
  todos: [],
  error: null
}
</code></pre>
<p>​	Object.freeze()阻止 属性响应</p>
<pre><code class="language-js">var obj = {
  foo: 'bar'
}

Object.freeze(obj)

new Vue({
  el: '#app',
  data: obj
})
</code></pre>
<p>​	Vue 实例还暴露了一些有用的实例 property 与方法,它们都有前缀 <code>$</code>，以便与用户定义的 property 区分开来</p>
<pre><code class="language-js">var data = { a: 1 }
var vm = new Vue({
  el: '#example',
  data: data
})

vm.$data === data // =&gt; true
vm.$el === document.getElementById('example') // =&gt; true

// $watch 是一个实例方法
vm.$watch('a', function (newValue, oldValue) {
  // 这个回调将在 `vm.a` 改变后调用
})
</code></pre>
<h2 id="实例生命周期钩子"><a class="header" href="#实例生命周期钩子">实例生命周期钩子</a></h2>
<p>每个 Vue 实例在被创建时都要经过一系列的初始化过程—例如，</p>
<ul>
<li>需要设置数据监听</li>
<li>编译模板</li>
<li>将实例挂载到 DOM </li>
<li>并在数据变化时更新 DOM 等</li>
</ul>
<pre><code class="language-js">new Vue({
  data: {
    a: 1
  },
  created: function () {
    // `this` 指向 vm 实例
    console.log('a is: ' + this.a)
  }
})
// =&gt; &quot;a is: 1&quot;
</code></pre>
<p>​	也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 <a href="https://vuejs.bootcss.com/api/#mounted"><code>mounted</code></a>、<a href="https://vuejs.bootcss.com/api/#updated"><code>updated</code></a> 和 <a href="https://vuejs.bootcss.com/api/#destroyed"><code>destroyed</code></a>。生命周期钩子的 <code>this</code> 上下文指向调用它的 Vue 实例。</p>
<h1 id="其他"><a class="header" href="#其他">其他</a></h1>
<p><a href="https://github.com/vuejs/vue/releases">仓库托管</a></p>
<p><a href="https://github.com/vuejs/vue-devtools#vue-devtools">浏览器插件</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="绑定-class"><a class="header" href="#绑定-class">绑定 class</a></h1>
<h2 id="对象语法"><a class="header" href="#对象语法">对象语法</a></h2>
<pre><code class="language-html">&lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;

&lt;div
  class=&quot;static&quot;
  v-bind:class=&quot;{ active: isActive, 'text-danger': hasError }&quot;
&gt;&lt;/div&gt;
</code></pre>
<p>isActive,hasError 决定类的存在与否</p>
<p>class 对象:多个 class 的集合:绑定的数据对象不必内联定义在模板里：</p>
<pre><code>&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;
data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
</code></pre>
<h2 id="绑定计算属性"><a class="header" href="#绑定计算属性">绑定计算属性</a></h2>
<pre><code>&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;
data: {
  isActive: true,
  error: null
},
computed: {
  classObject: function () {
    return {
      active: this.isActive &amp;&amp; !this.error,
      'text-danger': this.error &amp;&amp; this.error.type === 'fatal'
    }
  }
}
</code></pre>
<h2 id="绑定数组"><a class="header" href="#绑定数组">绑定数组</a></h2>
<pre><code>&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;

data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}

&lt;div v-bind:class=&quot;[isActive ? activeClass : '', errorClass]&quot;&gt;&lt;/div&gt;

&lt;div v-bind:class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt;
</code></pre>
<h1 id="绑定内联样式"><a class="header" href="#绑定内联样式">绑定内联样式</a></h1>
<h2 id="内联对象语法"><a class="header" href="#内联对象语法">内联对象语法</a></h2>
<pre><code class="language-html">&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;&gt;&lt;/div&gt;

data: { activeColor: 'red', fontSize: 30 }
</code></pre>
<h2 id="对象语法-1"><a class="header" href="#对象语法-1">对象语法</a></h2>
<pre><code>data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;
</code></pre>
<h2 id="数组语法"><a class="header" href="#数组语法">数组语法</a></h2>
<pre><code>&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;
</code></pre>
<h2 id="自动添加前缀"><a class="header" href="#自动添加前缀">自动添加前缀</a></h2>
<pre><code>当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS property 时，如 transform，Vue.js 会自动侦测并添加相应的前缀
</code></pre>
<h2 id="多重值"><a class="header" href="#多重值">多重值</a></h2>
<p>从 2.3.0 起你可以为 <code>style</code> 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：</p>
<pre><code>&lt;div :style=&quot;{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }&quot;&gt;&lt;/div&gt;
</code></pre>
<p>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 <code>display: flex</code>。</p>
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="监听事件"><a class="header" href="#监听事件">监听事件</a></h1>
<p>​ 可以用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</p>
<pre><code>&lt;div id=&quot;example-1&quot;&gt;
  &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;
  &lt;p&gt;The button above has been clicked {{ counter }} times.&lt;/p&gt;
&lt;/div&gt;
var example1 = new Vue({
  el: '#example-1',
  data: {
    counter: 0
  }
})
</code></pre>
<h1 id="事件处理方法"><a class="header" href="#事件处理方法">事件处理方法</a></h1>
<p>​ 然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 <code>v-on</code> 指令中是不可行的。因此 <code>v-on</code> 还可以接收一个需要调用的方法名称。</p>
<pre><code>&lt;div id=&quot;example-2&quot;&gt;
  &lt;!-- `greet` 是在下面定义的方法名 --&gt;
  &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;
&lt;/div&gt;
var example2 = new Vue({
  el: '#example-2',
  data: {
    name: 'Vue.js'
  },
  // 在 `methods` 对象中定义方法
  methods: {
    greet: function (event) {
      // `this` 在方法里指向当前 Vue 实例
      alert('Hello ' + this.name + '!')
      // `event` 是原生 DOM 事件
      if (event) {
        alert(event.target.tagName)
      }
    }
  }
})

// 也可以用 JavaScript 直接调用方法
example2.greet() // =&gt; 'Hello Vue.js!'
</code></pre>
<h1 id="内联处理器中的方法"><a class="header" href="#内联处理器中的方法">内联处理器中的方法</a></h1>
<p>​ 除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：</p>
<pre><code>&lt;div id=&quot;example-3&quot;&gt;
  &lt;button v-on:click=&quot;say('hi')&quot;&gt;Say hi&lt;/button&gt;
  &lt;button v-on:click=&quot;say('what')&quot;&gt;Say what&lt;/button&gt;
&lt;/div&gt;
new Vue({
  el: '#example-3',
  methods: {
    say: function (message) {
      alert(message)
    }
  }
})
</code></pre>
<p>​ 有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法：</p>
<pre><code>&lt;button v-on:click=&quot;warn('Form cannot be submitted yet.', $event)&quot;&gt;
  Submit
&lt;/button&gt;


// ...
methods: {
  warn: function (message, event) {
    // 现在我们可以访问原生事件对象
    if (event) {
      event.preventDefault()
    }
    alert(message)
  }
}
</code></pre>
<h1 id="事件修饰符"><a class="header" href="#事件修饰符">事件修饰符</a></h1>
<p>​ 在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>
<p>​ 为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<pre><code>&lt;!-- 阻止单击事件继续传播 --&gt;
&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

&lt;!-- 修饰符可以串联 --&gt;
&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

&lt;!-- 只有修饰符 --&gt;
&lt;form v-on:submit.prevent&gt;&lt;/form&gt;

&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;
&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;
&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;
&lt;!-- 即事件不是从内部元素触发的 --&gt;
&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;


</code></pre>
<blockquote>
<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p>
</blockquote>
<p>​ 不像其它只能对原生的 DOM 事件起作用的修饰符，<code>.once</code> 修饰符还能被用到自定义的<a href="https://vuejs.bootcss.com/guide/components-custom-events.html">组件事件</a>上。如果你还没有阅读关于组件的文档，现在大可不必担心。</p>
<pre><code>&lt;!-- 2.1.4 新增,点击事件将只会触发一次 --&gt;
&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;
</code></pre>
<p>​</p>
<p>​ Vue 还对应 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters"><code>addEventListener</code> 中的 <code>passive</code> 选项</a>提供了 <code>.passive</code> 修饰符。</p>
<pre><code>&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;
&lt;!-- 而不会等待 `onScroll` 完成  --&gt;
&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;
&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;
</code></pre>
<p>这个 <code>.passive</code> 修饰符尤其能够提升移动端的性能。</p>
<blockquote>
<p>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用，因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，<code>.passive</code> 会告诉浏览器你<em>不</em>想阻止事件的默认行为。</p>
</blockquote>
<h1 id="按键修饰符"><a class="header" href="#按键修饰符">按键修饰符</a></h1>
<p>​ 在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符：</p>
<pre><code>&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;
&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;

&lt;input v-on:keyup.page-down=&quot;onPageDown&quot;&gt;
在上述示例中，处理函数只会在 $event.key 等于 PageDown 时被调用。
</code></pre>
<h2 id="按键码"><a class="header" href="#按键码">按键码</a></h2>
<blockquote>
<p><code>keyCode</code> 的事件用法<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode">已经被废弃了</a>并可能不会被最新的浏览器支持。</p>
</blockquote>
<p>使用 <code>keyCode</code> attribute 也是允许的：</p>
<pre><code>&lt;input v-on:keyup.13=&quot;submit&quot;&gt;
</code></pre>
<p>为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“删除”和“退格”键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<p>有一些按键 (<code>.esc</code> 以及所有的方向键) 在 IE9 中有不同的 <code>key</code> 值, 如果你想支持 IE9，这些内置的别名应该是首选。</p>
<p>​ 你还可以通过全局 <code>config.keyCodes</code> 对象<a href="https://vuejs.bootcss.com/api/#keyCodes">自定义按键修饰符别名</a>：</p>
<p>// 可以使用 <code>v-on:keyup.f1</code> Vue.config.keyCodes.f1 = 112</p>
<h1 id="系统修饰键"><a class="header" href="#系统修饰键">系统修饰键</a></h1>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<blockquote>
<p>注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。</p>
</blockquote>
<pre><code>&lt;!-- Alt + C --&gt;
&lt;input v-on:keyup.alt.67=&quot;clear&quot;&gt;

&lt;!-- Ctrl + Click --&gt;
&lt;div v-on:click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;
</code></pre>
<blockquote>
<p>请注意修饰键与常规按键不同，在和 <code>keyup</code> 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 <code>ctrl</code> 的情况下释放其它按键，才能触发 <code>keyup.ctrl</code>。而单单释放 <code>ctrl</code> 也不会触发事件。如果你想要这样的行为，请为 <code>ctrl</code> 换用 <code>keyCode</code>：<code>keyup.17</code>。</p>
</blockquote>
<h1 id="exact-修饰符"><a class="header" href="#exact-修饰符">.exact 修饰符</a></h1>
<p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
<pre><code>&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;
&lt;button v-on:click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;
&lt;button v-on:click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;
&lt;button v-on:click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;
</code></pre>
<h1 id="鼠标按钮修饰符"><a class="header" href="#鼠标按钮修饰符">鼠标按钮修饰符</a></h1>
<ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
<p>这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p>
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="v-for-把一个数组对应为一组元素"><a class="header" href="#v-for-把一个数组对应为一组元素">v-for 把一个数组对应为一组元素</a></h1>
<p>实例</p>
<pre><code>&lt;ul id=&quot;example-1&quot;&gt;
  &lt;li v-for=&quot;item in items&quot; :key=&quot;item.message&quot;&gt;
    {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;

var example1 = new Vue({
  el: '#example-1',
  data: {
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
</code></pre>
<p>访问索引</p>
<pre><code>&lt;ul id=&quot;example-2&quot;&gt;
  &lt;li v-for=&quot;(item, index) in items&quot;&gt;
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>第二种语法</p>
<pre><code>&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;
</code></pre>
<h1 id="v-for-遍历对象"><a class="header" href="#v-for-遍历对象">v-for 遍历对象</a></h1>
<pre><code>&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt;
  &lt;li v-for=&quot;value in object&quot;&gt;
    {{ value }}
  &lt;/li&gt;
&lt;/ul&gt;

new Vue({
  el: '#v-for-object',
  data: {
    object: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
  }
})

</code></pre>
<p>获取键名</p>
<pre><code>&lt;div v-for=&quot;(value, name) in object&quot;&gt;
  {{ name }}: {{ value }}
&lt;/div&gt;
</code></pre>
<p>键索引</p>
<pre><code>&lt;div v-for=&quot;(value, name, index) in object&quot;&gt;
  {{ index }}. {{ name }}: {{ value }}
&lt;/div&gt;
</code></pre>
<h1 id="维护状态"><a class="header" href="#维护状态">维护状态</a></h1>
<p>​ 当 Vue 正在更新使用 <code>v-for</code> 渲染的元素列表时.它默认使用“就地更新”的策略。</p>
<p>如果数据项的顺序被改变,Vue 将不会移动 DOM 元素来匹配数据项的顺序,而是就地更新每个元素，并且确保它们在每个索引位置正确渲染</p>
<p>​ 这个默认的模式是高效的，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</strong>。</p>
<p>​ 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> attribute：</p>
<pre><code>&lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt;
  &lt;!-- 内容 --&gt;
&lt;/div&gt;
</code></pre>
<blockquote>
<p>不要使用对象或数组之类的非基本类型值作为 <code>v-for</code> 的 <code>key</code>。请用字符串或数值类型的值。</p>
</blockquote>
<h1 id="数组更新检测"><a class="header" href="#数组更新检测">数组更新检测</a></h1>
<h2 id="变更方法"><a class="header" href="#变更方法">变更方法</a></h2>
<p>变更方法，顾名思义，会变更调用了这些方法的原始数组</p>
<p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<p>非变更的方法</p>
<p>非变更方法，例如 <code>filter()</code>、<code>concat()</code> 和 <code>slice()</code>。它们不会变更原始数组，而<strong>总是返回一个新数组</strong>,用非变更方法时，可以用新数组替换旧数组：</p>
<pre><code>example1.items = example1.items.filter(function (item) {
  return item.message.match(/Foo/)
})
</code></pre>
<h1 id="显示过滤或排序后的结果"><a class="header" href="#显示过滤或排序后的结果">显示过滤或排序后的结果</a></h1>
<p>​ 有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。</p>
<pre><code>&lt;li v-for=&quot;n in evenNumbers&quot;&gt;{{ n }}&lt;/li&gt;
data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
computed: {
  evenNumbers: function () {
    return this.numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}
</code></pre>
<p>在计算属性不适用的情况下 (例如，在嵌套 <code>v-for</code> 循环中) 你可以使用一个方法：</p>
<pre><code>&lt;ul v-for=&quot;set in sets&quot;&gt;
  &lt;li v-for=&quot;n in even(set)&quot;&gt;{{ n }}&lt;/li&gt;
&lt;/ul&gt;
data: {
  sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]
},
methods: {
  even: function (numbers) {
    return numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}
</code></pre>
<h1 id="使用范围值"><a class="header" href="#使用范围值">使用范围值</a></h1>
<pre><code>&lt;div&gt;
  &lt;span v-for=&quot;n in 10&quot;&gt;{{ n }} &lt;/span&gt;
&lt;/div&gt;
</code></pre>
<h1 id="在template使用-v-for"><a class="header" href="#在template使用-v-for">在<code>&lt;template&gt;</code>使用 v-for</a></h1>
<p>渲染多个元素</p>
<pre><code>&lt;ul&gt;
  &lt;template v-for=&quot;item in items&quot;&gt;
    &lt;li&gt;{{ item.msg }}&lt;/li&gt;
    &lt;li class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/li&gt;
  &lt;/template&gt;
&lt;/ul&gt;
</code></pre>
<h1 id="v-for-与-v-if-一同使用"><a class="header" href="#v-for-与-v-if-一同使用"><code>v-for</code> 与 <code>v-if</code> 一同使用</a></h1>
<p>​ 当它们处于同一节点，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中。当你只想为<em>部分</em>项渲染节点时，这种优先级的机制会十分有用，如下：</p>
<pre><code>&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;
  {{ todo }}
&lt;/li&gt;
</code></pre>
<p>上面的代码将只渲染未完成的 todo。</p>
<p>​ 而如果你的目的是有条件地跳过循环的执行，那么可以将 <code>v-if</code> 置于外层元素 (或 <code>&lt;template&gt;</code>) 上。如：</p>
<pre><code>&lt;ul v-if=&quot;todos.length&quot;&gt;
  &lt;li v-for=&quot;todo in todos&quot;&gt;
    {{ todo }}
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p v-else&gt;No todos left!&lt;/p&gt;
</code></pre>
<h1 id="在组件上使用-v-for"><a class="header" href="#在组件上使用-v-for">在组件上使用 v-for</a></h1>
<pre><code>&lt;my-component v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&lt;/my-component&gt;
</code></pre>
<blockquote>
<p>2.2.0+ 的版本里，当在组件上使用 <code>v-for</code> 时，<code>key</code> 现在是必须的。</p>
</blockquote>
<p>​ 然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop：</p>
<pre><code>&lt;my-component
  v-for=&quot;(item, index) in items&quot;
  v-bind:item=&quot;item&quot;
  v-bind:index=&quot;index&quot;
  v-bind:key=&quot;item.id&quot;
&gt;&lt;/my-component&gt;
</code></pre>
<p>​ 不自动将 <code>item</code> 注入到组件里的原因是，这会使得组件与 <code>v-for</code> 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。</p>
<h1 id="简单的-todo-列表的完整例子"><a class="header" href="#简单的-todo-列表的完整例子">简单的 todo 列表的完整例子：</a></h1>
<pre><code>&lt;div id=&quot;todo-list-example&quot;&gt;
  &lt;form v-on:submit.prevent=&quot;addNewTodo&quot;&gt;
    &lt;label for=&quot;new-todo&quot;&gt;Add a todo&lt;/label&gt;
    &lt;input
      v-model=&quot;newTodoText&quot;
      id=&quot;new-todo&quot;
      placeholder=&quot;E.g. Feed the cat&quot;
    &gt;
    &lt;button&gt;Add&lt;/button&gt;
  &lt;/form&gt;
  &lt;ul&gt;
    &lt;li
      is=&quot;todo-item&quot;
      v-for=&quot;(todo, index) in todos&quot;
      v-bind:key=&quot;todo.id&quot;
      v-bind:title=&quot;todo.title&quot;
      v-on:remove=&quot;todos.splice(index, 1)&quot;
    &gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;

Vue.component('todo-item', {
  template: '\
    &lt;li&gt;\
      {{ title }}\
      &lt;button v-on:click=&quot;$emit(\'remove\')&quot;&gt;Remove&lt;/button&gt;\
    &lt;/li&gt;\
  ',
  props: ['title']
})

new Vue({
  el: '#todo-list-example',
  data: {
    newTodoText: '',
    todos: [
      {
        id: 1,
        title: 'Do the dishes',
      },
      {
        id: 2,
        title: 'Take out the trash',
      },
      {
        id: 3,
        title: 'Mow the lawn'
      }
    ],
    nextTodoId: 4
  },
  methods: {
    addNewTodo: function () {
      this.todos.push({
        id: this.nextTodoId++,
        title: this.newTodoText
      })
      this.newTodoText = ''
    }
  }
})
</code></pre>
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="v-ifv-else-ifv-else"><a class="header" href="#v-ifv-else-ifv-else">v-if,v-else-if,v-else</a></h1>
<pre><code>&lt;div v-if=&quot;type === 'A'&quot;&gt;
  A
&lt;/div&gt;
&lt;div v-else-if=&quot;type === 'B'&quot;&gt;
  B
&lt;/div&gt;
&lt;div v-else-if=&quot;type === 'C'&quot;&gt;
  C
&lt;/div&gt;
&lt;div v-else&gt;
  Not A/B/C
&lt;/div&gt;
</code></pre>
<p>切换多元素,使用 template 标签</p>
<pre><code>&lt;template v-if=&quot;ok&quot;&gt;
  &lt;h1&gt;Title&lt;/h1&gt;
  &lt;p&gt;Paragraph 1&lt;/p&gt;
  &lt;p&gt;Paragraph 2&lt;/p&gt;
&lt;/template&gt;
</code></pre>
<h1 id="用-key-管理可复用的元素"><a class="header" href="#用-key-管理可复用的元素">用 <code>key</code> 管理可复用的元素</a></h1>
<p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：</p>
<pre><code>&lt;template v-if=&quot;loginType === 'username'&quot;&gt;
  &lt;label&gt;Username&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your username&quot;&gt;
&lt;/template&gt;
&lt;template v-else&gt;
  &lt;label&gt;Email&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your email address&quot;&gt;
&lt;/template&gt;
</code></pre>
<p>​ 那么在上面的代码中切换 <code>loginType</code> 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code> 不会被替换掉——仅仅是替换了它的 <code>placeholder</code>。</p>
<p>​ 所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 <code>key</code> attribute 即可：</p>
<pre><code>&lt;template v-if=&quot;loginType === 'username'&quot;&gt;
  &lt;label&gt;Username&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;
&lt;/template&gt;
&lt;template v-else&gt;
  &lt;label&gt;Email&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;
&lt;/template&gt;
</code></pre>
<h1 id="v-show"><a class="header" href="#v-show">v-show</a></h1>
<p>根据条件展示元素的选项</p>
<pre><code>&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;
</code></pre>
<p>不同的是带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code> 只是简单地切换元素的 CSS property <code>display</code>。</p>
<blockquote>
<p>注意，<code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</p>
</blockquote>
<h1 id="v-if-v-show"><a class="header" href="#v-if-v-show">v-if v-show</a></h1>
<p>​ <code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>
<p>​ <code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>​ 相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>
<p>​ 一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p>
<p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级</p>
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="插值"><a class="header" href="#插值">插值</a></h1>
<h2 id="文本"><a class="header" href="#文本">文本</a></h2>
<p>使用“Mustache”语法 (双大括号)</p>
<pre><code class="language-html">&lt;span&gt;Message: {{ msg }}&lt;/span&gt;
</code></pre>
<p><a href="https://vuejs.bootcss.com/api/#v-once">v-once 指令</a>，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新</p>
<pre><code class="language-html">&lt;span v-once&gt;这个将不会改变: {{ msg }}&lt;/span&gt;
</code></pre>
<h2 id="原始-html"><a class="header" href="#原始-html">原始 HTML</a></h2>
<p>指定:v-html</p>
<p>双大括号会将数据解释为普通文本，而非 HTML 代码</p>
<pre><code class="language-html">&lt;p&gt;Using mustaches: {{ rawHtml }}&lt;/p&gt;
&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;
</code></pre>
<blockquote>
<p>你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS 攻击</a>。请只对可信内容使用 HTML 插值，<strong>绝不要</strong>对用户提供的内容使用插值。</p>
</blockquote>
<h2 id="作用于属性"><a class="header" href="#作用于属性">作用于属性</a></h2>
<p>指令:v-bind</p>
<pre><code class="language-html">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;
</code></pre>
<p>对于布尔 attribute (它们只要存在就意味着值为 <code>true</code>),如果 <code>isButtonDisabled</code> 的值是 <code>null</code>、<code>undefined</code> 或 <code>false</code>，则 <code>disabled</code> attribute 甚至不会被包含在渲染出来的 <code>&lt;button&gt;</code> 元素中。</p>
<pre><code class="language-html">&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;
</code></pre>
<h2 id="使用-javascript-表达式"><a class="header" href="#使用-javascript-表达式">使用 JavaScript 表达式</a></h2>
<pre><code class="language-js">{
  {
    number + 1;
  }
}

{
  {
    ok ? &quot;YES&quot; : &quot;NO&quot;;
  }
}

{
  {
    message.split(&quot;&quot;).reverse().join(&quot;&quot;);
  }
}

&lt;div v-bind:id=&quot;'list-' + id&quot;&gt;&lt;/div&gt;;
</code></pre>
<p>有个限制就是，每个绑定都只能包含<strong>单个表达式</strong>，所以下面的例子都<strong>不会</strong>生效。</p>
<pre><code class="language-js">&lt;!-- 这是语句，不是表达式 --&gt;
{{ var a = 1 }}

&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;
{{ if (ok) { return message } }}
</code></pre>
<blockquote>
<p>模板表达式都被放在沙盒中，只能访问<a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9">全局变量的一个白名单</a>，如 <code>Math</code> 和 <code>Date</code> 。你不应该在模板表达式中试图访问用户定义的全局变量。</p>
</blockquote>
<h1 id="指令"><a class="header" href="#指令">指令</a></h1>
<p>​ 指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute,指令 attribute 的值预期是<strong>单个 JavaScript 表达式</strong>(<code>v-for</code> 是例外情况)</p>
<p>​ 指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p>
<h2 id="参数"><a class="header" href="#参数">参数</a></h2>
<p>​ 一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，<code>v-bind</code> 指令可以用于响应式地更新 HTML attribute：</p>
<pre><code class="language-html">&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt; &lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;
</code></pre>
<h2 id="动态参数"><a class="header" href="#动态参数">动态参数</a></h2>
<p>​ 从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p>
<pre><code class="language-html">&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;
&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;
</code></pre>
<p>​ 这里的 <code>attributeName</code> 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。</p>
<h3 id="对动态参数的值的约束"><a class="header" href="#对动态参数的值的约束">对动态参数的值的约束</a></h3>
<ul>
<li>
<p>动态参数预期会求出一个字符串</p>
</li>
<li>
<p>异常情况下值为 <code>null</code>。</p>
</li>
<li>
<p>这个特殊的 <code>null</code> 值可以被显性地用于移除绑定。</p>
</li>
<li>
<p>任何其它非字符串类型的值都将会触发一个警告。</p>
</li>
</ul>
<h4 id="对动态参数表达式的约束"><a class="header" href="#对动态参数表达式的约束">对动态参数表达式的约束</a></h4>
<p>​ 动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的</p>
<pre><code class="language-html">&lt;!-- 这会触发一个编译警告 --&gt;
&lt;a v-bind:['foo' + bar]=&quot;value&quot;&gt; ... &lt;/a&gt;
</code></pre>
<p>变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。</p>
<pre><code class="language-html">&lt;!--
在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。
除非在实例中有一个名为“someattr”的 property，否则代码不会工作。
--&gt;
&lt;a v-bind:[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt;
</code></pre>
<h2 id="修饰符"><a class="header" href="#修饰符">修饰符</a></h2>
<ul>
<li>
<p>修饰符 (modifier) 是以半角句号 <code>.</code> 指明的特殊后缀</p>
</li>
<li>
<p>用于指出一个指令应该以特殊方式绑定</p>
</li>
</ul>
<p>例如，<code>.prevent</code> 修饰符告诉 <code>v-on</code> 指令对于触发的事件调用 <code>event.preventDefault()</code>：</p>
<pre><code class="language-html">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;
</code></pre>
<h1 id="缩写"><a class="header" href="#缩写">缩写</a></h1>
<p>Vue 为 <code>v-bind</code> 和 <code>v-on</code> 这两个最常用的指令，提供了特定简写：</p>
<h2 id="v-bind"><a class="header" href="#v-bind">v-bind</a></h2>
<pre><code class="language-js">&lt;!-- 完整语法 --&gt;
&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;

&lt;!-- 缩写 --&gt;
&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;

&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;
&lt;a :[key]=&quot;url&quot;&gt; ... &lt;/a&gt;
</code></pre>
<h2 id="v-on"><a class="header" href="#v-on">v-on</a></h2>
<pre><code class="language-js">&lt;!-- 完整语法 --&gt;
&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;

&lt;!-- 缩写 --&gt;
&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;

&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;
&lt;a @[event]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;
</code></pre>
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="组件基础"><a class="header" href="#组件基础">组件基础</a></h1>
<h2 id="基本示例"><a class="header" href="#基本示例">基本示例</a></h2>
<pre><code>// 定义一个名为 button-counter 的新组件
Vue.component('button-counter', {
  data: function () {
    return {
      count: 0
    }
  },
  template: '&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me {{ count }} times.&lt;/button&gt;'
})
</code></pre>
<h2 id="组件的复用"><a class="header" href="#组件的复用">组件的复用</a></h2>
<p>你可以将组件进行任意次数的复用,因为组件是可复用的 Vue 实例，所以它们与 <code>new Vue</code> 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code> 以及生命周期钩子等。仅有的例外是像 <code>el</code> 这样根实例特有的选项。</p>
<pre><code class="language-html">&lt;div id=&quot;components-demo&quot;&gt;
  &lt;button-counter&gt;&lt;/button-counter&gt;
  &lt;button-counter&gt;&lt;/button-counter&gt;
  &lt;button-counter&gt;&lt;/button-counter&gt;
&lt;/div&gt;
</code></pre>
<p>​ 注意当点击按钮时，每个组件都会各自独立维护它的 <code>count</code>。因为你每用一次组件，就会有一个它的新<strong>实例</strong>被创建。</p>
<p>​ data 必须是一个函数,当我们定义这个 <code>&lt;button-counter&gt;</code> 组件时，你可能会发现它的 <code>data</code> 并不是像这样直接提供一个对象：</p>
<h2 id="组件的组织"><a class="header" href="#组件的组织">组件的组织</a></h2>
<p>例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。</p>
<p>有两种组件的注册类型</p>
<ul>
<li>全局注册</li>
<li>局部注册</li>
</ul>
<h1 id="通过-prop-向子组件传递数据"><a class="header" href="#通过-prop-向子组件传递数据">通过 Prop 向子组件传递数据</a></h1>
<pre><code>Vue.component('blog-post', {
  props: ['title'],
  template: '&lt;h3&gt;{{ title }}&lt;/h3&gt;'
})
</code></pre>
<h3 id="组件-prop-传递示例"><a class="header" href="#组件-prop-传递示例">组件 prop 传递示例</a></h3>
<pre><code>定义组件
Vue.component('blog-post', {
  props: ['title'],
  template: '&lt;h3&gt;{{ title }}&lt;/h3&gt;'
})

新建VUE实例
new Vue({
  el: '#blog-post-demo',
  data: {
    posts: [
      { id: 1, title: 'My journey with Vue' },
      { id: 2, title: 'Blogging with Vue' },
      { id: 3, title: 'Why Vue is so fun' }
    ]
  }
})

渲染组件
&lt;blog-post
  v-for=&quot;post in posts&quot;
  v-bind:key=&quot;post.id&quot;
  v-bind:title=&quot;post.title&quot;
&gt;&lt;/blog-post&gt;
</code></pre>
<h2 id="单根元素"><a class="header" href="#单根元素">单根元素</a></h2>
<p>每个组件必须只有一个根元素,可以使用其他元素包裹</p>
<pre><code>&lt;div class=&quot;blog-post&quot;&gt;
  &lt;h3&gt;{{ title }}&lt;/h3&gt;
  &lt;div v-html=&quot;content&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h2 id="使用-prop-接受单独对象"><a class="header" href="#使用-prop-接受单独对象">使用 prop 接受单独对象</a></h2>
<pre><code>&lt;blog-post
  v-for=&quot;post in posts&quot;
  v-bind:key=&quot;post.id&quot;
  v-bind:post=&quot;post&quot;
&gt;&lt;/blog-post&gt;
Vue.component('blog-post', {
  props: ['post'],
  template: `
    &lt;div class=&quot;blog-post&quot;&gt;
      &lt;h3&gt;{{ post.title }}&lt;/h3&gt;
      &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;







## 在组件上使用 v-model

</code></pre>
<input v-model="searchText">
<p>等价于：</p>
<input v-bind:value="searchText"  v-on:input="searchText = $event.target.value">
<p>为了让它正常工作，这个组件内的 <input> 必须：
将其 value attribute 绑定到一个名叫 value 的 prop 上
在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出</p>
<p>Vue.component('custom-input', {
props: ['value'],
template: <code>&lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit('input', $event.target.value)&quot; &gt;</code>
})</p>
<pre><code>
现在 `v-model` 就应该可以在这个组件上完美地工作起来了：

</code></pre>
<p><custom-input v-model="searchText"></custom-input></p>
<pre><code>
## 通过插槽分发内容

</code></pre>
<p>Vue.component('alert-box', {
template: <code>&lt;div class=&quot;demo-alert-box&quot;&gt; &lt;strong&gt;Error!&lt;/strong&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;</code>
})</p>
<alert-box>
  Something bad happened.
</alert-box>
```
<p>如你所见，我们只要在需要的地方加入插槽就行了——就这么简单！</p>
<p>.</p>
<h2 id="动态组件"><a class="header" href="#动态组件">动态组件</a></h2>
<p>有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里：</p>
<p>上述内容可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is</code> attribute 来实现：</p>
<pre><code>&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;
&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
</code></pre>
<p>在上述示例中，<code>currentTabComponent</code> 可以包括</p>
<ul>
<li>已注册组件的名字，或</li>
<li>一个组件的选项对象</li>
</ul>
<h2 id="解析-dom-模板时的注意事项"><a class="header" href="#解析-dom-模板时的注意事项">解析 DOM 模板时的注意事项</a></h2>
<p>​ 有些 HTML 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。</p>
<p>​ 这会导致我们使用这些有约束条件的元素时遇到一些问题。例如：</p>
<pre><code>&lt;table&gt;
  &lt;blog-post-row&gt;&lt;/blog-post-row&gt;
&lt;/table&gt;
</code></pre>
<p>​ 这个自定义组件 <code>&lt;blog-post-row&gt;</code> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 <code>is</code> attribute 给了我们一个变通的办法：</p>
<pre><code>&lt;table&gt;
  &lt;tr is=&quot;blog-post-row&quot;&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>​ 需要注意的是<strong>如果我们从以下来源使用模板的话，这条限制是*不存在*的</strong></p>
<ul>
<li>
<p>字符串 (例如：<code>template: '...'</code>)</p>
</li>
<li>
<p>单文件组件 (.vue)</p>
</li>
<li>
<p><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></p>
</li>
</ul>
<h1 id="组件注册"><a class="header" href="#组件注册">组件注册</a></h1>
<h2 id="组件名"><a class="header" href="#组件名">组件名</a></h2>
<p>​ 在注册一个组件的时候，我们始终需要给它一个名字。比如在全局注册的时候我们已经看到了：</p>
<pre><code>Vue.component('my-component-name', { /* ... */ })
</code></pre>
<h2 id="全局注册"><a class="header" href="#全局注册">全局注册</a></h2>
<pre><code>Vue.component('component-a', { /* ... */ })
Vue.component('component-b', { /* ... */ })
Vue.component('component-c', { /* ... */ })

new Vue({ el: '#app' })
</code></pre>
<p>这些组件是<strong>全局注册的</strong>。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (<code>new Vue</code>) 的模板中。比如：</p>
<h2 id="局部注册"><a class="header" href="#局部注册">局部注册</a></h2>
<pre><code>var ComponentA = { /* ... */ }
var ComponentB = { /* ... */ }
var ComponentC = { /* ... */ }
</code></pre>
<pre><code>new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
</code></pre>
<p>​ 注意<strong>局部注册的组件在其子组件中*不可用*</strong>。例如，如果你希望 <code>ComponentA</code> 在 <code>ComponentB</code> 中可用，则你需要这样写：</p>
<pre><code>var ComponentA = { /* ... */ }

var ComponentB = {
  components: {
    'component-a': ComponentA
  },
  // ...
}
</code></pre>
<h1 id="prop"><a class="header" href="#prop">Prop</a></h1>
<h2 id="命名"><a class="header" href="#命名">命名</a></h2>
<p>​ HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：</p>
<h2 id="类型"><a class="header" href="#类型">类型</a></h2>
<p>​ 到这里，我们只看到了以字符串数组形式列出的 prop：</p>
<pre><code>props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
</code></pre>
<p>​ 但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：</p>
<pre><code>props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
}
</code></pre>
<h2 id="传递静态或动态-prop"><a class="header" href="#传递静态或动态-prop">传递静态或动态 Prop</a></h2>
<p>像这样，你已经知道了可以像这样给 prop 传入一个静态的值：</p>
<pre><code>&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;
</code></pre>
<p>你也知道 prop 可以通过 <code>v-bind</code> 动态赋值，例如：</p>
<pre><code>&lt;!-- 动态赋予一个变量的值 --&gt;
&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;

&lt;!-- 动态赋予一个复杂表达式的值 --&gt;
&lt;blog-post
  v-bind:title=&quot;post.title + ' by ' + post.author.name&quot;
&gt;&lt;/blog-post&gt;
</code></pre>
<h2 id="传入一个数字"><a class="header" href="#传入一个数字">传入一个数字</a></h2>
<pre><code>&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;
&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;
&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post&gt;

&lt;!-- 用一个变量进行动态赋值。--&gt;
&lt;blog-post v-bind:likes=&quot;post.likes&quot;&gt;&lt;/blog-post&gt;
</code></pre>
<h2 id="传入一个布尔值"><a class="header" href="#传入一个布尔值">传入一个布尔值</a></h2>
<pre><code>&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;
&lt;blog-post is-published&gt;&lt;/blog-post&gt;

&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;
&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;
&lt;blog-post v-bind:is-published=&quot;false&quot;&gt;&lt;/blog-post&gt;

&lt;!-- 用一个变量进行动态赋值。--&gt;
&lt;blog-post v-bind:is-published=&quot;post.isPublished&quot;&gt;&lt;/blog-pos
</code></pre>
<h2 id="传入一个对象"><a class="header" href="#传入一个对象">传入一个对象</a></h2>
<pre><code>&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;
&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;
&lt;blog-post
  v-bind:author=&quot;{
    name: 'Veronica',
    company: 'Veridian Dynamics'
  }&quot;
&gt;&lt;/blog-post&gt;

&lt;!-- 用一个变量进行动态赋值。--&gt;
&lt;blog-post v-bind:author=&quot;post.author&quot;&gt;&lt;/blog-post&gt;
</code></pre>
<h2 id="传入一个对象的所有-property"><a class="header" href="#传入一个对象的所有-property">传入一个对象的所有 property</a></h2>
<p>如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 <code>v-bind</code> (取代 <code>v-bind:prop-name</code>)。例如，对于一个给定的对象 <code>post</code>：</p>
<pre><code>post: {
  id: 1,
  title: 'My Journey with Vue'
}

下面的模板：

&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt;
等价于：

&lt;blog-post
  v-bind:id=&quot;post.id&quot;
  v-bind:title=&quot;post.title&quot;
&gt;&lt;/blog-post&gt;
</code></pre>
<h2 id="单向数据流"><a class="header" href="#单向数据流">单向数据流</a></h2>
<p>​ 所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行</p>
<h2 id="prop-验证"><a class="header" href="#prop-验证">Prop 验证</a></h2>
<p>​ 我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。</p>
<p>​ 为了定制 prop 的验证方式，你可以为 <code>props</code> 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：</p>
<pre><code>Vue.component('my-component', {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
})
</code></pre>
<blockquote>
<p>注意那些 prop 会在一个组件实例创建<strong>之前</strong>进行验证，所以实例的 property (如 <code>data</code>、<code>computed</code> 等) 在 <code>default</code> 或 <code>validator</code> 函数中是不可用的。</p>
</blockquote>
<h3 id="类型检查"><a class="header" href="#类型检查">类型检查</a></h3>
<p><code>type</code> 可以是下列原生构造函数中的一个：</p>
<ul>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Array</code></li>
<li><code>Object</code></li>
<li><code>Date</code></li>
<li><code>Function</code></li>
<li><code>Symbol</code></li>
</ul>
<p>额外的，<code>type</code> 还可以是一个自定义的构造函数，并且通过 <code>instanceof</code> 来进行检查确认。例如，给定下列现成的构造函数：</p>
<pre><code>function Person (firstName, lastName) {
  this.firstName = firstName
  this.lastName = lastName
}

Vue.component('blog-post', {
  props: {
    author: Person
  }
})

来验证 author prop 的值是否是通过 new Person 创建的。
</code></pre>
<h2 id="非-prop-的-attribute"><a class="header" href="#非-prop-的-attribute">非 Prop 的 Attribute</a></h2>
<p>一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。</p>
<p>​ 因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的 attribute，而这些 attribute 会被添加到这个组件的根元素上。</p>
<p>​ 例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的 <code>&lt;bootstrap-date-input&gt;</code> 组件，这个插件需要在其 <code>&lt;input&gt;</code> 上用到一个 <code>data-date-picker</code> attribute。我们可以将这个 attribute 添加到你的组件实例上：</p>
<pre><code>&lt;bootstrap-date-input data-date-picker=&quot;activated&quot;&gt;&lt;/bootstrap-date-input&gt;
</code></pre>
<p>​ 然后这个 <code>data-date-picker=&quot;activated&quot;</code> attribute 就会自动添加到 <code>&lt;bootstrap-date-input&gt;</code> 的根元素上。</p>
<h3 id="替换合并已有的-attribute"><a class="header" href="#替换合并已有的-attribute">替换/合并已有的 Attribute</a></h3>
<p>想象一下 <code>&lt;bootstrap-date-input&gt;</code> 的模板是这样的：</p>
<pre><code>&lt;input type=&quot;date&quot; class=&quot;form-control&quot;&gt;
</code></pre>
<p>为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：</p>
<pre><code>&lt;bootstrap-date-input
  data-date-picker=&quot;activated&quot;
  class=&quot;date-picker-theme-dark&quot;
&gt;&lt;/bootstrap-date-input&gt;
</code></pre>
<p>在这种情况下，我们定义了两个不同的 <code>class</code> 的值：</p>
<ul>
<li><code>form-control</code>，这是在组件的模板内设置好的</li>
<li><code>date-picker-theme-dark</code>，这是从组件的父级传入的</li>
</ul>
<p>对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 <code>type=&quot;text&quot;</code> 就会替换掉 <code>type=&quot;date&quot;</code> 并把它破坏！庆幸的是，</p>
<p><code>class</code> 和 <code>style</code> attribute 会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：<code>form-control date-picker-theme-dark</code>。</p>
<h3 id="禁用-attribute-继承"><a class="header" href="#禁用-attribute-继承">禁用 Attribute 继承</a></h3>
<p>如果你<strong>不</strong>希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p>
<pre><code>Vue.component('my-component', {
  inheritAttrs: false,
  // ...
})
</code></pre>
<p>这尤其适合配合实例的 <code>$attrs</code> property 使用，该 property 包含了传递给一个组件的 attribute 名和 attribute 值，例如：</p>
<pre><code>{
  required: true,
  placeholder: 'Enter your username'
}

</code></pre>
<p>有了 <code>inheritAttrs: false</code> 和 <code>$attrs</code>，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写<a href="https://vuejs.bootcss.com/style-guide/#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E5%90%8D-%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90">基础组件</a>的时候是常会用到的：</p>
<pre><code>Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  template: `
    &lt;label&gt;
      {{ label }}
      &lt;input
        v-bind=&quot;$attrs&quot;
        v-bind:value=&quot;value&quot;
        v-on:input=&quot;$emit('input', $event.target.value)&quot;
      &gt;
    &lt;/label&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; d9cb737ee9bc8daae6ce407dd99325fad6096657
  `
})
</code></pre>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
现在，不论何时为 <code>post</code> 对象添加一个新的 property，它都会自动地在 <code>&lt;blog-post&gt;</code> 内可用。</p>
<h2 id="监听子组件事件"><a class="header" href="#监听子组件事件">监听子组件事件</a></h2>
<pre><code>定义组件
Vue.component('blog-post', {
  props: ['post'],
  template: `
    &lt;div class=&quot;blog-post&quot;&gt;
      &lt;h3&gt;{{ post.title }}&lt;/h3&gt;
      &lt;button&gt;
        Enlarge text
      &lt;/button&gt;
      &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
  `
})

使用组件
&lt;div id=&quot;blog-posts-events-demo&quot;&gt;
  &lt;div :style=&quot;{ fontSize: postFontSize + 'em' }&quot;&gt;
    &lt;blog-post
      v-for=&quot;post in posts&quot;
      v-bind:key=&quot;post.id&quot;
      v-bind:post=&quot;post&quot;
    &gt;&lt;/blog-post&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;blog-post
  ...
  v-on:enlarge-text=&quot;postFontSize += 0.1&quot;
&gt;&lt;/blog-post&gt;

触发事件
&lt;button v-on:click=&quot;$emit('enlarge-text')&quot;&gt;
  Enlarge text
&lt;/button&gt;

</code></pre>
<p>=======</p>
<blockquote>
<p>注意 <code>inheritAttrs: false</code> 选项<strong>不会</strong>影响 <code>style</code> 和 <code>class</code> 的绑定。</p>
</blockquote>
<p>这个模式允许你在使用基础组件的时候更像是使用原始的 HTML 元素，而不会担心哪个元素是真正的根元素：</p>
<pre><code>&lt;base-input
  v-model=&quot;username&quot;
  required
  placeholder=&quot;Enter your username&quot;
&gt;&lt;/base-input&gt;
</code></pre>
<h1 id="自定义事件"><a class="header" href="#自定义事件">自定义事件</a></h1>
<h2 id="事件名"><a class="header" href="#事件名">事件名</a></h2>
<p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：</p>
<pre><code>this.$emit('myEvent')
</code></pre>
<p>则监听这个名字的 kebab-case 版本是不会有任何效果的：</p>
<pre><code class="language-.">&lt;!-- 没有效果 --&gt;
&lt;my-component v-on:my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;
</code></pre>
<p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p>
<p>因此，我们推荐你<strong>始终使用 kebab-case 的事件名</strong>。</p>
<h2 id="自定义组件的-v-model"><a class="header" href="#自定义组件的-v-model">自定义组件的 v-model</a></h2>
<p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">不同的目的</a>。<code>model</code> 选项可以用来避免这样的冲突：</p>
<pre><code>Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    &lt;input
      type=&quot;checkbox&quot;
      v-bind:checked=&quot;checked&quot;
      v-on:change=&quot;$emit('change', $event.target.checked)&quot;
    &gt;
  `
})

&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;
</code></pre>
<h2 id="将原生事件绑定到组件"><a class="header" href="#将原生事件绑定到组件">将原生事件绑定到组件</a></h2>
<p>你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 <code>v-on</code> 的 <code>.native</code> 修饰符：</p>
<pre><code>&lt;base-input v-on:focus.native=&quot;onFocus&quot;&gt;&lt;/base-input&gt;
</code></pre>
<p>在有的时候这是很有用的，不过在你尝试监听一个类似 <code>&lt;input&gt;</code> 的非常特定的元素时，这并不是个好主意。比如上述 <code>&lt;base-input&gt;</code> 组件可能做了如下重构，所以根元素实际上是一个 <code>&lt;label&gt;</code> 元素：</p>
<pre><code>&lt;label&gt;
  {{ label }}
  &lt;input
    v-bind=&quot;$attrs&quot;
    v-bind:value=&quot;value&quot;
    v-on:input=&quot;$emit('input', $event.target.value)&quot;
  &gt;
&lt;/label&gt;
</code></pre>
<p>这时，父级的 <code>.native</code> 监听器将静默失败。它不会产生任何报错，但是 <code>onFocus</code> 处理函数不会如你预期地被调用。</p>
<p>为了解决这个问题，Vue 提供了一个 <code>$listeners</code> property，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如：</p>
<pre><code>{
  focus: function (event) { /* ... */ }
  input: function (value) { /* ... */ },
}
</code></pre>
<p>有了这个 <code>$listeners</code> property，你就可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 <code>&lt;input&gt;</code> 的你希望它也可以配合 <code>v-model</code> 工作的组件来说，为这些监听器创建一个类似下述 <code>inputListeners</code> 的计算属性通常是非常有用的：</p>
<pre><code>Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  computed: {
    inputListeners: function () {
      var vm = this
      // `Object.assign` 将所有的对象合并为一个新对象
      return Object.assign({},
        // 我们从父级添加所有的监听器
        this.$listeners,
        // 然后我们添加自定义监听器，
        // 或覆写一些监听器的行为
        {
          // 这里确保组件配合 `v-model` 的工作
          input: function (event) {
            vm.$emit('input', event.target.value)
          }
        }
      )
    }
  },
  template: `
    &lt;label&gt;
      {{ label }}
      &lt;input
        v-bind=&quot;$attrs&quot;
        v-bind:value=&quot;value&quot;
        v-on=&quot;inputListeners&quot;
      &gt;
    &lt;/label&gt;
  `
})
</code></pre>
<p>现在 <code>&lt;base-input&gt;</code> 组件是一个<strong>完全透明的包裹器</strong>了，也就是说它可以完全像一个普通的 <code>&lt;input&gt;</code> 元素一样使用了：所有跟它相同的 attribute 和监听器都可以工作。</p>
<h2 id="sync-修饰符"><a class="header" href="#sync-修饰符">.sync 修饰符</a></h2>
<p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源。</p>
<p>这也是为什么我们推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。举个例子，在一个包含 <code>title</code> prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：</p>
<pre><code>this.$emit('update:title', newTitle)
</code></pre>
<p>然后父组件可以监听那个事件并根据需要更新一个本地的数据 property。例如：</p>
<pre><code>&lt;text-document
  v-bind:title=&quot;doc.title&quot;
  v-on:update:title=&quot;doc.title = $event&quot;
&gt;&lt;/text-document&gt;
</code></pre>
<p>为了方便起见，我们为这种模式提供一个缩写，即 <code>.sync</code> 修饰符：</p>
<pre><code>&lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt;
</code></pre>
<p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> <strong>不能</strong>和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 <code>v-model</code>。</p>
<p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 <code>.sync</code> 修饰符和 <code>v-bind</code> 配合使用：</p>
<pre><code>&lt;text-document v-bind.sync=&quot;doc&quot;&gt;&lt;/text-document&gt;
</code></pre>
<blockquote>
<p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”{ title: doc.title }”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p>
</blockquote>
<h1 id="插槽"><a class="header" href="#插槽">插槽</a></h1>
<h2 id="插槽内容"><a class="header" href="#插槽内容">插槽内容</a></h2>
<p>​ Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md">Web Components 规范草案</a>，将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口。</p>
<p>它允许你像这样合成组件：</p>
<pre><code>&lt;navigation-link url=&quot;/profile&quot;&gt;
  Your Profile
&lt;/navigation-link&gt;
</code></pre>
<p>然后你在 <code>&lt;navigation-link&gt;</code> 的模板中可能会写为：</p>
<pre><code>&lt;a
  v-bind:href=&quot;url&quot;
  class=&quot;nav-link&quot;
&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/a&gt;
</code></pre>
<p>当组件渲染的时候，<code>&lt;slot&gt;&lt;/slot&gt;</code> 将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML：</p>
<pre><code>&lt;navigation-link url=&quot;/profile&quot;&gt;
  &lt;!-- 添加一个 Font Awesome 图标 --&gt;
  &lt;span class=&quot;fa fa-user&quot;&gt;&lt;/span&gt;
  Your Profile
&lt;/navigation-link&gt;
</code></pre>
<p>甚至其它的组件：</p>
<pre><code>&lt;navigation-link url=&quot;/profile&quot;&gt;
  &lt;!-- 添加一个图标的组件 --&gt;
  &lt;font-awesome-icon name=&quot;user&quot;&gt;&lt;/font-awesome-icon&gt;
  Your Profile
&lt;/navigation-link&gt;
</code></pre>
<p>如果 <code>&lt;navigation-link&gt;</code> <strong>没有</strong>包含一个 <code>&lt;slot&gt;</code> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。</p>
<h2 id="编译作用域"><a class="header" href="#编译作用域">编译作用域</a></h2>
<p>当你想在一个插槽中使用数据时，例如：</p>
<pre><code>&lt;navigation-link url=&quot;/profile&quot;&gt;
  Logged in as {{ user.name }}
&lt;/navigation-link&gt;
</code></pre>
<p>该插槽跟模板的其它地方一样可以访问相同的实例 property (也就是相同的“作用域”)，而<strong>不能</strong>访问 <code>&lt;navigation-link&gt;</code> 的作用域。例如 <code>url</code> 是访问不到的：</p>
<pre><code>&lt;navigation-link url=&quot;/profile&quot;&gt;
  Clicking here will send you to: {{ url }}
  &lt;!--
  这里的 `url` 会是 undefined，因为其 (指该插槽的) 内容是
  _传递给_ &lt;navigation-link&gt; 的而不是
  在 &lt;navigation-link&gt; 组件*内部*定义的。
  --&gt;
&lt;/navigation-link&gt;
</code></pre>
<p>作为一条规则，请记住：</p>
<blockquote>
<p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>
</blockquote>
<h2 id="后备内容"><a class="header" href="#后备内容">后备内容</a></h2>
<p>有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。例如在一个</p>
<p><code>&lt;submit-button&gt;</code> 组件中：</p>
<pre><code>&lt;button type=&quot;submit&quot;&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/button&gt;
</code></pre>
<p>我们可能希望这个 <code>&lt;button&gt;</code> 内绝大多数情况下都渲染文本“Submit”。为了将“Submit”作为后备内容，我们可以将它放在 <code>&lt;slot&gt;</code> 标签内：</p>
<pre><code>&lt;button type=&quot;submit&quot;&gt;
  &lt;slot&gt;Submit&lt;/slot&gt;
&lt;/button&gt;
</code></pre>
<p>现在当我在一个父级组件中使用 <code>&lt;submit-button&gt;</code> 并且不提供任何插槽内容时：</p>
<pre><code>&lt;submit-button&gt;&lt;/submit-button&gt;
</code></pre>
<p>后备内容“Submit”将会被渲染：</p>
<pre><code>&lt;button type=&quot;submit&quot;&gt;
  Submit
&lt;/button&gt;
</code></pre>
<p>但是如果我们提供内容：</p>
<pre><code>&lt;submit-button&gt;
  Save
&lt;/submit-button&gt;
</code></pre>
<p>则这个提供的内容将会被渲染从而取代后备内容：</p>
<pre><code>&lt;button type=&quot;submit&quot;&gt;
  Save
&lt;/button&gt;
</code></pre>
<h2 id="具名插槽"><a class="header" href="#具名插槽">具名插槽</a></h2>
<p>有时我们需要多个插槽。例如对于一个带有如下模板的 <code>&lt;base-layout&gt;</code> 组件：</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;!-- 我们希望把页头放这里 --&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;!-- 我们希望把主要内容放这里 --&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;!-- 我们希望把页脚放这里 --&gt;
  &lt;/footer&gt;
&lt;/div&gt;

</code></pre>
<p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：<code>name</code>。这个 attribute 可以用来定义额外的插槽：</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre>
<p>一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。</p>
<p>在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称：</p>
<pre><code>&lt;base-layout&gt;
  &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<p>在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称：</p>
<pre><code>&lt;base-layout&gt;
  &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 <code>v-slot</code> 的 <code>&lt;template&gt;</code> 中的内容都会被视为默认插槽的内容。</p>
<p>然而，如果你希望更明确一些，仍然可以在一个 <code>&lt;template&gt;</code> 中包裹默认插槽的内容：</p>
<pre><code>&lt;base-layout&gt;
  &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;

  &lt;template v-slot:default&gt;
    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
    &lt;p&gt;And another one.&lt;/p&gt;
  &lt;/template&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<p>注意 <strong><code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code> 上</strong> (只有<a href="https://vuejs.bootcss.com/guide/components-slots.html#%E7%8B%AC%E5%8D%A0%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99%E8%AF%AD%E6%B3%95">一种例外情况</a>)，这一点和已经废弃的 <a href="https://vuejs.bootcss.com/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95"><code>slot</code> attribute</a> 不同。</p>
<h2 id="作用域插槽"><a class="header" href="#作用域插槽">作用域插槽</a></h2>
<p>有时让插槽内容能够访问子组件中才有的数据是很有用的。例如，设想一个带有如下模板的 <code>&lt;current-user&gt;</code> 组件：</p>
<pre><code>&lt;span&gt;
  &lt;slot&gt;{{ user.lastName }}&lt;/slot&gt;
&lt;/span&gt;
</code></pre>
<p>我们可能想换掉备用内容，用名而非姓来显示。如下：</p>
<pre><code>&lt;current-user&gt;
  {{ user.firstName }}
&lt;/current-user&gt;
</code></pre>
<p>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p>
<pre><code>&lt;span&gt;
  &lt;slot v-bind:user=&quot;user&quot;&gt;
    {{ user.lastName }}
  &lt;/slot&gt;
&lt;/span&gt;
</code></pre>
<p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为<strong>插槽 prop</strong>。现在在父级作用域中，我们可以使用带值的 <code>v-slot</code> 来定义我们提供的插槽 prop 的名字：</p>
<pre><code>&lt;current-user&gt;
  &lt;template v-slot:default=&quot;slotProps&quot;&gt;
    {{ slotProps.user.firstName }}
  &lt;/template&gt;
&lt;/current-user&gt;
</code></pre>
<p>在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 <code>slotProps</code>，但你也可以使用任意你喜欢的名字。</p>
<h3 id="独占默认插槽的缩写语法"><a class="header" href="#独占默认插槽的缩写语法">独占默认插槽的缩写语法</a></h3>
<p>在上述情况下，当被提供的内容<em>只有</em>默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 <code>v-slot</code> 直接用在组件上：</p>
<pre><code>&lt;current-user v-slot:default=&quot;slotProps&quot;&gt;
  {{ slotProps.user.firstName }}
&lt;/current-user&gt;
</code></pre>
<p>这种写法还可以更简单。就像假定未指明的内容对应默认插槽一样，不带参数的 <code>v-slot</code> 被假定对应默认插槽：</p>
<pre><code>&lt;current-user v-slot=&quot;slotProps&quot;&gt;
  {{ slotProps.user.firstName }}
&lt;/current-user&gt;
</code></pre>
<p>注意默认插槽的缩写语法<strong>不能</strong>和具名插槽混用，因为它会导致作用域不明确：</p>
<pre><code>&lt;!-- 无效，会导致警告 --&gt;
&lt;current-user v-slot=&quot;slotProps&quot;&gt;
  {{ slotProps.user.firstName }}
  &lt;template v-slot:other=&quot;otherSlotProps&quot;&gt;
    slotProps is NOT available here
  &lt;/template&gt;
&lt;/current-user&gt;
</code></pre>
<p>只要出现多个插槽，请始终为<em>所有的</em>插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法：</p>
<pre><code>&lt;current-user&gt;
  &lt;template v-slot:default=&quot;slotProps&quot;&gt;
    {{ slotProps.user.firstName }}
  &lt;/template&gt;

  &lt;template v-slot:other=&quot;otherSlotProps&quot;&gt;
    ...
  &lt;/template&gt;
&lt;/current-user&gt;
</code></pre>
<h3 id="解构插槽-prop"><a class="header" href="#解构插槽-prop">解构插槽 Prop</a></h3>
<p>作用域插槽的内部工作原理是将你的插槽内容包括在一个传入单个参数的函数里：</p>
<pre><code>function (slotProps) {
  // 插槽内容
}
</code></pre>
<p>这意味着 <code>v-slot</code> 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。所以在支持的环境下 (<a href="https://vuejs.bootcss.com/guide/single-file-components.html">单文件组件</a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9">现代浏览器</a>)，你也可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E8%A7%A3%E6%9E%84%E5%AF%B9%E8%B1%A1">ES2015 解构</a>来传入具体的插槽 prop，如下：</p>
<pre><code>&lt;current-user v-slot=&quot;{ user }&quot;&gt;
  {{ user.firstName }}
&lt;/current-user&gt;
</code></pre>
<p>这样可以使模板更简洁，尤其是在该插槽提供了多个 prop 的时候。它同样开启了 prop 重命名等其它可能，例如将 <code>user</code> 重命名为 <code>person</code>：</p>
<pre><code>&lt;current-user v-slot=&quot;{ user: person }&quot;&gt;
  {{ person.firstName }}
&lt;/current-user&gt;
</code></pre>
<p>你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形：</p>
<pre><code>&lt;current-user v-slot=&quot;{ user = { firstName: 'Guest' } }&quot;&gt;
  {{ user.firstName }}
&lt;/current-user&gt;
</code></pre>
<h2 id="动态插槽名"><a class="header" href="#动态插槽名">动态插槽名</a></h2>
<p><a href="https://vuejs.bootcss.com/guide/syntax.html#%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0">动态指令参数</a>也可以用在 <code>v-slot</code> 上，来定义动态的插槽名：</p>
<pre><code>&lt;base-layout&gt;
  &lt;template v-slot:[dynamicSlotName]&gt;
    ...
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<h2 id="具名插槽的缩写"><a class="header" href="#具名插槽的缩写">具名插槽的缩写</a></h2>
<p>跟 <code>v-on</code> 和 <code>v-bind</code> 一样，<code>v-slot</code> 也有缩写，即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code>：</p>
<pre><code>&lt;base-layout&gt;
  &lt;template #header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template #footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<p>然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：</p>
<pre><code>&lt;!-- 这样会触发一个警告 --&gt;
&lt;current-user #=&quot;{ user }&quot;&gt;
  {{ user.firstName }}
&lt;/current-user&gt;
</code></pre>
<p>如果你希望使用缩写的话，你必须始终以明确插槽名取而代之：</p>
<pre><code>&lt;current-user #default=&quot;{ user }&quot;&gt;
  {{ user.firstName }}
&lt;/current-user&gt;
</code></pre>
<h2 id="其它示例"><a class="header" href="#其它示例">其它示例</a></h2>
<p>**插槽 prop 允许我们将插槽转换为可复用的模板，这些模板可以基于输入的 prop 渲染出不同的内容。**这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的。</p>
<p>例如，我们要实现一个 <code>&lt;todo-list&gt;</code> 组件，它是一个列表且包含布局和过滤逻辑：</p>
<pre><code>&lt;ul&gt;
  &lt;li
    v-for=&quot;todo in filteredTodos&quot;
    v-bind:key=&quot;todo.id&quot;
  &gt;
    {{ todo.text }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>我们可以将每个 todo 作为父级组件的插槽，以此通过父级组件对其进行控制，然后将 <code>todo</code> 作为一个插槽 prop 进行绑定：</p>
<pre><code>&lt;ul&gt;
  &lt;li
    v-for=&quot;todo in filteredTodos&quot;
    v-bind:key=&quot;todo.id&quot;
  &gt;
    &lt;!--
    我们为每个 todo 准备了一个插槽，
    将 `todo` 对象作为一个插槽的 prop 传入。
    --&gt;
    &lt;slot name=&quot;todo&quot; v-bind:todo=&quot;todo&quot;&gt;
      &lt;!-- 后备内容 --&gt;
      {{ todo.text }}
    &lt;/slot&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>现在当我们使用 <code>&lt;todo-list&gt;</code> 组件的时候，我们可以选择为 todo 定义一个不一样的 <code>&lt;template&gt;</code> 作为替代方案，并且可以从子组件获取数据：</p>
<pre><code>&lt;todo-list v-bind:todos=&quot;todos&quot;&gt;
  &lt;template v-slot:todo=&quot;{ todo }&quot;&gt;
    &lt;span v-if=&quot;todo.isComplete&quot;&gt;✓&lt;/span&gt;
    {{ todo.text }}
  &lt;/template&gt;
&lt;/todo-list&gt;
</code></pre>
<h1 id="动态组件--异步组件"><a class="header" href="#动态组件--异步组件">动态组件 &amp; 异步组件</a></h1>
<h2 id="在动态组件上使用-keep-alive"><a class="header" href="#在动态组件上使用-keep-alive">在动态组件上使用 <code>keep-alive</code></a></h2>
<p>我们之前曾经在一个多标签的界面中使用 <code>is</code> attribute 来切换不同的组件：</p>
<pre><code>&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
</code></pre>
<p>当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。例如我们来展开说一说这个多标签界面：</p>
<p>你会注意到，如果你选择了一篇文章，切换到 <em>Archive</em> 标签，然后再切换回 <em>Posts</em>，是不会继续展示你之前选择的文章的。这是因为你每次切换新标签的时候，Vue 都创建了一个新的 <code>currentTabComponent</code> 实例。</p>
<p>重新创建动态组件的行为通常是非常有用的，但是在这个案例中，我们更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来。为了解决这个问题，我们可以用一个 <code>&lt;keep-alive&gt;</code> 元素将其动态组件包裹起来。</p>
<pre><code>&lt;!-- 失活的组件将会被缓存！--&gt;
&lt;keep-alive&gt;
  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre>
<p>注意这个 <code>&lt;keep-alive&gt;</code> 要求被切换到的组件都有自己的名字，不论是通过组件的 <code>name</code> 选项还是局部/全局注册。</p>
<h2 id="异步组件"><a class="header" href="#异步组件">异步组件</a></h2>
<p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：</p>
<pre><code>Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    // 向 `resolve` 回调传递组件定义
    resolve({
      template: '&lt;div&gt;I am async!&lt;/div&gt;'
    })
  }, 1000)
})
</code></pre>
<p>如你所见，这个工厂函数会收到一个 <code>resolve</code> 回调，这个回调函数会在你从服务器得到组件定义的时候被调用。你也可以调用 <code>reject(reason)</code> 来表示加载失败。这里的 <code>setTimeout</code> 是为了演示用的，如何获取组件取决于你自己。一个推荐的做法是将异步组件和 <a href="https://webpack.js.org/guides/code-splitting/">webpack 的 code-splitting 功能</a>一起配合使用：</p>
<pre><code>Vue.component('async-webpack-example', function (resolve) {
  // 这个特殊的 `require` 语法将会告诉 webpack
  // 自动将你的构建代码切割成多个包，这些包
  // 会通过 Ajax 请求加载
  require(['./my-async-component'], resolve)
})
</code></pre>
<p>你也可以在工厂函数中返回一个 <code>Promise</code>，所以把 webpack 2 和 ES2015 语法加在一起，我们可以写成这样：</p>
<pre><code>Vue.component(
  'async-webpack-example',
  // 这个 `import` 函数会返回一个 `Promise` 对象。
  () =&gt; import('./my-async-component')
)
</code></pre>
<p>当使用<a href="https://vuejs.bootcss.com/guide/components-registration.html#%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C">局部注册</a>的时候，你也可以直接提供一个返回 <code>Promise</code> 的函数：</p>
<pre><code>new Vue({
  // ...
  components: {
    'my-component': () =&gt; import('./my-async-component')
  }
})
</code></pre>
<h2 id="处理加载状态"><a class="header" href="#处理加载状态">处理加载状态</a></h2>
<p>这里的异步组件工厂函数也可以返回一个如下格式的对象：</p>
<pre><code>const AsyncComponent = () =&gt; ({
  // 需要加载的组件 (应该是一个 `Promise` 对象)
  component: import('./MyComponent.vue'),
  // 异步组件加载时使用的组件
  loading: LoadingComponent,
  // 加载失败时使用的组件
  error: ErrorComponent,
  // 展示加载时组件的延时时间。默认值是 200 (毫秒)
  delay: 200,
  // 如果提供了超时时间且组件加载也超时了，
  // 则使用加载失败时使用的组件。默认值是：`Infinity`
  timeout: 3000
})
</code></pre>
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="基础用法-29"><a class="header" href="#基础用法-29">基础用法</a></h1>
<p>​ 你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 <code>v-model</code> 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p>
<blockquote>
<p><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</p>
</blockquote>
<p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li>
<li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li>
<li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>
</ul>
<blockquote>
<p>对于需要使用<a href="https://zh.wikipedia.org/wiki/%E8%BE%93%E5%85%A5%E6%B3%95">输入法</a> (如中文、日文、韩文等) 的语言，你会发现 <code>v-model</code> 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 <code>input</code> 事件。</p>
</blockquote>
<h2 id="文本-1"><a class="header" href="#文本-1">文本</a></h2>
<pre><code>&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;
&lt;p&gt;Message is: {{ message }}&lt;/p&gt;
</code></pre>
<h2 id="多行文本"><a class="header" href="#多行文本">多行文本</a></h2>
<pre><code>span&gt;Multiline message is:&lt;/span&gt;
&lt;p style=&quot;white-space: pre-line;&quot;&gt;{{ message }}&lt;/p&gt;
&lt;br&gt;
&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;
</code></pre>
<blockquote>
<p>在文本区域插值 (<code>&lt;textarea&gt;{{text}}&lt;/textarea&gt;</code>) 并不会生效，应用 <code>v-model</code> 来代替</p>
</blockquote>
<h2 id="复选框"><a class="header" href="#复选框">复选框</a></h2>
<pre><code>&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;
&lt;label for=&quot;checkbox&quot;&gt;{{ checked }}&lt;/label&gt;
</code></pre>
<p>多个复选框，绑定到同一个数组：</p>
<pre><code>&lt;div id='example-3'&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;
  &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;
  &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;
  &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;
  &lt;br&gt;
  &lt;span&gt;Checked names: {{ checkedNames }}&lt;/span&gt;
&lt;/div&gt;

new Vue({
  el: '#example-3',
  data: {
    checkedNames: []
  }
})
</code></pre>
<h2 id="单选按钮"><a class="header" href="#单选按钮">单选按钮</a></h2>
<pre><code>&lt;div id=&quot;example-4&quot;&gt;
  &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;
  &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;
  &lt;br&gt;
  &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;
  &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;
  &lt;br&gt;
  &lt;span&gt;Picked: {{ picked }}&lt;/span&gt;
&lt;/div&gt;
new Vue({
  el: '#example-4',
  data: {
    picked: ''
  }
})
</code></pre>
<h2 id="下拉框"><a class="header" href="#下拉框">下拉框</a></h2>
<p>单选</p>
<pre><code>&lt;div id=&quot;example-5&quot;&gt;
  &lt;select v-model=&quot;selected&quot;&gt;
    &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt;
    &lt;option&gt;A&lt;/option&gt;
    &lt;option&gt;B&lt;/option&gt;
    &lt;option&gt;C&lt;/option&gt;
  &lt;/select&gt;
  &lt;span&gt;Selected: {{ selected }}&lt;/span&gt;
&lt;/div&gt;
new Vue({
  el: '...',
  data: {
    selected: ''
  }
})
</code></pre>
<p>多选时 (绑定到一个数组)：</p>
<pre><code>&lt;div id=&quot;example-6&quot;&gt;
  &lt;select v-model=&quot;selected&quot; multiple style=&quot;width: 50px;&quot;&gt;
    &lt;option&gt;A&lt;/option&gt;
    &lt;option&gt;B&lt;/option&gt;
    &lt;option&gt;C&lt;/option&gt;
  &lt;/select&gt;
  &lt;br&gt;
  &lt;span&gt;Selected: {{ selected }}&lt;/span&gt;
&lt;/div&gt;
new Vue({
  el: '#example-6',
  data: {
    selected: []
  }
})
</code></pre>
<p>用 <code>v-for</code> 渲染的动态选项：</p>
<pre><code>&lt;select v-model=&quot;selected&quot;&gt;
  &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt;
    {{ option.text }}
  &lt;/option&gt;
&lt;/select&gt;
&lt;span&gt;Selected: {{ selected }}&lt;/span&gt;
new Vue({
  el: '...',
  data: {
    selected: 'A',
    options: [
      { text: 'One', value: 'A' },
      { text: 'Two', value: 'B' },
      { text: 'Three', value: 'C' }
    ]
  }
})
</code></pre>
<h1 id="值绑定"><a class="header" href="#值绑定">值绑定</a></h1>
<p>bool 变量 true,false 用其他字符串替代</p>
<h2 id="复选框-1"><a class="header" href="#复选框-1">复选框</a></h2>
<pre><code>&lt;input
  type=&quot;checkbox&quot;
  v-model=&quot;toggle&quot;
  true-value=&quot;yes&quot;
  false-value=&quot;no&quot;
&gt;
// 当选中时
vm.toggle === 'yes'
// 当没有选中时
vm.toggle === 'no'
</code></pre>
<blockquote>
<p>这里的 <code>true-value</code> 和 <code>false-value</code> attribute 并不会影响输入控件的 <code>value</code> attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(即“yes”或“no”)，请换用单选按钮。</p>
</blockquote>
<h2 id="单选按钮-1"><a class="header" href="#单选按钮-1">单选按钮</a></h2>
<pre><code>&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; v-bind:value=&quot;a&quot;&gt;
// 当选中时
vm.pick === vm.a
</code></pre>
<h2 id="选择框的选项"><a class="header" href="#选择框的选项">选择框的选项</a></h2>
<pre><code>&lt;select v-model=&quot;selected&quot;&gt;
    &lt;!-- 内联对象字面量 --&gt;
  &lt;option v-bind:value=&quot;{ number: 123 }&quot;&gt;123&lt;/option&gt;
&lt;/select&gt;
// 当选中时
typeof vm.selected // =&gt; 'object'
vm.selected.number // =&gt; 123
</code></pre>
<h1 id="修饰符-1"><a class="header" href="#修饰符-1">修饰符</a></h1>
<h2 id="lazy"><a class="header" href="#lazy">.lazy</a></h2>
<p>​ 在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步 (除了<a href="https://vuejs.bootcss.com/guide/forms.html#vmodel-ime-tip">上述</a>输入法组合文字时)。你可以添加 <code>lazy</code> 修饰符，从而转为在 <code>change</code> 事件<em>之后</em>进行同步：</p>
<pre><code>&lt;!-- 在“change”时而非“input”时更新 --&gt;
&lt;input v-model.lazy=&quot;msg&quot;&gt;
</code></pre>
<h2 id="number"><a class="header" href="#number">.number</a></h2>
<p>​ 如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p>
<pre><code>&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;
</code></pre>
<p>​ 这通常很有用，因为即使在 <code>type=&quot;number&quot;</code> 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 <code>parseFloat()</code> 解析，则会返回原始的值。</p>
<h2 id="trim"><a class="header" href="#trim">.trim</a></h2>
<p>​ 如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p>
<pre><code>&lt;input v-model.trim=&quot;msg&quot;&gt;
</code></pre>
<h1 id="在组件上使用-v-model"><a class="header" href="#在组件上使用-v-model">在组件上使用 v-model</a></h1>
<p>HTML 原生的输入元素类型并不总能满足需求。幸好，Vue 的组件系统允许你创建具有完全自定义行为且可复用的输入组件。这些输入组件甚至可以和 <code>v-model</code> 一起使用！</p>
<p>要了解更多，请参阅组件指南中的<a href="https://vuejs.bootcss.com/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model">自定义输入组件</a>。</p>
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="计算属性"><a class="header" href="#计算属性">计算属性</a></h1>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<pre><code class="language-html">&lt;div id=&quot;example&quot;&gt;{{ message.split('').reverse().join('') }}&lt;/div&gt;
</code></pre>
<p>​ 上述代码难以维护,下面使用计算属性</p>
<pre><code class="language-html">&lt;div id=&quot;example&quot;&gt;
  &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;
  &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var vm = new Vue({
  el: &quot;#example&quot;,
  data: {
    message: &quot;Hello&quot;,
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split(&quot;&quot;).reverse().join(&quot;&quot;);
    },
  },
});
</code></pre>
<p>​ 这里我们声明了一个计算属性 <code>reversedMessage</code>。我们提供的函数将用作 property <code>vm.reversedMessage</code> 的 getter 函数：</p>
<pre><code class="language-js">console.log(vm.reversedMessage); // =&gt; 'olleH'
vm.message = &quot;Goodbye&quot;;
console.log(vm.reversedMessage); // =&gt; 'eybdooG'
</code></pre>
<h2 id="计算属性缓存-vs-方法"><a class="header" href="#计算属性缓存-vs-方法">计算属性缓存 VS 方法</a></h2>
<p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p>
<p>​ <strong>计算属性是基于它们的响应式依赖进行缓存的</strong>,只在相关响应式依赖发生改变时它们才会重新求值,这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>
<h2 id="计算属性-vs-侦听属性"><a class="header" href="#计算属性-vs-侦听属性">计算属性 vs 侦听属性</a></h2>
<p>​ Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：<strong>侦听属性</strong></p>
<pre><code class="language-js">var vm = new Vue({
  el: &quot;#demo&quot;,
  data: {
    firstName: &quot;Foo&quot;,
    lastName: &quot;Bar&quot;,
    fullName: &quot;Foo Bar&quot;,
  },
  watch: {
    firstName: function (val) {
      this.fullName = val + &quot; &quot; + this.lastName;
    },
    lastName: function (val) {
      this.fullName = this.firstName + &quot; &quot; + val;
    },
  },
});
</code></pre>
<p>上面代码是命令式且重复的。将它与计算属性的版本进行比较：</p>
<pre><code class="language-js">var vm = new Vue({
  el: &quot;#demo&quot;,
  data: {
    firstName: &quot;Foo&quot;,
    lastName: &quot;Bar&quot;,
  },
  computed: {
    fullName: function () {
      return this.firstName + &quot; &quot; + this.lastName;
    },
  },
});
</code></pre>
<h2 id="计算属性的-setter"><a class="header" href="#计算属性的-setter">计算属性的 setter</a></h2>
<pre><code class="language-js">// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
</code></pre>
<h1 id="侦听器"><a class="header" href="#侦听器">侦听器</a></h1>
<p>案例</p>
<pre><code class="language-html">&lt;div id=&quot;watch-example&quot;&gt;
  &lt;p&gt;
    Ask a yes/no question:
    &lt;input v-model=&quot;question&quot; /&gt;
  &lt;/p&gt;
  &lt;p&gt;{{ answer }}&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;
&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
var watchExampleVM = new Vue({
  el: '#watch-example',
  data: {
    question: '',
    answer: 'I cannot give you an answer until you ask a question!'
  },
  watch: {
    // 如果 `question` 发生改变，这个函数就会运行
    question: function (newQuestion, oldQuestion) {
      this.answer = 'Waiting for you to stop typing...'
      this.debouncedGetAnswer()
    }
  },
  created: function () {
    // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。
    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率
    // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于
    // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，
    // 请参考：https://lodash.com/docs#debounce
    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)
  },
  methods: {
    getAnswer: function () {
      if (this.question.indexOf('?') === -1) {
        this.answer = 'Questions usually contain a question mark. ;-)'
        return
      }
      this.answer = 'Thinking...'
      var vm = this
      axios.get('https://yesno.wtf/api')
        .then(function (response) {
          vm.answer = _.capitalize(response.data.answer)
        })
        .catch(function (error) {
          vm.answer = 'Error! Could not reach the API. ' + error
        })
    }
  }
})
&lt;/script&gt;
</code></pre>
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-6"><a class="header" href="#简介-6">简介</a></h1>
<p>Quasar CLI是Quasar Framework的骄傲。您可以无缝地构建：</p>
<ul>
<li>SPA（单页应用/网站），</li>
<li>SSR（服务器端渲染的应用/网站），</li>
<li>PWA（渐进式网页应用），</li>
<li>移动应用（通过Cordova），</li>
<li>Electron应用</li>
</ul>
<p>…在同一个项目文件夹中，确保您<strong>遵循最佳的Quasar实践，而一切都将开箱即用</strong>。</p>
<p><a href="http://www.quasarchs.com/quasar-cli/installation">Install Quasar CLI<em>launch</em></a></p>
<h1 id="使用quasar-cli"><a class="header" href="#使用quasar-cli">使用Quasar CLI</a></h1>
<pre><code class="language-shell"># 在Quasar v1项目中
# 运行这些命令
# (需要全局@quasar/cli &gt;= 1.0.0-beta.3)

# 检查可升级的软件包
$ quasar upgrade

# 做实际的升级
$ quasar upgrade --install
</code></pre>
<h1 id="升级指南"><a class="header" href="#升级指南"><a href="http://www.quasarchs.com/start/upgrade-guide#Introduction">升级指南</a></a></h1>
<h1 id="vscode配置"><a class="header" href="#vscode配置"><a href="http://www.quasarchs.com/start/vs-code-configuration#Introduction">VSCode配置</a></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quasarcli"><a class="header" href="#quasarcli">QuasarCli</a></h1>
<h2 id="安装-4"><a class="header" href="#安装-4">安装</a></h2>
<pre><code class="language-bash">npm install -g @quasar/cli
quasar create &lt;folder_name&gt;
 npx quasar dev
</code></pre>
<p>在你的<code>package.json</code>中添加几个npm脚本的例子：</p>
<pre><code class="language-js">// package.json
&quot;scripts&quot;: {
  &quot;dev&quot;: &quot;quasar dev&quot;,
  &quot;build&quot;: &quot;quasar build&quot;,
  &quot;build:pwa&quot;: &quot;quasar build -m pwa&quot;
}
</code></pre>
<h1 id="配置quasarconfjs"><a class="header" href="#配置quasarconfjs">配置quasar.conf.js</a></h1>
<p>那么你可以通过<code>/quasar.conf.js</code>来配置什么？</p>
<ul>
<li>您将在您的网站/应用程序中使用的Quasar组件、指令和插件</li>
<li>默认的<a href="http://www.quasarchs.com/options/quasar-language-packs">Quasar语言包</a></li>
<li>你想使用的<a href="http://www.quasarchs.com/options/installing-icon-libraries">图标库</a></li>
<li>Quasar组件的默认的<a href="http://www.quasarchs.com/options/quasar-icon-sets">Quasar图标集</a></li>
<li>开发服务器端口、HTTPS模式、主机名等</li>
<li>你想使用的<a href="http://www.quasarchs.com/options/animations">CSS动画</a></li>
<li><a href="http://www.quasarchs.com/quasar-cli/cli-documentation/boot-files">启动文件</a> 列表（也决定了执行顺序) - 这是<code>/src/boot</code>中的文件，告诉你在安装根Vue组件之前如何初始化应用程序</li>
<li>bundle中包含的全局CSS/Stylus/…文件</li>
<li>PWA <a href="http://www.quasarchs.com/quasar-cli/developing-pwa/configuring-pwa#%E9%85%8D%E7%BD%AEManifest%E6%96%87%E4%BB%B6">manifest</a> 和 <a href="http://www.quasarchs.com/quasar-cli/developing-pwa/configuring-pwa#Quasar.conf.js">Workbox选项</a></li>
<li><a href="http://www.quasarchs.com/quasar-cli/developing-electron-apps/configuring-electron#Quasar.conf.js">Electron打包器</a> 和/或 <a href="http://www.quasarchs.com/quasar-cli/developing-electron-apps/configuring-electron#Quasar.conf.js">Electron构建器</a></li>
<li>IE11 +支持</li>
<li>扩展的Webpack配置</li>
</ul>
<blockquote>
<p>您会注意到，更改任何这些设置不需要您手动重新加载开发服务器。 Quasar检测是否可以通过<a href="https://webpack.js.org/concepts/hot-module-replacement/">热模块更换</a> 注入更改，如果不能，则会自动重新加载开发服务器。 您不会丢失开发流程，因为您只需坐等Quasar CLI快速重新加载更改的代码，甚至保持当前状态。 这节省了大量的时间！</p>
</blockquote>
<p>WARNING</p>
<p><code>/quasar.conf.js</code>由Quasar CLI构建系统运行，因此这些配置代码直接在Node下运行，而不是在应用程序的上下文中运行。这意味着你可以导入像’fs’，‘path’，'webpack’等模块。确保您在此文件编写的ES6功能受安装的Node版本（应该&gt;=8.9.0)支持。</p>
<h2 id="结构"><a class="header" href="#结构">结构</a></h2>
<p>您会注意到<code>/quasar.conf.js</code>会导出一个函数，该函数接受<code>ctx</code>(context)参数并返回一个对象。这使您可以根据此上下文动态更改您的网站/应用配置：</p>
<pre><code class="language-js">module.exports = function (ctx) {
  console.log(ctx)

  // 输出到控制台的例子:
  {
    dev: true,
    prod: false,
    mode: { spa: true },
    modeName: 'spa',
    target: {},
    targetName: undefined,
    arch: {},
    archName: undefined,
    debug: undefined
  }

  // 根据这些参数上下文将会被创建
  // 当你运行&quot;quasar dev&quot;或&quot;quasar build&quot;时
}
</code></pre>
<p>这意味着，作为一个例子，您可以在构建特定模式（如PWA）时加载字体，并为其他模式选择另一个：</p>
<pre><code class="language-js">module.exports = function (ctx) {
  extras: [
    ctx.mode.pwa // we're adding only if working on a PWA
      ? 'roboto-font'
      : null
  ]
}
</code></pre>
<p>或者，您可以使用一个全局CSS文件用于SPA模式，使用另一个用于Cordova模式，同时避免为其他模式加载任何此类文件。</p>
<pre><code class="language-js">module.exports = function (ctx) {
  css: [
    ctx.mode.spa ? 'app-spa.styl' : null, // looks for /src/css/app-spa.styl
    ctx.mode.cordova ? 'app-cordova.styl' : null  // looks for /src/css/app-cordova.styl
  ]
}
</code></pre>
<p>或者，您可以将开发服务器配置为在端口8000上运行SPA模式，在端口9000上运行PWA模式或在端口9090上运行其他模式：</p>
<pre><code class="language-js">module.exports = function (ctx) {
  devServer: {
    port: ctx.mode.spa
      ? 8000
      : (ctx.mode.pwa ? 9000 : 9090)
  }
}
</code></pre>
<h2 id="配置选项"><a class="header" href="#配置选项">配置选项</a></h2>
<p>让我们逐个采取每个选项：</p>
<table><thead><tr><th style="text-align: left">属性</th><th style="text-align: left">类型</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">css</td><td style="text-align: left">Array</td><td style="text-align: left">来自/src/css/的全局CSS/Stylus/…文件，默认包含的主题文件除外。</td></tr>
<tr><td style="text-align: left">preFetch</td><td style="text-align: left">Boolean</td><td style="text-align: left">启用<a href="http://www.quasarchs.com/quasar-cli/cli-documentation/prefetch-feature">PreFetch功能</a>.</td></tr>
<tr><td style="text-align: left">extras</td><td style="text-align: left">Array</td><td style="text-align: left">从<a href="https://github.com/quasarframework/quasar/tree/dev/extras">@quasar/extras</a>包中导入什么内容。 例： <em>[‘material-icons’, ‘roboto-font’, ‘ionicons-v4’]</em></td></tr>
<tr><td style="text-align: left">vendor</td><td style="text-align: left">Object</td><td style="text-align: left">向vendor块添加/删除文件/第三方库： { add: […], remove: […] }.</td></tr>
<tr><td style="text-align: left">supportIE</td><td style="text-align: left">Boolean</td><td style="text-align: left">增加IE11+支持.</td></tr>
<tr><td style="text-align: left">htmlVariables</td><td style="text-align: left">Object</td><td style="text-align: left">添加可在index.template.html中使用的变量。</td></tr>
<tr><td style="text-align: left">framework</td><td style="text-align: left">Object/String</td><td style="text-align: left">导入哪个Quasar组件/指令/插件，选择哪个Quasar语言包,使用Quasar组件的哪个Quasar图标集。</td></tr>
<tr><td style="text-align: left">animations</td><td style="text-align: left">Object/String</td><td style="text-align: left">导入哪个<a href="http://www.quasarchs.com/options/animations">CSS动画</a>。 例： <em>[‘bounceInLeft’, ‘bounceOutRight’]</em></td></tr>
<tr><td style="text-align: left">devServer</td><td style="text-align: left">Object</td><td style="text-align: left">Webpack开发服务器<a href="https://webpack.js.org/configuration/dev-server/">选项</a>。 根据您使用的Quasar模式覆盖某些属性，以确保正确的配置。注意：如果您要代理开发服务器（即使用云IDE），请将“public”设置为你的公共应用程序URL。</td></tr>
<tr><td style="text-align: left">build</td><td style="text-align: left">Object</td><td style="text-align: left">构建配置。</td></tr>
<tr><td style="text-align: left">sourceFiles</td><td style="text-align: left">Object</td><td style="text-align: left">更改应用部分的默认名称.</td></tr>
<tr><td style="text-align: left">cordova</td><td style="text-align: left">Object</td><td style="text-align: left">Cordova特定<a href="http://www.quasarchs.com/quasar-cli/developing-cordova-apps/configuring-cordova">配置</a>。</td></tr>
<tr><td style="text-align: left">capacitor</td><td style="text-align: left">Object</td><td style="text-align: left">Quasar CLI Capacitor特定<a href="http://www.quasarchs.com/quasar-cli/developing-capacitor-apps/configuring-capacitor">配置</a>。</td></tr>
<tr><td style="text-align: left">pwa</td><td style="text-align: left">Object</td><td style="text-align: left">PWA特定<a href="http://www.quasarchs.com/quasar-cli/developing-pwa/configuring-pwa">配置</a>。</td></tr>
<tr><td style="text-align: left">ssr</td><td style="text-align: left">Object</td><td style="text-align: left">SSR特定<a href="http://www.quasarchs.com/quasar-cli/developing-ssr/configuring-ssr">配置</a>.</td></tr>
<tr><td style="text-align: left">electron</td><td style="text-align: left">Object</td><td style="text-align: left">Electron特定<a href="http://www.quasarchs.com/quasar-cli/developing-electron-apps/configuring-electron">配置</a>。</td></tr>
</tbody></table>
<h2 id="example-3"><a class="header" href="#example-3">example</a></h2>
<h3 id="属性css"><a class="header" href="#属性css">属性：css</a></h3>
<p>来自<code>/src/css/</code>的全局CSS/Stylus/…文件，默认包含的主题文件除外。</p>
<pre><code class="language-js">// quasar.conf.js
return {
  css: [
    'app.styl', // referring to /src/css/app.styl
    '~some-library/style.css' // referring to node_modules/some-library/style.css
  ]
}
</code></pre>
<h3 id="属性vendor"><a class="header" href="#属性vendor">属性：vendor</a></h3>
<p>默认情况下，出于性能和缓存原因，来自<code>node_modules</code>的所有内容都将注入到vendor块中。 但是，如果您希望在此特殊块中添加或删除某些内容，您可以这样做：</p>
<pre><code class="language-js">// quasar.conf.js
return {
  vendor: {
    /* 可选的; @quasar/app v1.4.2+; 
       禁用vendor块: */ disable: true,

    add: ['src/plugins/my-special-plugin'],
    remove: ['axios', 'vue$']
  }
}
</code></pre>
<h3 id="属性framework"><a class="header" href="#属性framework">属性：framework</a></h3>
<p>告诉CLI要导入的Quasar组件/指令/插件，要使用的Quasar I18n语言包，用于Quasar组件的图标集等等。</p>
<pre><code class="language-js">// quasar.conf.js
return {
  // a list with all options (all are optional)
  framework: {
    components: ['QBtn', 'QIcon' /* ... */],
    directives: ['TouchSwipe' /* ... */],
    plugins: ['Notify' /* ... */],

    // Quasar config
    // You'll see this mentioned for components/directives/plugins which use it
    config: { /* ... */ },

    iconSet: 'fontawesome', // requires icon library to be specified in &quot;extras&quot; section too,
    lang: 'de', // Tell Quasar which language pack to use for its own components

    cssAddon: true // Adds the flex responsive++ CSS classes (noticeable bump in footprint)
  }
}
</code></pre>
<p>更多关于cssAddon参考<a href="http://www.quasarchs.com/layout/grid/introduction-to-flexbox#Flex-Addons">这里</a>.</p>
<h3 id="自动导入功能"><a class="header" href="#自动导入功能">自动导入功能</a></h3>
<p>@quasar/app v1.1.1+</p>
<p>quasar v1.1.2+</p>
<p>您还可以通过<code>framework：{all}</code>属性将Quasar CLI配置为自动导入正在使用的Quasar组件和指令：</p>
<pre><code class="language-js">// quasar.conf.js
framework: {
  // Possible values for &quot;all&quot;:
  // * 'auto' - Auto-import needed Quasar components &amp; directives
  //            (slightly higher compile time; next to minimum bundle size; most convenient)
  // * false  - Manually specify what to import
  //            (fastest compile time; minimum bundle size; most tedious)
  // * true   - Import everything from Quasar
  //            (not treeshaking Quasar; biggest bundle size; convenient)
  all: 'auto',
</code></pre>
<p>如果您设置<code>all: 'auto'</code>， <strong>那么Quasar将自动为您导入组件和指令</strong>。 编译时间将略有增加，但是您无需在quasar.conf.js中指定组件和指令。 <strong>请注意，仍需要指定Quasar插件。</strong></p>
<p>从<code>@quasar/app</code> v1.1.2（以及<code>quasar</code> v1.1.3 +）开始，使用自动导入功能时，您还可以配置编写组件的方式：</p>
<pre><code class="language-js">// quasar.conf.js
framework: {
  all: 'auto',
  autoImportComponentCase: 'pascal' // or 'kebab' (default) or 'combined'
</code></pre>
<h3 id="属性devserver"><a class="header" href="#属性devserver">属性：devServer</a></h3>
<p><strong>Webpack devServer 选项</strong>. 看看<a href="https://webpack.js.org/configuration/dev-server/">完整列表</a>的选项。 有些被Quasar CLI根据“Quasar dev”参数和Quasar模式覆盖，以确保正确的设置。 注意：如果您要代理开发服务器（即使用云IDE），请将“public”设置为公共应用程序URL。</p>
<p>大多数使用的属性是：</p>
<table><thead><tr><th style="text-align: left">属性</th><th style="text-align: left">类型</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">port</td><td style="text-align: left">Number</td><td style="text-align: left">dev server端口</td></tr>
<tr><td style="text-align: left">host</td><td style="text-align: left">String</td><td style="text-align: left">dev server使用的本地IP/主机名</td></tr>
<tr><td style="text-align: left">open</td><td style="text-align: left">Boolean/String</td><td style="text-align: left">除非将其设置为“false”，否则Quasar将打开一个自动指向开发服务器地址的浏览器。 适用于SPA，PWA和SSR模式。 如果指定String，请参阅下面的说明。</td></tr>
<tr><td style="text-align: left">public</td><td style="text-align: left">String</td><td style="text-align: left">应用程序的公共地址（用于反向代理）</td></tr>
</tbody></table>
<p>使用<code>open</code>属性打开特定浏览器，而不是使用操作系统的默认浏览器（基于主机操作系统检查<a href="https://github.com/sindresorhus/open/blob/master/test.js">支持的值</a>）：</p>
<pre><code class="language-js">// quasar.conf.js

devServer: {
  open: 'firefox'
}
</code></pre>
<p>在quasar.conf.js文件中设置<code>devServer &gt; https: true</code>时，Quasar会自动为您生成SSL证书。 但是，如果您想自己为本地主机创建一个，请查看<a href="https://blog.filippo.io/mkcert-valid-https-certificates-for-localhost/">Filippo</a>的博客文章。 然后你的<code>quasar.conf.js &gt; devServer &gt; https</code>应该看起来像这样：</p>
<pre><code class="language-js">// quasar.conf.js

const fs = require('fs')
// ...

devServer: {
  https: {
    key: fs.readFileSync('/path/to/server.key'),
    cert: fs.readFileSync('/path/to/server.crt'),
    ca: fs.readFileSync('/path/to/ca.pem'),
  }
}
</code></pre>
<p>从 <strong>@quasar/app v1.3.2</strong> 开始，您还可以配置自动打开远程Vue Devtools：</p>
<pre><code class="language-js">// quasar.conf.js

devServer: {
  vueDevtools: true
}
</code></pre>
<h3 id="属性build"><a class="header" href="#属性build">属性：build</a></h3>
<table><thead><tr><th style="text-align: left">属性</th><th style="text-align: left">类型</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">transpileDependencies</td><td style="text-align: left">Array of Regex</td><td style="text-align: left">添加使用Babel进行转换的依赖项（来自node_modules，默认情况下不会被转换）。 例： <code>[ /my-dependency/, ...]</code></td></tr>
<tr><td style="text-align: left">transformAssetUrls</td><td style="text-align: left">Object</td><td style="text-align: left">(<strong>@quasar/app 1.3.4+</strong>) 添加对自定义标记属性的引用资源的支持。例如： <code>{ 'my-img-comp': 'src', 'my-avatar': [ 'src', 'placeholder-src' ]}</code></td></tr>
<tr><td style="text-align: left">showProgress</td><td style="text-align: left">Boolean</td><td style="text-align: left">编译时显示进度条。</td></tr>
<tr><td style="text-align: left">extendWebpack(cfg)</td><td style="text-align: left">Function</td><td style="text-align: left">Quasar CLI生成的扩展Webpack配置。 等同于chainWebpack()，但您可以直接访问Webpack配置对象。</td></tr>
<tr><td style="text-align: left">chainWebpack(chain)</td><td style="text-align: left">Function</td><td style="text-align: left">Quasar CLI生成的扩展Webpack配置。 等同于extendWebpack()，但改为使用webpack-chain。</td></tr>
<tr><td style="text-align: left">beforeDev({ quasarConf })</td><td style="text-align: left">Function</td><td style="text-align: left">在运行<code>$ quasar dev</code>命令之前准备外部服务，比如启动一些后端或应用所依赖的任何其他服务。 可以使用async/await或直接返回Promise。</td></tr>
<tr><td style="text-align: left">afterDev({ quasarConf })</td><td style="text-align: left">Function</td><td style="text-align: left">quasar开发服务器启动后（<code>$ quasar dev</code>）运行钩子。 此时，开发服务器已启动，如果您希望对其执行某些操作则可用这个方法。 可以使用async/await或直接返回Promise。</td></tr>
<tr><td style="text-align: left">beforeBuild({ quasarConf })</td><td style="text-align: left">Function</td><td style="text-align: left">在Quasar构建用于生产环境的应用（<code>$ quasar build</code>）之前运行钩子。 此时，尚未创建redistributables文件夹。 可以使用async/await或直接返回Promise。</td></tr>
<tr><td style="text-align: left">afterBuild({ quasarConf })</td><td style="text-align: left">Function</td><td style="text-align: left">在Quasar构建用于生产环境的应用（<code>$ quasar build</code>）之后运行钩子。 此时，distributables文件夹已创建，如果您希望对其执行某些操作，则可用。 可以使用async/await或直接返回Promise。</td></tr>
<tr><td style="text-align: left">onPublish(opts)</td><td style="text-align: left">Function</td><td style="text-align: left">在Quasar构建用于生产环境的应用并执行afterBuild挂钩（如果指定）之后，如果请求发布（<code>$ quasar build -P</code>），则运行挂钩。 可以使用async/await或直接返回Promise。 <code>opts</code>是<code>{arg, distDir}</code>形式的对象，其中“arg”是提供给-P的参数（如果有的话）。</td></tr>
<tr><td style="text-align: left">publicPath</td><td style="text-align: left">String</td><td style="text-align: left">部署时的公共路径。</td></tr>
<tr><td style="text-align: left">forceDevPublicPath</td><td style="text-align: left">Boolean</td><td style="text-align: left">(<strong>@quasar/app 1.0.6+</strong>) 也在开发版本中强制使用自定义publicPath（仅适用于SPA和PWA模式）。 请确保这确实是您要查找的内容，并且您知道自己在做什么，否则不建议这样做。</td></tr>
<tr><td style="text-align: left">appBase</td><td style="text-align: left">String</td><td style="text-align: left">(<strong>@quasar/app 1.4.2+</strong>) 使用您的自定义值强制应用基本标签；仅在您<strong>确实</strong>知道自己在做什么的情况下进行配置，否则您可以轻松破坏应用程序。 强烈建议您保留由quasar/app计算的结果。</td></tr>
<tr><td style="text-align: left">vueRouterBase</td><td style="text-align: left">String</td><td style="text-align: left">(<strong>@quasar/app 1.4.2+</strong>) 用您的自定义值强制应用vue router base；仅在您<strong>确实</strong>知道自己在做什么的情况下进行配置，否则您可以轻松破坏应用程序。 强烈建议您保留由quasar / app计算的结果。</td></tr>
<tr><td style="text-align: left">vueRouterMode</td><td style="text-align: left">String</td><td style="text-align: left">设置<a href="https://router.vuejs.org/en/essentials/history-mode.html">Vue路由器模式</a>：‘hash’或’history’。 请明智选择。 历史记录模式也需要在部署Web服务器上进行配置。</td></tr>
<tr><td style="text-align: left">htmlFilename</td><td style="text-align: left">String</td><td style="text-align: left">默认是’index.html’.</td></tr>
<tr><td style="text-align: left">productName</td><td style="text-align: left">String</td><td style="text-align: left">默认值取自package.json&gt; productName字段。</td></tr>
<tr><td style="text-align: left">distDir</td><td style="text-align: left">String</td><td style="text-align: left">Quasar CLI生成可分发包的目录，对应项目根目录的相对路径。 默认是’dist/{ctx.modeName}’。 适用于除Cordova (强制生成到src-cordova/www目录)以外的所有模式。</td></tr>
<tr><td style="text-align: left">devtool</td><td style="text-align: left">String</td><td style="text-align: left">Source map<a href="https://webpack.js.org/configuration/devtool/">策略</a>使用。</td></tr>
<tr><td style="text-align: left">env</td><td style="text-align: left">Object</td><td style="text-align: left">将属性添加到<code>process.env</code>，您可以在您的网站/应用程序JS代码中使用它。 每个属性都需要JSON编码。 例如：{SOMETHING：JSON.stringify(‘someValue’)}。</td></tr>
<tr><td style="text-align: left">gzip</td><td style="text-align: left">Boolean</td><td style="text-align: left">使用Gzip压缩可分发包。 当您提供内容的网络服务器没有gzip功能时很有用。</td></tr>
<tr><td style="text-align: left">scopeHoisting</td><td style="text-align: left">Boolean</td><td style="text-align: left">默认值：“true”。 使用 Webpack范围提升功能 来获得稍微更好的运行时性能。</td></tr>
<tr><td style="text-align: left">analyze</td><td style="text-align: left">Boolean/Object</td><td style="text-align: left">使用webpack-bundle-analyzer显示构建包的分析。 如果用作对象，则表示webpack-bundle-analyzer配置对象。</td></tr>
<tr><td style="text-align: left">vueCompiler</td><td style="text-align: left">Boolean</td><td style="text-align: left">包括vue runtime + compiler版本，而不是默认的Vue运行时版本</td></tr>
<tr><td style="text-align: left">uglifyOptions</td><td style="text-align: left">Object</td><td style="text-align: left">缩小选项。 <a href="https://github.com/webpack-contrib/terser-webpack-plugin/#minify">完整清单</a>.</td></tr>
<tr><td style="text-align: left">preloadChunks</td><td style="text-align: left">Boolean</td><td style="text-align: left">默认为“true”。 浏览器空闲时预加载块以改善用户以后导航到其他页面的体验。</td></tr>
<tr><td style="text-align: left">scssLoaderOptions</td><td style="text-align: left">Object</td><td style="text-align: left">为<code>.scss</code>文件提供<code>sass-loader</code>的选项。</td></tr>
<tr><td style="text-align: left">sassLoaderOptions</td><td style="text-align: left">Object</td><td style="text-align: left">为<code>.sass</code>文件提供<code>sass-loader</code>的选项。</td></tr>
<tr><td style="text-align: left">stylusLoaderOptions</td><td style="text-align: left">Object</td><td style="text-align: left">提供给’stylus-loader`的选项.</td></tr>
<tr><td style="text-align: left">lessLoaderOptions</td><td style="text-align: left">Object</td><td style="text-align: left">提供给’less-loader`的选项。</td></tr>
</tbody></table>
<p>Quasar CLI根据dev/build命令和Quasar模式自动配置<code>build</code>的以下属性。 但是如果你想重写一些（确保你知道你在做什么)，你可以这样做：</p>
<table><thead><tr><th style="text-align: left">属性</th><th style="text-align: left">类型</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">extractCSS</td><td style="text-align: left">Boolean</td><td style="text-align: left">从Vue文件中提取CSS</td></tr>
<tr><td style="text-align: left">sourceMap</td><td style="text-align: left">Boolean</td><td style="text-align: left">使用 source maps</td></tr>
<tr><td style="text-align: left">minify</td><td style="text-align: left">Boolean</td><td style="text-align: left">压缩代码（html，js，css）</td></tr>
<tr><td style="text-align: left">webpackManifest</td><td style="text-align: left">Boolean</td><td style="text-align: left">改进缓存策略。 使用一个webpack清单文件来避免在每个版本的vendor块上更改散列导致缓存崩溃。</td></tr>
</tbody></table>
<p>例如，如果运行“quasar build --debug”，则无论您配置了什么，sourceMap和extractCSS都将设置为“true”。</p>
<h3 id="属性htmlvariables"><a class="header" href="#属性htmlvariables">属性：htmlVariables</a></h3>
<p>您可以在<code>src/index.template.html</code>中定义然后引用变量，如下所示：</p>
<pre><code class="language-js">// quasar.conf.js
module.exports = function (ctx) {
  return {
    htmlVariables: { title: 'test name' }
</code></pre>
<p>然后（只是一个示例，向您展示如何引用上面定义的变量，在本例中为<code>title</code>）：</p>
<pre><code class="language-html">&lt;!-- src/index.template.html --&gt;
&lt;%= htmlWebpackPlugin.options.title %&gt;
</code></pre>
<h3 id="属性sourcefiles"><a class="header" href="#属性sourcefiles">属性：sourceFiles</a></h3>
<p>如果必须，请使用此属性更改网站/应用程序的某些文件的默认名称。 所有路径必须相对于项目的根文件夹。</p>
<pre><code class="language-js">// default values:
sourceFiles: {
  rootComponent: 'src/App.vue',
  router: 'src/router',
  store: 'src/store',
  indexHtmlTemplate: 'src/index.template.html',
  registerServiceWorker: 'src-pwa/register-service-worker.js',
  serviceWorker: 'src-pwa/custom-service-worker.js',
  electronMainDev: 'src-electron/main-process/electron-main.dev.js',
  electronMainProd: 'src-electron/main-process/electron-main.js'
}
</code></pre>
<h3 id="为devbuild设置env的示例"><a class="header" href="#为devbuild设置env的示例">为dev/build设置env的示例</a></h3>
<pre><code class="language-js">build: {
  env: ctx.dev
    ? { // 在开发状态下我们拥有以下属性
      API: JSON.stringify('https://dev.api.com')
    }
    : { // 在构建状态（生产版本）下
      API: JSON.stringify('https://prod.api.com')
    }
}
</code></pre>
<p>然后，在您的网站/应用程序中，您可以访问<code>process.env.API</code>，它将根据开发或生产构建类型指向上述两个链接中的一个。</p>
<p>你甚至可以更进一步。 提供来自<code>quasar dev/build</code> env变量的值：</p>
<pre><code class="language-js"># 我们在终端设置一个env变量
$ MY_API=api.com quasar build

# 然后我们在/quasar.conf.js获取它
build: {
  env: ctx.dev
    ? { // 在开发状态下我们拥有以下属性
      API: JSON.stringify('https://dev.'+ process.env.MY_API)
    }
    : { // 在构建状态（生产版本）下
      API: JSON.stringify('https://prod.'+ process.env.MY_API)
    }
}
</code></pre>
<blockquote>
<p>或者你可以使用我们的<a href="https://github.com/quasarframework/app-extension-dotenv">@quasar/dotenv</a>或<a href="https://github.com/quasarframework/app-extension-qenv">@quasar/qenv</a>应用扩展。</p>
</blockquote>
<p>TIP</p>
<p>另请参阅<a href="http://www.quasarchs.com/quasar-cli/cli-documentation/handling-process-env">处理process.env</a>页面。</p>
<h3 id="处理webpack配置"><a class="header" href="#处理webpack配置">处理Webpack配置</a></h3>
<p>深入分析<a href="http://www.quasarchs.com/quasar-cli/cli-documentation/handling-webpack">处理Webpack</a>文档页面。</p>
<h1 id="应用图标"><a class="header" href="#应用图标"><a href="http://www.quasarchs.com/quasar-cli/app-icons#Introduction">应用图标</a></a></h1>
<p>如果您的目标是Quasar当前支持的所有平台，则需要制作大约80种不同的包含4种不同媒体类型（png，ico，icns和svg）的文件。 如果您只使用像Gimp，Photoshop或Affinity Designer这样的工具，您会发现这些文件相当大，制作它们并命名它们的过程容易出现操作错误。 您可能希望至少压缩PNG文件，并从SVG中删除不必要的应用元数据。</p>
<p>此页面记录了每个构建目标所需的所有图标</p>
<h1 id="测试与审核"><a class="header" href="#测试与审核"><a href="http://www.quasarchs.com/quasar-cli/testing-and-auditing#Introduction">测试与审核</a></a></h1>
<p>您的Quasar项目能够添加单元和e2e测试工具，以及不断增长的产品质量审计工具套件。这篇介绍不会详细介绍如何编写和使用测试，为此请参考<a href="https://github.com/quasarframework/quasar-testing">GitHub上的测试报告</a>中特别准备和维护的文档。如果您是初学者，请考虑阅读“进一步阅读”章节中的其中一本书。</p>
<h1 id="cli文档"><a class="header" href="#cli文档"><a href="http://www.quasarchs.com/quasar-cli/cli-documentation/directory-structure#Introduction">cli文档</a></a></h1>
<h2 id="目录结构"><a class="header" href="#目录结构">目录结构</a></h2>
<p>TIP</p>
<p>如果你是初学者，你需要关心的是 <code>/quasar.conf.js</code> (Quasar应用配置文件)、<code>/src/router</code>、 <code>/src/layouts</code>、 <code>/src/pages</code> 以及可选的 <code>/src/assets</code>。</p>
<pre><code class="language-bash">.
├── src/
│   ├── assets/              # 动态资源（由webpack处理）
│   ├── statics/             # 纯静态资源（直接复制）
│   ├── components/          # 用于页面和布局的.vue组件
│   ├── css/                 # CSS/Stylus/Sass/...文件
|   |   ├── app.styl
|   │   └── quasar.variables.styl # 供您调整的Quasar Stylus变量
│   ├── layouts/             # 布局 .vue 文件
│   ├── pages/               # 页面 .vue 文件
│   ├── boot/                # 启动文件 (app initialization code) 
│   ├── router/              # Vue路由
|   |   ├── index.js         # Vue路由定义
|   │   └── routes.js        # App路由定义
│   ├── store/               # Vuex Store
|   |   ├── index.js         # Vuex Store 定义
|   │   ├── &lt;folder&gt;         # Vuex Store 模块...
|   │   └── &lt;folder&gt;         # Vuex Store 模块...
│   ├── App.vue              # APP的根Vue组件
│   └── index.template.html  # index.html模板
├── src-ssr/                 # SSR特定代码(就像生产环境的Node网页服务器)
├── src-pwa/                 # PWA特定代码（如Service Worker）
├── src-cordova/             # Cordova生成的文件夹用于创建移动APP
├── src-electron/            # Electron特定代码（如&quot;main&quot;线程)
├── dist/                    # 生产版本代码，用于部署
│   ├── spa/                 # 构建SPA的例子
│   ├── ssr/                 # 构建SSR的例子
│   ├── electron/            # 构建Electron的例子
│   └── ....
├── quasar.conf.js           # Quasar App配置文件
├── babel.config.js          # Babeljs配置
├── .editorconfig            # editor配置
├── .eslintignore            # ESlint忽略路径
├── .eslintrc.js             # ESlint配置
├── .postcssrc.js            # PostCSS配置
├── .stylintrc               # Stylus lint配置
├── .gitignore               # GIT忽略路径
├── package.json             # npm脚本和依赖项
└── README.md                # 您的网站/应用程序的自述文件
</code></pre>
<h2 id="构建命令"><a class="header" href="#构建命令"><a href="http://www.quasarchs.com/quasar-cli/cli-documentation/build-commands#Introduction">构建命令</a></a></h2>
<h2 id="css预处理"><a class="header" href="#css预处理">CSS预处理</a></h2>
<p>如果想使用<strong>Sass</strong>或<strong>SCSS</strong>（推荐这两种中的任何一种）和<strong>Stylus</strong>，它们是通过Quasar CLI开箱即用的css预处理器。</p>
<p>您无需安装任何其他软件包或扩展Webpack配置。</p>
<p>WARNING</p>
<p>为了获得完整的Sass/SCSS支持，您将需要@quasar/app v1.1.0+</p>
<h3 id="怎么用"><a class="header" href="#怎么用">怎么用</a></h3>
<p>您的Vue文件可以通过<code>&lt;style&gt;</code>标签包含Sass/SCSS/Stylus代码。</p>
<pre><code class="language-html">&lt;!-- 注意lang=&quot;sass&quot; --&gt;
&lt;style lang=&quot;sass&quot;&gt;
div
  color: #444
  background-color: #dadada
&lt;/style&gt;
&lt;!-- 注意lang=&quot;scss&quot; --&gt;
&lt;style lang=&quot;scss&quot;&gt;
div {
  color: #444;
  background-color: #dadada;
}
&lt;/style&gt;
&lt;!-- 注意lang=&quot;stylus&quot; --&gt;
&lt;style lang=&quot;stylus&quot;&gt;
div
  color #444
  background-color #dadada
&lt;/style&gt;
</code></pre>
<p>而且，当然，还支持标准CSS：</p>
<pre><code class="language-html">&lt;style&gt;
div {
  color: #444;
  background-color: #dadada;
}
&lt;/style&gt;
</code></pre>
<h3 id="变量-1"><a class="header" href="#变量-1">变量</a></h3>
<p>Quasar还提供变量（<code>$primary</code>, <code>$grey-3</code>等），您可以直接使用它们。 阅读有关<a href="http://www.quasarchs.com/style/sass-scss-variables">Sass/SCSS变量</a>和<a href="http://www.quasarchs.com/style/stylus-variables">Stylus变量</a>的更多信息。</p>
<h2 id="应用路由"><a class="header" href="#应用路由"><a href="http://www.quasarchs.com/quasar-cli/cli-documentation/routing#Introduction">应用路由</a></a></h2>
<h2 id="延迟加载"><a class="header" href="#延迟加载">延迟加载</a></h2>
<p>当您的网站/应用程序很小时，您可以将所有布局/页面/组件加载到初始包中，并在启动时提供所有内容。 但是，当您的代码变得复杂时，有大量的布局/页面/组件，这样做并不是最理想的，因为它会影响加载时间。 幸运的是，有一种方法可以解决这个问题。</p>
<p>我们将介绍如何延迟加载/编码拆分应用程序的部分，以便仅在需要时自动请求它们。 这是通过动态导入完成的。 让我们从一个例子开始，然后转换它，以便我们使用延迟加载 - 我们将聚焦这个加载一个页面的例子，但同样的原则可以应用于加载任何东西（资源、JSONs、…）：</p>
<h3 id="延迟加载路由页面"><a class="header" href="#延迟加载路由页面">延迟加载路由页面</a></h3>
<p>使用Vue-Router调用静态组件是正常的。</p>
<pre><code class="language-js">import SomePage from 'pages/SomePage'

const routes = [
  {
    path: '/some-page',
    component: SomePage
  }
]
</code></pre>
<p>现在让我们改变这种方式，并使用动态导入使页面按需加载：</p>
<pre><code class="language-js">const routes = [
  {
    path: '/some-page',
    component: () =&gt; import('pages/SomePage')
  }
]
</code></pre>
<p>很简单，对吧？ 它所做的是为<code>/src/pages/SomePage.vue</code>创建一个单独的块，只有在需要时才加载。 在这个例子中，指当用户访问’/same-page’的路由的时候。</p>
<h3 id="延迟加载组件"><a class="header" href="#延迟加载组件">延迟加载组件</a></h3>
<p>通常，您将导入一个组件，然后将其注册到页面、布局或组件。</p>
<pre><code class="language-html">&lt;script&gt;
import SomeComponent from 'components/SomeComponent'

export default {
  components: {
    SomeComponent,
  }
}
&lt;/script&gt;
</code></pre>
<p>现在让我们改变这种方式，使用动态导入使组件按需加载：</p>
<pre><code class="language-html">&lt;script&gt;
export default {
  components: {
    SomeComponent: () =&gt; import('components/SomeComponent'),
  }
}
&lt;/script&gt;
</code></pre>
<h3 id="延迟加载即时生效"><a class="header" href="#延迟加载即时生效">延迟加载即时生效</a></h3>
<p>正如你在上面注意到的那样，我们使用动态导入（<code>import('.. resource ..')</code>）而不是常规导入（<code>import resource from './path/to/resource'</code>）。 动态导入基本上返回一个您可以使用的Promise：</p>
<pre><code class="language-js">import('./categories.json')
  .then(categories =&gt; {
    // 嘿, 我们已经延迟加载了这个文件
    // 并且我们有了&quot;categories&quot;中的内容
  })
  .catch(() =&gt; {
    // 哦, 哪里出错了...
    // 不能加载资源
  })
</code></pre>
<p>使用动态导入而不是常规导入的一个优点是导入路径可以在运行时确定：</p>
<pre><code class="language-js">import('pages/' + pageName + '/' + 'id')
</code></pre>
<h3 id="注意动态导入"><a class="header" href="#注意动态导入">注意动态导入</a></h3>
<p>在前面的例子中使用可变部分的动态导入时有一点需要注意。 当网站/应用程序被打包，在编译时我们无法知道运行时确切的导入路径。 因此，将为每个可以匹配变量路径的文件创建块。 您可能会在构建日志中看到不必要的文件。</p>
<p>那么我们如何限制在这种情况下创建的块的数量呢？ 方法是尽可能地限制可变部分，因此匹配的路径尽可能少。 1.添加文件扩展名，即使它没有扩展名也能用。 这将仅为该文件类型创建块。 当该文件夹包含许多文件类型时很有用。</p>
<pre><code class="language-js">// 糟糕
import('./folder/' + pageName)

// 这样更好
import('./folder/' + pageName + '.vue')
</code></pre>
<p>2.尝试创建一个文件夹结构，以限制可变路径中的文件。 尽可能具体说明：</p>
<pre><code class="language-js">// 糟糕 -- 为在./folder中的所有JSON创建块 (递归查询)
const asset = 'my/jsons/categories.json'
import('./folder/' + asset)

// 很好 --仅为在./folder/my/jsons中的JSON创建块
const asset = 'categories.json'
import('./folder/my/jsons/' + asset)
</code></pre>
<p>3.尝试从仅包含文件的文件夹导入。 以前面的例子为例，假设./folder/my/jsons还包含子文件夹。 我们通过指定更具体的路径来使动态导入更好，但在这种情况下它仍然不是最优的。 最好是使用仅包含文件的终端文件夹，因此我们限制匹配路径的数量。</p>
<ol>
<li>使用<a href="https://webpack.js.org/api/module-methods/#magic-comments">Webpack魔术注释</a>的<code>webpackInclude</code>和<code>webpackExclude</code>通过正则表达式约束捆绑的块，例如：</li>
</ol>
<pre><code class="language-js">await import(
  /* webpackInclude: /(ar|en-us|ro)\.js$/ */
  `quasar/lang/${langIso}`
)
  .then(lang =&gt; {
    Quasar.lang.set(lang.default)
  })
</code></pre>
<p>将导致仅捆绑您网站/应用程序所需的语言包，而不是捆绑所有语言包（超过40种！），这可能会妨碍<code>quasar dev</code>和<code>quasar build</code>.命令的性能。</p>
<p>请记住，匹配路径的数量等于正在生成的组块的数量。</p>
<h2 id="资源处理"><a class="header" href="#资源处理"><a href="http://www.quasarchs.com/quasar-cli/cli-documentation/handling-assets#Introduction">资源处理</a></a></h2>
<h2 id="启动文件"><a class="header" href="#启动文件">启动文件</a></h2>
<p><strong>在实例化根Vue应用程序实例之前运行代码</strong></p>
<h3 id="解剖一个启动文件"><a class="header" href="#解剖一个启动文件">解剖一个启动文件</a></h3>
<p>启动文件是一个简单的可以选择导出函数的JavaScript文件。 当启动应用程序时，Quasar将调用导出的函数，并将具有以下属性的<strong>一个对象</strong>传递给该函数：</p>
<table><thead><tr><th style="text-align: left">属性名称</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>app</code></td><td style="text-align: left">根组件通过Vue实例化的对象</td></tr>
<tr><td style="text-align: left"><code>router</code></td><td style="text-align: left">来自’src/router/index.js’的Vue路由器实例</td></tr>
<tr><td style="text-align: left"><code>store</code></td><td style="text-align: left">应用Vuex存储的实例 - <strong>只有当您的项目使用Vuex（您有src/store）时才会传递store</strong></td></tr>
<tr><td style="text-align: left"><code>Vue</code></td><td style="text-align: left">和<code>import Vue from 'vue'</code>一样，它在那里是为了方便</td></tr>
<tr><td style="text-align: left"><code>ssrContext</code></td><td style="text-align: left">如果为SSR构建，则仅在服务器端可用</td></tr>
<tr><td style="text-align: left"><code>urlPath</code></td><td style="text-align: left">(<strong>@quasar/app 1.0.7+</strong>) URL的路径名（路径+搜索）部分；在客户端（仅在客户端），它也包含哈希值。</td></tr>
<tr><td style="text-align: left"><code>redirect</code></td><td style="text-align: left">(<strong>@quasar/app 1.0.7+</strong>) 重定向到另一个URL的调用函数。</td></tr>
</tbody></table>
<pre><code class="language-js">export default ({ app, router, store, Vue }) =&gt; {
  // something to do
}
export default async ({ app, router, store, Vue }) =&gt; {
  // something to do
  await something()
}

注意我们正在使用ES6解构赋值。只分配你实际需要/使用的东西。
</code></pre>
<h3 id="何时使用启动文件"><a class="header" href="#何时使用启动文件">何时使用启动文件</a></h3>
<p>WARNING</p>
<p>请确保您了解应用插件解决什么问题，以及何时适合使用它们，以避免在不需要它们的情况下应用它们。</p>
<ul>
<li>你的Vue插件有安装说明，就像需要调用<code>Vue.use()</code>一样。</li>
<li>你的Vue插件需要实例化添加到根实例的数据 - 一个例子是<a href="https://github.com/kazupon/vue-i18n/">vue-i18n</a>。</li>
<li>您想使用<code>Vue.mixin()</code>添加全局mixin。</li>
<li>您想添加一些东西到Vue原型以方便访问 - 一个例子是在Vue文件中方便地使用<code>this.$axios</code>而不是在每个这样的文件中导入Axios。</li>
<li>你想干涉路由器 - 一个例子是使用<code>router.beforeEach</code>进行认证</li>
<li>你想干涉Vuex存储实例 - 一个例子是使用<code>vuex-router-sync</code>软件包</li>
<li>配置库的方面 - 一个例子是创建一个带有基本URL的Axios实例;你可以将它注入到Vue原型中和/或导出它（这样你就可以从应用程序中的任何其他地方导入实例）</li>
</ul>
<h3 id="不需要使用启动文件的示例"><a class="header" href="#不需要使用启动文件的示例">不需要使用启动文件的示例</a></h3>
<ul>
<li>对于像Lodash这样的普通JavaScript库，在使用之前不需要任何初始化。例如，Lodash可能只有在你想注入Vue原型时(例如可以在你的Vue文件中使用<code>this.$_</code>)用作启动文件才有意义。</li>
</ul>
<h3 id="使用启动文件"><a class="header" href="#使用启动文件">使用启动文件</a></h3>
<p>第一步总是使用Quasar CLI生成一个新的启动文件：</p>
<pre><code class="language-bash">$ quasar new boot &lt;name&gt;
</code></pre>
<p>其中<code>&lt;name&gt;</code>应该替换为您的启动文件的合适名称。</p>
<p>这个命令创建一个新文件：<code>/src/boot/&lt;name&gt;.js</code>包含以下内容：</p>
<pre><code class="language-js">// import something here

// &quot;async&quot; is optional
// remove it if you don't need it
export default async ({ /* app, router, store, Vue */ }) =&gt; {
  // something to do
}
</code></pre>
<p>You can also return a Promise:</p>
<pre><code class="language-js">// import something here

export default ({ /* app, router, store, Vue */ }) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    // do something
  })
}
</code></pre>
<p>最后一步是告诉Quasar使用你的新启动文件。 为了做到这一点，你需要在<code>/quasar.conf.js</code>中添加启动文件</p>
<pre><code class="language-js">boot: [
  // references /src/boot/&lt;name&gt;.js
  '&lt;name&gt;'
]
</code></pre>
<p>构建SSR应用程序时，您可能希望某些启动文件仅在服务器上运行或仅在客户端上运行，在这种情况下，您可以执行以下操作：</p>
<pre><code class="language-js">boot: [
  {
    server: false, // run on client-side only!
    path: '&lt;name&gt;' // references /src/boot/&lt;name&gt;.js
  },
  {
    client: false, // run on server-side only!
    path: '&lt;name&gt;' // references /src/boot/&lt;name&gt;.js
  }
]
</code></pre>
<p>如果要从node_modules指定启动文件，可以通过在路径前加上<code>~</code>（波浪号）字符来实现：</p>
<pre><code class="language-js">boot: [
  // boot file from an npm package
  '~my-npm-package/some/file'
]
</code></pre>
<p>如果您希望仅针对特定的构建类型将启动文件注入您的应用程序：</p>
<pre><code class="language-js">boot: [
  ctx.mode.electron ? 'some-file' : ''
]
</code></pre>
<h3 id="重定向到另一个页面"><a class="header" href="#重定向到另一个页面">重定向到另一个页面</a></h3>
<p>@quasar/app 1.0.7+</p>
<pre><code class="language-js">export default ({ urlPath, redirect }) =&gt; {
  // ...
  const isAuthorized = // ...
  if (!isAuthorized &amp;&amp; !urlPath.startsWith('/login')) {
    redirect('/login')
    return
  }
  // ...
}
</code></pre>
<p>如前几节所述，引导文件的默认导出可以返回Promise。 如果此Promise被包含“url”属性的对象拒绝，则Quasar CLI会将用户重定向到该URL：</p>
<pre><code class="language-js">export default ({ urlPath }) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    // ...
    const isAuthorized = // ...
    if (!isAuthorized &amp;&amp; !urlPath.startsWith('/login')) {
      reject({ url: '/login' })
      return
    }
    // ...
  })
}
</code></pre>
<p>或更简单的等效代码：</p>
<pre><code class="language-js">export default () =&gt; {
  // ...
  const isAuthorized = // ...
    if (!isAuthorized &amp;&amp; !urlPath.startsWith('/login')) {
    return Promise.reject({ url: '/login' })
  }
  // ...
}
</code></pre>
<h3 id="quasar应用程序流程"><a class="header" href="#quasar应用程序流程">Quasar应用程序流程</a></h3>
<p>为了更好地理解启动文件的功能和用途，您需要了解您的网站/应用程序是如何启动的：</p>
<ol>
<li>Quasar已初始化（组件、指令、插件、Quasar i18n、Quasar图标集）</li>
<li>Quasar Extras被导入（Roboto字体 - 如果使用，图标，动画…）</li>
<li>Quasar CSS和您的应用程序的全局CSS已导入</li>
<li>App.vue被加载（尚未被使用）</li>
<li>Store被导入（如果在src/store中使用Vuex存储）</li>
<li>启动文件已导入</li>
<li>启动文件会执行其默认导出功能 7.（如果在Electron模式下）Electron 被导入并注入Vue原型 8.（如果在Cordova模式下）收听“deviceready”事件，然后继续执行以下步骤</li>
<li>使用根组件实例化Vue并附加到DOM</li>
</ol>
<h3 id="启动文件的例子"><a class="header" href="#启动文件的例子">启动文件的例子</a></h3>
<h4 id="axios"><a class="header" href="#axios">Axios</a></h4>
<pre><code class="language-js">import Vue from 'vue'
import axios from 'axios'

// we add it to Vue prototype
// so we can reference it in Vue files
// without the need to import axios
Vue.prototype.$axios = axios

// Example: this.$axios will reference Axios now so you don't need stuff like vue-axios
</code></pre>
<h4 id="vue-i18n"><a class="header" href="#vue-i18n">vue-i18n</a></h4>
<pre><code class="language-js">import Vue from 'vue'
// 导入外部包
import VueI18n from 'vue-i18n'

// 包含语言包的/src/i18n中一个文件
import messages from 'src/i18n'


// 告诉Vue使用我们的Vue包:
Vue.use(VueI18n)
export default ({ app, Vue }) =&gt; {
  // 在应用中设置i18n实例;
  // 我们通过这样做将它注入到根组件;
  // new Vue({..., i18n: ... }).$mount(...)

  app.i18n = new VueI18n({
    locale: 'en',
    fallbackLocale: 'en',
    messages
  })
}
</code></pre>
<h4 id="路由验证"><a class="header" href="#路由验证">路由验证</a></h4>
<p>一些插件可能需要干涉Vue路由器配置：</p>
<pre><code class="language-js">export default ({ router, store, Vue }) =&gt; {
  router.beforeEach((to, from, next) =&gt; {
    //现在您需要在这里添加验证逻辑，比如调用一个API
  })
}
</code></pre>
<h3 id="从启动文件访问数据"><a class="header" href="#从启动文件访问数据">从启动文件访问数据</a></h3>
<p>有时，您想访问您在启动文件中配置的数据，这些数据在您无权访问根Vue实例的文件中。</p>
<p>幸运的是，因为启动文件只是普通的JavaScript文件，所以您可以根据需要将任意数量的导出添加到您的启动文件。</p>
<p>以Axios为例。 有时候你想要在你的JavaScript文件中访问你的Axios实例，但是你不能访问根Vue实例。 为了解决这个问题，你可以在你的启动文件中导出Axios实例并将其导入到别处。</p>
<p>考虑下面的axios启动文件：</p>
<pre><code class="language-js">// axios启动文件(src/boot/axios.js)

import Vue from 'vue'
import axios from 'axios'

// 我们创建我们自己的axios实例并设置一个自定义的基本URL。
// 请注意，如果我们不在这里设置任何配置，我们不需要
// 一个命名的导出，因为我们可以`import axios from 'axios'`
const axiosInstance = axios.create({
  baseURL: 'https://api.example.com'
})

// 在Vue文件中通过this.$axios来使用
Vue.prototype.$axios = axiosInstance

// 这里我们定义一个命名的导出，
// 然后我们后面可以使用这个内部的.js文件:
export { axiosInstance }
</code></pre>
<p>在任何JavaScript文件中，您都可以像这样导入axios实例:</p>
<pre><code class="language-js">// 我们从src/boot/axios.js中导入一个命名的导出
import { axiosInstance } from 'boot/axios'
</code></pre>
<h2 id="预取prefetch功能"><a class="header" href="#预取prefetch功能">预取（PreFetch）功能</a></h2>
<p>预取是一项功能（<strong>仅在使用Quasar CLI</strong>时可用），它允许Vue路由(在<code>/src/router/routes.js</code>定义)获取的组件去：</p>
<ul>
<li>预取数据</li>
<li>验证路由</li>
<li>当某些条件不满足时（如用户未登录），重定向到另一条路由</li>
<li>可以帮助初始化存储状态</li>
</ul>
<p>以上所有内容都将在实际路由组件呈现之前运行。</p>
<p><strong>它适用于所有Quasar模式</strong>（SPA、PWA、SSR、Cordova、Electron），但它对SSR构建特别有用。</p>
<h3 id="安装-5"><a class="header" href="#安装-5">安装</a></h3>
<pre><code class="language-js">// quasar.conf.js
return {
  preFetch: true
}
</code></pre>
<blockquote>
<p>WARNING</p>
<p>当您使用它来预取数据时，您需要使用Vuex存储，因此在创建项目时请确保您的项目文件夹具有<code>/src/store</code>文件夹，否则生成新项目并复制store文件夹内容到当前项目。</p>
</blockquote>
<h3 id="预取功能激活场景"><a class="header" href="#预取功能激活场景">预取功能激活场景</a></h3>
<p><code>preFetch</code>钩子（在下一节中描述）由访问的路由决定 - 它也决定了渲染的组件。实际上，给定路由所需的数据也是在该路由上渲染的组件所需的数据。 <strong>因此将钩子逻辑仅置于路由组件内是很自然的（也是必需的）</strong>。 这包括<code>/src/App.vue</code>，在这种情况下，它只会在app启动时运行一次。</p>
<p>让我们举一个例子来了解何时调用钩子。假设我们有这些路由，并且我们为所有这些组件编写了<code>preFetch</code>钩子：</p>
<pre><code class="language-js">// routes
[
  {
    path: '/',
    component: LandingPage
  },
  {
    path: '/shop',
    component: ShopLayout,
    children: [
      {
        path: 'all',
        component: ShopAll
      },
      {
        path: 'new',
        component: ShopNew
      },
      {
        path: 'product/:name',
        component: ShopProduct,
        children: [{
          path: 'overview',
          component: ShopProductOverview
        }]
      }
    ]
  }
]
</code></pre>
<p>现在，让我们看看当用户一个接一个地按照下面指定的顺序访问这些路由时如何调用钩子。</p>
<table><thead><tr><th style="text-align: left">正在访问的路由</th><th style="text-align: left">调用的钩子</th><th style="text-align: left">观察</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>/</code></td><td style="text-align: left">App.vue然后登陆页面</td><td style="text-align: left">自我们的应用程序启动以来，就调用了App.vue挂钩。</td></tr>
<tr><td style="text-align: left"><code>/shop/all</code></td><td style="text-align: left">ShopLayout然后ShopAll</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left"><code>/shop/new</code></td><td style="text-align: left">ShopNew</td><td style="text-align: left">ShopNew是ShopLayout的子项，ShopLayout已经渲染，因此不再调用ShopLayout。</td></tr>
<tr><td style="text-align: left"><code>/shop/product/pyjamas</code></td><td style="text-align: left">ShopProduct</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left"><code>/shop/product/shoes</code></td><td style="text-align: left">ShopProduct</td><td style="text-align: left">Quasar注意到已经渲染了相同的组件，但是路由已经更新并且它有路由参数，所以它再次调用了钩子。</td></tr>
<tr><td style="text-align: left"><code>/shop/product/shoes/overview</code></td><td style="text-align: left">ShopProduct然后ShopProductOverview</td><td style="text-align: left">ShopProduct具有路由参数，因此即使已经渲染它也会被调用。</td></tr>
<tr><td style="text-align: left"><code>/</code></td><td style="text-align: left">登陆页面</td><td style="text-align: left"></td></tr>
</tbody></table>
<h3 id="用法"><a class="header" href="#用法">用法</a></h3>
<p>钩子被定义为我们的路由组件上名为<code>preFetch</code>的自定义静态函数。请注意，因为在实例化组件之前将调用此函数，所以它无法访问<code>this</code>。</p>
<pre><code class="language-html">&lt;!-- some .vue component used as route --&gt;
&lt;template&gt;
  &lt;div&gt;{{ item.title }}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  // our hook here
  preFetch ({ store, currentRoute, previousRoute, redirect, ssrContext }) {
    // fetch data, validate route and optionally redirect to some other route...

    // ssrContext is available only server-side in SSR mode

    // No access to &quot;this&quot; here as preFetch() is called before
    // the component gets instantiated.

    // Return a Promise if you are running an async job
    // Example:
    return store.dispatch('fetchItem', currentRoute.params.id)
  },

  computed: {
    // display the item from store state.
    item () {
      return this.$store.state.items[this.$route.params.id]
    }
  }
}
&lt;/script&gt;
// related action for Promise example
// ...

actions: {
  fetchItem ({ commit }, id) {
    return axiosInstance.get(url, id).then(({ data }) =&gt; {
      commit('mutation', data)
    })
  }
}

// ...
</code></pre>
<h3 id="重定向示例"><a class="header" href="#重定向示例">重定向示例</a></h3>
<p>下面是在某些情况下重定向用户的示例，例如当他们尝试访问只有经过身份验证的用户应该看到的页面时。</p>
<pre><code class="language-js">// We assume here we already wrote the authentication logic
// in the Vuex Store, so take as a high-level example only.
preFetch ({ store, redirect }) {
  if (!store.state.authenticated) {
    // IMPORTANT! Always use the String form of a
    // route if also building for SSR. The Object form
    // won't work on SSR builds.
    redirect('/login')
  }
}
</code></pre>
<h3 id="使用预取功能初始化存储"><a class="header" href="#使用预取功能初始化存储">使用预取功能初始化存储</a></h3>
<p>当应用程序启动时，<code>preFetch</code>挂钩只运行一次，因此您可以利用此机会在此处初始化Vuex存储。</p>
<pre><code class="language-js">// App.vue
export default {
  // ...
  preFetch ({ store }) {
    // initialize something in store here
  }
}
</code></pre>
<h3 id="加载中-1"><a class="header" href="#加载中-1">加载中</a></h3>
<p>还可以使用<a href="http://www.quasarchs.com/quasar-plugins/loading">加载中</a> 插件。 这是一个例子：</p>
<pre><code class="language-js">
// a route .vue component
import { Loading } from 'quasar'

export default {
  // ...
  preFetch ({ /* ... */ }) {
    Loading.show()

    return new Promise(resolve =&gt; {
      // do something async here
      // then call &quot;resolve()&quot;
    }).then(() =&gt; {
      Loading.hide()
    })
  }
}
</code></pre>
<h2 id="api代理"><a class="header" href="#api代理">API代理</a></h2>
<p>将项目文件夹（由Quasar CLI创建）与现有后端集成时，通常需要在使用开发服务器时访问后端API。 为此，我们可以并行（或远程）运行开发服务器和API后端，并让开发服务器将所有API请求代理到实际的后端。</p>
<p>如果您在API请求中访问相对路径，这很有用。 显然，这些相对路径可能在您开发时无法正常工作。 为了创建与您部署的网站/应用使用的环境类似的环境，您可以代理您的API请求。</p>
<p>要配置代理规则，编辑<code>/quasar.conf.js</code>中的<code>devServer.proxy</code>。 有关详细用法，请参阅<a href="https://webpack.js.org/configuration/dev-server/#devserver-proxy">Webpack Dev Server Proxy</a>文档。 但是这里有一个简单的例子：</p>
<pre><code class="language-js">// quasar.conf.js

devServer: {
  proxy: {
    // 将所有以/api开头的请求代理到jsonplaceholder
    '/api': {
      target: 'http://some.api.target.com:7070',
      changeOrigin: true,
      pathRewrite: {
        '^/api': ''
      }
    }
  }
}
</code></pre>
<p>上面的例子将代理请求 <code>/api/posts/1</code> 到 <code>http://some.api.target.com:7070/posts/1</code>.</p>
<h2 id="webpack处理"><a class="header" href="#webpack处理">Webpack处理</a></h2>
<p>构建系统使用Webpack创建您的网站/应用程序。 如果您不熟悉Webpack，请不要担心。 因为它开箱即用。您无需对其进行配置，因为它已经设置了一切。</p>
<h3 id="与quasarconfjs一起使用"><a class="header" href="#与quasarconfjs一起使用">与quasar.conf.js一起使用</a></h3>
<p>对于需要调整默认Webpack配置的情况，可以通过编辑<code>/quasar.conf.js</code>和配置<code>build&gt; extendWebpack(cfg)</code> 方法或 <code>build &gt; chainWebpack (chain)</code>来实现。</p>
<p>向Webpack添加ESLint加载器的例子（假设你已经安装了它）：</p>
<p>对于需要调整默认Webpack配置的情况，可以通过编辑<code>/quasar.conf.js</code>和配置<code>build&gt; extendWebpack(cfg)</code> 方法或 <code>build &gt; chainWebpack (chain)</code>来实现。</p>
<p>向Webpack添加ESLint加载器的例子（假设你已经安装了它）：</p>
<pre><code class="language-js">// quasar.conf.js
build: {
  extendWebpack (cfg, { isServer, isClient }) {
    cfg.module.rules.push({
      enforce: 'pre',
      test: /\.(js|vue)$/,
      loader: 'eslint-loader',
      exclude: /(node_modules|quasar)/,
      options: {
        formatter: require('eslint').CLIEngine.getFormatter('stylish')
      }
    })
  }
}
</code></pre>
<p>注意你不需要返回任何东西。 extendWebpack（cfg）的参数是由Quasar为您生成的Webpack配置对象。 假设你真的知道你在做什么，你可以添加/删除/替换任何东西。</p>
<p>chainWebpack()的等价quasar.conf：</p>
<pre><code class="language-js">// quasar.conf.js
build: {
  chainWebpack (chain, { isServer, isClient }) {
    chain.module.rule('eslint')
      .test(/\.(js|vue)$/)
      .enforce('pre')
      .exclude
        .add((/[\\/]node_modules[\\/]/))
        .end()
      .use('eslint-loader')
        .loader('eslint-loader')
  }
}
</code></pre>
<h3 id="检查webpack配置"><a class="header" href="#检查webpack配置">检查Webpack配置</a></h3>
<p>Quasar CLI为此提供了一个有用的命令：</p>
<pre><code class="language-bash">$ quasar inspect -h

  Description
    Inspect Quasar generated Webpack config

  Usage
    $ quasar inspect
    $ quasar inspect -c build
    $ quasar inspect -m electron -p 'module.rules'

  Options
    --cmd, -c        Quasar command [dev|build] (default: dev)
    --mode, -m       App mode [spa|ssr|pwa|cordova|electron] (default: spa)
    --depth, -d      Number of levels deep (default: 5)
    --path, -p       Path of config in dot notation
                        Examples:
                          -p module.rules
                          -p plugins
    --help, -h       Displays this message
</code></pre>
<h3 id="webpack别名"><a class="header" href="#webpack别名">Webpack别名</a></h3>
<p>Quasar带有一些预先配置好的Webpack别名。 您可以在项目中的任何位置使用它们，webpack将解析为正确的路径。</p>
<table><thead><tr><th style="text-align: left">别名</th><th style="text-align: left">解析为</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>src</code></td><td style="text-align: left">/src</td></tr>
<tr><td style="text-align: left"><code>app</code></td><td style="text-align: left">/</td></tr>
<tr><td style="text-align: left"><code>components</code></td><td style="text-align: left">/src/components</td></tr>
<tr><td style="text-align: left"><code>layouts</code></td><td style="text-align: left">/src/layouts</td></tr>
<tr><td style="text-align: left"><code>pages</code></td><td style="text-align: left">/src/pages</td></tr>
<tr><td style="text-align: left"><code>assets</code></td><td style="text-align: left">/src/assets</td></tr>
<tr><td style="text-align: left"><code>boot</code></td><td style="text-align: left">/src/boot</td></tr>
</tbody></table>
<p>另外，如果您配置为使用Vue编译器版本（quasar.conf &gt; build &gt; vueCompiler: true）进行构建，那么<code>vue$</code>会解析为<code>vue/dist/vue.esm.js</code>。</p>
<h3 id="添加webpack别名"><a class="header" href="#添加webpack别名">添加Webpack别名</a></h3>
<p>要添加自己的别名，可以扩展webpack配置并将其与现有别名合并。 使用<code>path.resolve</code>辅助程序来解析目标别名的路径。</p>
<pre><code class="language-js">// quasar.conf.js
const path = require('path')

module.exports = function (ctx) {
  return {
    build: {
      extendWebpack (cfg, { isServer, isClient }) {
        cfg.resolve.alias = {
          ...cfg.resolve.alias, // This adds the existing alias

          // Add your own alias like this
          myalias: path.resolve(__dirname, './src/somefolder'),
        }
      }
    }
  }
}
</code></pre>
<p>与chainWebpack()等效：</p>
<pre><code class="language-js">
// quasar.conf.js
const path = require('path')

module.exports = function (ctx) {
  return {
    build: {
      chainWebpack (chain, { isServer, isClient }) {
        chain.resolve.alias
          .set('myalias', path.resolve(__dirname, './src/somefolder'))
      }
    }
  }
}
</code></pre>
<h3 id="webpack装载器"><a class="header" href="#webpack装载器">Webpack装载器</a></h3>
<p>构建系统使用Webpack，所以它依靠使用webpack加载器来处理不同类型的文件（js，css，styl，scss，json等）。 默认情况下，最常用的加载程序是默认提供的。</p>
<h3 id="安装装载器"><a class="header" href="#安装装载器">安装装载器</a></h3>
<p>我们举个例子吧。 你想能够导入<code>.json</code>文件。 <strong>Quasar提供开箱即用的json支持，所以您实际上不需要执行这些步骤，但为了演示如何添加加载程序，我们将假装Quasar不提供它。</strong></p>
<p>所以，你需要一个装载机。 你搜索谷歌，看看你需要什么样的webpack loader。 在这种情况下，它是“json-loader”。 我们先安装它：</p>
<pre><code class="language-bash">$ yarn add --dev json-loader
</code></pre>
<p>在安装新的加载器之后，我们想告诉Webpack使用它。 因此，我们编辑<code>/quasar.conf.js</code>并更改<code>build.extendWebpack()</code>为这个新的加载器添加条目到<code>module/rules</code>：</p>
<pre><code class="language-js">// quasar.conf
build: {
  extendWebpack (cfg) {
    cfg.module.rules.push({
      test: /\.json$/,
      loader: 'json-loader'
    })
  }
}
</code></pre>
<p>与chainWebpack()等效:</p>
<pre><code class="language-js">// quasar.conf
build: {
  chainWebpack (chain) {
    chain.module.rule('json')
      .test(/\.json$/)
      .use('json-loader')
        .loader('json-loader')
  }
}
</code></pre>
<p>你完成了。</p>
<h3 id="sassscss"><a class="header" href="#sassscss">SASS/SCSS</a></h3>
<p>所以你希望能够编写SASS/SCSS形式的CSS代码。 你需要一个装载机。 我们首先安装它。 请注意，对于这种特殊情况，您还需要安装node-sass，因为sass-loader依赖于它（作为对等依赖）。</p>
<pre><code class="language-bash">$ yarn add --dev sass-loader node-sass
</code></pre>
<p>你完成了。 对于SCSS/SASS来说，这一切都是需要的。 你不需要进一步配置<code>/quasar.conf.js</code>。</p>
<p>安装完成后，您可以在<code>*.vue</code>组件中使用此预处理器(通过在<code>&lt;style&gt;</code>标签中使用lang属性)：</p>
<pre><code class="language-html">&lt;style lang=&quot;scss&quot;&gt;
/* We can write SASS now! */
&lt;/style&gt;
</code></pre>
<p>关于SASS语法的说明：</p>
<ul>
<li>lang=&quot;scss&quot;对应于CSS超集语法（带花括号和分号）。</li>
<li>lang=&quot;sass&quot;对应于基于缩进的语法。</li>
</ul>
<h3 id="postcss"><a class="header" href="#postcss">PostCSS</a></h3>
<p><code>*.vue</code>文件（以及所有其他样式文件）中的样式默认通过PostCSS传送，因此您不需要使用特定的装载器。</p>
<p>默认情况下，PostCSS配置为使用Autoprefixer。看看`/.postcssrc.js’，你可以在那里调整它，如果你需要的话</p>
<h3 id="pug"><a class="header" href="#pug">Pug</a></h3>
<p>首先，您需要安装一些依赖项：</p>
<pre><code class="language-bash">$ yarn add --dev pug pug-plain-loader
</code></pre>
<p>然后，您需要通过quasar.conf.js扩展webpack配置：</p>
<pre><code class="language-js">// quasar.conf.js
build: {
  extendWebpack (cfg) {
    cfg.module.rules.push({
      test: /\.pug$/,
      loader: 'pug-plain-loader'
    })
  }
}
</code></pre>
<p>与chainWebpack()等效:</p>
<pre><code class="language-js">// quasar.conf.js
build: {
  chainWebpack (chain) {
    chain.module.rule('pug')
      .test(/\.pug$/)
      .use('pug-plain-loader')
        .loader('pug-plain-loader')
  }
}
</code></pre>
<h3 id="coffeescript"><a class="header" href="#coffeescript">Coffeescript</a></h3>
<p>如果您使用Coffeescript，则需要禁用ESLint或告诉ESLint哪些Vue组件正在使用Coffeescript。</p>
<p>请注意<code>vue-loader</code>使用<code>lang='coffee'</code>来标识使用Coffeescript的组件，但是<code>lang='coffee'</code>不能识别ESLint。幸运的是，ESLint（遵循传统的HTML）使用<code>type=“xxx”</code>来标识脚本的类型。只要<code>&lt;script&gt;</code>标签有<code>javascript</code>之外的<code>type</code>，ESLint就会将该脚本标记为非javascript，并跳过它。 Coffeescript的约定是使用<code>type=“text/coffeescript”</code>来标识自己。因此，在使用Coffeescript的Vue组件中，同时使用<code>lang</code>和<code>type</code>来避免ESLint警告：</p>
<pre><code class="language-html">&lt;template&gt;
  ...
&lt;/template&gt;
&lt;script lang=&quot;coffee&quot; type=&quot;text/coffeescript&quot;&gt;
  ...
&lt;/script&gt;
</code></pre>
<h2 id="processenv处理"><a class="header" href="#processenv处理">process.env处理</a></h2>
<p>访问<code>process.env</code>可以在很多方面为您提供帮助：</p>
<ul>
<li>根据Quasar模式 (SPA/PWA/Cordova/Electron)区分运行时程序</li>
<li>根据运行开发或生产构建，区分运行时程序</li>
<li>在构建时根据终端环境变量向其添加标志</li>
</ul>
<h3 id="quasar-cli提供的值"><a class="header" href="#quasar-cli提供的值">Quasar CLI提供的值</a></h3>
<table><thead><tr><th style="text-align: left">名称</th><th style="text-align: left">输入</th><th style="text-align: left">意义</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>process.env.DEV</code></td><td style="text-align: left">布尔</td><td style="text-align: left">在开发模式下运行的代码</td></tr>
<tr><td style="text-align: left"><code>process.env.PROD</code></td><td style="text-align: left">布尔</td><td style="text-align: left">在生产模式下运行的代码</td></tr>
<tr><td style="text-align: left"><code>process.env.CLIENT</code></td><td style="text-align: left">布尔</td><td style="text-align: left">在客户端上（不在服务器上）运行的代码</td></tr>
<tr><td style="text-align: left"><code>process.env.SERVER</code></td><td style="text-align: left">布尔</td><td style="text-align: left">在服务器上（不在客户端上）运行的代码</td></tr>
<tr><td style="text-align: left"><code>process.env.MODE</code></td><td style="text-align: left">字符串</td><td style="text-align: left">Quasar CLI 模式 (<code>spa</code>、 <code>pwa</code>、 …)</td></tr>
<tr><td style="text-align: left"><code>process.env.NODE_ENV</code></td><td style="text-align: left">字符串</td><td style="text-align: left">有两个可能的值：<code>production</code>或<code>development</code></td></tr>
</tbody></table>
<h3 id="例子"><a class="header" href="#例子">例子</a></h3>
<pre><code class="language-js">if (process.env.DEV) {
  console.log(`I'm on a development build`)
}

// process.env.MODE is the &lt;mode&gt; in
// &quot;quasar dev/build -m &lt;mode&gt;&quot;
// (defaults to 'spa' if -m parameter is not specified)
if (process.env.MODE === 'electron') {
  const { remote } = require('electron')
  const win = remote.BrowserWindow.getFocusedWindow()

  if (win.isMaximized()) {
    win.unmaximize()
  }
  else {
    win.maximize()
  }
}
</code></pre>
<h3 id="剥离代码"><a class="header" href="#剥离代码">剥离代码</a></h3>
<p>在编译您的网站/应用程序时，会根据process.env评估<code>if()</code>分支，如果表达式为“false”，则会将其从文件中删除。 例：</p>
<pre><code class="language-js">if (process.env.DEV) {
  console.log('dev')
}
else {
  console.log('build')
}

// running with &quot;quasar dev&quot; will result in:
console.log('dev')
// while running with &quot;quasar build&quot; will result in:
console.log('build')
</code></pre>
<p>请注意上面的<code>if</code>在编译时被评估并完全剥离，导致更小的包。</p>
<h3 id="基于processenv导入"><a class="header" href="#基于processenv导入">基于process.env导入</a></h3>
<p>您可以将上面学到的内容与动态导入结合起来：</p>
<pre><code class="language-js">if (process.env.MODE === 'electron') {
  import('my-fancy-npm-package').then(package =&gt; {
    // notice &quot;default&quot; below, which is the prop with which
    // you can access what your npm imported package exports
    package.default.doSomething()
  })
}
</code></pre>
<h3 id="添加到processenv"><a class="header" href="#添加到processenv">添加到process.env</a></h3>
<p>您可以通过<code>/ quasar.conf.js</code>文件将自己的定义添加到<code>process.env</code>：</p>
<pre><code class="language-js">// quasar.conf.js

build: {
  env: ctx.dev
    ? { // so on dev we'll have
      API: JSON.stringify('https://dev.api.com')
    }
    : { // and on build (production):
      API: JSON.stringify('https://prod.api.com')
    }
}
</code></pre>
<p>然后在您的网站/应用程序中，您可以访问<code>process.env.API</code>，它将指向上面的两个链接之一，基于开发或生产构建类型。</p>
<p>你甚至可以更进一步。 提供来自<code>quasar dev/build</code>环境变量的值：</p>
<pre><code class="language-js"># we set an env variable in terminal
$ MY_API=api.com quasar build

# then we pick it up in /quasar.conf.js
build: {
  env: ctx.dev
    ? { // so on dev we'll have
      API: JSON.stringify('https://dev.'+ process.env.MY_API)
    }
    : { // and on build (production):
      API: JSON.stringify('https://prod.'+ process.env.MY_API)
    }
}
</code></pre>
<p>或者你可以使用我们的<a href="https://github.com/quasarframework/app-extension-dotenv">@quasar/dotenv</a> 或 <a href="https://github.com/quasarframework/app-extension-qenv">@quasar/qenv</a>应用扩展。</p>
<h2 id="应用vuex存储vuex-store"><a class="header" href="#应用vuex存储vuex-store">应用Vuex存储(Vuex Store)</a></h2>
<p>我们不会详细介绍如何配置或使用Vuex，因为它有很棒的文档。 相反，我们只是告诉你在Quasar项目中使用它时文件夹结构的样子。</p>
<pre><code class="language-bash">.
└── src/
    └── store/               # Vuex Store
        ├── index.js         # Vuex Store 定义
        ├── &lt;folder&gt;         # Vuex Store 模块...
        └── &lt;folder&gt;         # Vuex Store 模块...
</code></pre>
<p>默认情况下，如果您在使用Quasar CLI创建项目文件夹时选择使用Vuex，它将设置使用Vuex模块。 <code>/src/store</code>的每个子文件夹代表一个Vuex模块。</p>
<p>TIP</p>
<p>如果在您的网站应用程序中Vuex模块太多，您可以更改<code>/src/store/index.js</code>并避免导入任何模块。</p>
<h3 id="添加一个vuex模块"><a class="header" href="#添加一个vuex模块">添加一个Vuex模块</a></h3>
<p>Quasar CLI通过<code>$ quasar new</code>命令轻松添加Vuex模块。</p>
<pre><code class="language-bash">$ quasar new store &lt;store_name&gt;
</code></pre>
<p>它会在上面的命令中创建一个名为“store_name”的<code>/src/store</code>文件夹。 它将包含您需要的所有样板。</p>
<p>假设您要创建一个“showcase”Vuex模块。 你运行<code>$ quasar new store showcase</code>。 然后您会注意到新创建的<code>/src/store/showcase</code>文件夹，其中包含以下文件：</p>
<pre><code class="language-bash">.
└── src/
    └── store/
        ├── index.js         # Vuex Store定义
        └── showcase         # &quot;showcase&quot;模块
            ├── index.js     # 将模块粘合在一起
            ├── actions.js   # actions模块
            ├── getters.js   # getters模块
            ├── mutations.js # mutations模块
            └── state.js     # state模块
</code></pre>
<p>我们已经创建了新的Vuex模块，但我们还没有通知Vuex使用它。 所以我们编辑<code>/src/store/index.js</code>并添加一个引用：</p>
<pre><code class="language-js">import Vue from 'vue'
import Vuex from 'vuex'

// 首先导入模块
import showcase from './showcase'

Vue.use(Vuex)

export default function (/* { ssrContext } */) {
  const Store = new Vuex.Store({
    modules: {
      // 然后我们引用它
      showcase
    },

    // 启用严格模式（增加开销！）
    // 仅适用于开发模式
    strict: process.env.DEV
  })

  /*
    如果我们需要一些HMR魔术，我们会处理
    下面的热点更新。 注意我们实现这个
    用“process.env.DEV”代码 - 所以这不会
    进入我们的生产版本（也不应该）。
  */

  if (process.env.DEV &amp;&amp; module.hot) {
    module.hot.accept(['./showcase'], () =&gt; {
      const newShowcase = require('./showcase').default
      Store.hotUpdate({ modules: { showcase: newShowcase } })
    })
  }

  return Store
}
</code></pre>
<p>现在我们可以在我们的Vue文件中使用这个Vuex模块。 这是一个简单的例子。假设我们配置了state的 <code>drawerState</code>属性并增加了 <code>updateDrawerState</code>变动(mutation)。</p>
<pre><code class="language-js">// src/store/showcase/mutations.js
export const updateDrawerState = (state, opened) =&gt; {
  state.drawerState = opened
}

// src/store/showcase/state.js
// 如果使用SSR，请务必使用函数返回状态
export default function () {
  return {
    drawerState: true
  }
}
</code></pre>
<p>在Vue文件中</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;q-toggle v-model=&quot;drawerState&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  computed: {
    drawerState: {
      get () {
        return this.$store.state.showcase.drawerState
      },
      set (val) {
        this.$store.commit('showcase/updateDrawerState', val)
      }
    }
  }
}
&lt;/script&gt;
</code></pre>
<h3 id="存储代码拆分"><a class="header" href="#存储代码拆分">存储代码拆分</a></h3>
<p>您可以利用<a href="http://www.quasarchs.com/quasar-cli/cli-documentation/prefetch-feature#Store-Code-Splitting">预取功能</a>来对Vuex模块进行代码拆分。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vue原型注入"><a class="header" href="#vue原型注入">Vue原型注入</a></h1>
<p>Quasar用<code>$q</code>对象注入Vue原型：</p>
<table><thead><tr><th style="text-align: left">注入</th><th style="text-align: left">类型</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>$q.version</code></td><td style="text-align: left">字符串</td><td style="text-align: left">quasar版本。</td></tr>
<tr><td style="text-align: left"><code>$q.platform</code></td><td style="text-align: left">对象</td><td style="text-align: left">从Quasar导入与<a href="http://www.quasarchs.com/options/platform-detection">平台</a>相同的对象。</td></tr>
<tr><td style="text-align: left"><code>$q.screen</code></td><td style="text-align: left">对象</td><td style="text-align: left"><a href="http://www.quasarchs.com/options/screen-plugin">屏幕插件</a>提供的对象。</td></tr>
<tr><td style="text-align: left"><code>$q.lang</code></td><td style="text-align: left">对象</td><td style="text-align: left">Quasar语言包管理，包含标签等（<a href="https://github.com/quasarframework/quasar/tree/dev/ui/lang">语言文件</a>之一）。 专为Quasar组件设计，但您也可以在您的应用组件中使用。更多信息: <a href="http://www.quasarchs.com/options/quasar-language-packs">Quasar语言包</a>.</td></tr>
<tr><td style="text-align: left"><code>$q.iconSet</code></td><td style="text-align: left">Object</td><td style="text-align: left">Quasar图标集管理 (<a href="https://github.com/quasarframework/quasar/tree/dev/ui/icon-set">图标集文件</a>之一). 专为Quasar组件设计，但您也可以在您的应用组件中使用。更多信息: <a href="http://www.quasarchs.com/options/quasar-icon-sets">Quasar图标集</a>.</td></tr>
<tr><td style="text-align: left"><code>$q.cordova</code></td><td style="text-align: left">对象</td><td style="text-align: left">引用Cordova全局对象。 只有在Cordova应用程序下运行时才可用。</td></tr>
<tr><td style="text-align: left"><code>$q.capacitor</code></td><td style="text-align: left">对象</td><td style="text-align: left">(@quasar/app v1.2+) 引用Capacitor全局对象。 只有在Capacitor应用程序下运行时才可用。</td></tr>
<tr><td style="text-align: left"><code>$q.electron</code></td><td style="text-align: left">对象</td><td style="text-align: left">参考Electron全局对象。 仅在Electron应用程序下运行和<strong>如果<a href="http://www.quasarchs.com/quasar-cli/developing-electron-apps/node-integration">Node集成</a>未关闭</strong>时才可用。</td></tr>
</tbody></table>
<h2 id="例子-1"><a class="header" href="#例子-1">例子</a></h2>
<p>判断是否是IOS</p>
<pre><code class="language-vue">&lt;!-- 在Vue模板中 --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;div v-if=&quot;$q.platform.is.ios&quot;&gt;
      Gets rendered only on iOS platform.
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// 在export以外不可用

export default {
  // 在一个Vue组件脚本中
  ...,

  // 显示一个方法的例子，但是
  // 可以是Vue脚本的任何部分
  methods: {
    show () {
      // 打印出Quasar版本
      console.log(this.$q.version)
    }
  }
}
&lt;/script&gt;
</code></pre>
<h1 id="应用图标-1"><a class="header" href="#应用图标-1">应用图标</a></h1>
<h2 id="icon-genie"><a class="header" href="#icon-genie">Icon Genie</a></h2>
<p>查看<a href="https://github.com/quasarframework/app-extension-icon-genie/blob/dev/README.md">Icon Genie存储库</a>，了解有关工作原理的详细信息，或者深入了解并如<a href="http://www.quasarchs.com/app-extensions/introduction">任何应用扩展</a>一样在你的项目安装它：</p>
<pre><code class="language-bash">$ quasar ext add @quasar/icon-genie
</code></pre>
<p>它会要求您告诉它在哪里可以找到源图像（1240x1240）以及您要使用的缩小策略。 然后当你运行<code>$ quasar dev</code>时 - 它会生成正确的图标并将它们放在适合你的所有位置，无论你使用什么样的<code>--mode</code>; 如果您只是在本地提供HMR服务或使用<code>build</code>生成最终资产。</p>
<h2 id="尚未使用quasar-cli"><a class="header" href="#尚未使用quasar-cli">尚未使用Quasar CLI</a></h2>
<p>您必须转换、调整大小、命名和放置文件(无论它们在哪里)，并且取决于您构建应用（可在任何地方）的方式。</p>
<p>对于这种情况下的开发人员，我们提供了一个选项，您可以全局安装Icon Genie作为npm模块，并使用它来生成您需要的图标：</p>
<pre><code class="language-bash">$ npm install --global @quasar/app-extension-icon-genie
$ icongenie -p=kitchensink -s=icon-1280x1280.png -t=./outputFolder -m=pngquant
</code></pre>
<p>有关此类用法的完整详细信息，请访问app-extension存储库。</p>
<h1 id="quasar框架的seo"><a class="header" href="#quasar框架的seo">Quasar框架的SEO</a></h1>
<h2 id="quasar-meta插件"><a class="header" href="#quasar-meta插件">Quasar Meta插件</a></h2>
<p><a href="http://www.quasarchs.com/quasar-plugins/meta">Quasar Meta插件</a> 可以动态更改页面标题、管理<code>&lt;meta&gt;</code>标签、管理<code>&lt;html&gt;</code>和<code>&lt;body&gt;</code>DOM元素属性、添加/删除/更改文档头部的<code>&lt;style&gt;</code>和<code>&lt;script&gt;</code>标签（例如用于CDN样式表或json-ld标记）或管理<code>&lt;noscript&gt;</code>标签。</p>
<p>使用<strong>Quasar CLI</strong>，特别是<strong>用于SSR（服务器端渲染）构建</strong>时，充分利用此功能。 将它用于SPA（单页应用程序）是没有意义的，因为在这种情况下，元信息将在运行时添加，而不是由Web服务器直接提供（如在SSR构建中）。</p>
<blockquote>
<p>这个Quasar插件与Quasar的集成最紧密，因此它具有与任何其他类似解决方案相比的最佳性能。</p>
</blockquote>
<h1 id="quasar语言包"><a class="header" href="#quasar语言包">Quasar语言包</a></h1>
<p>Quasar语言包作用于Quasar自己组件的国际化，其中一些组件具有标签。</p>
<blockquote>
<p>应该注意，下面描述的仅是Quasar组件的国际化。 如果您需要国际化自己的组件，请阅读<a href="http://www.quasarchs.com/options/app-internationalization">应用国际化</a> 文档页面。</p>
</blockquote>
<h2 id="配置默认语言包"><a class="header" href="#配置默认语言包">配置默认语言包</a></h2>
<p>除非另有配置（见下文），否则Quasar默认使用<code>en-us</code>语言包。</p>
<h3 id="硬编码默认语言包"><a class="header" href="#硬编码默认语言包">硬编码默认语言包</a></h3>
<p>如果未动态确定默认的Quasar语言包（例如，不依赖于cookie），则可以：</p>
<h4 id="quasar-cli"><a class="header" href="#quasar-cli">Quasar CLI</a></h4>
<p>编辑<code>/quasar.conf.js</code>:</p>
<pre><code class="language-js">framework: {
  lang: 'de'
}
</code></pre>
<h4 id="vue-cli"><a class="header" href="#vue-cli">Vue CLI</a></h4>
<p>编辑你的<code>main.js</code>:</p>
<pre><code class="language-js">import langDe from 'quasar/lang/de'
// ...

// when not selecting to import all Quasar components:
import { Quasar } from 'quasar'
// OTHERWISE:
import Quasar from 'quasar'

// ...
Vue.use(Quasar, {
  // ...,
  lang: langDe
})
</code></pre>
<h4 id="quasar-umd"><a class="header" href="#quasar-umd">Quasar UMD</a></h4>
<p>包含你的Quasar版本的语言包JS标签，并告诉Quasar使用它。 例：</p>
<pre><code class="language-html">&lt;!-- 在Quasar JS之后包含这个标签 --&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/quasar@v1.0.0/dist/lang/de.umd.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  Quasar.lang.set(Quasar.lang.de)
&lt;/script&gt;
</code></pre>
<h3 id="动态选择默认语言"><a class="header" href="#动态选择默认语言">动态选择默认语言</a></h3>
<p>Quasar CLI：如果必须动态选择所需的Quasar语言包（例如：依赖于cookie），则需要创建一个启动文件：<code>$ quasar new boot quasar-lang-pack</code>。 这将创建``/src/boot/quasar-lang-pack.js` 文件。 编辑为：</p>
<pre><code class="language-js">// for when you don't specify quasar.conf.js &gt; framework: 'all'
import { Quasar } from 'quasar'
// OTHERWISE:
import Quasar from 'quasar'

export default async () =&gt; {
  const langIso = 'de' // ... some logic to determine it (use Cookies Plugin?)

  try {
    await import(
      /* webpackInclude: /(de|en-us)\.js$/ */
      `quasar/lang/${langIso}`
      )
      .then(lang =&gt; {
        Quasar.lang.set(lang.default)
      })
  }
  catch (err) {
    // Requested Quasar Language Pack does not exist,
    // let's not break the app, so catching error
  }
}
</code></pre>
<p>然后将此启动文件注册到<code>/quasar.conf.js</code>：</p>
<pre><code class="language-js">boot: [
  'quasar-lang-pack'
]
</code></pre>
<h2 id="在运行时更改quasar语言包"><a class="header" href="#在运行时更改quasar语言包">在运行时更改Quasar语言包</a></h2>
<p>使用QSelect动态更改Quasar组件语言的示例：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;q-select
    v-model=&quot;lang&quot;
    :options=&quot;langOptions&quot;
    label=&quot;Quasar Language&quot;
    dense
    borderless
    emit-value
    map-options
    options-dense
    style=&quot;min-width: 150px&quot;
  /&gt;
&lt;/template&gt;

&lt;script&gt;
import languages from 'quasar/lang/index.json'
const appLanguages = languages.filter(lang =&gt;
  [ 'de', 'en-us' ].includes(lang.isoName)
)

export default {
  data () {
    return {
      lang: this.$q.lang.isoName
    }
  },

  watch: {
    lang (lang) {
      // dynamic import, so loading on demand only
      import(
        /* webpackInclude: /(de|en-us)\.js$/ */
        `quasar/lang/${lang}`
        ).then(lang =&gt; {
        this.$q.lang.set(lang.default)
      })
    }
  },

  created () {
    this.langOptions = appLanguages.map(lang =&gt; ({
      label: lang.nativeName, value: lang.isoName
    }))
  }
}
&lt;/script&gt;
</code></pre>
<h2 id="在app-space中使用quasar语言包"><a class="header" href="#在app-space中使用quasar语言包">在App Space中使用Quasar语言包</a></h2>
<p>虽然Quasar语言包<strong>仅适用于Quasar组件内部使用</strong>，但您仍可以将其标签用于您自己的网站/应用程序组件。</p>
<pre><code class="language-html">当前Quasar语言包中的“Close”标签是：
{{ $q.lang.label.close }}
</code></pre>
<p>查看[GitHub]（https://github.com/quasarframework/quasar/tree/dev/ui/lang）上的Quasar语言包，查看<code>$q.lang</code>的结构。</p>
<h2 id="检测区域设置"><a class="header" href="#检测区域设置">检测区域设置</a></h2>
<p>还有一种Quasar提供的开箱即用的方法可以确定用户区域设置：</p>
<pre><code class="language-js">// outside of a Vue file

// for when you don't specify quasar.conf.js &gt; framework: 'all'
import { Quasar } from 'quasar'
// OTHERWISE:
import Quasar from 'quasar'

Quasar.lang.getLocale() // returns a string

// inside of a Vue file
this.$q.lang.getLocale() // returns a string
</code></pre>
<h1 id="应用国际化-i18n"><a class="header" href="#应用国际化-i18n"><a href="http://www.quasarchs.com/options/app-internationalization#Introduction">应用国际化 (I18n)</a></a></h1>
<p>国际化是一个设计过程，可确保产品（网站或应用程序）可适应各种语言和地区，而无需对源代码进行工程更改。将国际化视为本土化的准备。</p>
<h1 id="rtl支持"><a class="header" href="#rtl支持"><a href="http://www.quasarchs.com/options/rtl-support#Introduction">RTL</a>支持</a></h1>
<p>RTL指的是需要“从右到左”展示的语言的UI。</p>
<h1 id="安装图标库"><a class="header" href="#安装图标库"><a href="http://www.quasarchs.com/options/installing-icon-libraries#Introduction">安装图标库</a></a></h1>
<p><strong>此页面仅指使用<a href="http://www.quasarchs.com/vue-components/icon#Webfont-icons">webfont图标</a>。</strong> SVG图标不需要任何安装步骤。</p>
<p>您很可能想要在您的网站/应用中使用图标，而Quasar提供了一个开箱即用的简单方法，用于以下图标库： <a href="https://material.io/icons/">Material Icons</a> 、 <a href="http://fontawesome.io/icons/">Font Awesome</a>、 <a href="http://ionicons.com/">Ionicons</a>, <a href="https://materialdesignicons.com/">MDI</a>、 <a href="https://akveo.github.io/eva-icons">Eva Icons</a> 和 <a href="https://themify.me/themify-icons">Themify Icons</a>。</p>
<p>TIP</p>
<p>关于webfont图标，您可以选择安装一个或多个这些图标库。</p>
<h1 id="quasar图标集"><a class="header" href="#quasar图标集"><a href="http://www.quasarchs.com/options/quasar-icon-sets#Introduction">Quasar</a>图标集</a></h1>
<p>Quasar组件有自己的图标。 Quasar并不强迫您特别使用一个图标库（以便它们可以正确显示），而允许您选择<strong>应该用于其组件的图标</strong>。 这被称为“Quasar图标集”。</p>
<p>您可以安装多个图标库，但必须只选择一个用于Quasar组件的图标库。</p>
<p>Quasar当前支持: <a href="https://material.io/icons/">Material Icons</a>、 <a href="http://fontawesome.io/icons/">Font Awesome</a>、 <a href="http://ionicons.com/">Ionicons</a>、 <a href="https://materialdesignicons.com/">MDI</a>、 <a href="https://akveo.github.io/eva-icons">Eva Icons</a>和<a href="https://themify.me/themify-icons">Themify Icons</a>。</p>
<p>也可以将自己的图标（作为自定义svg或任何格式的图像）与任何Quasar组件一起使用，有关更多信息，请参见<a href="http://www.quasarchs.com/vue-components/icon#Image-icons">QIcon</a>页面。</p>
<p>TIP</p>
<p>相关页面： <a href="http://www.quasarchs.com/options/installing-icon-libraries">安装图标库</a> and <a href="http://www.quasarchs.com/vue-components/icon">QIcon组件</a>.</p>
<h1 id="平台检测"><a class="header" href="#平台检测"><a href="http://www.quasarchs.com/options/platform-detection#Introduction">平台检测</a></a></h1>
<p>辅助程序内置于Quasar中，用于在运行代码的上下文中检测平台（及其功能）。</p>
<p>TIP</p>
<p>根据您的需要，您可能还需要查看<a href="http://www.quasarchs.com/style/visibility">风格&amp;特性 &gt; 可见性</a> 页面以了解如何仅使用CSS来实现相同的效果。后一种方法将渲染您的DOM元素或组件，而不管平台如何，所以基于应用程序的性能做出明智的选择 。</p>
<h2 id="用法-1"><a class="header" href="#用法-1">用法</a></h2>
<p>Vue组件JS中的用法：</p>
<pre><code class="language-js">this.$q.platform.is.mobile
</code></pre>
<p>Vue组件模板中的用法：</p>
<pre><code class="language-js">$q.platform.is.cordova
</code></pre>
<p>在Vue组件之外使用它时必须导入它：</p>
<pre><code class="language-js">import { Platform } from 'quasar'
</code></pre>
<p><code>Platform.is</code>本身返回一个包含当前平台详细信息的对象。 例如，在MacOS桌面计算机上运行Chrome时，<code>Platform.is</code>会返回类似以下信息：</p>
<pre><code class="language-js">{
  chrome: true,
  desktop: true,
  mac: true,
  name: &quot;chrome&quot;,
  platform: &quot;mac&quot;,
  version: &quot;70.0.3538.110&quot;,
  versionNumber: 70,
  webkit: true
}
</code></pre>
<p>现在，假设我们想要根据代码运行的平台呈现不同的组件或DOM元素。 我们想在桌面上展示一些东西，在移动设备上展示其他东西，我们会这样做：</p>
<pre><code class="language-html">&lt;div v-if=&quot;$q.platform.is.desktop&quot;&gt;
  I'm only rendered on desktop!
&lt;/div&gt;

&lt;div v-if=&quot;$q.platform.is.mobile&quot;&gt;
  I'm only rendered on mobile!
&lt;/div&gt;

&lt;div v-if=&quot;$q.platform.is.electron&quot;&gt;
  I'm only rendered on Electron!
&lt;/div&gt;
</code></pre>
<h2 id="属性-2"><a class="header" href="#属性-2">属性</a></h2>
<p>Platform对象可以使用以下属性。 尽管如此，这并不是一个详尽的清单。 有关详细信息，请参阅下面的API部分。</p>
<table><thead><tr><th style="text-align: left">属性</th><th style="text-align: left">类型</th><th style="text-align: left">含义</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>Platform.is.mobile</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在移动设备上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.cordova</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在Cordova内运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.capacitor</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否与Capacitor一起运行？ （需要@quasar/app v1.2 +）</td></tr>
<tr><td style="text-align: left"><code>Platform.is.electron</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在Electron内运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.desktop</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在桌面浏览器上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.bex</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在浏览器扩展中运行？ （需要@quasar/app v1.2 +）</td></tr>
<tr><td style="text-align: left"><code>Platform.is.android</code></td><td style="text-align: left">布尔</td><td style="text-align: left">应用是否在Android设备上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.blackberry</code></td><td style="text-align: left">布尔</td><td style="text-align: left">应用是否在Blackberry设备上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.cros</code></td><td style="text-align: left">布尔</td><td style="text-align: left">应用是否在具有Chrome OS操作系统的设备上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.ios</code></td><td style="text-align: left">布尔</td><td style="text-align: left">应用是否在iOS设备上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.ipad</code></td><td style="text-align: left">布尔</td><td style="text-align: left">应用是否在iPad上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.iphone</code></td><td style="text-align: left">布尔</td><td style="text-align: left">应用是否在iPhone上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.ipod</code></td><td style="text-align: left">布尔</td><td style="text-align: left">应用是否在iPod上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.kindle</code></td><td style="text-align: left">布尔</td><td style="text-align: left">应用是否在Kindle设备上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.linux</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在具有Linux操作系统的设备上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.mac</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在具有MacOS操作系统的设备上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.win</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在具有Windows操作系统的设备上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.winphone</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在Windows Phone设备上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.playbook</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在Blackberry Playbook设备上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.silk</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在Kindle Silk浏览器中运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.chrome</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在Google Chrome浏览器中运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.opera</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在Opera Phone浏览器中运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.safari</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在Apple Safari浏览器中运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.edge</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在Microsoft Edge浏览器中运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.is.ie</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在Microsoft Internet Explorer浏览器中运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.has.touch</code></td><td style="text-align: left">布尔</td><td style="text-align: left">代码是否在支持触摸的屏幕上运行？</td></tr>
<tr><td style="text-align: left"><code>Platform.within.iframe</code></td><td style="text-align: left">布尔</td><td style="text-align: left">该应用是否在IFRAME内运行？</td></tr>
</tbody></table>
<h1 id="屏幕插件"><a class="header" href="#屏幕插件"><a href="http://www.quasarchs.com/options/screen-plugin#Introduction">屏幕插件</a></a></h1>
<p>Quasar屏幕插件允许您在处理Javascript代码时拥有动态且响应迅速的UI。 如果可能，出于性能原因，建议使用<a href="http://www.quasarchs.com/style/visibility#Window-Width-Related">响应式CSS类</a> 。</p>
<h2 id="安装-6"><a class="header" href="#安装-6">安装</a></h2>
<p>你不需要做任何事情。屏幕插件会自动安装。</p>
<h2 id="用法-2"><a class="header" href="#用法-2">用法</a></h2>
<p>请注意下面的<code>$q.screen</code>。 这只是一个简单的用法示例。</p>
<pre><code class="language-html">&lt;q-list :dense=&quot;$q.screen.lt.md&quot;&gt;
  &lt;q-item&gt;
    &lt;q-item-section&gt;John Doe&lt;/q-item-section&gt;
  &lt;/q-item&gt;

  &lt;q-item&gt;
    &lt;q-item-section&gt;Jane Doe&lt;/q-item-section&gt;
  &lt;/q-item&gt;
&lt;/q-list&gt;
// Vue组件的脚本部分
export default {
  computed: {
    buttonColor () {
      return this.$q.screen.lt.md
        ? 'primary'
        : 'secondary'
    }
  }
}
</code></pre>
<p>我们也可以在Vue组件之外使用屏幕插件：</p>
<pre><code class="language-js">import { Screen } from 'quasar'

// Screen.gt.md
// Screen.md
// Screen.name ('xs', 'sm', ...; Quasar v1.5.2+)
</code></pre>
<h1 id="动画-1"><a class="header" href="#动画-1"><a href="http://www.quasarchs.com/options/animations#Introduction">动画</a></a></h1>
<p>CSS过渡可以由<a href="https://vuejs.org/v2/guide/transitions.html">Vue过渡组件</a>处理。 过渡效果用于展示输入（出现）或离开（消失）动画。</p>
<p>但是，Quasar可以提供大量即用型CSS动画。 动画效果来自<a href="https://daneden.github.io/animate.css/">Animate.css</a>。 因此，目前有12个常规，32个输入（In）和32个离开（Out）动画类型可供您开箱即用。 查看Animate.css网站上的列表或此页面的展示的DEMO。</p>
<blockquote>
<p>请参阅<a href="https://vuejs.org/v2/guide/transitions.html">Vue</a>文档，了解如何使用Vue提供的<code>&lt;transition&gt;</code> 组件。</p>
</blockquote>
<h2 id="安装-7"><a class="header" href="#安装-7">安装</a></h2>
<p>编辑 <code>/quasar.conf.js</code>.</p>
<pre><code class="language-js">// embedding all animations
animations: 'all'

// or embedding only specific animations
animations: [
  'bounceInLeft',
  'bounceOutRight'
]
</code></pre>
<p>如果您正在构建一个网站，您也可以跳过配置quasar.conf.js并使用指向Animate.css的CDN链接（以下仅为示例，Google为最新链接）。 请记住，这需要为您的用户提供Internet连接，而不是从quasar.conf.js中进行捆绑。</p>
<pre><code class="language-html">&lt;!-- src/index.template.html --&gt;
&lt;head&gt;
  ...

  &lt;!-- CDN example for Animate.css --&gt;
  &lt;link
    rel=&quot;stylesheet&quot;
    href=&quot;https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css&quot;
  &gt;
&lt;/head&gt;
</code></pre>
<h2 id="用法-3"><a class="header" href="#用法-3">用法</a></h2>
<p>注意实际动画名称前面的字符串“animated”。</p>
<pre><code class="language-html">&lt;!-- Example with wrapping only one DOM element / component --&gt;
&lt;transition
  appear
  enter-active-class=&quot;animated fadeIn&quot;
  leave-active-class=&quot;animated fadeOut&quot;
&gt;
  &lt;!-- Wrapping only one DOM element, defined by QBtn --&gt;
  &lt;q-btn
    color=&quot;secondary&quot;
    icon=&quot;mail&quot;
    label=&quot;Email&quot;
  /&gt;
&lt;/transition&gt;
</code></pre>
<h3 id="包装多个元素"><a class="header" href="#包装多个元素">包装多个元素</a></h3>
<p>您还可以在过渡中对组件或DOM元素进行分组，以便同时将相同的效果应用于所有这些元素。</p>
<pre><code class="language-html">
&lt;!-- Example with wrapping multiple DOM elements / components --&gt;
&lt;transition-group
  appear
  enter-active-class=&quot;animated fadeIn&quot;
  leave-active-class=&quot;animated fadeOut&quot;
&gt;
  &lt;!-- We wrap a &quot;p&quot; tag and a QBtn --&gt;
  &lt;p key=&quot;text&quot;&gt;
     Lorem Ipsum
  &lt;/p&gt;
  &lt;q-btn
    key=&quot;email-button&quot;
    color=&quot;secondary&quot;
    icon=&quot;mail&quot;
    label=&quot;Email&quot;
  /&gt;
&lt;/transition-group&gt;
</code></pre>
<p>请注意以上示例中的一些内容：</p>
<ol>
<li>注意使用<code>&lt;transition-group&gt;</code>而不是<code>&lt;transition&gt;</code>。</li>
<li>必须键入组件和DOM元素，例如上面示例中的<code>key=&quot;text&quot;</code>或<code>key=&quot;email-button&quot;</code>。</li>
<li>上面的两个例子都指定了布尔属性<code>appear</code>，这使得在渲染组件后立即进入动画。 此属性是可选的。</li>
</ol>
<h1 id="quasar组件过渡效果"><a class="header" href="#quasar组件过渡效果"><a href="http://www.quasarchs.com/options/transitions#Introduction">Quasar组件过渡效果</a></a></h1>
<p>有一些Quasar组件通过 <code>transition-show</code>/<code>transition-hide</code> 或<code>transition-prev</code>/<code>transition-next</code>或简单的<code>transition</code>属性提到过渡。 我们将在这里展示这些过渡效果。</p>
<h1 id="全局事件总线"><a class="header" href="#全局事件总线">全局事件总线</a></h1>
<p>有时您需要一个事件总线或发布/订阅通道。 Vue已经为每个组件提供了一个事件总线。 为了方便起见，您可以使用根Vue组件通过<code>this.$root</code>来注册并监听事件。</p>
<p>WARNING</p>
<p>不要与Quasar组件支持的事件混淆。 这些是由各个组件发出的Vue事件，并且不会干扰全局事件总线。</p>
<blockquote>
<p>考虑使用<a href="https://vuex.vuejs.org/">Vuex</a>而不是事件总线。</p>
</blockquote>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>请查看Vue的 <a href="https://vuejs.org/v2/api/#Instance-Methods-Events">实例方法/事件</a>API页面。 然后让我们看看如何在应用程序的根Vue组件上注册一个事件：</p>
<pre><code class="language-js">// callback
function cb (msg) {
  console.log(msg)
}

// listen for an event
this.$root.$on('event_name', cb)

// listen once (only) for an event
this.$root.$once('event_name', cb)

// Make sure you stop listening for an event
// when your respective component gets destroyed
this.$root.$off('event_name', cb)


// Emitting an event:
this.$root.$emit('event_name', 'some message')
</code></pre>
<p>Example using event to open drawer from another component or page. Not recommended – a better way would be through <a href="https://vuex.vuejs.org/">Vuex</a>, but the example below is for educational purposes only.</p>
<p>从另一个组件或页面打开侧滑菜单的使用事件的示例。 不推荐 - 更好的方法是通过<a href="https://vuex.vuejs.org/">Vuex</a>，但下面的示例仅用于教育目的。</p>
<pre><code class="language-js">// (1) This code is inside layout file that have a drawer
//     if this.leftDrawerOpen is true, drawer is displayed

// (2) Listen for an event in created
created () {
  this.$root.$on('openLeftDrawer', this.openLeftDrawerCallback)
},

beforeDestroy () {
  // Don't forget to turn the listener off before your component is destroyed
  this.$root.$off('openLeftDrawer', this.openLeftDrawerCallback)
}

methods: {
  // (3) Define the callback in methods
  openLeftDrawerCallback () {
    this.leftDrawerOpen = !this.leftDrawerOpen
  }
}

// (4) In another component or page, emit the event!
//     Call the method when clicking button etc.
methods: {
  openLeftDrawer () {
    this.$root.$emit('openLeftDrawer')
  }
}
</code></pre>
<h3 id="用于qdialog和qmenu"><a class="header" href="#用于qdialog和qmenu">用于QDialog和QMenu</a></h3>
<p>这些组件使用Quasar Portals，从而可以在<code>&lt;body&gt;</code>标记的末尾呈现内容，以便： 1.避免css污染 2.避免z-index问题 3.避免可能的父CSS溢出 4.在iOS上正常工作</p>
<p>如果需要在这些组件中使用总线，则必须通过.js文件创建自己的全局总线：</p>
<pre><code class="language-js">import Vue from 'vue'
const bus = new Vue()
export default bus
</code></pre>
<p>然后在需要访问此总线的任何位置导入此文件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ajax栏"><a class="header" href="#ajax栏"><a href="http://www.quasarchs.com/vue-components/ajax-bar#Introduction">Ajax栏</a></a></h1>
<ul>
<li>
<p>ajax调用反馈</p>
</li>
<li>
<p>QAjaxBar组件自动捕获Ajax调用（除非被告知不这样做）。</p>
</li>
<li>
<p>手动触发</p>
<pre><code class="language-js">&lt;script&gt;
export default {
  methods: {
    // we manually trigger it (this is not needed if we
    // don't skip Ajax calls hijacking)
    trigger () {
      const bar = this.$refs.bar

      bar.start()

      this.timer = setTimeout(() =&gt; {
        if (this.$refs.bar) {
          this.$refs.bar.stop()
        }
      }, Math.random() * 3000 + 1000)
    }
  }
}
&lt;/script&gt;
</code></pre>
</li>
</ul>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;q-pa-md&quot;&gt;
    &lt;q-ajax-bar
      ref=&quot;bar&quot;
      position=&quot;bottom&quot;
      color=&quot;accent&quot;
      size=&quot;10px&quot;
      skip-hijack
    /&gt;

    &lt;q-btn color=&quot;primary&quot; label=&quot;Trigger&quot; @click=&quot;trigger&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h1 id="头像"><a class="header" href="#头像"><a href="http://www.quasarchs.com/vue-components/avatar#Introduction">头像</a></a></h1>
<p>QAvatar组件创建一个可缩放的、可着色的元素，其形状内可以包含文本、图标或图像。 默认情况下，它是圆形的，但也可以是正方形的，也可以应用边框半径为正方形提供圆角。</p>
<p>它通常与插槽中的其他组件一起使用。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;q-pa-md q-gutter-sm&quot;&gt;
    &lt;q-avatar color=&quot;red&quot; text-color=&quot;white&quot; icon=&quot;directions&quot; /&gt;
    &lt;q-avatar color=&quot;primary&quot; text-color=&quot;white&quot;&gt;J&lt;/q-avatar&gt;
    &lt;q-avatar size=&quot;100px&quot; font-size=&quot;52px&quot; color=&quot;teal&quot; text-color=&quot;white&quot; icon=&quot;directions&quot; /&gt;
    &lt;q-avatar size=&quot;24px&quot; color=&quot;orange&quot;&gt;J&lt;/q-avatar&gt;
    &lt;q-avatar&gt;
      &lt;img src=&quot;https://cdn.quasar.dev/img/avatar.png&quot;&gt;
    &lt;/q-avatar&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h1 id="标记"><a class="header" href="#标记"><a href="http://www.quasarchs.com/vue-components/badge#Introduction">标记</a></a></h1>
<p>使用QBadge组件，您可以创建一个小型标记，以添加需要突出和引起注意的信息（如上下文数据）。 与其他元素（例如用户头像）结合使用以显示大量新消息时，通常也很有用。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;q-pa-md q-gutter-md&quot;&gt;
    &lt;q-badge color=&quot;blue&quot;&gt;
      #4D96F2
    &lt;/q-badge&gt;

    &lt;q-badge color=&quot;orange&quot; text-color=&quot;black&quot; label=&quot;2&quot; /&gt;

    &lt;q-badge color=&quot;purple&quot;&gt;
      &lt;q-icon name=&quot;bluetooth&quot; color=&quot;white&quot; /&gt;
    &lt;/q-badge&gt;

    &lt;q-badge color=&quot;red&quot;&gt;
      12 &lt;q-icon name=&quot;warning&quot; color=&quot;white&quot; class=&quot;q-ml-xs&quot; /&gt;
    &lt;/q-badge&gt;

    &lt;div class=&quot;text-h6&quot;&gt;
      Badge &lt;q-badge color=&quot;primary&quot;&gt;v1.0.0+&lt;/q-badge&gt;
    &lt;/div&gt;

    &lt;div&gt;
      Feature &lt;q-badge color=&quot;primary&quot;&gt;v1.0.0+&lt;/q-badge&gt;
    &lt;/div&gt;

    &lt;q-item clickable v-ripple class=&quot;bg-grey-2&quot;&gt;
      &lt;q-item-section avatar&gt;
        &lt;q-avatar rounded&gt;
          &lt;img src=&quot;https://cdn.quasar.dev/img/chaosmonkey.png&quot;&gt;
        &lt;/q-avatar&gt;
      &lt;/q-item-section&gt;

      &lt;q-item-section&gt;
        &lt;q-item-label&gt;
          Ganglia
        &lt;/q-item-label&gt;
        &lt;q-item-label caption&gt;
          &lt;q-badge color=&quot;yellow-6&quot; text-color=&quot;black&quot;&gt;
            3
            &lt;q-icon
              name=&quot;warning&quot;
              size=&quot;14px&quot;
              class=&quot;q-ml-xs&quot;
            /&gt;
          &lt;/q-badge&gt;
        &lt;/q-item-label&gt;
      &lt;/q-item-section&gt;

      &lt;q-item-section side&gt;
        &lt;span&gt;2 min ago&lt;/span&gt;
      &lt;/q-item-section&gt;
    &lt;/q-item&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h1 id="横幅"><a class="header" href="#横幅"><a href="http://www.quasarchs.com/vue-components/banner#Introduction">横幅</a></a></h1>
<p>QBanner组件创建横幅元素以显示突出的消息和相关的可选操作。</p>
<p>根据Material Design规范，横幅应“显示在屏幕顶部，顶部应用栏下方”-但是您当然可以在任何有意义的地方放置一个横幅，即使在QDialog中也可以。</p>
<h1 id="栏"><a class="header" href="#栏"><a href="http://www.quasarchs.com/vue-components/bar#Introduction">栏</a></a></h1>
<pre><code class="language-html"> &lt;q-bar&gt;
      &lt;q-btn dense flat :icon=&quot;fabApple&quot; /&gt;
      &lt;div class=&quot;text-weight-bold&quot;&gt;
        App
      &lt;/div&gt;
      &lt;div class=&quot;cursor-pointer gt-md&quot;&gt;File&lt;/div&gt;
      &lt;div class=&quot;cursor-pointer gt-md&quot;&gt;Edit&lt;/div&gt;
      &lt;div class=&quot;cursor-pointer gt-md&quot;&gt;View&lt;/div&gt;
      &lt;div class=&quot;cursor-pointer gt-md&quot;&gt;Window&lt;/div&gt;
      &lt;div class=&quot;cursor-pointer gt-md&quot;&gt;Help&lt;/div&gt;
      &lt;q-space /&gt;
      &lt;q-btn dense flat icon=&quot;airplay&quot; class=&quot;gt-xs&quot; /&gt;
      &lt;q-btn dense flat icon=&quot;battery_charging_full&quot; /&gt;
      &lt;q-btn dense flat icon=&quot;wifi&quot; /&gt;
      &lt;div&gt;9:41&lt;/div&gt;
      &lt;q-btn dense flat icon=&quot;search&quot; /&gt;
      &lt;q-btn dense flat icon=&quot;list&quot; /&gt;
    &lt;/q-bar&gt;
</code></pre>
<h1 id="面包屑"><a class="header" href="#面包屑"><a href="http://www.quasarchs.com/vue-components/breadcrumbs#Introduction">面包屑</a></a></h1>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;q-pa-md q-gutter-sm&quot;&gt;
    &lt;q-breadcrumbs&gt;
      &lt;q-breadcrumbs-el label=&quot;Home&quot; /&gt;
      &lt;q-breadcrumbs-el label=&quot;Components&quot; /&gt;
      &lt;q-breadcrumbs-el label=&quot;Breadcrumbs&quot; /&gt;
    &lt;/q-breadcrumbs&gt;

    &lt;q-breadcrumbs&gt;
      &lt;q-breadcrumbs-el label=&quot;Home&quot; icon=&quot;home&quot; /&gt;
      &lt;q-breadcrumbs-el label=&quot;Components&quot; icon=&quot;widgets&quot; /&gt;
      &lt;q-breadcrumbs-el label=&quot;Breadcrumbs&quot; /&gt;
    &lt;/q-breadcrumbs&gt;

    &lt;q-breadcrumbs class=&quot;text-grey&quot;&gt;
      &lt;q-breadcrumbs-el icon=&quot;home&quot; /&gt;
      &lt;q-breadcrumbs-el icon=&quot;widgets&quot; /&gt;
      &lt;q-breadcrumbs-el icon=&quot;navigation&quot; /&gt;
    &lt;/q-breadcrumbs&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h1 id="按钮-1"><a class="header" href="#按钮-1">按钮</a></h1>
<p>图标</p>
<p>按钮形状</p>
<p>大小</p>
<p>内容对齐</p>
<p>进度</p>
<p>波纹</p>
<p>路由链接</p>
<p>tooltip</p>
<p>禁用</p>
<h1 id="按钮组-1"><a class="header" href="#按钮组-1"><a href="http://www.quasarchs.com/vue-components/button-group#Introduction">按钮组</a></a></h1>
<p>您可以使用QBtnGroup方便地将<a href="http://www.quasarchs.com/vue-components/button">QBtn</a>和<a href="http://www.quasarchs.com/vue-components/button-dropdown">QBtnDropdown</a>分组。 确保查阅那些组件的相应页面以查看其属性和方法。</p>
<h1 id="按钮下拉"><a class="header" href="#按钮下拉"><a href="http://www.quasarchs.com/vue-components/button-dropdown#Introduction">按钮下拉</a></a></h1>
<h1 id="卡片"><a class="header" href="#卡片"><a href="http://www.quasarchs.com/vue-components/card#Introduction">卡片</a></a></h1>
<p>QCard组件是显示重要分组内容的好方法。 这种模式正在迅速成为应用、网站预览和电子邮件内容的核心设计模式。 它通过包含和组织信息来帮助观看者，同时还设置可预测的期望。</p>
<p>卡片具有一次可显示的大量内容，而屏幕尺寸通常很少，因此，卡片已迅速成为许多公司（包括Google和Twitter之类）的首选设计模式。</p>
<p>QCard组件特意是轻巧的，并且实质上是一个包含元素，该元素能够“容纳”任何其他合适的组件。</p>
<ul>
<li>
<p>qcard</p>
</li>
<li>
<p>qcard-selection</p>
</li>
<li>
<p>qcard-actions</p>
</li>
<li>
<p>对齐</p>
</li>
<li>
<p>可以放置多媒体</p>
</li>
<li>
<pre><code>      &lt;q-parallax
        src=&quot;https://cdn.quasar.dev/img/parallax1.jpg&quot;
        :height=&quot;150&quot;
      /&gt;平行
      
</code></pre>
</li>
<li>
<p>水平布局垂直布局</p>
</li>
<li>
<p>可展开的</p>
</li>
</ul>
<h1 id="转盘"><a class="header" href="#转盘">转盘</a></h1>
<p>跑马灯</p>
<ul>
<li>
<p>q-carousel</p>
</li>
<li>
<p>q-carousel-slide</p>
</li>
<li></li>
</ul>
<h1 id="聊天消息"><a class="header" href="#聊天消息">聊天消息</a></h1>
<ul>
<li>q-chat-message</li>
</ul>
<pre><code class="language-html">&lt;q-chat-message
        :text=&quot;['hey, how are you?']&quot;
        sent
      /&gt;
      &lt;q-chat-message
        :text=&quot;['doing fine, how r you?']&quot;
      /&gt;
</code></pre>
<h1 id="碎片"><a class="header" href="#碎片">碎片</a></h1>
<p>QChip组件基本上是一个简单的UI块实体，以紧凑的方式表示例如更高级的基础数据，就像联系人。</p>
<p>碎片可以包含诸如头像，文本或图标之类的实体，还可以选择具有指针。 如果进行了配置，它们也可以关闭或移除。</p>
<pre><code class="language-html"> &lt;div&gt;
      &lt;q-chip icon=&quot;event&quot;&gt;Add to calendar&lt;/q-chip&gt;
      &lt;q-chip icon=&quot;bookmark&quot;&gt;Bookmark&lt;/q-chip&gt;
      &lt;q-chip icon=&quot;alarm&quot; label=&quot;Set alarm&quot; /&gt;
      &lt;q-chip class=&quot;glossy&quot; icon=&quot;directions&quot;&gt;Get directions&lt;/q-chip&gt;
    &lt;/div&gt;
</code></pre>
<h1 id="循环进度"><a class="header" href="#循环进度"><a href="http://www.quasarchs.com/vue-components/circular-progress#Introduction">循环进度</a></a></h1>
<p>QCircularProgress</p>
<h1 id="选色器"><a class="header" href="#选色器">选色器</a></h1>
<pre><code class="language-html"> &lt;div class=&quot;q-pa-md row items-start q-gutter-md&quot;&gt;
    &lt;q-color v-model=&quot;hex&quot; class=&quot;my-picker&quot; /&gt;
    &lt;q-color v-model=&quot;hexa&quot; class=&quot;my-picker&quot; /&gt;
    &lt;q-color v-model=&quot;rgb&quot; class=&quot;my-picker&quot; /&gt;
    &lt;q-color v-model=&quot;rgba&quot; class=&quot;my-picker&quot; /&gt;
  &lt;/div&gt;
</code></pre>
<h1 id="对话框"><a class="header" href="#对话框">对话框</a></h1>
<p>q-dialog</p>
<h1 id="编辑器"><a class="header" href="#编辑器">编辑器</a></h1>
<p>QEditor</p>
<h1 id="表单组件"><a class="header" href="#表单组件">表单组件</a></h1>
<ul>
<li>
<p>q-input</p>
</li>
<li>
<p>q-select</p>
</li>
<li>
<p>q-form</p>
</li>
<li>
<p>QField(包裹器)</p>
</li>
<li>
<p>q-radio</p>
<pre><code> &lt;div class=&quot;q-gutter-sm&quot;&gt;
      &lt;q-radio v-model=&quot;shape&quot; val=&quot;line&quot; label=&quot;Line&quot; /&gt;
      &lt;q-radio v-model=&quot;shape&quot; val=&quot;rectangle&quot; label=&quot;Rectangle&quot; /&gt;
      &lt;q-radio v-model=&quot;shape&quot; val=&quot;ellipse&quot; label=&quot;Ellipse&quot; /&gt;
      &lt;q-radio v-model=&quot;shape&quot; val=&quot;polygon&quot; label=&quot;Polygon&quot; /&gt;
    &lt;/div&gt;
</code></pre>
</li>
<li>
<p>q-option-group</p>
<pre><code> &lt;div class=&quot;q-pa-md&quot;&gt;
    &lt;q-option-group
      :options=&quot;options&quot;
      label=&quot;Notifications&quot;
      type=&quot;radio&quot;
      v-model=&quot;group&quot;
    /&gt;
  &lt;/div&gt;
</code></pre>
</li>
<li>
<p>checkbox</p>
</li>
<li>
<p>QToggle</p>
</li>
<li>
<p>QBtnToggle</p>
</li>
<li>
<p>q-option-group</p>
</li>
<li>
<p>q-slider</p>
</li>
<li>
<p>q-range</p>
</li>
<li>
<p>q-time</p>
</li>
<li>
<p>q-date</p>
</li>
</ul>
<h1 id="图标-2"><a class="header" href="#图标-2"><a href="http://www.quasarchs.com/vue-components/icon#Introduction">图标</a></a></h1>
<h1 id="图像"><a class="header" href="#图像"><a href="http://www.quasarchs.com/vue-components/img#Introduction">图像</a></a></h1>
<p>qimage</p>
<h1 id="无线滚动"><a class="header" href="#无线滚动">无线滚动</a></h1>
<p>q-infinite-scroll </p>
<h1 id="内部加载"><a class="header" href="#内部加载">内部加载</a></h1>
<p>QInnerLoading组件允许您在组件内添加进度动画。 与<a href="http://www.quasarchs.com/quasar-plugins/loading">加载插件</a>非常相似，其目的是向用户提供视觉确认，表明某些进程正在后台进行，这会花费大量时间。 QInnerLoading将在延迟的元素以及<a href="http://www.quasarchs.com/vue-components/spinners">旋转器</a>上添加一个不透明的覆盖层。</p>
<h1 id="交叉"><a class="header" href="#交叉"><a href="http://www.quasarchs.com/vue-components/intersection#Introduction">交叉</a></a></h1>
<p>QIntersection组件本质上是<a href="http://www.quasarchs.com/vue-directives/intersection">Intersection指令</a>的封装，它的附加好处是它可以单独处理状态（不需要您手动添加状态），并且可以有显示/隐藏过渡效果。</p>
<p>但是，使用QIntersection的主要好处是，DOM树释放了隐藏的节点，因此使用了尽可能少的RAM内存，并使页面感觉非常活泼。</p>
<p>在幕后，它使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">Intersection Observer API</a>。</p>
<h1 id="旋钮"><a class="header" href="#旋钮"><a href="http://www.quasarchs.com/vue-components/knob#Introduction">旋钮</a></a></h1>
<p>QKnob</p>
<h1 id="线性进度"><a class="header" href="#线性进度"><a href="http://www.quasarchs.com/vue-components/linear-progress#Introduction">线性进度</a></a></h1>
<p>QLinearProgress</p>
<h1 id="列表和选项"><a class="header" href="#列表和选项"><a href="http://www.quasarchs.com/vue-components/list-and-list-items#Introduction">列表和选项</a></a></h1>
<p>'QList',      'QItem',      'QItemSection',      'QItemLabel'</p>
<h1 id="标记表"><a class="header" href="#标记表"><a href="http://www.quasarchs.com/vue-components/markup-table#Introduction">标记表</a></a></h1>
<p>使用QMarkupTable可以简单地包裹原生的<code>&lt;table&gt;</code>以使其看起来像Material Design表。</p>
<h1 id="菜单"><a class="header" href="#菜单"><a href="http://www.quasarchs.com/vue-components/menu#Introduction">菜单</a></a></h1>
<p>QMenu的想法是将其放置在您希望成为触发器的DOM元素/组件中, 作为直接子元素。 不必担心QMenu内容会从容器继承CSS，因为QMenu将通过Quasar Portal作为<code>&lt;body&gt;</code>的直接子元素注入。</p>
<blockquote>
<p>如果您希望菜单自动关闭，请不要忘记在可单击的菜单项中使用指令<code>v-close-popup</code>。 另外，您可以使用QMenu的属性<code>auto-close</code>，也可以通过其v-model自行处理关闭菜单的操作。</p>
</blockquote>
<h1 id="大小调整侦听器-对于元素"><a class="header" href="#大小调整侦听器-对于元素">大小调整侦听器 (对于元素)</a></h1>
<p>QResizeObserver</p>
<h1 id="滚动侦听器"><a class="header" href="#滚动侦听器"><a href="http://www.quasarchs.com/vue-components/scroll-observer#Introduction">滚动侦听器</a></a></h1>
<p>QScrollObserver</p>
<h1 id="分页"><a class="header" href="#分页">分页</a></h1>
<p>QPagination</p>
<h1 id="视差"><a class="header" href="#视差">视差</a></h1>
<p>QParallax</p>
<h1 id="弹出编辑"><a class="header" href="#弹出编辑"><a href="http://www.quasarchs.com/vue-components/popup-edit#Introduction">弹出编辑</a></a></h1>
<p>QPopupEdit</p>
<h1 id="弹出代理"><a class="header" href="#弹出代理"><a href="http://www.quasarchs.com/vue-components/popup-proxy#Introduction">弹出代理</a></a></h1>
<h1 id="拉动刷新"><a class="header" href="#拉动刷新"><a href="http://www.quasarchs.com/vue-components/pull-to-refresh#Introduction">拉动刷新</a></a></h1>
<h1 id="评分"><a class="header" href="#评分"><a href="http://www.quasarchs.com/vue-components/rating#Introduction">评分</a></a></h1>
<h1 id="滚动区域"><a class="header" href="#滚动区域">滚动区域</a></h1>
<h1 id="骨架skeleton"><a class="header" href="#骨架skeleton">骨架(Skeleton)</a></h1>
<h1 id="滑动项"><a class="header" href="#滑动项">滑动项</a></h1>
<p>QSlideItem</p>
<h1 id="滑动过度"><a class="header" href="#滑动过度">滑动过度</a></h1>
<pre><code class="language-html">   &lt;q-slide-transition&gt;
      &lt;div v-show=&quot;visible&quot;&gt;
        &lt;img
          class=&quot;responsive&quot;
          src=&quot;https://cdn.quasar.dev/img/quasar.jpg&quot;
        &gt;
      &lt;/div&gt;
    &lt;/q-slide-transition&gt;
</code></pre>
<h1 id="间距填充"><a class="header" href="#间距填充">间距填充</a></h1>
<p>q-space</p>
<h1 id="旋转器"><a class="header" href="#旋转器">旋转器</a></h1>
<p>QSpinner</p>
<h1 id="分割条"><a class="header" href="#分割条">分割条</a></h1>
<p>QSplitter</p>
<h1 id="步骤"><a class="header" href="#步骤">步骤</a></h1>
<p>QStep</p>
<h1 id="表格"><a class="header" href="#表格">表格</a></h1>
<p>QTable是允许您以表格方式显示数据的组件。 通常称为数据表。 它包含以下主要功能：</p>
<ul>
<li>过滤</li>
<li>排序</li>
<li>具有自定义选择操作的单行/多行选择</li>
<li>分页（如果需要，包括服务器端）</li>
<li>网格模式（例如，您可以使用QCard以非表格方式显示数据）</li>
<li>通过有限范围的插槽，对行和单元格进行全面定制</li>
<li>能够在数据行的顶部或底部添加额外的行</li>
<li>列选取器（通过本页其中一节中描述的QTableColumns组件）</li>
<li>自定义顶部或底部表格控件</li>
<li>响应式设计</li>
</ul>
<h1 id="选项卡面板"><a class="header" href="#选项卡面板">选项卡面板</a></h1>
<p>'QTabPanels',      'QTabPanel'</p>
<h1 id="时间线"><a class="header" href="#时间线">时间线</a></h1>
<p>​     'QTimeline',      'QTimelineEntry'</p>
<h1 id="提示"><a class="header" href="#提示">提示</a></h1>
<p>QTooltip</p>
<h1 id="树"><a class="header" href="#树">树</a></h1>
<p>QTree</p>
<h1 id="上传器"><a class="header" href="#上传器">上传器</a></h1>
<p>QUploader</p>
<h1 id="视频"><a class="header" href="#视频">视频</a></h1>
<p>QVideo</p>
<h1 id="虚拟滚动"><a class="header" href="#虚拟滚动">虚拟滚动</a></h1>
<p>QVirtualScroll</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="布局-1"><a class="header" href="#布局-1">布局</a></h1>
<p>QLayout是一个组件，用于管理整个窗口并使用导航栏或侧滑菜单等元素包装页面内容。 多个页面可以共享同一个QLayout，因此代码是可重用的，这是它们的关键点之一。</p>
<p><strong>QLayout不是强制性的</strong>，但它确实可以帮助您更好地构建网站/应用程序。 它具有许多开箱即用的功能，可为您带来简化网站/应用布局设计的极大好处。</p>
<h2 id="layout的views属性"><a class="header" href="#layout的views属性">layout的views属性</a></h2>
<p>为了解释它是如何工作的，假设您的布局是一个3x3的容器矩阵（下面以蓝色表示）。 容器的第一行是页眉，最后一行是页脚。 容器的第一列为“左”，最后一列为“右”。 矩阵的中心在页眉下方和页脚上方，将是页面或主要内容容器。</p>
<p>容器矩阵或“QLayout View”可以由您应该提供给QLayout的<code>view</code>属性的字符串表示。 该字符串必须恰好包含11个字符：</p>
<ul>
<li>3个字符定义页眉行</li>
<li>然后一个空格</li>
<li>3个字符定义中间行</li>
<li>一个空格</li>
<li>然后3个字符定义页脚行</li>
</ul>
<p>默认情况下，QLayout管理整个窗口。 但是，您也可以将QLayout用作容器（具有特定的高度和宽度），以将其隔离在页面中的某个位置。</p>
<h2 id="使用布局和页面进行路由"><a class="header" href="#使用布局和页面进行路由">使用布局和页面进行路由</a></h2>
<p><strong>创建文件</strong></p>
<pre><code class="language-bash">quasar new layout User
quasar new page Profile Posts
</code></pre>
<h2 id="布局页眉和页脚"><a class="header" href="#布局页眉和页脚">布局页眉和页脚</a></h2>
<p>由于页眉和页脚需要布局，并且默认情况下QLayout管理整个窗口</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;q-pa-md&quot;&gt;
    &lt;q-layout view=&quot;lHh lpr lFf&quot; container style=&quot;height: 400px&quot; class=&quot;shadow-2 rounded-borders&quot;&gt;
      &lt;q-header elevated&gt;
        &lt;q-toolbar&gt;
          &lt;q-btn flat round dense icon=&quot;menu&quot; class=&quot;q-mr-sm&quot; /&gt;
          &lt;q-avatar&gt;
            &lt;img src=&quot;https://cdn.quasar.dev/logo/svg/quasar-logo.svg&quot;&gt;
          &lt;/q-avatar&gt;

          &lt;q-toolbar-title&gt;Quasar Framework&lt;/q-toolbar-title&gt;

          &lt;q-btn flat round dense icon=&quot;whatshot&quot; /&gt;
        &lt;/q-toolbar&gt;
      &lt;/q-header&gt;

      &lt;q-footer elevated&gt;
        &lt;q-toolbar&gt;
          &lt;q-toolbar-title&gt;Footer&lt;/q-toolbar-title&gt;
        &lt;/q-toolbar&gt;
      &lt;/q-footer&gt;

      &lt;q-page-container&gt;
        &lt;q-page class=&quot;q-pa-md&quot;&gt;
          &lt;p v-for=&quot;n in 15&quot; :key=&quot;n&quot;&gt;
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Fugit nihil praesentium molestias a adipisci, dolore vitae odit, quidem consequatur optio voluptates asperiores pariatur eos numquam rerum delectus commodi perferendis voluptate?
          &lt;/p&gt;
        &lt;/q-page&gt;
      &lt;/q-page-container&gt;
    &lt;/q-layout&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p><strong>详见</strong>  <a href="http://www.quasarchs.com/layout/header-and-footer#qheader-api">q-footer and q-header API</a></p>
<h2 id="侧滑菜单"><a class="header" href="#侧滑菜单"><a href="http://www.quasarchs.com/layout/drawer#Introduction">侧滑菜单</a></a></h2>
<p>QDrawer是QLayout的侧边栏部分。</p>
<h2 id="布局页面"><a class="header" href="#布局页面"><a href="http://www.quasarchs.com/layout/page#Introduction">布局页面</a></a></h2>
<p>QPage必须由QPageContainer封装，而QPageContainer又必须是QLayout的子节点。</p>
<pre><code class="language-html"> &lt;q-page-container&gt;
    &lt;q-page&gt;
      &lt;!-- 页面内容 --&gt;
    &lt;/q-page&gt;
  &lt;/q-page-container&gt;
</code></pre>
<h2 id="页面粘性"><a class="header" href="#页面粘性"><a href="http://www.quasarchs.com/layout/page-sticky#Introduction">页面粘性</a></a></h2>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;q-pa-md&quot;&gt;
    &lt;q-layout view=&quot;lHh Lpr lFf&quot; container style=&quot;height: 400px&quot; class=&quot;shadow-2 rounded-borders&quot;&gt;
      &lt;q-header reveal elevated&gt;
        &lt;q-toolbar&gt;
          &lt;q-btn flat round dense icon=&quot;menu&quot; @click=&quot;drawerLeft = !drawerLeft&quot; /&gt;

          &lt;q-toolbar-title&gt;
            &lt;strong&gt;Quasar&lt;/strong&gt; Framework
          &lt;/q-toolbar-title&gt;

          &lt;q-btn flat round dense icon=&quot;menu&quot; @click=&quot;drawerRight = !drawerRight&quot; /&gt;
        &lt;/q-toolbar&gt;
      &lt;/q-header&gt;

      &lt;q-footer reveal elevated&gt;
        &lt;q-toolbar&gt;
          &lt;q-btn flat round dense icon=&quot;menu&quot; @click=&quot;drawerLeft = !drawerLeft&quot; /&gt;

          &lt;q-toolbar-title&gt;
            &lt;strong&gt;Quasar&lt;/strong&gt; Framework
          &lt;/q-toolbar-title&gt;

          &lt;q-btn flat round dense icon=&quot;menu&quot; @click=&quot;drawerRight = !drawerRight&quot; /&gt;
        &lt;/q-toolbar&gt;
      &lt;/q-footer&gt;

      &lt;q-drawer
        v-model=&quot;drawerLeft&quot;
        :width=&quot;150&quot;
        :breakpoint=&quot;700&quot;
        behavior=&quot;desktop&quot;
        bordered
        content-class=&quot;bg-grey-3&quot;
      &gt;
        &lt;q-scroll-area class=&quot;fit&quot;&gt;
          &lt;div class=&quot;q-pa-sm&quot;&gt;
            &lt;div v-for=&quot;n in 50&quot; :key=&quot;n&quot;&gt;Drawer {{ n }} / 50&lt;/div&gt;
          &lt;/div&gt;
        &lt;/q-scroll-area&gt;
      &lt;/q-drawer&gt;

      &lt;q-drawer
        side=&quot;right&quot;
        v-model=&quot;drawerRight&quot;
        bordered
        :width=&quot;150&quot;
        :breakpoint=&quot;500&quot;
        behavior=&quot;desktop&quot;
        content-class=&quot;bg-grey-3&quot;
      &gt;
        &lt;q-scroll-area class=&quot;fit&quot;&gt;
          &lt;div class=&quot;q-pa-sm&quot;&gt;
            &lt;div v-for=&quot;n in 50&quot; :key=&quot;n&quot;&gt;Drawer {{ n }} / 50&lt;/div&gt;
          &lt;/div&gt;
        &lt;/q-scroll-area&gt;
      &lt;/q-drawer&gt;

      &lt;q-page-container&gt;
        &lt;q-page padding&gt;
          &lt;p v-for=&quot;n in 15&quot; :key=&quot;n&quot;&gt;
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Fugit nihil praesentium molestias a adipisci, dolore vitae odit, quidem consequatur optio voluptates asperiores pariatur eos numquam rerum delectus commodi perferendis voluptate?
          &lt;/p&gt;

          &lt;!-- place QPageSticky at end of page --&gt;
          &lt;q-page-sticky position=&quot;top-left&quot; :offset=&quot;[18, 18]&quot;&gt;
            &lt;q-btn round color=&quot;accent&quot; icon=&quot;arrow_back&quot; class=&quot;rotate-45&quot; /&gt;
          &lt;/q-page-sticky&gt;
          &lt;q-page-sticky position=&quot;top&quot; :offset=&quot;[0, 18]&quot;&gt;
            &lt;q-btn round color=&quot;accent&quot; icon=&quot;arrow_back&quot; class=&quot;rotate-90&quot; /&gt;
          &lt;/q-page-sticky&gt;
          &lt;q-page-sticky position=&quot;top-right&quot; :offset=&quot;[18, 18]&quot;&gt;
            &lt;q-btn round color=&quot;accent&quot; icon=&quot;arrow_upward&quot; class=&quot;rotate-45&quot; /&gt;
          &lt;/q-page-sticky&gt;
          &lt;q-page-sticky position=&quot;right&quot; :offset=&quot;[18, 0]&quot;&gt;
            &lt;q-btn round color=&quot;accent&quot; icon=&quot;arrow_upward&quot; class=&quot;rotate-90&quot; /&gt;
          &lt;/q-page-sticky&gt;
          &lt;q-page-sticky position=&quot;left&quot; :offset=&quot;[18, 0]&quot;&gt;
            &lt;q-btn round color=&quot;accent&quot; icon=&quot;arrow_back&quot; /&gt;
          &lt;/q-page-sticky&gt;
          &lt;q-page-sticky position=&quot;bottom-left&quot; :offset=&quot;[18, 18]&quot;&gt;
            &lt;q-btn round color=&quot;accent&quot; icon=&quot;arrow_forward&quot; class=&quot;rotate-135&quot; /&gt;
          &lt;/q-page-sticky&gt;
          &lt;q-page-sticky position=&quot;bottom&quot; :offset=&quot;[0, 18]&quot;&gt;
            &lt;q-btn round color=&quot;accent&quot; icon=&quot;arrow_forward&quot; class=&quot;rotate-90&quot; /&gt;
          &lt;/q-page-sticky&gt;
          &lt;q-page-sticky position=&quot;bottom-right&quot; :offset=&quot;[18, 18]&quot;&gt;
            &lt;q-btn round color=&quot;accent&quot; icon=&quot;arrow_forward&quot; class=&quot;rotate-45&quot; /&gt;
          &lt;/q-page-sticky&gt;
        &lt;/q-page&gt;
      &lt;/q-page-container&gt;
    &lt;/q-layout&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h2 id="页面滚动条"><a class="header" href="#页面滚动条"><a href="http://www.quasarchs.com/layout/page-scroller#Introduction">页面滚动条</a></a></h2>
<ul>
<li>为了使QPageScroller起作用，必须将其放置在QLayout组件内。</li>
<li>QPageScroller必须是其父级中的最后一个子元素，以便它可以显示在其他内容的顶部</li>
</ul>
<h2 id="浮动操作按钮"><a class="header" href="#浮动操作按钮">浮动操作按钮</a></h2>
<h3 id="不可展开"><a class="header" href="#不可展开">不可展开</a></h3>
<pre><code class="language-html">  &lt;q-page-container&gt;
        &lt;q-page padding&gt;
          &lt;p v-for=&quot;n in 15&quot; :key=&quot;n&quot;&gt;
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Fugit nihil praesentium molestias a adipisci, dolore vitae odit, quidem consequatur optio voluptates asperiores pariatur eos numquam rerum delectus commodi perferendis voluptate?
          &lt;/p&gt;

          &lt;q-page-sticky position=&quot;bottom-right&quot; :offset=&quot;[18, 18]&quot;&gt;
            &lt;q-btn fab icon=&quot;add&quot; color=&quot;accent&quot; /&gt;
          &lt;/q-page-sticky&gt;
        &lt;/q-page&gt;
      &lt;/q-page-container&gt;
</code></pre>
<h3 id="可展开的"><a class="header" href="#可展开的">可展开的</a></h3>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;q-px-sm q-py-lg&quot;&gt;
    &lt;div class=&quot;column items-center&quot; style=&quot;margin-top: 100px; margin-bottom: 100px;&quot;&gt;
      &lt;q-fab color=&quot;purple&quot; icon=&quot;keyboard_arrow_up&quot; direction=&quot;up&quot;&gt;
        &lt;q-fab-action color=&quot;primary&quot; @click=&quot;onClick&quot; icon=&quot;mail&quot; /&gt;
        &lt;q-fab-action color=&quot;secondary&quot; @click=&quot;onClick&quot; icon=&quot;alarm&quot; /&gt;
      &lt;/q-fab&gt;

      &lt;br&gt;

      &lt;q-fab color=&quot;amber&quot; text-color=&quot;black&quot; icon=&quot;keyboard_arrow_left&quot; direction=&quot;left&quot;&gt;
        &lt;q-fab-action color=&quot;amber&quot; text-color=&quot;black&quot; @click=&quot;onClick&quot; icon=&quot;mail&quot; /&gt;
        &lt;q-fab-action color=&quot;amber&quot; text-color=&quot;black&quot; @click=&quot;onClick&quot; icon=&quot;alarm&quot; /&gt;
      &lt;/q-fab&gt;

      &lt;br&gt;

      &lt;q-fab color=&quot;secondary&quot; push icon=&quot;keyboard_arrow_right&quot; direction=&quot;right&quot;&gt;
        &lt;q-fab-action color=&quot;primary&quot; @click=&quot;onClick&quot; icon=&quot;mail&quot; /&gt;
        &lt;q-fab-action color=&quot;accent&quot; @click=&quot;onClick&quot; icon=&quot;alarm&quot; /&gt;
      &lt;/q-fab&gt;

      &lt;br&gt;

      &lt;q-fab color=&quot;accent&quot; glossy icon=&quot;keyboard_arrow_down&quot; direction=&quot;down&quot;&gt;
        &lt;q-fab-action color=&quot;amber&quot; text-color=&quot;black&quot; @click=&quot;onClick&quot; icon=&quot;mail&quot; /&gt;
        &lt;q-fab-action color=&quot;amber&quot; text-color=&quot;black&quot; @click=&quot;onClick&quot; icon=&quot;alarm&quot; /&gt;
      &lt;/q-fab&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h1 id="布局实例"><a class="header" href="#布局实例">布局实例</a></h1>
<p><a href="http://www.quasarchs.com/layout/gallery#Introduction">布局展示</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flexbox介绍"><a class="header" href="#flexbox介绍">Flexbox介绍</a></h1>
<p>Flexbox（Quasar Flex CSS类所基于的基础）模块旨在提供一种更有效的方式来布置、对齐和分配容器中各个项目之间的空间，即使它们的大小未知和/或动态（“flex”一词也是如此）“）。</p>
<h2 id="关键概念"><a class="header" href="#关键概念">关键概念</a></h2>
<p>Quasar Flex CSS类适用于容器（Container, 父元素）或容器项（item, 子元素）。</p>
<h2 id="管理父元素"><a class="header" href="#管理父元素">管理父元素</a></h2>
<h3 id="设置方向"><a class="header" href="#设置方向">设置方向</a></h3>
<p>以下CSS类之一对于父元素是强制性的，以使子级上的CSS类（在下一节中描述）起作用。</p>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>row</code></td><td style="text-align: left">Flex行</td></tr>
<tr><td style="text-align: left"><code>row inline</code></td><td style="text-align: left">内联Flex行</td></tr>
<tr><td style="text-align: left"><code>column</code></td><td style="text-align: left">Flex列</td></tr>
<tr><td style="text-align: left"><code>column inline</code></td><td style="text-align: left">内联Flex列</td></tr>
<tr><td style="text-align: left"><code>row reverse</code></td><td style="text-align: left">将<code>flex-direction</code>设置为<code>row-reverse</code>的Flex行</td></tr>
<tr><td style="text-align: left"><code>column reverse</code></td><td style="text-align: left">将<code>flex-direction</code>设置为<code>column-reverse</code>的Flex列</td></tr>
</tbody></table>
<h3 id="换行"><a class="header" href="#换行">换行</a></h3>
<p>默认情况下，所有行和列都包裹其内容。</p>
<p><img src="https://cdn.quasar.dev/img/flexbox-wrap.svg" alt="img" /></p>
<p>但是，如果您明确不想包裹，即您想将所有内容合并到一行中，那么添加<code>no-wrap</code> CSS辅助类。</p>
<p>另外，如果你想以相反的顺序换行，那么<code>reverse-wrap</code>就是可用的。</p>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>wrap</code></td><td style="text-align: left">如有必要进行包裹（默认为“on”，不需要指定）</td></tr>
<tr><td style="text-align: left"><code>no-wrap</code></td><td style="text-align: left">即使有必要，也不要包裹</td></tr>
<tr><td style="text-align: left"><code>reverse-wrap</code></td><td style="text-align: left">如有必要逆向包裹</td></tr>
</tbody></table>
<h3 id="对齐-1"><a class="header" href="#对齐-1">对齐</a></h3>
<p><strong>要沿主轴</strong>对齐，请使用以下类。 当一条线上的所有弹性元素都不灵活或灵活但达到其最大尺寸时，它有助于分配剩余的可用空间。 当元素溢出时，它也对元素的排列起到一定的控制作用。</p>
<p><img src="https://cdn.quasar.dev/img/flexbox-main-axis-align---2.svg" alt="img" /></p>
<p><strong>对于垂直于主轴</strong>的对齐，使用下面的类。 这定义了flex元素沿当前行的横轴进行放置的默认行为。 将其视为横轴（垂直于主轴）的水平版本。</p>
<p><img src="https://cdn.quasar.dev/img/flexbox-cross-axis-align.svg" alt="img" /></p>
<p>接下来的类在横轴上有额外的空间时<strong>对齐flex容器的线</strong>，类似于水平对齐主轴内的单个元素的方式。</p>
<p><img src="https://cdn.quasar.dev/img/flexbox-content-align.svg" alt="img" /></p>
<h2 id="管理子元素"><a class="header" href="#管理子元素">管理子元素</a></h2>
<h3 id="大小分布"><a class="header" href="#大小分布">大小分布</a></h3>
<p>Quasar使用一个12分的列系统来分配子行的大小。 以下是可用的CSS辅助类的一些示例：</p>
<pre><code class="language-html">&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-8&quot;&gt;two thirds&lt;/div&gt;
  &lt;div class=&quot;col-2&quot;&gt;one sixth&lt;/div&gt;
  &lt;div class=&quot;col-auto&quot;&gt;auto size based on content and available space&lt;/div&gt;
  &lt;div class=&quot;col&quot;&gt;fills remaining available space&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>在上面的例子中，由于8/12 = 2/3 = 66％，col-8占据了行宽的三分之二（2/3），而col-2占据了六分之一（2/12 = 1 / 6〜16.67％）。</p>
<p>CSS辅助类<code>col-auto</code>使单元格只填充需要渲染的空间。 另一方面，<code>col</code>试图填充所有可用的空间，同时如果需要也可以缩小。</p>
<p>CSS辅助类<code>col-grow</code>使单元格至少填充需要渲染的空间，并有可能在有更多空间可用时增长。</p>
<p>CSS辅助类<code>col-shrink</code>使单元格最多填充需要呈现的空间，并且当没有足够的可用空间时有可能收缩。</p>
<h3 id="包裹"><a class="header" href="#包裹">包裹</a></h3>
<p>包裹是理解Flex CSS类的关键特性。 你不一定每行使用12点。 您可以使用更少或更多。</p>
<p>这使得您可以在较小的屏幕上垂直动态堆叠行，并在大屏幕上的单行上显示它们。 阅读“响应式设计”部分。</p>
<pre><code class="language-html">&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-2&quot;&gt;...&lt;/div&gt;

  &lt;!-- 2 + 6 &lt; 12, 所以下一个元素放在同一行上 --&gt;
  &lt;div class=&quot;col-6&quot;&gt;...&lt;/div&gt;

  &lt;!-- 2 + 6 + 10 &gt; 12, 所以下一个元素换行到下一行 --&gt;
  &lt;div class=&quot;col-10&quot;&gt;...&lt;/div&gt;

  &lt;!--
    10 + 3 &gt; 12, 所以下一个元素换行到下一行。
     请注意，我们只考虑当前行
     （只有col-10，因为它被包裹到自己的行）。
  --&gt;
  &lt;div class=&quot;col-3&quot;&gt;...&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="自对齐"><a class="header" href="#自对齐">自对齐</a></h3>
<p><strong>子元素可以覆盖父元素上指定的对齐方式</strong>。 这允许对单个Flex项进行对齐。 请参阅“管理父元素”中的“对齐”说明以了解可用值(<code>self-start</code>, <code>self-center</code>, <code>self-baseline</code>, <code>self-end</code>, <code>self-stretch</code>)。</p>
<p><img src="https://cdn.quasar.dev/img/flexbox-self.svg" alt="img" /></p>
<h3 id="顺序"><a class="header" href="#顺序">顺序</a></h3>
<p><strong>您可以使用<code>order-first</code>和<code>order-last</code> CSS辅助类来设置子元素的顺序</strong>。</p>
<p>默认情况下，Flex项按源(source)顺序排列。 但是，order属性控制它们在flex容器中的显示顺序。 如果您需要更多粒度，请使用<code>order</code> CSS属性并分配所需的值。</p>
<p>例子：</p>
<pre><code class="language-html">&lt;div class=&quot;row&quot;&gt;
  &lt;div style=&quot;order: 2&quot;&gt;Second column&lt;/div&gt;
  &lt;div class=&quot;order-last&quot;&gt;Third column&lt;/div&gt;
  &lt;div class=&quot;order-first&quot;&gt;First column&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h2 id="响应式设计"><a class="header" href="#响应式设计">响应式设计</a></h2>
<p>Quasar Flex CSS辅助类可以根据屏幕宽度进行应用，以帮助您制作响应式用户界面。 12分网格受Bootstrap的启发，因此有很多相似之处。</p>
<p>我们到目前为止学到的是，例如，我们可以调整列的大小，而不管窗口的宽度。 如果我们要创建一个响应UI，我们需要动态改变大小，同时考虑窗口的宽度。 首先，让我们学习一些可以在<code>col-*</code>，<code>offset-*</code>和<code>col-auto</code>辅助类中注入的标记（查看下表中的标记）。</p>
<table><thead><tr><th style="text-align: left">标记</th><th style="text-align: left">最大窗口宽度</th><th style="text-align: left">描述/应用时间</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>xs</code></td><td style="text-align: left">599px</td><td style="text-align: left">特小尺寸窗口</td></tr>
<tr><td style="text-align: left"><code>sm</code></td><td style="text-align: left">1023px</td><td style="text-align: left">小尺寸窗口</td></tr>
<tr><td style="text-align: left"><code>md</code></td><td style="text-align: left">1439px</td><td style="text-align: left">中尺寸窗口</td></tr>
<tr><td style="text-align: left"><code>lg</code></td><td style="text-align: left">1919px</td><td style="text-align: left">大尺寸窗口</td></tr>
<tr><td style="text-align: left"><code>xl</code></td><td style="text-align: left">Infinite</td><td style="text-align: left">超大尺寸的窗口</td></tr>
</tbody></table>
<p>例: <code>col-md-7</code>, <code>offset-lg-3</code>, <code>col-xs-auto</code>.</p>
<p>一个完整的例子：假设我们有三个子元素的行。 在特小窗口中，我们需要垂直叠放子元素。在小窗口中我们需要并排显示它们的（每个窗口都有相同的宽度），并且从中等窗口开始，我们应该将它们全部显示在同一行上：</p>
<pre><code class="language-html">&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;
    col
  &lt;/div&gt;
  &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;
    col
  &lt;/div&gt;
  &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;
    col
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>在上面的例子中我们注意到我们使用了<code>col-xs-12</code>（12/12 = 100％的行，所以每个子元素都会占用容器的全部宽度，使得所有的子元素垂直堆叠，因为行默认是包裹内容）、<code>col-sm-6</code>（6/12 = 50％的行）和<code>col-md-4</code>（4/12 = 33％的行）。</p>
<p>像前面提到的那样，行默认包裹内容，因此当一行使用12个（或更多）网格点时，内容将被包裹到下一行。 如果我们有两个<code>&lt;div&gt;</code>并且我们都使用<code>col-8</code>，它们也会堆叠，因为8 + 8 = 16，我们只能在一行上显示12个点。</p>
<pre><code class="language-html">&lt;div class=&quot;row&quot;&gt;
  &lt;!--
     加一起超过12个网格点，
     所以第二个&lt;div&gt;将包裹到下一行
  --&gt;
  &lt;div class=&quot;col-8&quot;&gt;col&lt;/div&gt;
  &lt;div class=&quot;col-8&quot;&gt;col&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>另外查阅<a href="http://www.quasarchs.com/style/visibility#Window-Width-Related">可见性</a>风格页面查看窗口宽度和这些标记（xs、sm、md、lg、xl）的阈值以隐藏或显示DOM元素。</p>
<h2 id="flex插件addons"><a class="header" href="#flex插件addons">Flex插件(Addons)</a></h2>
<p>启用后（通过<code>quasar.conf.js &gt; framework &gt; cssAddon: true</code>），它将为所有与Flex（和显示）相关的CSS类提供断点感知版本。</p>
<p>WARNING</p>
<p>请注意，启用后，CSS占用空间将明显增加。 因此，只有在您确实需要时才这样做。</p>
<pre><code class="language-js">.flex-&lt;bp&gt;-(block|inline)
.(row|column|flex)-&lt;bp&gt;(|-inline)
.reverse-&lt;bp&gt;
.(wrap|no-wrap|reverse-wrap)-&lt;bp&gt;
.order-&lt;bp&gt;-(first|last|none)
.justify-&lt;bp&gt;-(start|end|center|between|around|evenly)
.items-&lt;bp&gt;-(start|end|center|baseline|stretch)
.content-&lt;bp&gt;-(start|end|center|between|around)
.self-&lt;bp&gt;-(start|end|center|baseline|stretch)
.flex-&lt;bp&gt;-center
.gutter-&lt;bp&gt;(|-x|-y)-(xs|sm|md|lg|xl)
.(col|offset)-&lt;bp&gt;(|0..12)
</code></pre>
<p>还有间距的响应类，包括填充(padding)和边距(margin)：</p>
<pre><code class="language-js">.q-(p|m)(t|r|b|l|a|x|y)-&lt;bp&gt;-(none|auto|xs|sm|md|lg|xl)
.q-my-&lt;bp&gt;-form
</code></pre>
<p>例: <code>row-md</code>, <code>items-lg-end</code>, <code>q-pa-xs q-pa-sm-sm q-px-md-lg q-py-md-md</code></p>
<h1 id="网格行"><a class="header" href="#网格行">网格行</a></h1>
<p>容器中的子元素项 按从左到右的顺序排列</p>
<h2 id="基本使用-1"><a class="header" href="#基本使用-1">基本使用</a></h2>
<pre><code>    &lt;div class=&quot;row&quot; style=&quot;width: 150px&quot;&gt;
      &lt;div class=&quot;col&quot;&gt;
        1 of 2
      &lt;/div&gt;
      &lt;div class=&quot;col&quot;&gt;
        1 of 2
      &lt;/div&gt;
    &lt;/div&gt;
</code></pre>
<h2 id="等宽"><a class="header" href="#等宽">等宽</a></h2>
<blockquote>
<p>col 默认是等宽分</p>
</blockquote>
<h2 id="12等分布局"><a class="header" href="#12等分布局">12等分布局</a></h2>
<p>按12等分 分配子元素宽度</p>
<h2 id="对齐-2"><a class="header" href="#对齐-2">对齐</a></h2>
<p><strong>垂直对齐</strong></p>
<ul>
<li>
<p>容器样式<code>items-start</code> <code>items-center</code> <code>items-end</code></p>
</li>
<li>
<p>子元素样式： <code>self-start</code> <code>self-center</code> <code>self-end</code></p>
</li>
</ul>
<p><strong>水平对齐</strong></p>
<ul>
<li>容器样式：<code>justify-start</code> <code>justify-center</code> <code>justify-end</code> <code>justify-around</code> <code>justify-bewteen</code> <code>justify-evenly</code></li>
</ul>
<h2 id="改变子元素的顺序"><a class="header" href="#改变子元素的顺序">改变子元素的顺序</a></h2>
<blockquote>
<p>通过 reverse,order改变子元素的排列顺序</p>
</blockquote>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;q-pa-md&quot;&gt;

    &lt;div class=&quot;row&quot;&gt;
      &lt;div class=&quot;col order-none&quot;&gt;
        First, but unordered&lt;br&gt;(.order-none)
      &lt;/div&gt;
      &lt;div class=&quot;col order-last&quot;&gt;
        Second, but last&lt;br&gt;(.order-last)
      &lt;/div&gt;
      &lt;div class=&quot;col order-first&quot;&gt;
        Third, but first&lt;br&gt;(.order-first)
      &lt;/div&gt;
    &lt;/div&gt;

  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h2 id="子元素偏移"><a class="header" href="#子元素偏移">子元素偏移</a></h2>
<p>使用<code>.offset-md-*</code>类将列向右移动。 这些类通过*列增加一列的左边距。 例如，<code>.offset-md-4</code>将<code>.col-md-4</code>移到四列上。</p>
<p>会从当前位置 移动n个 网格，超出容器宽度后 换行</p>
<h1 id="网格列"><a class="header" href="#网格列">网格列</a></h1>
<h2 id="基本使用-2"><a class="header" href="#基本使用-2">基本使用</a></h2>
<pre><code class="language-vue">  &lt;div class=&quot;column&quot; style=&quot;height: 150px&quot;&gt;
      &lt;div class=&quot;col&quot;&gt;
        1 of 2
      &lt;/div&gt;
      &lt;div class=&quot;col&quot;&gt;
        1 of 2
      &lt;/div&gt;
    &lt;/div&gt;
</code></pre>
<h2 id="等高"><a class="header" href="#等高">等高</a></h2>
<p><code>col</code> 默认在所有 给定了 <em>col</em> 类 的子元素平均分配高度</p>
<h2 id="对齐-3"><a class="header" href="#对齐-3">对齐</a></h2>
<h2 id="水平对齐"><a class="header" href="#水平对齐"><strong>水平对齐</strong></a></h2>
<p><strong>应用于容器中的样式</strong></p>
<p><code>items-start</code> <code>items-center</code></p>
<p><code>items-end</code></p>
<p><strong>应用于子元素的样式</strong></p>
<p><code>self-start</code> <code>self-center</code> <code>self-end</code></p>
<h2 id="垂直对齐"><a class="header" href="#垂直对齐">垂直对齐</a></h2>
<p><strong>元素对齐</strong></p>
<p><code>justify-start</code> <code>justify-center</code> <code>justify-end</code></p>
<p><strong>垂直方向的空白分配</strong></p>
<p><code>justify-around</code> <code>justify-bewteen</code> <code>justify-evenly</code></p>
<h1 id="网格样式"><a class="header" href="#网格样式">网格样式</a></h1>
<blockquote>
<p>对其所有子元素应用等相等的距离的</p>
</blockquote>
<h2 id="q--gutter-size"><a class="header" href="#q--gutter-size">q--gutter-{size}</a></h2>
<p><strong>原理</strong></p>
<blockquote>
<p><code>q-gutter-*</code>类对父元素应用<strong>负top左margin</strong>，对子元素应用<strong>正top左margin</strong>。 在与其他<a href="http://www.quasarchs.com/style/spacing">间距类</a>一起使用时，请考虑到这一点，以免破坏gutter的css。</p>
</blockquote>
<p><strong>使用场景</strong></p>
<p>在您想要彼此隔开的元素不使用<code>col-*</code>或<code>offset-*</code>类指定宽度时使用的</p>
<p><strong>基本使用</strong></p>
<p><code>q-gutter-xs</code> <code>q-gutter-sm</code> <code>q-gutter-md</code> <code>q-gutter-lg</code> <code>q-gutter-xl</code> </p>
<p><code>q-gutter-xs</code></p>
<p><code>q-gutter-x-md</code>（应用于X轴）</p>
<p><code>q-gutter-y-md</code> （应用于y轴）</p>
<pre><code class="language-vue">    &lt;div class=&quot;q-gutter-xs&quot;&gt;
      &lt;q-btn color=&quot;brown&quot; label=&quot;Button&quot; v-for=&quot;n in 7&quot; :key=&quot;`xs-${n}`&quot; /&gt;
    &lt;/div&gt;
</code></pre>
<h2 id="q-col-gutter-size"><a class="header" href="#q-col-gutter-size">q-col-gutter-{size}</a></h2>
<p><strong>原理</strong></p>
<blockquote>
<p><code>q-col-gutter-*</code>类对父元素应用<strong>负top左margin</strong>，对子元素应用<strong>正padding-top以及 左padding-left</strong>。 在与其他<a href="http://www.quasarchs.com/style/spacing">间距类</a>一起使用时，请考虑到这一点，以免破坏gutter的css。</p>
</blockquote>
<p><strong>使用场景</strong></p>
<p>将间隙撑大实际元素之间的距离为0</p>
<h1 id="flexbox模式"><a class="header" href="#flexbox模式">flexBox模式</a></h1>
<h2 id="分栏"><a class="header" href="#分栏">分栏</a></h2>
<h2 id="瀑布流布局模式"><a class="header" href="#瀑布流布局模式">瀑布流布局模式</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="排版typography"><a class="header" href="#排版typography">排版（Typography）</a></h1>
<p>我们将在以下各节中处理Quasar提供的排版。</p>
<h2 id="字体由大到小"><a class="header" href="#字体由大到小">字体由大到小</a></h2>
<pre><code>text-h1
text-h2
text-h3
text-h4
text-h5
text-h6
text-subtitle1
text-subtitle2
text-body1
text-body2
text-caption
text-overline
</code></pre>
<h2 id="字体粗细"><a class="header" href="#字体粗细">字体粗细</a></h2>
<pre><code>text-weight-thin
text-weight-light
text-weight-regular
text-weight-medium
text-weight-bold
text-weight-bolder
</code></pre>
<h2 id="css辅助类"><a class="header" href="#css辅助类">CSS辅助类</a></h2>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>text-right</code></td><td style="text-align: left">将文本对齐到右侧</td></tr>
<tr><td style="text-align: left"><code>text-left</code></td><td style="text-align: left">将文字对齐到左侧</td></tr>
<tr><td style="text-align: left"><code>text-center</code></td><td style="text-align: left">将文本对齐到中心</td></tr>
<tr><td style="text-align: left"><code>text-justify</code></td><td style="text-align: left">文字将是合理的</td></tr>
<tr><td style="text-align: left"><code>text-bold</code></td><td style="text-align: left">文本将以粗体显示</td></tr>
<tr><td style="text-align: left"><code>text-italic</code></td><td style="text-align: left">文本将以斜体显示</td></tr>
<tr><td style="text-align: left"><code>text-no-wrap</code></td><td style="text-align: left">非包装文本（适用于<code>white-space：nowrap</code>）</td></tr>
<tr><td style="text-align: left"><code>text-strike</code></td><td style="text-align: left">应用<code>text-decoration: line-through</code></td></tr>
<tr><td style="text-align: left"><code>text-uppercase</code></td><td style="text-align: left">将文本转换为大写</td></tr>
<tr><td style="text-align: left"><code>text-lowercase</code></td><td style="text-align: left">将文本转换为小写</td></tr>
<tr><td style="text-align: left"><code>text-capitalize</code></td><td style="text-align: left">使文本的第一个字母大写</td></tr>
</tbody></table>
<h2 id="默认字体"><a class="header" href="#默认字体">默认字体</a></h2>
<p>嵌入的默认Webfont是<a href="https://fonts.google.com/specimen/Roboto">Roboto</a>。但这不是必需的。你可以使用任何你喜欢的字体。</p>
<p>oboto带有5种不同的字体粗细，您可以使用：100,300,400,500,700。</p>
<p>这里是默认嵌入Roboto字体的配置，如果您寻求删除Roboto字体的话：</p>
<pre><code class="language-js">// 文件: /quasar.conf.js
extras: [
  'roboto-font'
]
</code></pre>
<h2 id="添加自定义字体"><a class="header" href="#添加自定义字体">添加自定义字体</a></h2>
<p>也可以包括其他字体以在应用程序中使用它们。 以下是一种实现方法：</p>
<ol>
<li>在您选择的目录中复制新的Webfont<code>[customfont].woff</code>（或其扩展名；建议使用<code>woff</code>以在所有浏览器之间兼容），例如：<code>./src/css/fonts/[customfont.woff]</code></li>
<li>在<code>./src/css/app.{css|sass|scss|styl}</code>中声明字体（或在您认为合适的任何位置，但正确更新webfont文件的相对路径）：</li>
</ol>
<pre><code class="language-css">@font-face {
  font-family: customfont;
  src: url(./fonts/customfont.woff);
}

// 声明一个应用它的类
.my-font {
  font-family: 'customfont';
}
</code></pre>
<ol>
<li>然后在需要的地方使用该类。</li>
</ol>
<h1 id="调色板color-palette"><a class="header" href="#调色板color-palette">调色板(Color Palette)</a></h1>
<p>Quasar Framework开箱即可提供多种颜色选择。 您可以在CSS代码中将它们用作Stylus变量，或者直接在HTML模板中将它们用作CSS类。</p>
<h2 id="品牌brand颜色"><a class="header" href="#品牌brand颜色">品牌(Brand)颜色</a></h2>
<p>primary</p>
<p>secondary</p>
<p>accent</p>
<p>dark</p>
<p>positive</p>
<p>negative</p>
<p>info</p>
<p>warning</p>
<h2 id="颜色列表"><a class="header" href="#颜色列表"><a href="http://www.quasarchs.com/style/color-palette#%E9%A2%9C%E8%89%B2%E5%88%97%E8%A1%A8">颜色列表</a></a></h2>
<h2 id="使用css类"><a class="header" href="#使用css类">使用CSS类</a></h2>
<p>使用<code>text-</code>或<code>bg-</code>前缀作为类名来改变文本的颜色或背景的颜色。</p>
<pre><code class="language-html">&lt;!-- 更改文字颜色 --&gt;
&lt;p class=&quot;text-primary&quot;&gt;....&lt;/p&gt;

&lt;!-- 改变背景色 --&gt;
&lt;p class=&quot;bg-positive&quot;&gt;...&lt;/p&gt;
</code></pre>
<h2 id="使用sassscssstylus变量"><a class="header" href="#使用sassscssstylus变量">使用Sass/SCSS/Stylus变量</a></h2>
<p>在应用程序的<code>*.vue</code>文件中，可以使用<code>$primary</code>，<code>$red-1</code>等颜色。请注意，对于Sass/SCSS，您将需要“@quasar/app” v1.1.0 +和Quasar v1.1.1 +。</p>
<pre><code class="language-html">&lt;!-- 注意lang=&quot;sass&quot; --&gt;
&lt;style lang=&quot;sass&quot;&gt;
div
  color: $red-1
  background-color: $grey-5
&lt;/style&gt;
&lt;!-- 注意lang=&quot;scss&quot; --&gt;
&lt;style lang=&quot;scss&quot;&gt;
div {
  color: $red-1;
  background-color: $grey-5;
}
&lt;/style&gt;
&lt;!-- 注意lang=&quot;stylus&quot; --&gt;
&lt;style lang=&quot;stylus&quot;&gt;
div
  color $red-1
  background-color $grey-5
&lt;/style&gt;
</code></pre>
<h2 id="添加自己的颜色"><a class="header" href="#添加自己的颜色">添加自己的颜色</a></h2>
<p>如果您想为自己的组件使用自己的颜色（假设我们要添加一种名为“ brand”的颜色），您要做的就是将以下CSS添加到您的应用中：</p>
<pre><code class="language-css">.text-brand {
  color: #a2aa33;
}
.bg-brand {
  background: #a2aa33;
}
</code></pre>
<p>现在我们可以将这种颜色用于Quasar组件：</p>
<pre><code class="language-html">&lt;q-btn color=&quot;brand&quot; ... /&gt;
</code></pre>
<h2 id="品牌brand颜色的动态变化动态主题颜色"><a class="header" href="#品牌brand颜色的动态变化动态主题颜色">品牌(Brand)颜色的动态变化（动态主题颜色）</a></h2>
<p>WARNING</p>
<p>这仅在<a href="https://caniuse.com/#feat=css-variables">支持CSS变量的浏览器</a>（自定义属性）上受支持。 它不会在IE11上工作，但它会恢复到CSS主题中的品牌颜色。</p>
<p>您可以在运行时动态定制品牌颜色： <code>primary</code>, <code>secondary</code>, <code>accent</code>, <code>dark</code>, <code>positive</code>, <code>negative</code>, <code>info</code>, <code>warning</code>。这意味着您可以使用默认颜色主题构建应用程序的一个构建版本，但显示时使用运行时所选的一个。</p>
<p>主要颜色配置使用存储在根元素（<code>:root</code>）中的CSS自定义属性完成。每个属性的名称都是<code>--q-color-${name}</code>（例如：<code>--q-color-primary</code>，<code>--q-color-secondary</code>），并且应该具有有效的CSS颜色作为值。</p>
<p>CSS自定义属性使用与普通CSS相同的继承规则，因此只能重新定义所需的颜色，其余的将从父元素继承。</p>
<p>推荐的工作流程是在<code>html</code>（<code>document.documentElement</code>）或<code>body</code>（<code>document.body</code>）元素上设置自定义的颜色属性。这将允许您通过删除自定义颜色来恢复为默认颜色。</p>
<p>有关CSS自定义属性（变量）的更多信息：http://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables</p>
<h3 id="辅助方法---setbrand"><a class="header" href="#辅助方法---setbrand">辅助方法 - setBrand</a></h3>
<p>在<code>colors</code>实用程序中，Quasar提供了一个辅助方法用于设置自定义颜色：<code>setBrand(colorName,colorValue[,element])</code></p>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">类型</th><th style="text-align: left">必需</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>colorName</code></td><td style="text-align: left">字符串</td><td style="text-align: left"><em>是</em></td><td style="text-align: left"><code>primary</code>, <code>secondary</code>, <code>accent</code>, <code>dark</code>, <code>positive</code>, <code>negative</code>, <code>info</code>, <code>warning</code>之一</td></tr>
<tr><td style="text-align: left"><code>colorValue</code></td><td style="text-align: left">字符串</td><td style="text-align: left"><em>是</em></td><td style="text-align: left">有效的CSS颜色值</td></tr>
<tr><td style="text-align: left"><code>element</code></td><td style="text-align: left">元素</td><td style="text-align: left">-</td><td style="text-align: left">（默认：<code>document.body</code>）设置自定义属性的元素。</td></tr>
</tbody></table>
<p>使用辅助方法设置品牌颜色的示例：</p>
<pre><code class="language-js">import { colors } from 'quasar'

colors.setBrand('light', '#DDD')
colors.setBrand('primary', '#33F')
colors.setBrand('primary', '#F33', document.getElementById('rebranded-section-id'))
</code></pre>
<blockquote>
<p>WARNING</p>
<p>辅助方法还将负责为品牌颜色（<code>positive</code>，<code>negative</code>，<code>light</code>）设置相关的自定义属性，所以这是推荐的使用方式，而不是原始的Javascript<code>setProperty（）</code>。</p>
</blockquote>
<h1 id="主题生成器"><a class="header" href="#主题生成器"><a href="http://www.quasarchs.com/style/theme-builder#Introduction">主题生成器</a></a></h1>
<h1 id="暗色模式v13"><a class="header" href="#暗色模式v13">暗色模式v1.3+</a></h1>
<p>暗色模式是一种补充模式，可用于在UI上显示大部分暗色表面。该设计减少了设备屏幕发出的光，同时保持了可读性所需的最小颜色对比度。</p>
<p>暗色模式的优点是：</p>
<ul>
<li>通过减少眼睛疲劳来增强视觉人体工程学。</li>
<li>提供夜间或黑暗环境中的舒适使用。</li>
<li>主要在设备屏幕为OLED或AMOLED的情况下节省电池电量，从而可以长时间使用设备而无需充电。</li>
</ul>
<h2 id="它能做什么"><a class="header" href="#它能做什么">它能做什么</a></h2>
<ol>
<li>它为页面设置默认的暗色背景（您可以使用<code>body.body--dark</code>选择器通过CSS轻松覆盖该背景）</li>
<li>所有具有<code>dark</code>属性的Quasar组件将自动将此属性设置为<code>true</code>。无需手动进行。</li>
</ol>
<p>自动检测通过查看<code>prefers-color-scheme: dark</code>媒体查询来进行，并且是动态的。如果您的应用程序在运行时客户端浏览器/平台切换到暗色模式，则它还将更新Quasar的暗色模式（如果暗色模式设置为<code>auto</code>）。</p>
<h2 id="如何使用它"><a class="header" href="#如何使用它">如何使用它</a></h2>
<p>您可以通过<a href="http://www.quasarchs.com/quasar-plugins/dark">暗色插件</a>在暗色模式和亮色模式（默认）之间轻松切换。</p>
<h2 id="如何设计您的应用"><a class="header" href="#如何设计您的应用">如何设计您的应用</a></h2>
<p>由于您的应用程序可以处于暗色模式，也可以不处于暗色模式，因此您可以利用带有<code>body</code>标签的CSS类轻松地设置样式：<code>body--light</code>或者<code>body--dark</code>。 <strong>也就是说，如果您想同时支持两种模式。</strong></p>
<pre><code class="language-css">.body--light {
  /* ... */
}

.body--dark {
  /* ... */
}
</code></pre>
<p>您是否要覆盖默认的暗色模式页面背景色：</p>
<pre><code class="language-css">body.body--dark {
  background: #000
}
</code></pre>
<h1 id="css间距类"><a class="header" href="#css间距类">CSS间距类</a></h1>
<p>Quasar提供了CSS类来帮助您为DOM元素或组件提供间距。 所有选项都以<code>q-</code>为前缀，然后细分为类型（T），方向（D）和大小（S）。 有关所有可能的排列，请参见下表。</p>
<h2 id="语法-1"><a class="header" href="#语法-1">语法</a></h2>
<pre><code class="language-js">q-[p|m][t|r|b|l|a|x|y]-[none|auto|xs|sm|md|lg|xl]
    T       D                   S

T - type
  - values: p (padding), m (margin)

D - direction
  - values:
      t (top), r (right), b (bottom), l (left),
      a (all), x (both left &amp; right), y (both top &amp; bottom)

S - size
  - values:
      none,
      auto (ONLY for specific margins: q-ml-*, q-mr-*, q-mx-*),
      xs (extra small),
      sm (small),
      md (medium),
      lg (large),
      xl (extra large)
</code></pre>
<h2 id="flex插件addons-1"><a class="header" href="#flex插件addons-1">Flex插件(Addons)</a></h2>
<p>启用后（通过<code>quasar.conf.js &gt; framework &gt; cssAddon: true</code>），它将为所有与间距相关的CSS类提供断点感知版本。</p>
<blockquote>
<p>请注意，启用后，CSS占用空间将明显增加。 因此，只有在您确实需要时才这样做。</p>
</blockquote>
<pre><code class="language-js">.q-(p|m)(t|r|b|l|a|x|y)-&lt;bp&gt;-(none|auto|xs|sm|md|lg|xl)
</code></pre>
<p>例子: <code>q-pa-xs-md q-pa-sm-sm q-px-md-lg q-py-md-md</code>.</p>
<h1 id="阴影"><a class="header" href="#阴影">阴影</a></h1>
<p>简单而有效的方法来添加阴影以创建深度/拔高效果。 阴影符合Material Design规范（24级深度）。</p>
<h2 id="用法-4"><a class="header" href="#用法-4">用法</a></h2>
<table><thead><tr><th style="text-align: left">CSS类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>no-shadow</code></td><td style="text-align: left">移除任何阴影</td></tr>
<tr><td style="text-align: left"><code>inset-shadow</code></td><td style="text-align: left">设置一个插入阴影</td></tr>
<tr><td style="text-align: left"><code>shadow-1</code></td><td style="text-align: left">设置1的深度</td></tr>
<tr><td style="text-align: left"><code>shadow-2</code></td><td style="text-align: left">设置2的深度</td></tr>
<tr><td style="text-align: left"><code>shadow-N</code></td><td style="text-align: left">其中<code>N</code>是1到24的整数</td></tr>
<tr><td style="text-align: left"><code>shadow-transition</code></td><td style="text-align: left">在阴影上应用CSS转换; 最好与<code>hoverable</code>类一起使用</td></tr>
</tbody></table>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;q-pa-md&quot;&gt;
    &lt;div
      class=&quot;flex inline shadow-box flex-center&quot;
      v-for=&quot;n in 24&quot; :key=&quot;n&quot;
      :class=&quot;`shadow-${n}`&quot;
    &gt;
      .shadow-{{ n }}
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>上面的阴影指向元素的底部。 如果您希望它们指向元素的顶部，请在数字前加上<code>up</code></p>
<table><thead><tr><th style="text-align: left">CSS类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>shadow-up-1</code></td><td style="text-align: left">设置1的深度</td></tr>
<tr><td style="text-align: left"><code>shadow-up-2</code></td><td style="text-align: left">设置2的深度</td></tr>
<tr><td style="text-align: left"><code>shadow-up-N</code></td><td style="text-align: left">其中<code>N</code>是1到24的整数</td></tr>
</tbody></table>
<h1 id="断点"><a class="header" href="#断点"><a href="http://www.quasarchs.com/style/breakpoints#Introduction">断点</a></a></h1>
<h1 id="body类"><a class="header" href="#body类">body类</a></h1>
<p>Quasar将一些非常有用的辅助CSS类附加到document.body，您可以利用：</p>
<table><thead><tr><th style="text-align: left">名称</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">body–dark</td><td style="text-align: left">在<a href="http://www.quasarchs.com/style/dark-mode">暗色模式</a>下</td></tr>
<tr><td style="text-align: left">body–light</td><td style="text-align: left">不在<a href="http://www.quasarchs.com/style/dark-mode">dark mode</a>下</td></tr>
<tr><td style="text-align: left">desktop</td><td style="text-align: left">当客户端在桌面设备上时</td></tr>
<tr><td style="text-align: left">mobile</td><td style="text-align: left">客户端在移动设备上时</td></tr>
<tr><td style="text-align: left">touch</td><td style="text-align: left">当客户端有触摸支持时</td></tr>
<tr><td style="text-align: left">no-touch</td><td style="text-align: left">当客户端没有触摸支持时</td></tr>
<tr><td style="text-align: left">platform-android</td><td style="text-align: left">当客户端在Android设备上时</td></tr>
<tr><td style="text-align: left">platform-ios</td><td style="text-align: left">当客户端在iOS设备上时</td></tr>
<tr><td style="text-align: left">native-mobile</td><td style="text-align: left">当客户端在一个<a href="http://www.quasarchs.com/quasar-cli/developing-cordova-apps/introduction">Cordova</a>或<a href="http://www.quasarchs.com/quasar-cli/developing-capacitor-apps/introduction">Capacitor</a>应用上时</td></tr>
<tr><td style="text-align: left">electron</td><td style="text-align: left">当客户端在一个<a href="http://www.quasarchs.com/quasar-cli/developing-electron-apps/introduction">Electron</a>应用上时</td></tr>
<tr><td style="text-align: left">bex</td><td style="text-align: left">通过浏览器扩展程序运行应用时</td></tr>
<tr><td style="text-align: left">within-iframe</td><td style="text-align: left">当应用从iframe运行时</td></tr>
<tr><td style="text-align: left"><code>screen--*</code></td><td style="text-align: left">如果<a href="http://www.quasarchs.com/options/screen-plugin#How-to-enable-body-classes">启用（仅）</a>，则告诉当前窗口断点（<code>screen--xs</code>, <code>screen--sm</code>, …, <code>screen--xl</code>）（<strong>Quasar v1.5.3+</strong>）.</td></tr>
</tbody></table>
<h1 id="css可见性"><a class="header" href="#css可见性">CSS可见性</a></h1>
<p>有一些CSS类可以用于常用功能。</p>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>disabled</code></td><td style="text-align: left">游标更改为“disable”，不透明度设置为较低值。</td></tr>
<tr><td style="text-align: left"><code>hidden</code></td><td style="text-align: left">将<code>display</code>设置为<code>none</code>。与下面的类相比 - <code>hidden</code>类意味着元素不会显示并且不会占用布局中的空间。</td></tr>
<tr><td style="text-align: left"><code>invisible</code></td><td style="text-align: left">将<code>visibility</code>设置为<code>hidden</code>。与上面的类相比，<code>invisible</code>类意味着元素不会显示，但它仍然占用布局空间。</td></tr>
<tr><td style="text-align: left"><code>transparent</code></td><td style="text-align: left">背景颜色是透明的。</td></tr>
<tr><td style="text-align: left"><code>dimmed</code></td><td style="text-align: left">在您的元素上应用深色透明覆盖层。不要使用在已经有**:after**伪元素的元素。</td></tr>
<tr><td style="text-align: left"><code>light-dimmed</code></td><td style="text-align: left">在您的元素上应用白色透明覆盖层。不要使用在已经有**:after**伪元素的元素。</td></tr>
<tr><td style="text-align: left"><code>ellipsis</code></td><td style="text-align: left">截取文本并在没有足够的可用空间时显示省略号。</td></tr>
<tr><td style="text-align: left"><code>ellipsis-2-lines</code></td><td style="text-align: left">当两行中没有足够的可用空间时，截断文本并显示省略号（仅适用于Webkit浏览器）。</td></tr>
<tr><td style="text-align: left"><code>ellipsis-3-lines</code></td><td style="text-align: left">当三行中没有足够的可用空间时，截断文本并显示省略号（仅适用于Webkit浏览器）。</td></tr>
<tr><td style="text-align: left"><code>z-top</code></td><td style="text-align: left">将元素定位在任何其他组件的顶部，但位于Popovers、提示框、通知框之后。</td></tr>
<tr><td style="text-align: left"><code>z-max</code></td><td style="text-align: left">将元素定位在任何其他组件（包括Drawer，Modals，Notifications，Layout header/footer…）之上</td></tr>
</tbody></table>
<h2 id="窗口宽度相关"><a class="header" href="#窗口宽度相关">窗口宽度相关</a></h2>
<p>首先，让我们定义断点是什么：</p>
<table><thead><tr><th style="text-align: left">窗口大小</th><th style="text-align: left">名称</th><th style="text-align: left">宽度阈值（以像素为单位）</th></tr></thead><tbody>
<tr><td style="text-align: left">Extra Small</td><td style="text-align: left"><code>xs</code></td><td style="text-align: left">高达599px</td></tr>
<tr><td style="text-align: left">Small</td><td style="text-align: left"><code>sm</code></td><td style="text-align: left">高达1023px</td></tr>
<tr><td style="text-align: left">Medium</td><td style="text-align: left"><code>md</code></td><td style="text-align: left">高达1439px</td></tr>
<tr><td style="text-align: left">Large</td><td style="text-align: left"><code>lg</code></td><td style="text-align: left">高达1919px</td></tr>
<tr><td style="text-align: left">Extra Large</td><td style="text-align: left"><code>xl</code></td><td style="text-align: left">大于1920像素</td></tr>
</tbody></table>
<p>窗口宽度相关的CSS类。</p>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>xs</code></td><td style="text-align: left">仅在特小窗口上显示</td></tr>
<tr><td style="text-align: left"><code>sm</code></td><td style="text-align: left">仅在小窗口上显示</td></tr>
<tr><td style="text-align: left"><code>md</code></td><td style="text-align: left">仅在中等大小的窗口上显示</td></tr>
<tr><td style="text-align: left"><code>lg</code></td><td style="text-align: left">仅在大窗口上显示</td></tr>
<tr><td style="text-align: left"><code>xl</code></td><td style="text-align: left">仅在特大窗口上显示</td></tr>
</tbody></table>
<p><strong>如果它低于其中一个尺寸并且大于其中一个尺寸</strong>, 您仍然可以显示某些DOM元素或组件。 只需附加来自“低于”和“大于”的前缀<code>lt-</code> 或 <code>gt-</code>。例如：<code>lt-md</code>（仅在xs和sm上显示），<code>lt-xl</code>（仅在xs，sm，md和lg窗口中显示），<code>gt-md</code>（大于中等窗口的显示：lg和xl）。</p>
<p>TIP</p>
<p>对于内置块，您可以和可见性类<code>inline</code>结合使用。</p>
<p>例子: <code>&lt;span class=&quot;gt-sm inline&quot;&gt;...&lt;/span&gt;</code></p>
<h2 id="平台相关"><a class="header" href="#平台相关">平台相关</a></h2>
<p>仅在以下位置可见：</p>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>desktop-only</code></td><td style="text-align: left">仅在桌面上可见</td></tr>
<tr><td style="text-align: left"><code>mobile-only</code></td><td style="text-align: left">仅在移动设备上可见</td></tr>
<tr><td style="text-align: left"><code>native-mobile-only</code></td><td style="text-align: left">仅在Cordova/Capacitor上可见</td></tr>
<tr><td style="text-align: left"><code>cordova-only</code></td><td style="text-align: left">仅在Cordova包装的应用上可见</td></tr>
<tr><td style="text-align: left"><code>capacitor-only</code></td><td style="text-align: left">仅在Capacitor包装的应用上可见</td></tr>
<tr><td style="text-align: left"><code>electron-only</code></td><td style="text-align: left">仅在Electron包装的应用上可见</td></tr>
<tr><td style="text-align: left"><code>touch-only</code></td><td style="text-align: left">仅在具有触摸功能的平台上可见</td></tr>
<tr><td style="text-align: left"><code>platform-ios-only</code></td><td style="text-align: left">仅在iOS平台上可见</td></tr>
<tr><td style="text-align: left"><code>platform-android-only</code></td><td style="text-align: left">仅在Android平台上可见</td></tr>
<tr><td style="text-align: left"><code>within-iframe-only</code></td><td style="text-align: left">仅当整个网站在IFRAME标记下时才可见</td></tr>
</tbody></table>
<p>在以下位置隐藏：</p>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>desktop-hide</code></td><td style="text-align: left">在桌面上隐藏</td></tr>
<tr><td style="text-align: left"><code>mobile-hide</code></td><td style="text-align: left">在手机上隐藏</td></tr>
<tr><td style="text-align: left"><code>native-mobile-hide</code></td><td style="text-align: left">在Cordova/Capacitor上隐藏</td></tr>
<tr><td style="text-align: left"><code>cordova-hide</code></td><td style="text-align: left">在Cordova包装的应用上隐藏</td></tr>
<tr><td style="text-align: left"><code>capacitor-hide</code></td><td style="text-align: left">在Capacitor包装的应用上隐藏</td></tr>
<tr><td style="text-align: left"><code>electron-hide</code></td><td style="text-align: left">在Electron包装的应用上隐藏</td></tr>
<tr><td style="text-align: left"><code>touch-hide</code></td><td style="text-align: left">在支持触摸的平台上隐藏</td></tr>
<tr><td style="text-align: left"><code>platform-ios-hide</code></td><td style="text-align: left">在iOS平台上隐藏</td></tr>
<tr><td style="text-align: left"><code>platform-android-hide</code></td><td style="text-align: left">在Android平台上隐藏</td></tr>
<tr><td style="text-align: left"><code>within-iframe-hide</code></td><td style="text-align: left">仅当整个网站位于IFRAME标记下时才隐藏</td></tr>
</tbody></table>
<h2 id="方向相关"><a class="header" href="#方向相关">方向相关</a></h2>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>orientation-portrait</code></td><td style="text-align: left">仅当屏幕方向为<em>纵向</em>时才可见</td></tr>
<tr><td style="text-align: left"><code>orientation-landscape</code></td><td style="text-align: left">仅当屏幕方向为<em>横向</em>时才可见</td></tr>
</tbody></table>
<h2 id="打印相关"><a class="header" href="#打印相关">打印相关</a></h2>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>print-only</code></td><td style="text-align: left">仅在打印媒体上可见 - 在<em>屏幕</em>媒体隐藏</td></tr>
<tr><td style="text-align: left"><code>print-hide</code></td><td style="text-align: left"><em>屏幕</em>媒体上可见 - 在<em>打印</em>媒体隐藏</td></tr>
</tbody></table>
<h1 id="定位-1"><a class="header" href="#定位-1">定位</a></h1>
<p>Quasar提供的CSS类可以帮助您轻松定位DOM元素：</p>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>fullscreen</code></td><td style="text-align: left">全屏</td></tr>
<tr><td style="text-align: left"><code>fixed</code></td><td style="text-align: left">将<code>position</code>设置为<code>fixed</code>而不指定<code>top</code>，<code>left</code>，<code>right</code>或<code>bottom</code>属性</td></tr>
<tr><td style="text-align: left"><code>fixed-center</code></td><td style="text-align: left">将<code>position</code>设置为<code>fixed</code>，但在窗口中间。</td></tr>
<tr><td style="text-align: left"><code>absolute</code></td><td style="text-align: left">将<code>position</code>设置为<code>absolute</code>而不指定<code>top</code>，<code>left</code>，<code>right</code>或<code>bottom</code>属性</td></tr>
<tr><td style="text-align: left"><code>absolute-center</code></td><td style="text-align: left">将<code>position</code>设置为<code>absolute</code>，但在容器中间（容器需要相对位置）。</td></tr>
<tr><td style="text-align: left"><code>fixed-top</code>，<code>absolute-top</code></td><td style="text-align: left">固定或绝对定位在屏幕顶部</td></tr>
<tr><td style="text-align: left"><code>fixed-right</code>，<code>absolute-right</code></td><td style="text-align: left">固定或绝对定位在屏幕右边缘</td></tr>
<tr><td style="text-align: left"><code>fixed-bottom</code>，<code>absolute-bottom</code></td><td style="text-align: left">固定或绝对定位在屏幕底部</td></tr>
<tr><td style="text-align: left"><code>fixed-left</code>，<code>absolute-left</code></td><td style="text-align: left">固定或绝对定位在屏幕左边缘</td></tr>
<tr><td style="text-align: left"><code>fixed-top-left</code>，<code>absolute-top-left</code></td><td style="text-align: left">固定或绝对定位在屏幕左上角</td></tr>
<tr><td style="text-align: left"><code>fixed-top-right</code>，<code>absolute-top-right</code></td><td style="text-align: left">固定或绝对定位在屏幕右上角</td></tr>
<tr><td style="text-align: left"><code>fixed-bottom-left</code>, <code>absolute-bottom-left</code></td><td style="text-align: left">固定或绝对定位在屏幕左下角</td></tr>
<tr><td style="text-align: left"><code>fixed-bottom-right</code>, <code>absolute-bottom-right</code></td><td style="text-align: left">固定或绝对定位在屏幕右下角</td></tr>
<tr><td style="text-align: left"><code>relative-position</code></td><td style="text-align: left">将<code>position</code>设置为<code>relative</code></td></tr>
</tbody></table>
<h2 id="对齐-4"><a class="header" href="#对齐-4">对齐</a></h2>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>float-left</code></td><td style="text-align: left">浮动到左侧</td></tr>
<tr><td style="text-align: left"><code>float-right</code></td><td style="text-align: left">浮动到右侧</td></tr>
<tr><td style="text-align: left"><code>on-left</code></td><td style="text-align: left">在右侧设置一个小边距;通常用于有兄弟元素的图标元素</td></tr>
<tr><td style="text-align: left"><code>on-right</code></td><td style="text-align: left">在左侧设置一个小边距;通常用于有兄弟元素的图标元素</td></tr>
</tbody></table>
<p>TIP</p>
<p>我们建议您阅读Quasar网格系统而不要使用<code>float-left</code> 或 <code>float-right</code>。</p>
<p>垂直对齐：</p>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>vertical-top</code></td><td style="text-align: left">将CSS垂直对齐设置为<code>top</code></td></tr>
<tr><td style="text-align: left"><code>vertical-middle</code></td><td style="text-align: left">将CSS垂直对齐设置为<code>middle</code></td></tr>
<tr><td style="text-align: left"><code>vertical-bottom</code></td><td style="text-align: left">将CSS垂直对齐设置为<code>bottom</code></td></tr>
</tbody></table>
<h1 id="sassscss变量"><a class="header" href="#sassscss变量"><a href="http://www.quasarchs.com/style/sass-scss-variables#Introduction">Sass/SCSS变量</a></a></h1>
<h1 id="stylus变量"><a class="header" href="#stylus变量"><a href="http://www.quasarchs.com/style/stylus-variables#Introduction">Stylus变量</a></a></h1>
<h1 id="其他css辅助类"><a class="header" href="#其他css辅助类">其他CSS辅助类</a></h1>
<p>在编写Vue模板时可以使用很多CSS类。对减轻VueModels和模板的复杂性上非常有用。</p>
<p>以下所列是不完整的。同时检查其他CSS文档页面，如排版、可见性、阴影、定位。</p>
<h2 id="鼠标相关"><a class="header" href="#鼠标相关">鼠标相关</a></h2>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>non-selectable</code></td><td style="text-align: left">用户将无法选择DOM节点及其文本</td></tr>
<tr><td style="text-align: left"><code>scroll</code></td><td style="text-align: left">应用CSS调整使所有平台上的滚动工作达到最佳状态</td></tr>
<tr><td style="text-align: left"><code>no-scroll</code></td><td style="text-align: left">隐藏DOM节点上的滚动条</td></tr>
<tr><td style="text-align: left"><code>no-pointer-events</code></td><td style="text-align: left">DOM元素不会成为鼠标事件的目标 - 点击、悬停等</td></tr>
<tr><td style="text-align: left"><code>all-pointer-events</code></td><td style="text-align: left"><code>no-pointer-events</code>的反义词</td></tr>
<tr><td style="text-align: left"><code>cursor-pointer</code></td><td style="text-align: left">改变DOM元素上的鼠标指针，看起来好像在可点击的链接上</td></tr>
<tr><td style="text-align: left"><code>cursor-not-allowed</code></td><td style="text-align: left">更改DOM元素上的鼠标指针，使其看起来好像不会执行任何操作</td></tr>
<tr><td style="text-align: left"><code>cursor-inherit</code></td><td style="text-align: left">将DOM元素上的鼠标指针更改为与父选项相同</td></tr>
<tr><td style="text-align: left"><code>cursor-none</code></td><td style="text-align: left">没有鼠标光标被渲染</td></tr>
</tbody></table>
<h2 id="大小相关"><a class="header" href="#大小相关">大小相关</a></h2>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>fit</code></td><td style="text-align: left">宽度和高度设置为100％</td></tr>
<tr><td style="text-align: left"><code>full-height</code></td><td style="text-align: left">高度设置为100％</td></tr>
<tr><td style="text-align: left"><code>full-width</code></td><td style="text-align: left">宽度设置为100％</td></tr>
<tr><td style="text-align: left"><code>window-height</code></td><td style="text-align: left">高度设置为100vh，顶部和底部边距为0</td></tr>
<tr><td style="text-align: left"><code>window-width</code></td><td style="text-align: left">宽度设置为100vw，左边距和右边距0</td></tr>
<tr><td style="text-align: left"><code>block</code></td><td style="text-align: left">将<code>display</code>属性设置为<code>block</code></td></tr>
</tbody></table>
<h2 id="方向有关"><a class="header" href="#方向有关">方向有关</a></h2>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>rotate-45</code></td><td style="text-align: left">旋转45度</td></tr>
<tr><td style="text-align: left"><code>rotate-90</code></td><td style="text-align: left">旋转90度</td></tr>
<tr><td style="text-align: left"><code>rotate-135</code></td><td style="text-align: left">旋转135度</td></tr>
<tr><td style="text-align: left"><code>rotate-180</code></td><td style="text-align: left">旋转180度</td></tr>
<tr><td style="text-align: left"><code>rotate-205</code></td><td style="text-align: left">旋转205度</td></tr>
<tr><td style="text-align: left"><code>rotate-270</code></td><td style="text-align: left">旋转270度</td></tr>
<tr><td style="text-align: left"><code>rotate-315</code></td><td style="text-align: left">旋转315度</td></tr>
<tr><td style="text-align: left"><code>flip-horizontal</code></td><td style="text-align: left">水平翻转DOM元素</td></tr>
<tr><td style="text-align: left"><code>flip-vertical</code></td><td style="text-align: left">垂直翻转DOM元素</td></tr>
</tbody></table>
<h2 id="边界相关"><a class="header" href="#边界相关">边界相关</a></h2>
<table><thead><tr><th style="text-align: left">类名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>no-border</code></td><td style="text-align: left">删除任何边框</td></tr>
<tr><td style="text-align: left"><code>no-border-radius</code></td><td style="text-align: left">删除边框可能具有的任何半径</td></tr>
<tr><td style="text-align: left"><code>rounded-borders</code></td><td style="text-align: left">应用通用边框半径</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="展开项"><a class="header" href="#展开项">展开项</a></h1>
<p>QExpansionItem组件允许隐藏与用户不立即相关的内容。 将它们视为单击时会扩展的手风琴元素。 也称为可折叠。</p>
<h1 id="基础用法-30"><a class="header" href="#基础用法-30">基础用法</a></h1>
<pre><code class="language-vue">&lt;q-expansion-item
                  expand-separator
                  icon=&quot;perm_identity&quot;
                  label=&quot;Account settings&quot;
                  caption=&quot;John Doe&quot;
                  &gt;
    &lt;q-card&gt;
        &lt;q-card-section&gt;
            Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quidem, eius reprehenderit eos corrupti
            commodi magni quaerat ex numquam, dolorum officiis modi facere maiores architecto suscipit iste
            eveniet doloribus ullam aliquid.
        &lt;/q-card-section&gt;
    &lt;/q-card&gt;
&lt;/q-expansion-item&gt;
</code></pre>
<h1 id="行为"><a class="header" href="#行为">行为</a></h1>
<h2 id="路由集成"><a class="header" href="#路由集成">路由集成</a></h2>
<table><thead><tr><th>name</th><th>type</th><th>description</th><th>defaultValue</th><th>example</th></tr></thead><tbody>
<tr><td>to</td><td>String |Object</td><td>等价于 <code>&lt;router-link&gt;</code> 'to' property</td><td></td><td>:to=&quot;{ name: 'my-route-name' }&quot;</td></tr>
<tr><td>exact</td><td>Boolean</td><td>Equivalent to Vue Router <router-link> 'exact' property</td><td></td><td></td></tr>
<tr><td>append</td><td>Boolean</td><td>Equivalent to Vue Router <router-link> 'append' property</td><td></td><td></td></tr>
<tr><td>replace</td><td>Boolean</td><td>Equivalent to Vue Router <router-link> 'replace' property</td><td></td><td></td></tr>
<tr><td>active-class</td><td>String</td><td>Equivalent to Vue Router <router-link> 'active-class' property</td><td></td><td>my-active-class</td></tr>
<tr><td>exact-active-class</td><td></td><td>Equivalent to Vue Router <router-link> 'active-class' property</td><td></td><td>my-exact-active-class</td></tr>
</tbody></table>
<h2 id="行为-1"><a class="header" href="#行为-1">行为</a></h2>
<table><thead><tr><th>name</th><th>type</th><th>description</th><th>defaultValue</th><th>example</th></tr></thead><tbody>
<tr><td>duration</td><td>Number</td><td>展开与收起的速度</td><td>300</td><td>:duration=&quot;1000&quot;</td></tr>
<tr><td>default-opened</td><td>Boolean</td><td>默认是否展开</td><td>false</td><td></td></tr>
<tr><td>expand-icon-toggle</td><td>boolean</td><td>触发展开事件，只有 icon 才触发展开事件</td><td>false，整个item都会触发</td><td></td></tr>
<tr><td>group</td><td>String</td><td>将item分组 的key</td><td></td><td></td></tr>
<tr><td>popup</td><td>Boolean</td><td>将展开收起动画 改成 弹出动画</td><td></td><td></td></tr>
</tbody></table>
<h2 id="内容"><a class="header" href="#内容">内容</a></h2>
<table><thead><tr><th>name</th><th>type</th><th>description</th><th>defaultValue</th><th>example</th></tr></thead><tbody>
<tr><td>icon</td><td>String</td><td>左侧icon图标</td><td></td><td></td></tr>
<tr><td>expand-icon</td><td>String</td><td>右侧展开项 图标</td><td></td><td></td></tr>
<tr><td>expanded-icon</td><td>String</td><td>右侧展开后图标</td><td></td><td></td></tr>
<tr><td>label</td><td>String</td><td>标题</td><td></td><td></td></tr>
<tr><td>label-lines</td><td>Number |String</td><td>如果内容在指定行无法完成渲染 标题 则以省略号</td><td></td><td>:label-lines=&quot;2&quot;</td></tr>
<tr><td>caption</td><td>String</td><td>副标题</td><td></td><td></td></tr>
<tr><td>caption-lines</td><td>String</td><td>如果内容在指定行无法完成渲染 副标题 则以省略号</td><td></td><td></td></tr>
<tr><td>header-inset-level</td><td>Number</td><td>应用缩进，给整个item应用 padding-left</td><td></td><td>:header-inset-level=&quot;1&quot;</td></tr>
<tr><td>content-inset-level</td><td>Number</td><td>给隐藏的内容区 应用 padding-left</td><td></td><td>:content-inset-level=&quot;1&quot;</td></tr>
<tr><td>expand-separator</td><td>Boolean</td><td>给展开项之间 应用 分割线</td><td></td><td></td></tr>
<tr><td>switch-toggle-side</td><td>Boolean</td><td>切换 expand icon  左右 方向</td><td>false,right</td><td>true left</td></tr>
</tbody></table>
<h2 id="样式"><a class="header" href="#样式">样式</a></h2>
<table><thead><tr><th>name</th><th>type</th><th>description</th><th>defaultValue</th><th>example</th></tr></thead><tbody>
<tr><td>expand-icon-class</td><td>Array |String |Object</td><td>对于展开图标 应用自定义的样式</td><td></td><td>expand-icon-class=&quot;text-purple&quot;</td></tr>
<tr><td>dark</td><td>Boolean</td><td>黑暗模式</td><td></td><td></td></tr>
<tr><td>dense</td><td>Boolean</td><td>Dense mode; occupies less space</td><td></td><td></td></tr>
<tr><td>dense-toggle</td><td>Boolean</td><td>Use dense mode for expand icon</td><td></td><td></td></tr>
<tr><td>header-style</td><td>Array |String |Object</td><td>对 header应用自定义的 样式</td><td></td><td></td></tr>
<tr><td>header-class</td><td>Array |String |Object</td><td>对 header应用自定义的 样式</td><td></td><td>:header-class=&quot;{ 'my-custom-class': someCondition }&quot;</td></tr>
</tbody></table>
<h2 id="其他-1"><a class="header" href="#其他-1">其他</a></h2>
<table><thead><tr><th>name</th><th>type</th><th>description</th><th>defaultValue</th><th>example</th></tr></thead><tbody>
<tr><td>disable</td><td>Boolean</td><td>禁用图标</td><td></td><td></td></tr>
<tr><td>value</td><td>Boolean</td><td>Model of the component</td><td></td><td></td></tr>
</tbody></table>
<h2 id="slot槽"><a class="header" href="#slot槽">SLOT槽</a></h2>
<table><thead><tr><th>name</th><th>description</th><th>example</th></tr></thead><tbody>
<tr><td>default</td><td>Slot used for expansion item's content</td><td></td></tr>
<tr><td>header</td><td>Slot used for overriding default header</td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-7"><a class="header" href="#简介-7">简介</a></h1>
<p>QPageSticky组件有助于将由它包裹的DOM元素/组件放置到QPage内容区域中的静态位置，无论用户在哪里滚动。</p>
<p>这样做的最大好处是，即使未配置为固定，此组件包裹的元素也不会与布局页眉、页脚或侧滑菜单重叠。 在后一种情况下，位置将偏移，因此不会发生重叠。 例如，尝试使用非固定页脚。 当用户触及屏幕底部并进入视图时，组件将向上移动，因此它不会与页脚重叠。</p>
<h1 id="基本使用-3"><a class="header" href="#基本使用-3">基本使用</a></h1>
<pre><code class="language-vue">   &lt;!-- place QPageSticky at end of page --&gt;
          &lt;q-page-sticky position=&quot;top-left&quot; :offset=&quot;[18, 18]&quot;&gt;
            &lt;q-btn round color=&quot;accent&quot; icon=&quot;arrow_back&quot; class=&quot;rotate-45&quot; /&gt;
          &lt;/q-page-sticky&gt;
</code></pre>
<h1 id="api-1"><a class="header" href="#api-1">API</a></h1>
<table><thead><tr><th>name</th><th>type</th><th>description</th><th>defaultValue</th><th>可选值</th><th>example</th></tr></thead><tbody>
<tr><td>position</td><td>String</td><td>决定位于Page的位置</td><td>&quot;bottom-right&quot;</td><td>top-right<br />top-left<br />bottom-right<br />bottom-left<br />top<br />right<br />bottom<br />left</td><td>:to=&quot;{ name: 'my-route-name' }&quot;</td></tr>
<tr><td>offset</td><td>Array</td><td>偏移量</td><td></td><td></td><td>[8, 8]</td></tr>
<tr><td>expand</td><td>Boolean</td><td>默认情况下，该组件自动收缩，如果使用该属性，则充分扩展</td><td></td><td></td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="选项卡"><a class="header" href="#选项卡">选项卡</a></h1>
<p>选项卡是一种使用较少的窗口空间显示更多信息的方法。 本页通过QTab、QTab和QRouteTab描述选项卡选择部分。</p>
<p>该组件的一种常见用例是在布局的页眉/页脚中。</p>
<blockquote>
<p>与<a href="http://www.quasarchs.com/vue-components/tab-panels">QTabPanels</a>配合使用，这是一个严格指向面板（选项卡内容）本身的组件。</p>
</blockquote>
<h1 id="基本使用-4"><a class="header" href="#基本使用-4">基本使用</a></h1>
<pre><code class="language-vue">      &lt;q-tabs
        v-model=&quot;tab&quot;
        class=&quot;text-red&quot;
      &gt;
        &lt;q-tab name=&quot;mails&quot; icon=&quot;mail&quot; label=&quot;Mails&quot; /&gt;
        &lt;q-tab name=&quot;alarms&quot; icon=&quot;alarm&quot; label=&quot;Alarms&quot; /&gt;
        &lt;q-tab name=&quot;movies&quot; icon=&quot;movie&quot; label=&quot;Movies&quot; /&gt;
      &lt;/q-tabs&gt;
</code></pre>
<h1 id="样式-1"><a class="header" href="#样式-1">样式</a></h1>
<h2 id="溢出样式"><a class="header" href="#溢出样式">溢出样式</a></h2>
<p>当宽度大于容器宽度时，QTab可以水平滚动</p>
<ul>
<li>
<p>在桌面上，你会看到两边有可以点击的V形符号。</p>
</li>
<li>
<p>在手机上，你可以用手指平移选项卡。</p>
</li>
<li>
<p>如果要强制箭头在手机上可见，请使用<code>mobile-arrows</code>属性。</p>
</li>
</ul>
<p>使用<code>outside-arrows</code>        <code>mobile-arrows</code> 属性指定外部，内部箭头</p>
<h2 id="箭头"><a class="header" href="#箭头">箭头</a></h2>
<p><strong>外部箭头</strong></p>
<pre><code class="language-vue">  &lt;q-tabs
        v-model=&quot;tab&quot;
        inline-label
        outside-arrows
        mobile-arrows
        class=&quot;bg-primary text-white shadow-2&quot;
      &gt;
        &lt;q-tab name=&quot;mails&quot; icon=&quot;mail&quot; label=&quot;Mails&quot; /&gt;
        &lt;q-tab name=&quot;alarms&quot; icon=&quot;alarm&quot; label=&quot;Alarms&quot; /&gt;
        &lt;q-tab name=&quot;movies&quot; icon=&quot;movie&quot; label=&quot;Movies&quot; /&gt;
        &lt;q-tab name=&quot;photos&quot; icon=&quot;photo&quot; label=&quot;Photos&quot; /&gt;
        &lt;q-tab name=&quot;videos&quot; icon=&quot;slow_motion_video&quot; label=&quot;Videos&quot; /&gt;
        &lt;q-tab name=&quot;addressbook&quot; icon=&quot;people&quot; label=&quot;Address Book&quot; /&gt;
      &lt;/q-tabs&gt;
</code></pre>
<p><strong>内部箭头</strong></p>
<pre><code class="language-vue">   &lt;q-tabs
        v-model=&quot;tab&quot;
        inline-label
        mobile-arrows
        class=&quot;bg-purple text-white shadow-2&quot;
      &gt;
        &lt;q-tab name=&quot;mails&quot; icon=&quot;mail&quot; label=&quot;Mails&quot; /&gt;
        &lt;q-tab name=&quot;alarms&quot; icon=&quot;alarm&quot; label=&quot;Alarms&quot; /&gt;
        &lt;q-tab name=&quot;movies&quot; icon=&quot;movie&quot; label=&quot;Movies&quot; /&gt;
        &lt;q-tab name=&quot;photos&quot; icon=&quot;photo&quot; label=&quot;Photos&quot; /&gt;
        &lt;q-tab name=&quot;videos&quot; icon=&quot;slow_motion_video&quot; label=&quot;Videos&quot; /&gt;
        &lt;q-tab name=&quot;addressbook&quot; icon=&quot;people&quot; label=&quot;Address Book&quot; /&gt;
      &lt;/q-tabs&gt;

</code></pre>
<h2 id="垂直布局"><a class="header" href="#垂直布局">垂直布局</a></h2>
<blockquote>
<p>vertical</p>
<p>作用于容器</p>
</blockquote>
<pre><code class="language-vue">  &lt;q-splitter
      v-model=&quot;splitterModel&quot;
      style=&quot;height: 250px&quot;
    &gt; //确定了两个分隔区域布局

      //before区域 tab垂直分布
      &lt;template v-slot:before&gt;
        &lt;q-tabs
          v-model=&quot;tab&quot;
          vertical 
          class=&quot;text-teal&quot;
        &gt;
          &lt;q-tab name=&quot;mails&quot; icon=&quot;mail&quot; label=&quot;Mails&quot; /&gt;
          &lt;q-tab name=&quot;alarms&quot; icon=&quot;alarm&quot; label=&quot;Alarms&quot; /&gt;
          &lt;q-tab name=&quot;movies&quot; icon=&quot;movie&quot; label=&quot;Movies&quot; /&gt;
        &lt;/q-tabs&gt;
      &lt;/template&gt;

      //after区域 使用 tab-panels
      &lt;template v-slot:after&gt;
        &lt;q-tab-panels
          v-model=&quot;tab&quot;
          animated
          swipeable
          vertical
          transition-prev=&quot;jump-up&quot;
          transition-next=&quot;jump-up&quot;
        &gt;
          &lt;q-tab-panel name=&quot;mails&quot;&gt;
            &lt;div class=&quot;text-h4 q-mb-md&quot;&gt;Mails&lt;/div&gt;
            &lt;p&gt;Lorem ipsum dolor sit, amet consectetur adipisicing elit. Quis praesentium cumque magnam odio iure quidem, quod illum numquam possimus obcaecati commodi minima assumenda consectetur culpa fuga nulla ullam. In, libero.&lt;/p&gt;
            &lt;p&gt;Lorem ipsum dolor sit, amet consectetur adipisicing elit. Quis praesentium cumque magnam odio iure quidem, quod illum numquam possimus obcaecati commodi minima assumenda consectetur culpa fuga nulla ullam. In, libero.&lt;/p&gt;
          &lt;/q-tab-panel&gt;

          &lt;q-tab-panel name=&quot;alarms&quot;&gt;
            &lt;div class=&quot;text-h4 q-mb-md&quot;&gt;Alarms&lt;/div&gt;
            &lt;p&gt;Lorem ipsum dolor sit, amet consectetur adipisicing elit. Quis praesentium cumque magnam odio iure quidem, quod illum numquam possimus obcaecati commodi minima assumenda consectetur culpa fuga nulla ullam. In, libero.&lt;/p&gt;
            &lt;p&gt;Lorem ipsum dolor sit, amet consectetur adipisicing elit. Quis praesentium cumque magnam odio iure quidem, quod illum numquam possimus obcaecati commodi minima assumenda consectetur culpa fuga nulla ullam. In, libero.&lt;/p&gt;
          &lt;/q-tab-panel&gt;

          &lt;q-tab-panel name=&quot;movies&quot;&gt;
            &lt;div class=&quot;text-h4 q-mb-md&quot;&gt;Movies&lt;/div&gt;
            &lt;p&gt;Lorem ipsum dolor sit, amet consectetur adipisicing elit. Quis praesentium cumque magnam odio iure quidem, quod illum numquam possimus obcaecati commodi minima assumenda consectetur culpa fuga nulla ullam. In, libero.&lt;/p&gt;
            &lt;p&gt;Lorem ipsum dolor sit, amet consectetur adipisicing elit. Quis praesentium cumque magnam odio iure quidem, quod illum numquam possimus obcaecati commodi minima assumenda consectetur culpa fuga nulla ullam. In, libero.&lt;/p&gt;
            &lt;p&gt;Lorem ipsum dolor sit, amet consectetur adipisicing elit. Quis praesentium cumque magnam odio iure quidem, quod illum numquam possimus obcaecati commodi minima assumenda consectetur culpa fuga nulla ullam. In, libero.&lt;/p&gt;
          &lt;/q-tab-panel&gt;
        &lt;/q-tab-panels&gt;
      &lt;/template&gt;

    &lt;/q-splitter&gt;
</code></pre>
<h2 id="稠密"><a class="header" href="#稠密">稠密</a></h2>
<blockquote>
<p>dense</p>
<p>作用于容器</p>
</blockquote>
<p>高度减小</p>
<h2 id="颜色跟随"><a class="header" href="#颜色跟随">颜色跟随</a></h2>
<blockquote>
<p>narrow-indicator</p>
<p>作用于容器</p>
</blockquote>
<p>指示器跟随 子元素的颜色</p>
<pre><code class="language-vue"> &lt;q-tabs
        v-model=&quot;tab&quot;
        narrow-indicator
        dense
        align=&quot;justify&quot;
      &gt;
        &lt;q-tab class=&quot;text-purple&quot; name=&quot;mails&quot; icon=&quot;mail&quot; label=&quot;Mails&quot; /&gt;
        &lt;q-tab class=&quot;text-orange&quot; name=&quot;alarms&quot; icon=&quot;alarm&quot; label=&quot;Alarms&quot; /&gt;
        &lt;q-tab class=&quot;text-teal&quot; name=&quot;movies&quot; icon=&quot;movie&quot; label=&quot;Movies&quot; /&gt;
      &lt;/q-tabs&gt;

      &lt;q-tabs
        v-model=&quot;tab&quot;
        class=&quot;bg-grey-1&quot;
        dense
        align=&quot;justify&quot;
      &gt;
        &lt;q-tab class=&quot;text-orange&quot; name=&quot;mails&quot; icon=&quot;mail&quot; label=&quot;Mails&quot; /&gt;
        &lt;q-tab class=&quot;text-cyan&quot; name=&quot;alarms&quot; icon=&quot;alarm&quot; label=&quot;Alarms&quot; /&gt;
        &lt;q-tab class=&quot;text-red&quot; name=&quot;movies&quot; icon=&quot;movie&quot; label=&quot;Movies&quot; /&gt;
      &lt;/q-tabs&gt;
</code></pre>
<h2 id="波纹"><a class="header" href="#波纹">波纹</a></h2>
<blockquote>
<p>点击 波纹</p>
<p>作用于 子元素</p>
<p>属性值 json</p>
</blockquote>
<pre><code class="language-vue">   &lt;q-tabs
        v-model=&quot;tab&quot;
        narrow-indicator
        dense
        align=&quot;justify&quot;
        class=&quot;text-primary&quot;
      &gt;
        &lt;q-tab :ripple=&quot;false&quot; name=&quot;mails&quot; icon=&quot;mail&quot; label=&quot;Mails&quot; /&gt;
        &lt;q-tab :ripple=&quot;false&quot; name=&quot;alarms&quot; icon=&quot;alarm&quot; label=&quot;Alarms&quot; /&gt;
        &lt;q-tab :ripple=&quot;false&quot; name=&quot;movies&quot; icon=&quot;movie&quot; label=&quot;Movies&quot; /&gt;
      &lt;/q-tabs&gt;

      &lt;q-tabs
        v-model=&quot;tab&quot;
        narrow-indicator
        dense
        align=&quot;justify&quot;
        class=&quot;text-purple&quot;
      &gt;
        &lt;q-tab :ripple=&quot;{ color: 'orange' }&quot; name=&quot;mails&quot; icon=&quot;mail&quot; label=&quot;Mails&quot; /&gt;
        &lt;q-tab :ripple=&quot;{ color: 'orange' }&quot; name=&quot;alarms&quot; icon=&quot;alarm&quot; label=&quot;Alarms&quot; /&gt;
        &lt;q-tab :ripple=&quot;{ color: 'orange' }&quot; name=&quot;movies&quot; icon=&quot;movie&quot; label=&quot;Movies&quot; /&gt;
      &lt;/q-tabs&gt;
</code></pre>
<h2 id="自定义指示器"><a class="header" href="#自定义指示器">自定义指示器</a></h2>
<p>修改颜色</p>
<blockquote>
<p>indicator-color=&quot;transparent&quot;</p>
</blockquote>
<p>修改长短</p>
<blockquote>
<p>narrow-indicator</p>
</blockquote>
<pre><code class="language-vue">   &lt;q-tabs
        v-model=&quot;tab&quot;
        narrow-indicator
        class=&quot;bg-purple text-white shadow-2&quot;
      &gt;
        &lt;q-tab name=&quot;mails&quot; icon=&quot;mail&quot; label=&quot;Mails&quot; /&gt;
        &lt;q-tab name=&quot;alarms&quot; icon=&quot;alarm&quot; label=&quot;Alarms&quot; /&gt;
        &lt;q-tab name=&quot;movies&quot; icon=&quot;movie&quot; label=&quot;Movies&quot; /&gt;
      &lt;/q-tabs&gt;

</code></pre>
<h2 id="对齐-5"><a class="header" href="#对齐-5">对齐</a></h2>
<blockquote>
<p>当容器宽度（而非窗口宽度）大于配置的断点时，QTab会做出响应，并且<code>align</code>属性（请参见下文）会被激活</p>
</blockquote>
<p><strong>align</strong></p>
<ul>
<li>left</li>
<li>right</li>
<li>center</li>
<li>justify</li>
</ul>
<pre><code class="language-vue">        &lt;q-tabs v-model=&quot;tab&quot; :breakpoint=&quot;1000&quot; align=&quot;left&quot;&gt;
          &lt;q-tab name=&quot;tab1&quot; label=&quot;Tab 1&quot; /&gt;
          &lt;q-tab name=&quot;tab2&quot; label=&quot;Tab 2&quot; /&gt;
          &lt;q-tab name=&quot;tab3&quot; label=&quot;Tab 3&quot; /&gt;
        &lt;/q-tabs&gt;
</code></pre>
<h2 id="提示与通知"><a class="header" href="#提示与通知">提示与通知</a></h2>
<blockquote>
<p>alert， alert-icon</p>
</blockquote>
<pre><code class="language-vue">
      &lt;q-tabs
        v-model=&quot;tab&quot;
        class=&quot;bg-purple text-white shadow-2&quot;
      &gt;
        &lt;q-tab alert=&quot;yellow&quot; alert-icon=&quot;warning&quot; name=&quot;mails&quot; label=&quot;Mails&quot; /&gt;
        &lt;q-tab alert alert-icon=&quot;event&quot; label=&quot;Alarms&quot; name=&quot;alarms&quot; /&gt;
        &lt;q-tab alert=&quot;orange&quot; alert-icon=&quot;announcement&quot; name=&quot;movies&quot; label=&quot;Movies&quot; /&gt;
      &lt;/q-tabs&gt;

</code></pre>
<h1 id="与其他组件结合"><a class="header" href="#与其他组件结合">与其他组件结合</a></h1>
<h2 id="与q-badge使用"><a class="header" href="#与q-badge使用">与q-badge使用</a></h2>
<pre><code class="language-vue">        &lt;q-tabs v-model=&quot;tab&quot; :breakpoint=&quot;1000&quot; align=&quot;left&quot;&gt;
          &lt;q-tab name=&quot;tab1&quot; label=&quot;Tab 1&quot;&gt;
            &lt;q-badge color=&quot;red&quot; floating&gt;2&lt;/q-badge&gt;
          &lt;/q-tab&gt;
          &lt;q-tab name=&quot;tab2&quot; label=&quot;Tab 2&quot; /&gt;
          &lt;q-tab name=&quot;tab3&quot; label=&quot;Tab 3&quot; /&gt;
        &lt;/q-tabs&gt;
</code></pre>
<h2 id="与tabspanel一起使用"><a class="header" href="#与tabspanel一起使用"><strong>与tabsPanel一起使用</strong></a></h2>
<pre><code class="language-vue">      &lt;q-card&gt;
        &lt;q-tabs
          v-model=&quot;tab&quot;
          dense
          class=&quot;text-grey&quot;
          active-color=&quot;primary&quot;
          indicator-color=&quot;primary&quot;
          align=&quot;justify&quot;
          narrow-indicator
        &gt;
          &lt;q-tab name=&quot;mails&quot; label=&quot;Mails&quot; /&gt;
          &lt;q-tab name=&quot;alarms&quot; label=&quot;Alarms&quot; /&gt;
          &lt;q-tab name=&quot;movies&quot; label=&quot;Movies&quot; /&gt;
        &lt;/q-tabs&gt;

        &lt;q-separator /&gt;

        &lt;q-tab-panels v-model=&quot;tab&quot; animated&gt;
          &lt;q-tab-panel name=&quot;mails&quot;&gt;
            &lt;div class=&quot;text-h6&quot;&gt;Mails&lt;/div&gt;
            Lorem ipsum dolor sit amet consectetur adipisicing elit.
          &lt;/q-tab-panel&gt;

          &lt;q-tab-panel name=&quot;alarms&quot;&gt;
            &lt;div class=&quot;text-h6&quot;&gt;Alarms&lt;/div&gt;
            Lorem ipsum dolor sit amet consectetur adipisicing elit.
          &lt;/q-tab-panel&gt;

          &lt;q-tab-panel name=&quot;movies&quot;&gt;
            &lt;div class=&quot;text-h6&quot;&gt;Movies&lt;/div&gt;
            Lorem ipsum dolor sit amet consectetur adipisicing elit.
          &lt;/q-tab-panel&gt;
        &lt;/q-tab-panels&gt;
      &lt;/q-card&gt;
</code></pre>
<h1 id="案例"><a class="header" href="#案例">案例</a></h1>
<h2 id="根据屏幕宽度响应式设计"><a class="header" href="#根据屏幕宽度响应式设计">根据屏幕宽度响应式设计</a></h2>
<pre><code class="language-vue">      &lt;q-tabs
        v-model=&quot;tab&quot;
        inline-label
        :breakpoint=&quot;0&quot;
        align=&quot;justify&quot;
        class=&quot;bg-purple text-white shadow-2&quot;
      &gt;
        &lt;q-tab name=&quot;mails&quot; label=&quot;Mails&quot; /&gt;
        &lt;q-tab name=&quot;alarms&quot; label=&quot;Alarms&quot; /&gt;
        &lt;q-tab v-if=&quot;$q.screen.gt.sm&quot; name=&quot;movies&quot; label=&quot;Movies&quot; /&gt;
        &lt;q-tab v-if=&quot;$q.screen.gt.sm&quot; name=&quot;photos&quot; label=&quot;Photos&quot; /&gt;
        &lt;q-btn-dropdown v-if=&quot;$q.screen.lt.md&quot; auto-close stretch flat label=&quot;More...&quot;&gt;
          &lt;q-list&gt;
            &lt;q-item clickable @click=&quot;tab = 'movies'&quot;&gt;
              &lt;q-item-section&gt;Movies&lt;/q-item-section&gt;
            &lt;/q-item&gt;

            &lt;q-item clickable @click=&quot;tab = 'photos'&quot;&gt;
              &lt;q-item-section&gt;Photos&lt;/q-item-section&gt;
            &lt;/q-item&gt;
          &lt;/q-list&gt;
        &lt;/q-btn-dropdown&gt;
      &lt;/q-tabs&gt;
</code></pre>
<h2 id="动态更新"><a class="header" href="#动态更新">动态更新</a></h2>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;q-pa-md&quot;&gt;
    &lt;div class=&quot;q-gutter-y-md&quot; style=&quot;max-width: 600px&quot;&gt;
      &lt;q-list&gt;
        &lt;q-item v-for=&quot;item in allTabs&quot; :key=&quot;item.tab.name&quot; tag=&quot;label&quot; dense v-ripple&gt;
          &lt;q-item-section side&gt;
            &lt;q-checkbox :value=&quot;item.selected&quot; @input=&quot;status =&gt; { setTabSelected(item.tab, status) }&quot; /&gt;
          &lt;/q-item-section&gt;

          &lt;q-item-section&gt;
            &lt;q-item-label&gt;{{ item.tab.label }}&lt;/q-item-label&gt;
          &lt;/q-item-section&gt;

          &lt;q-item-section side&gt;
            &lt;q-icon :name=&quot;item.tab.icon&quot; /&gt;
          &lt;/q-item-section&gt;
        &lt;/q-item&gt;
      &lt;/q-list&gt;

      &lt;q-toolbar class=&quot;bg-purple text-white shadow-2 rounded-borders&quot;&gt;
        &lt;q-btn flat label=&quot;Homepage&quot; /&gt;
        &lt;q-space /&gt;

        &lt;!--
          notice shrink property since we are placing it
          as child of QToolbar
        --&gt;
        &lt;q-tabs
          v-model=&quot;tab&quot;
          inline-label
          shrink
          stretch
        &gt;
          &lt;q-tab v-for=&quot;tab in tabs&quot; :key=&quot;tab.name&quot; v-bind=&quot;tab&quot; /&gt;
        &lt;/q-tabs&gt;
      &lt;/q-toolbar&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h2 id="连接vue-router"><a class="header" href="#连接vue-router">连接Vue-router</a></h2>
<pre><code class="language-vue">&lt;q-tabs&gt;
  &lt;q-route-tab
    icon=&quot;mail&quot;
    to=&quot;/mails&quot;
    exact
  /&gt;
  &lt;q-route-tab
    icon=&quot;alarm&quot;
    to=&quot;/alarms&quot;
    exact
  /&gt;
&lt;/q-tabs&gt;

&lt;template&gt;
  &lt;div class=&quot;q-pa-md&quot;&gt;
    &lt;div class=&quot;q-gutter-y-md&quot; style=&quot;max-width: 600px&quot;&gt;
      &lt;q-tabs
        no-caps
        class=&quot;bg-orange text-white shadow-2&quot;
      &gt;
        &lt;q-route-tab :to=&quot;{ query: { tab: '1' } }&quot; exact replace label=&quot;Activate in 2s&quot; @click=&quot;navDelay&quot; /&gt;
        &lt;q-route-tab :to=&quot;{ query: { tab: '2' } }&quot; exact replace label=&quot;Do nothing&quot; @click=&quot;navCancel&quot; /&gt;
        &lt;q-route-tab :to=&quot;{ query: { tab: '3' } }&quot; exact replace label=&quot;Navigate to the second tab&quot; @click=&quot;navRedirect&quot; /&gt;
        &lt;q-route-tab :to=&quot;{ query: { tab: '4' } }&quot; exact replace label=&quot;Navigate immediatelly&quot; @click=&quot;navPass&quot; /&gt;
      &lt;/q-tabs&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  methods: {
    navDelay (e, go) {
      e.navigate = false // we cancel the default navigation

      // console.log('triggering navigation in 2s')
      setTimeout(() =&gt; {
        // console.log('navigating as promised 2s ago')
        go()
      }, 2000)
    },

    navCancel (e) {
      e.navigate = false // we cancel the default navigation
    },

    navRedirect (e, go) {
      e.navigate = false // we cancel the default navigation

      go({ query: { tab: '2', noScroll: true } })
    },

    navPass () {}
  }
}
&lt;/script&gt;
</code></pre>
<h1 id="api-2"><a class="header" href="#api-2"><a href="http://www.quasarchs.com/vue-components/tabs#qtabs-api">API</a></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工具栏"><a class="header" href="#工具栏"><a href="http://www.quasarchs.com/vue-components/toolbar#Introduction">工具栏</a></a></h1>
<blockquote>
<p>QToolbar通常是布局页眉和页脚的一部分，但可以在页面上的任何位置使用。</p>
</blockquote>
<h1 id="布局-2"><a class="header" href="#布局-2">布局</a></h1>
<pre><code class="language-vue">  &lt;q-toolbar class=&quot;text-primary&quot;&gt;
      &lt;q-btn flat round dense icon=&quot;menu&quot; /&gt;
      &lt;q-toolbar-title&gt;
        Toolbar
      &lt;/q-toolbar-title&gt;
      &lt;q-btn flat round dense icon=&quot;more_vert&quot; /&gt;
    &lt;/q-toolbar&gt;

</code></pre>
<ul>
<li><code>toolbarTitle</code> 将位于 <em>toolbar</em> 的最左边，并有一定的 留白</li>
<li><em>toolbar</em> 的所有直接子元素 如果写在 <em>title</em> 的左边 则位于左边如果写在右边 则位于右边</li>
<li>所有直接子元素 均垂直居中</li>
</ul>
<h1 id="组合嵌套"><a class="header" href="#组合嵌套">组合嵌套</a></h1>
<h2 id="垂直组合"><a class="header" href="#垂直组合">垂直组合</a></h2>
<ul>
<li><strong>insert缩进一个单位</strong></li>
</ul>
<pre><code class="language-vue">&lt;q-toolbar&gt;
    &lt;q-btn flat round dense icon=&quot;menu&quot; class=&quot;q-mr-sm&quot; /&gt;
    &lt;q-space /&gt;
    &lt;q-btn flat round dense icon=&quot;search&quot; class=&quot;q-mr-xs&quot; /&gt;
    &lt;q-btn flat round dense icon=&quot;group_add&quot; /&gt;
&lt;/q-toolbar&gt;
&lt;q-toolbar inset&gt;
    &lt;q-toolbar-title&gt;&lt;strong&gt;Quasar&lt;/strong&gt; Framework&lt;/q-toolbar-title&gt;
&lt;/q-toolbar&gt;
</code></pre>
<h2 id="水平组合"><a class="header" href="#水平组合">水平组合</a></h2>
<ul>
<li>row表示该容器为 弹性容器。且元素为水平分布</li>
<li><em>col-8</em> 表示 该子元素占 2/3,col-4 表示该元素占 1/3</li>
</ul>
<pre><code class="language-vue">&lt;div class=&quot;row no-wrap shadow-1&quot;&gt;
    &lt;q-toolbar class=&quot;col-8 bg-grey-3&quot;&gt;
        &lt;q-btn flat round dense icon=&quot;menu&quot; /&gt;
        &lt;q-toolbar-title&gt;Title&lt;/q-toolbar-title&gt;
        &lt;q-btn flat round dense icon=&quot;search&quot; /&gt;
    &lt;/q-toolbar&gt;
    &lt;q-toolbar class=&quot;col-4 bg-primary text-white&quot;&gt;
        &lt;q-space /&gt;
        &lt;q-btn flat round dense icon=&quot;bluetooth&quot; class=&quot;q-mr-sm&quot; /&gt;
        &lt;q-btn flat round dense icon=&quot;more_vert&quot; /&gt;
    &lt;/q-toolbar&gt;
&lt;/div&gt;
</code></pre>
<h1 id="与其他组件结合-1"><a class="header" href="#与其他组件结合-1">与其他组件结合</a></h1>
<h2 id="与tabs结合"><a class="header" href="#与tabs结合">与Tabs结合</a></h2>
<pre><code class="language-vue"> &lt;q-toolbar class=&quot;bg-purple text-white shadow-2 rounded-borders&quot;&gt;
      &lt;q-btn flat label=&quot;Homepage&quot; /&gt;
      &lt;q-space /&gt;

      &lt;!--
        notice shrink property since we are placing it
        as child of QToolbar
      --&gt;
      &lt;q-tabs v-model=&quot;tab&quot; shrink&gt;
        &lt;q-tab name=&quot;tab1&quot; label=&quot;Tab 1&quot; /&gt;
        &lt;q-tab name=&quot;tab2&quot; label=&quot;Tab 2&quot; /&gt;
        &lt;q-tab name=&quot;tab3&quot; label=&quot;Tab 3&quot; /&gt;
      &lt;/q-tabs&gt;
    &lt;/q-toolbar&gt;
</code></pre>
<h2 id="with-button-dropdown"><a class="header" href="#with-button-dropdown">With Button Dropdown</a></h2>
<pre><code class="language-vue">   &lt;q-toolbar class=&quot;bg-primary text-white q-my-md shadow-2&quot;&gt;
      &lt;q-btn flat round dense icon=&quot;menu&quot; class=&quot;q-mr-sm&quot; /&gt;
      &lt;q-separator dark vertical inset /&gt;
      &lt;q-btn stretch flat label=&quot;Link&quot; /&gt;

      &lt;q-space /&gt;

      &lt;q-btn-dropdown stretch flat label=&quot;Dropdown&quot;&gt;
        &lt;q-list&gt;
          &lt;q-item-label header&gt;Folders&lt;/q-item-label&gt;
          &lt;q-item v-for=&quot;n in 3&quot; :key=&quot;`x.${n}`&quot; clickable v-close-popup tabindex=&quot;0&quot;&gt;
            &lt;q-item-section avatar&gt;
              &lt;q-avatar icon=&quot;folder&quot; color=&quot;secondary&quot; text-color=&quot;white&quot; /&gt;
            &lt;/q-item-section&gt;
            &lt;q-item-section&gt;
              &lt;q-item-label&gt;Photos&lt;/q-item-label&gt;
              &lt;q-item-label caption&gt;February 22, 2016&lt;/q-item-label&gt;
            &lt;/q-item-section&gt;
            &lt;q-item-section side&gt;
              &lt;q-icon name=&quot;info&quot; /&gt;
            &lt;/q-item-section&gt;
          &lt;/q-item&gt;
          &lt;q-separator inset spaced /&gt;
          &lt;q-item-label header&gt;Files&lt;/q-item-label&gt;
          &lt;q-item v-for=&quot;n in 3&quot; :key=&quot;`y.${n}`&quot; clickable v-close-popup tabindex=&quot;0&quot;&gt;
            &lt;q-item-section avatar&gt;
              &lt;q-avatar icon=&quot;assignment&quot; color=&quot;primary&quot; text-color=&quot;white&quot; /&gt;
            &lt;/q-item-section&gt;
            &lt;q-item-section&gt;
              &lt;q-item-label&gt;Vacation&lt;/q-item-label&gt;
              &lt;q-item-label caption&gt;February 22, 2016&lt;/q-item-label&gt;
            &lt;/q-item-section&gt;
            &lt;q-item-section side&gt;
              &lt;q-icon name=&quot;info&quot; /&gt;
            &lt;/q-item-section&gt;
          &lt;/q-item&gt;
        &lt;/q-list&gt;
      &lt;/q-btn-dropdown&gt;
      &lt;q-separator dark vertical /&gt;
      &lt;q-btn stretch flat label=&quot;Link&quot; /&gt;
      &lt;q-separator dark vertical /&gt;
      &lt;q-btn stretch flat label=&quot;Link&quot; /&gt;
    &lt;/q-toolbar&gt;
</code></pre>
<h2 id="with-button-toggle"><a class="header" href="#with-button-toggle">With Button Toggle</a></h2>
<pre><code class="language-vue">  &lt;q-toolbar class=&quot;bg-secondary text-white q-my-md shadow-2&quot;&gt;
      &lt;q-btn flat round dense icon=&quot;menu&quot; class=&quot;q-mr-sm&quot; /&gt;

      &lt;q-space /&gt;

      &lt;q-btn-toggle
        v-model=&quot;model&quot;
        flat stretch
        toggle-color=&quot;yellow&quot;
        :options=&quot;[
          {label: 'One', value: 'one'},
          {label: 'Two', value: 'two'},
          {label: 'Three', value: 'three'}
        ]&quot;
      /&gt;
    &lt;/q-toolbar&gt;
</code></pre>
<h1 id="api-3"><a class="header" href="#api-3">API</a></h1>
<h1 id="样式-2"><a class="header" href="#样式-2">样式</a></h1>
<table><thead><tr><th>样式名</th><th>说明</th><th>默认值</th><th>可选值</th></tr></thead><tbody>
<tr><td><code>glossy</code></td><td>使工具栏具有光泽</td><td>无</td><td>bool值</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="content-disposition"><a class="header" href="#content-disposition"><em>Content-Disposition</em></a></h1>
<h2 id="含义"><a class="header" href="#含义">含义</a></h2>
<p>指示回复的内容 浏览器要以何种形式展示</p>
<ul>
<li>是以<strong>内联</strong>的形式即网页或者页面的一部分）</li>
<li>还是以<strong>附件</strong>的形式下载并保存到本地</li>
</ul>
<p>在 <em>multipart/form-data</em>类型的应答消息体中<em>Content-Disposition</em>消息头可以被用在multipart消息体的子部分中,用来给出其对应字段的相关信息</p>
<h2 id="语法-2"><a class="header" href="#语法-2">语法</a></h2>
<p>作为消息主体中的消息头</p>
<pre><code>Content-Disposition: inline
Content-Disposition: attachment
Content-Disposition: attachment; filename=&quot;filename.jpg&quot;
</code></pre>
<p>作为multipart body中的消息头</p>
<pre><code>Content-Disposition: form-data
Content-Disposition: form-data; name=&quot;fieldName&quot;
Content-Disposition: form-data; name=&quot;fieldName&quot;; filename=&quot;filename.jpg&quot;
</code></pre>
<p>filename*</p>
<p>&quot;filename&quot; 和 &quot;filename*&quot; 两个参数的唯一区别在于，&quot;filename*&quot;采用了 <a href="https://tools.ietf.org/html/rfc5987">RFC 5987</a> 中规定的编码方式。当&quot;filename&quot; 和 &quot;filename*&quot; 同时出现的时候，应该优先采用&quot;filename*&quot;，假如二者都支持的话。</p>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<pre><code class="language-html">200 OK
Content-Type: text/html; charset=utf-8
Content-Disposition: attachment; filename=&quot;cool.html&quot;
Content-Length: 22

&lt;HTML&gt;Save me!&lt;/HTML&gt;
</code></pre>
<pre><code class="language-html">POST /test.html HTTP/1.1
Host: example.org
Content-Type: multipart/form-data;boundary=&quot;boundary&quot;

--boundary
Content-Disposition: form-data; name=&quot;field1&quot;

value1
--boundary
Content-Disposition: form-data; name=&quot;field2&quot;; filename=&quot;example.txt&quot;

value2
--boundary--
</code></pre>
<h2 id="规范"><a class="header" href="#规范">规范</a></h2>
<table><thead><tr><th style="text-align: left">Specification</th><th style="text-align: left">Title</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://tools.ietf.org/html/rfc7578">RFC 7578</a></td><td style="text-align: left">Returning Values from Forms: multipart/form-data</td></tr>
<tr><td style="text-align: left"><a href="https://tools.ietf.org/html/rfc6266">RFC 6266</a></td><td style="text-align: left">Use of the Content-Disposition Header Field in the Hypertext Transfer Protocol (HTTP)</td></tr>
<tr><td style="text-align: left"><a href="https://tools.ietf.org/html/rfc2183">RFC 2183</a></td><td style="text-align: left">Communicating Presentation Information in Internet Messages: The Content-Disposition Header Field</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是cookie"><a class="header" href="#什么是cookie">什么是Cookie</a></h1>
<p>​	HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据,它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</p>
<p>​	通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态,Cookie使基于<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#HTTP_is_stateless_but_not_sessionless">无状态</a>的HTTP协议记录稳定的状态信息成为了可能。</p>
<h1 id="cookie的使用场景"><a class="header" href="#cookie的使用场景">cookie的使用场景</a></h1>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<blockquote>
<p>Cookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。<strong>由于服务器指定Cookie后，浏览器的每次请求都会携带Cookie数据</strong>，会带来额外的性能开销</p>
</blockquote>
<h1 id="创建cookie"><a class="header" href="#创建cookie">创建Cookie</a></h1>
<p>当服务器收到HTTP请求时，服务器可以在<strong>响应头</strong>里面添加一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie"><code>Set-Cookie</code></a>选项。浏览器收到响应后通常会保存下Cookie，之后对该服务器每一次请求中都通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie"><code>Cookie</code></a>请求头部将Cookie信息发送给服务器。另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p>
<pre><code>Set-Cookie: &lt;cookie名&gt;=&lt;cookie值&gt;
</code></pre>
<pre><code class="language-html">HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[页面内容]
</code></pre>
<p>现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie"><code>Cookie</code></a>请求头部再发送给服务器。</p>
<pre><code class="language-html">GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
</code></pre>
<h1 id="cookie种类"><a class="header" href="#cookie种类">Cookie种类</a></h1>
<h2 id="会话期cookie"><a class="header" href="#会话期cookie">会话期Cookie</a></h2>
<p>会话期Cookie是最简单的Cookie：浏览器关闭之后它会被自动删除,也就是说它仅在会话期内有效,会话期Cookie不需要指定过期时间（<code>Expires</code>）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie也会被保留下来，就好像浏览器从来没有关闭一样。</p>
<h2 id="持久性cookie"><a class="header" href="#持久性cookie">持久性Cookie</a></h2>
<p>和关闭浏览器便失效的会话期Cookie不同，持久性Cookie可以指定一个特定的过期时间（<code>Expires</code>）或有效期（<code>Max-Age</code>）。</p>
<pre><code class="language-html">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
</code></pre>
<blockquote>
<p>当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</p>
</blockquote>
<p>​	</p>
<h1 id="cookie的secure-和httponly-标记"><a class="header" href="#cookie的secure-和httponly-标记">Cookie的<code>Secure</code> 和<code>HttpOnly</code> 标记</a></h1>
<p>​	标记为 <code>Secure</code> 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端,但即便设置了 <code>Secure</code> 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，<code>Secure </code>标记也无法提供确实的安全保障。从 Chrome 52 和 Firefox 52 开始，不安全的站点（<code>http:</code>）无法使用Cookie的 <code>Secure</code> 标记。</p>
<p>​	为避免跨域脚本 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS">XSS</a>) 攻击，通过JavaScript的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie"><code>Document.cookie</code></a> API无法访问带有 <code>HttpOnly</code> 标记的Cookie</p>
<p>它们只应该发送给服务端,如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 <code>HttpOnly</code> 标记。</p>
<pre><code class="language-html">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
</code></pre>
<h1 id="cookie的作用域"><a class="header" href="#cookie的作用域">Cookie的作用域</a></h1>
<ul>
<li><code>Domain</code> 和 <code>Path</code> 标识定义了Cookie的*作用域：*即Cookie应该发送给哪些URL。</li>
<li><code>Domain</code> 标识指定了哪些主机可以接受Cookie。如果不指定，默认为<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/location">当前文档的主机</a>（<strong>不包含子域名</strong>）。如果指定了<code>Domain</code>，则一般包含子域名。</li>
<li>例如，如果设置 <code>Domain=mozilla.org</code>，则Cookie也包含在子域名中（如<code>developer.mozilla.org</code>）。</li>
<li><code>Path</code> 标识指定了主机下的哪些路径可以接受Cookie（该URL路径必须存在于请求URL中）。以字符 <code>%x2F</code> (&quot;/&quot;) 作为路径分隔符，子路径也会被匹配。</li>
<li>那么cookie的作用域：<strong>cookie的作用域是domain本身以及domain下的所有子域名</strong></li>
</ul>
<pre><code>例如，设置 Path=/docs，则以下地址都会匹配：

/docs
/docs/Web/
/docs/Web/HTTP
</code></pre>
<h1 id="samesite-cookie"><a class="header" href="#samesite-cookie"><code>SameSite</code> Cookie</a></h1>
<p>允许服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSRF">CSRF</a>）。</p>
<pre><code class="language-js">Set-Cookie: key=value; SameSite=Strict
</code></pre>
<p>SameSite可以有下面三种值：</p>
<ul>
<li>
<p><strong>None</strong></p>
<p>浏览器会在同站请求、跨站请求下继续发送cookies，不区分大小写。</p>
</li>
<li>
<p><strong><code>Strict</code></strong></p>
<p>浏览器将只在访问相同站点时发送cookie。（在原有Cookies的限制条件上的加强，如上文“Cookie的作用域” 所述）</p>
</li>
<li>
<p>Lax</p>
<p>在新版本浏览器中，为默认选项，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者frames的调用，但只有当用户从外部站点导航到URL时才会发送。如link链接</p>
</li>
</ul>
<h1 id="javascript通过documentcookie访问cookie"><a class="header" href="#javascript通过documentcookie访问cookie">JavaScript通过Document.cookie访问Cookie</a></h1>
<p>通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie"><code>Document.cookie</code></a>属性可创建新的Cookie，也可通过该属性访问非<code>HttpOnly</code>标记的Cookie。</p>
<h1 id="安全"><a class="header" href="#安全">安全</a></h1>
<p>当机器处于不安全环境时，切记<em>不能</em>通过HTTP Cookie存储、传输敏感信息。</p>
<h2 id="会话劫持和xss"><a class="header" href="#会话劫持和xss">会话劫持和XSS</a></h2>
<p>在Web应用中，Cookie常用来标记用户或授权会话。因此，如果Web应用的Cookie被窃取，可能导致授权用户的会话受到攻击。常用的窃取Cookie的方法有利用社会工程学攻击和利用应用程序漏洞进行<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS">XSS</a>攻击。</p>
<h2 id="跨站请求伪造csrf"><a class="header" href="#跨站请求伪造csrf">跨站请求伪造（CSRF）</a></h2>
<p>比如在不安全聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求：</p>
<pre><code class="language-html">&lt;img src=&quot;http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory&quot;&gt;
</code></pre>
<p>当你打开含有了这张图片的HTML页面时，如果你之前已经登录了你的银行帐号并且Cookie仍然有效（还没有其它验证步骤）,你银行里的钱很可能会被自动转走。有一些方法可以阻止此类事件的发生：</p>
<ul>
<li>对用户输入进行过滤来阻止<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS">XSS</a>；</li>
<li>任何敏感操作都需要确认；</li>
<li>用于敏感信息的Cookie只能拥有较短的生命周期；</li>
</ul>
<h1 id="第三方cookie"><a class="header" href="#第三方cookie">第三方Cookie</a></h1>
<ul>
<li>每个Cookie都会有与之关联的域（Domain）,如果Cookie的域和页面的域相同，那么我们称这个Cookie为<em>第一方Cookie</em>（<em>first-party cookie</em>）</li>
<li>如果Cookie的域和页面的域不同，则称之为<em>第三方Cookie</em>（<em>third-party cookie</em>.）</li>
<li>第一方的Cookie也只会发送给设置它们的服务器。通过第三方组件发送的第三方Cookie主要用于广告和网络追踪</li>
</ul>
<h2 id="如何让浏览器发送第三方cookie"><a class="header" href="#如何让浏览器发送第三方cookie">如何让浏览器发送第三方cookie</a></h2>
<p>当前域名只能设置当前域名以及他的子域名</p>
<p>例如:</p>
<pre><code>zydya.com 域名设置的cookie 只能 发送给
blog.zyday.com	one.blog.zyday.com
自身及其子域名
</code></pre>
<h1 id="set-cookie"><a class="header" href="#set-cookie">Set-Cookie</a></h1>
<p>被用来由服务器端向客户端发送 cookie。</p>
<pre><code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt; 
Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;
Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Max-Age=&lt;non-zero-digit&gt;
Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;
Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Path=&lt;path-value&gt;
Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Secure
Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; HttpOnly

Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; SameSite=Strict
Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; SameSite=Lax

// Multiple directives are also possible, for example:
Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;; Secure; HttpOnly
</code></pre>
<h2 id="cookie-namecookie-value"><a class="header" href="#cookie-namecookie-value"><code>&lt;cookie-name&gt;=&lt;cookie-value&gt;</code></a></h2>
<p>一个 cookie 开始于一个名称/值对：</p>
<ul>
<li><code>&lt;cookie-name&gt;</code> 可以是除了控制字符 (CTLs)、空格 (spaces) 或制表符 (tab)之外的任何 US-ASCII 字符。同时不能包含以下分隔字符： ( ) &lt; &gt; @ , ; : \ &quot; / [ ] ? = { }.</li>
<li><code>&lt;cookie-value&gt;</code> 是可选的，如果存在的话，那么需要包含在双引号里面。支持除了控制字符（CTLs）、空格（whitespace）、双引号（double quotes）、逗号（comma）、分号（semicolon）以及反斜线（backslash）之外的任意 US-ASCII 字符。<strong>关于编码</strong>：许多应用会对 cookie 值按照URL编码（URL encoding）规则进行编码，但是按照 RFC 规范，这不是必须的。不过满足规范中对于 <cookie-value> 所允许使用的字符的要求是有用的。</li>
<li><strong><code>__Secure-</code> 前缀</strong>：以 __Secure- 为前缀的 cookie（其中连接符是前缀的一部分），必须与 secure 属性一同设置，同时必须应用于安全页面（即使用 HTTPS 访问的页面）。</li>
<li><strong><code>__Host-</code> 前缀：</strong> 以 __Host- 为前缀的 cookie，必须与 secure 属性一同设置，必须应用于安全页面（即使用 HTTPS 访问的页面），必须不能设置 domain 属性 （也就不会发送给子域），同时 path 属性的值必须为“/”。</li>
</ul>
<h2 id="expiresdate"><a class="header" href="#expiresdate"><code>Expires=&lt;date&gt; </code></a></h2>
<p>可选</p>
<p>cookie 的最长有效时间，形式为符合 HTTP-date 规范的时间戳。参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Date"><code>Date</code></a> 可以获取详细信息。如果没有设置这个属性，那么表示这是一个<strong>会话期 cookie</strong> 。一个会话结束于客户端被关闭时，这意味着会话期 cookie 在彼时会被移除。然而，很多Web浏览器支持会话恢复功能，这个功能可以使浏览器保留所有的tab标签，然后在重新打开浏览器的时候将其还原。与此同时，cookie 也会恢复，就跟从来没有关闭浏览器一样。</p>
<h2 id="max-agenon-zero-digit"><a class="header" href="#max-agenon-zero-digit"><code>Max-Age=&lt;non-zero-digit&gt;</code></a></h2>
<p>可选</p>
<p>在 cookie 失效之前需要经过的秒数。秒数为 0 或 -1 将会使 cookie 直接过期。一些老的浏览器（ie6、ie7 和 ie8）不支持这个属性。对于其他浏览器来说，假如二者 （指 <code>Expires</code> 和<code>Max-Age</code>） 均存在，那么 Max-Age 优先级更高。</p>
<h2 id="domaindomain-value"><a class="header" href="#domaindomain-value"><code>**Domain=&lt;domain-value&gt;**</code></a></h2>
<p>可选</p>
<p>指定 cookie 可以送达的主机名。假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）。与之前的规范不同的是，域名之前的点号会被忽略。假如指定了域名，那么相当于各个子域名也包含在内了。</p>
<h2 id="secure"><a class="header" href="#secure"><strong>Secure</strong></a></h2>
<p>可选</p>
<p>一个带有安全属性的 cookie 只有在请求使用SSL和HTTPS协议的时候才会被发送到服务器。然而，保密或敏感信息永远不要在 HTTP cookie 中存储或传输，因为整个机制从本质上来说都是不安全的，比如前述协议并不意味着所有的信息都是经过加密的。</p>
<blockquote>
<p>非安全站点（http:）已经不能再在 cookie 中设置 secure 指令了</p>
</blockquote>
<h2 id="httponly"><a class="header" href="#httponly">HttpOnly</a></h2>
<p>可选</p>
<p>设置了 HttpOnly 属性的 cookie 不能使用 JavaScript 经由  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie"><code>Document.cookie</code></a> 属性、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 和  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request"><code>Request</code></a> APIs 进行访问，以防范跨站脚本攻击（<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS">XSS</a>）。</p>
<h1 id="示例-1"><a class="header" href="#示例-1">示例</a></h1>
<h2 id="会话期-cookie"><a class="header" href="#会话期-cookie">会话期 cookie</a></h2>
<pre><code class="language-html">Set-Cookie: sessionid=38afes7a8; HttpOnly; Path=/
</code></pre>
<h2 id="持久化-cookie"><a class="header" href="#持久化-cookie">持久化 cookie</a></h2>
<pre><code class="language-html">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
</code></pre>
<h2 id="非法域"><a class="header" href="#非法域">非法域</a></h2>
<p>属于特定域的 cookie，假如域名不能涵盖原始服务器的域名，那么<a href="https://tools.ietf.org/html/rfc6265#section-4.1.2.3">应该被用户代理拒绝</a>。下面这个 cookie 假如是被域名为 originalcompany.com 的服务器设置的，那么将会遭到用户Http客户端的拒绝(Http连接报错)：</p>
<pre><code class="language-html">Set-Cookie: qwerty=219ffwef9w0f; Domain=somecompany.co.uk; Path=/; Expires=Wed, 30 Aug 2019 00:00:00 GMT
</code></pre>
<h3 id="cookie-前缀"><a class="header" href="#cookie-前缀">Cookie 前缀</a></h3>
<ul>
<li>
<p>名称中包含 __Secure- 或 __Host- 前缀的 cookie，只可以应用在使用了安全连接（HTTPS）的域中，需要同时设置 secure 指令。</p>
</li>
<li>
<p>假如 cookie 以 __Host- 为前缀，那么 path 属性的值必须为 &quot;/&quot; （表示整个站点）,且不能含有 domain 属性。</p>
</li>
<li>
<p>对于不支持 cookie 前缀的客户端，无法保证这些附加的条件成立，所以 cookie 总是被接受的。</p>
</li>
</ul>
<pre><code class="language-html">// 当响应来自于一个安全域（HTTPS）的时候，二者都可以被客户端接受
Set-Cookie: __Secure-ID=123; Secure; Domain=example.com
Set-Cookie: __Host-ID=123; Secure; Path=/

// 缺少 Secure 指令，会被拒绝
Set-Cookie: __Secure-id=1

// 缺少 Path=/ 指令，会被拒绝
Set-Cookie: __Host-id=1; Secure

// 由于设置了 domain 属性，会被拒绝
Set-Cookie: __Host-id=1; Secure; Path=/; domain=example.com
</code></pre>
<h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">MDN-Cookie</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-8"><a class="header" href="#简介-8">简介</a></h1>
<p>通过复用以前获取的资源,可提高性能,减轻服务端的压力</p>
<h1 id="分类-1"><a class="header" href="#分类-1">分类</a></h1>
<p>缓存种类有很多,网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式,大致上分两类</p>
<p>私有缓存:浏览器缓存</p>
<p>共享缓存:架设的web代理</p>
<h1 id="缓存操作目标"><a class="header" href="#缓存操作目标">缓存操作目标</a></h1>
<p>只能缓存GET 请求,普遍的缓存案例</p>
<ul>
<li>一个检索请求的成功响应: 对于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a>请求，响应状态码为：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200"><code>200</code></a>，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应。</li>
<li>永久重定向: 响应状态码：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/301"><code>301</code></a>。</li>
<li>错误响应: 响应状态码：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/404"><code>404</code></a> 的一个页面。</li>
<li>不完全的响应: 响应状态码 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206"><code>206</code></a>，只返回局部的信息。</li>
<li>除了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 请求外，如果匹配到作为一个已被定义的cache键名的响应。</li>
</ul>
<h1 id="缓存控制"><a class="header" href="#缓存控制">缓存控制</a></h1>
<p><em>Cache-control</em>取值</p>
<p><em>no-store</em>:缓存中不得存储任何关于客户端请求和服务端响应的内容</p>
<p><em>no-cache</em>:每次有请求发出时,会将带有本地缓存相关的验证字段发到服务器,服务器会验证缓存是否过期,若未过期(返回304),则缓存才使用本地缓存副本</p>
<p>私有与公共缓存</p>
<p><em>private</em>|<em>public</em>:控制中间人是否能缓存 目标用户的页面</p>
<p>过期机制</p>
<pre><code class="language-html">Cache-Control: max-age=31536000
</code></pre>
<ul>
<li>表示资源能够被缓存的最大时间</li>
<li>max-age是距离请求发起的时间的秒数</li>
<li>针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源</li>
</ul>
<p><em>must-revalidate</em></p>
<ul>
<li>使用一个陈旧的资源时，必须先验证它的状态</li>
</ul>
<h1 id="pragma-头"><a class="header" href="#pragma-头">Pragma 头</a></h1>
<ul>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma"><code>Pragma</code></a> 是<strong>HTTP/1.0</strong>标准中定义的一个header属性，</p>
</li>
<li>
<p>请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头没有明确定义这个属性，</p>
</li>
<li>
<p>所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头</p>
</li>
</ul>
<h1 id="新鲜度"><a class="header" href="#新鲜度">新鲜度</a></h1>
<p><img src="HTTP/C:%5CUsers%5Cweisanju%5CDesktop%5C%E5%AE%9E%E7%94%A8%E5%9B%BE%5CHTTPStaleness.png" alt="HTTP时序图" /></p>
<h1 id="计算缓存寿命"><a class="header" href="#计算缓存寿命">计算缓存寿命</a></h1>
<ol>
<li>
<p>首先 查 <code>Cache-control: max-age=N</code>的头</p>
</li>
<li>
<p>然后 expires属性,比较Expires的值和头里面<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Date">Date</a>属性的值来判断是否缓存还有效</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified">Last-Modified</a>信息:缓存的寿命就等于头里面Date的值减去Last-Modified的值除以10（注：根据rfc2626其实也就是乘以10%）。</p>
</li>
</ol>
<pre><code>expirationTime = responseTime + freshnessLifetime - currentAge
</code></pre>
<h1 id="改进资源"><a class="header" href="#改进资源">改进资源</a></h1>
<p>revving</p>
<ul>
<li>给 不频繁更新的文件在URL后面（通常是文件名后面）会加上版本号</li>
<li>加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长</li>
<li>所有引用这个资源的地方都需要更新链接,通常会采用自动化构建工具在实际工作中完成这些琐碎的工作</li>
<li>加在加速文件后面的版本号不一定是一个正式的版本号字符串，如1.1.3这样或者其他固定自增的版本数。它可以是任何防止缓存碰撞的标记例如hash或者时间戳。</li>
</ul>
<h1 id="缓存验证"><a class="header" href="#缓存验证">缓存验证</a></h1>
<ul>
<li>用户点击刷新按钮时会开始缓存验证</li>
<li>如果缓存的响应头信息里含有&quot;Cache-control: must-revalidate”的定义</li>
<li>另外，在浏览器偏好设置里设置Advanced-&gt;Cache为强制验证缓存也能达到相同的效果。</li>
</ul>
<p><em>ETags</em></p>
<ul>
<li>强校验器,是服务器给 UA的 一个不透明的值, UA可以在后续的 <em>if-none-match</em> 头来验证缓存</li>
</ul>
<p><em>last-modified</em></p>
<ul>
<li>弱校验器: 只能精确到秒,客户端后续可以在请求中带上 <em>if-modified-since</em> 来验证缓存</li>
<li>客户端向 服务端 发起校验时,服务端会返回 200,或者304 <em>not modified</em> ,304响应头也可以同时更新缓存文档的过期时间</li>
</ul>
<h1 id="vary响应"><a class="header" href="#vary响应"><em>Vary</em>响应</a></h1>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary"><code>Vary</code></a> HTTP 响应头 决定了对于后续的请求头，如何判断是请求一个新的资源还是使用缓存的文件。</p>
<p><img src="HTTP/C:%5CUsers%5Cweisanju%5CDesktop%5C%E5%AE%9E%E7%94%A8%E5%9B%BE%5CHTTPVary.png" alt="HttpVary图" /></p>
<ul>
<li>vary头有利于内容服务的动态多样性</li>
<li>除了 请求的URI 不同 导致缓存失效以外,还有 区分移动端,桌面端缓存,区分不通编码类型的缓存,区别不通浏览器的缓存</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是跨域资源共享cors"><a class="header" href="#什么是跨域资源共享cors">什么是跨域资源共享(CORS)</a></h1>
<ul>
<li>
<p>跨域资源共享,实际上叫跨源 资源共享(Cross-Origin-Resource-share),是一种 用来控制跨域访问的机制</p>
</li>
<li>
<p>它使用额外的Http头来告诉浏览器,让运行在一个源(origin)上的web应用准许访问来自不同源的服务器上指定的资源</p>
</li>
<li>
<p>源的定义为: 域名:协议:端口.这三者一致则认为同源,当一个资源试图访问 不同源的资源时源会发起一个<strong>跨域 HTTP 请求</strong>。</p>
</li>
<li>
<p>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求</p>
<ul>
<li>例如，XMLHttpRequest和Fetch API遵循同源策略</li>
<li>这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。</li>
</ul>
<blockquote>
<p>并不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。</p>
</blockquote>
</li>
</ul>
<h1 id="功能概述"><a class="header" href="#功能概述">功能概述</a></h1>
<ul>
<li>跨域资源共享标准新增了一组HTTP首部字段,允许服务器申明哪些源 通过浏览器 有权限访问哪些资源</li>
<li>另外,规范要求,对那些可能对服务器数据产生副作用的HTTP请求方法,浏览器必须首先使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS"><code>OPTIONS</code></a> 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。
<ul>
<li>特别是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 以外的 HTTP 请求</li>
<li>或者搭配某些 MIME 类型的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a> 请求</li>
</ul>
</li>
<li>服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">Cookies </a>和 HTTP 认证相关数据）。</li>
<li>CORS请求失败会产生错误，但是为了安全，在JavaScript代码层面是无法获知到底具体是哪里出了问题。你只能查看浏览器的控制台以得知具体是哪里出现了错误。</li>
</ul>
<h1 id="访问控制场景"><a class="header" href="#访问控制场景">访问控制场景</a></h1>
<p>这里，我们使用三个场景来解释跨域资源共享机制的工作原理。这些例子都使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 对象。</p>
<p><a href="http://arunranga.com/examples/access-control/">JavaScript 代码片段</a></p>
<p>关于服务端对跨域资源共享的支持的讨论，请参见这篇文章： <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Server-Side_Access_Control">Server-Side_Access_Control (CORS)</a>。</p>
<h2 id="简单请求"><a class="header" href="#简单请求">简单请求</a></h2>
<p>某些跨域请求不会触发 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests">CORS 预检请求</a>.本文称这样的请求为“简单请求”，请注意，该术语并不属于 <a href="https://fetch.spec.whatwg.org/">Fetch</a> （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：</p>
<ul>
<li>
<p>使用下列方法之一：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a></li>
</ul>
</li>
<li>
<p>除了被浏览器自动设置的首部字段（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection"><code>Connection</code></a> ，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent"><code>User-Agent</code></a>）和在 Fetch 规范中定义为 <a href="https://fetch.spec.whatwg.org/#forbidden-header-name">禁用首部名称</a> 的其他首部，允许人为设置的字段为 Fetch 规范定义的 <a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header">对 CORS 安全的首部字段集合</a>。该集合为：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept"><code>Accept</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language"><code>Accept-Language</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language"><code>Content-Language</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> （需要注意额外的限制）</li>
<li><code>DPR</code></li>
<li><code>Downlink</code></li>
<li><code>Save-Data</code></li>
<li><code>Viewport-Width</code></li>
<li><code>Width</code></li>
</ul>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> 的值仅限于下列三者之一：</p>
<ul>
<li><code>text/plain</code></li>
<li><code>multipart/form-data</code></li>
<li><code>application/x-www-form-urlencoded</code></li>
</ul>
</li>
<li>
<p>请求中的任意<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload"><code>XMLHttpRequestUpload</code></a> 对象均没有注册任何事件监听器；<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload"><code>XMLHttpRequestUpload</code></a> 对象可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload"><code>XMLHttpRequest.upload</code></a> 属性访问。</p>
</li>
<li>
<p>请求中没有使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream"><code>ReadableStream</code></a> 对象。</p>
</li>
</ul>
<p><strong>一次跨域的 <code>简单请求</code>示例</strong></p>
<pre><code class="language-shell">GET /resources/public-data/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Referer: http://foo.example/examples/access-control/simpleXSInvocation.html
Origin: http://foo.example


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 00:23:53 GMT
Server: Apache/2.0.61 
Access-Control-Allow-Origin: *
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: application/xml

[XML Data]
响应中携带了响应首部字段 Access-Control-Allow-Origin（第 16 行）。使用 Origin 和 Access-Control-Allow-Origin 就能完成最简单的访问控制。
本例中，服务端返回的 Access-Control-Allow-Origin: * 表明，该资源可以被任意外域访问。如果服务端仅允许来自 http://foo.example 的访问，该首部字段的内容如下：

Access-Control-Allow-Origin: http://foo.example

现在，除了 http://foo.example，其它外域均不能访问该资源
</code></pre>
<h2 id="预检请求"><a class="header" href="#预检请求">预检请求</a></h2>
<p>​	与前述简单请求不同，“需预检的请求”要求必须首先使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS"><code>OPTIONS</code></a>  方法发起一个预检请求到服务器,以获知服务器是否允许该实际请求</p>
<p>​	&quot;预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>
<h3 id="示例-2"><a class="header" href="#示例-2">示例</a></h3>
<p><strong>如下是一个需要执行预检请求的 HTTP 请求：</strong></p>
<pre><code class="language-js">// 上面的代码使用 POST 请求发送一个 XML 文档,该请求包含了一个自定义的请求首部字段（X-PINGOTHER: pingpong）,另外，该请求的 Content-Type 为 application/xml。因此，该请求需要首先发起“预检请求”。
var invocation = new XMLHttpRequest();
var url = 'http://bar.other/resources/post-here/';
var body = '&lt;?xml version=&quot;1.0&quot;?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;';
    
function callOtherDomain(){
  if(invocation)
    {
      invocation.open('POST', url, true);
      invocation.setRequestHeader('X-PINGOTHER', 'pingpong');
      invocation.setRequestHeader('Content-Type', 'application/xml');
      invocation.onreadystatechange = handler;
      invocation.send(body); 
    }
}

......
</code></pre>
<p><strong>预检报文</strong></p>
<pre><code class="language-html">OPTIONS /resources/post-here/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Origin: http://foo.example
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
</code></pre>
<p><strong>预检完成后发送实际请求</strong></p>
<pre><code>POST /resources/post-here/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
X-PINGOTHER: pingpong
Content-Type: text/xml; charset=UTF-8
Referer: http://foo.example/examples/preflightInvocation.html
Content-Length: 55
Origin: http://foo.example
Pragma: no-cache
Cache-Control: no-cache

&lt;?xml version=&quot;1.0&quot;?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:40 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://foo.example
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 235
Keep-Alive: timeout=2, max=99
Connection: Keep-Alive
Content-Type: text/plain

[Some GZIP'd payload]
</code></pre>
<h3 id="预检请求携带的字段"><a class="header" href="#预检请求携带的字段">预检请求携带的字段</a></h3>
<p>​	浏览器检测到，从 JavaScript 中发起的请求需要被预检。</p>
<p>​	从上面的报文中，我们看到，第 1~12 行发送了一个使用 <code>OPTIONS 方法的“</code>预检请求<code>”。</code> </p>
<p>​	OPTIONS 是 HTTP/1.1 协议中定义的方法，用以从服务器获取更多信息。该方法不会对服务器资源产生影响。 预检请求中同时携带了下面两个首部字段：</p>
<pre><code>//告知服务器 实际请求的方法
Access-Control-Request-Method: POST
//告知服务器器:将携带两个自定义首部字段
Access-Control-Request-Headers: X-PINGOTHER, Content-Type

服务器据此决定，该实际请求是否被允许。
</code></pre>
<h3 id="预检请求响应的字段"><a class="header" href="#预检请求响应的字段">预检请求响应的字段</a></h3>
<pre><code>#表明服务器允许客户端的来源
Access-Control-Allow-Origin: http://foo.example
#表明服务器允许客户端使用的方法,该字段与 HTTP/1.1 Allow: response header 类似,但仅限于在需要访问控制的场景中使用。
Access-Control-Allow-Methods: POST, GET, OPTIONS
#表明服务器允许请求中携带字段
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
#表明该响应的有效时间为 86400 秒,也就是 24 小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。请注意，浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。
Access-Control-Max-Age: 86400
</code></pre>
<h3 id="预检请求与重定向"><a class="header" href="#预检请求与重定向">预检请求与重定向</a></h3>
<p>大多数浏览器不支持针对于预检请求的重定向。如果一个预检请求发生了重定向，浏览器将报告错误：</p>
<blockquote>
<p>The request was redirected to 'https://example.com/foo', which is disallowed for cross-origin requests that require preflight</p>
</blockquote>
<blockquote>
<p>Request requires preflight, which is disallowed to follow cross-origin redirect</p>
</blockquote>
<p>CORS 最初要求该行为，不过<a href="https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2">在后续的修订中废弃了这一要求</a>。</p>
<p>在浏览器的实现跟上规范之前，有两种方式规避上述报错行为：</p>
<ul>
<li>在服务端去掉对预检请求的重定向；</li>
<li>将实际请求变成一个简单请求。</li>
</ul>
<p>如果上面两种方式难以做到，我们仍有其他办法：</p>
<ul>
<li>发出一个简单请求（使用  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/url">Response.url</a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseURL">XHR.responseURL</a>）以判断真正的预检请求会返回什么地址。</li>
<li>发出另一个请求（真正的请求），使用在上一步通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/url">Response.url</a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseURL">XMLHttpRequest.responseURL</a>获得的URL。</li>
</ul>
<p>不过，如果请求是由于存在 Authorization 字段而引发了预检请求，则这一方法将无法使用。这种情况只能由服务端进行更改。</p>
<h3 id="附带身份凭证的请求"><a class="header" href="#附带身份凭证的请求">附带身份凭证的请求</a></h3>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch</a> 与 CORS 的一个有趣的特性是，可以基于  <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">HTTP cookies</a> 和 HTTP 认证信息发送身份凭证,一般而言，对于跨域 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch</a> 请求，浏览器<strong>不会</strong>发送身份凭证信息。如果要发送凭证信息，需要设置 <code>XMLHttpRequest </code>的某个特殊标志位。</p>
<pre><code>//本例中，http://foo.example 的某脚本向 http://bar.other 发起一个GET 请求，并设置 Cookies：
var invocation = new XMLHttpRequest();
var url = 'http://bar.other/resources/credentialed-content/';
    
function callOtherDomain(){
  if(invocation) {
    invocation.open('GET', url, true);
    invocation.withCredentials = true;
    invocation.onreadystatechange = handler;
    invocation.send(); 
  }
}
但是，如果服务器端的响应中未携带 Access-Control-Allow-Credentials: true ，浏览器将不会把响应内容返回给请求的发送者。

GET /resources/access-control-with-credentials/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
Referer: http://foo.example/examples/credential.html
Origin: http://foo.example
Cookie: pageAccess=2


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:34:52 GMT
Server: Apache/2
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Credentials: true
Cache-Control: no-cache
Pragma: no-cache
Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 106
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain


[text/plain payload]
</code></pre>
<p><strong>附带身份凭证的请求与通配符</strong></p>
<p>对于附带身份凭证的请求，服务器不得设置 <code>Access-Control-Allow-Origin</code> 的值为“<code>*</code>”。</p>
<p>这是因为请求的首部中携带了 <code>Cookie</code> 信息，如果 <code>Access-Control-Allow-Origin</code> 的值为“<code>*</code>”，请求将会失败。而将 <code>Access-Control-Allow-Origin</code> 的值设置为 <code>http://foo.example</code>，则请求将成功执行。</p>
<p>另外，响应首部中也携带了 Set-Cookie 字段，尝试对 Cookie 进行修改。如果操作失败，将会抛出异常。</p>
<h2 id="第三方-cookies"><a class="header" href="#第三方-cookies">第三方 cookies</a></h2>
<p>注意在 CORS 响应中设置的 cookies 适用一般性第三方 cookie 策略。在上面的例子中，页面是在 <code>foo.example</code> 加载，但是第 20 行的 cookie 是被 <code>bar.other</code> 发送的，如果用户设置其浏览器拒绝所有第三方 cookies，那么将不会被保存。</p>
<h2 id="访问控制的请求首部字段"><a class="header" href="#访问控制的请求首部字段">访问控制的请求首部字段</a></h2>
<h2 id="访问控制的响应首部字段"><a class="header" href="#访问控制的响应首部字段">访问控制的响应首部字段</a></h2>
<h1 id="springmvc实现跨域请求"><a class="header" href="#springmvc实现跨域请求"><a href="https://www.jianshu.com/p/9203e9b14465">SpringMVC实现跨域请求</a></a></h1>
<h2 id="servlet-filter-实现-cors"><a class="header" href="#servlet-filter-实现-cors">Servlet Filter 实现 CORS</a></h2>
<h2 id="crossorigin-注解实现-cors-跨域"><a class="header" href="#crossorigin-注解实现-cors-跨域">@CrossOrigin 注解实现 CORS 跨域</a></h2>
<h2 id="全局-cors-配置"><a class="header" href="#全局-cors-配置">全局 CORS 配置</a></h2>
<p>基于 JavaConfig</p>
<p>基于 XML 配置文件</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="状态码分类"><a class="header" href="#状态码分类">状态码分类</a></h1>
<p><strong>HTTP的响应状态码通常是由三位数字构成的，其中数字中的第一位指定了HTTP的响应类别</strong>。常见的HTTP响应类别如下表格所述：</p>
<table><thead><tr><th>数字</th><th>类别</th></tr></thead><tbody>
<tr><td>1XX</td><td>信息性状态码，用来表示服务器的状态</td></tr>
<tr><td>2XX</td><td>成功状态码，表示服务器已正常处理请求</td></tr>
<tr><td>3XX</td><td>重定向状态码，用来表示需要额外的操作才能交由服务器正常处理</td></tr>
<tr><td>4XX</td><td>客户端错误码，无法处理客户端的请求</td></tr>
<tr><td>5XX</td><td>服务器错误，服务器出错</td></tr>
</tbody></table>
<h1 id="2xx请求成功"><a class="header" href="#2xx请求成功">2XX请求成功</a></h1>
<table><thead><tr><th>状态码</th><th>原因短语</th><th>意思</th><th>场景</th></tr></thead><tbody>
<tr><td>200</td><td>OK</td><td>请求被正常处理</td><td></td></tr>
<tr><td>204</td><td>No Content</td><td>请求被正常处理，但服务端不响应任何东西</td><td></td></tr>
<tr><td>206</td><td>Parital Content</td><td>客户端进行了范围请求，</td><td>用于下载文件</td></tr>
</tbody></table>
<h1 id="3xx-重定向"><a class="header" href="#3xx-重定向">3XX 重定向</a></h1>
<table><thead><tr><th>状态码</th><th>原因短语</th><th>意思</th><th>场景</th></tr></thead><tbody>
<tr><td>301</td><td>Moved Permanently</td><td>请求资源被永久移除，返回资源的新的URL</td><td>响应头Location 会返回新的URL，并且会更新书签保存的URL</td></tr>
<tr><td>302</td><td>Found</td><td>使用返回的Location的URL重新请求</td><td>临时重定向</td></tr>
<tr><td>303</td><td>See Other</td><td>表示请求的资源 存在另一个URL，应使用GET方法获取请求的资源</td><td></td></tr>
<tr><td>304</td><td>Not Modified</td><td>表示请求的资源没有变动，可以使用本地缓存</td><td></td></tr>
<tr><td>307</td><td>Temporary Redirect</td><td>与302含义相同，302禁止POST变成 GET，但使用的时候不会遵守，307会遵守浏览器标准，不会从GET变成POST</td><td>临时重定向</td></tr>
</tbody></table>
<h1 id="4xx-客户端错误"><a class="header" href="#4xx-客户端错误">4XX 客户端错误</a></h1>
<table><thead><tr><th>状态码</th><th>原因短语</th><th>意思</th><th>场景</th></tr></thead><tbody>
<tr><td>400</td><td>BAD Request</td><td>请求报文不符合服务器规范</td><td></td></tr>
<tr><td>401</td><td>Unauthorized</td><td>需要由Http认证，（BASIC,DIGEST认证）等认证信息</td><td>认证</td></tr>
<tr><td>403</td><td>Forbidden</td><td>未授权</td><td></td></tr>
<tr><td>404</td><td>Not Found</td><td>未找到</td><td></td></tr>
</tbody></table>
<h1 id="5xx-服务器错误"><a class="header" href="#5xx-服务器错误">5XX 服务器错误</a></h1>
<table><thead><tr><th>状态码</th><th>原因短语</th><th>意思</th><th>场景</th></tr></thead><tbody>
<tr><td>500</td><td>Internal Server Error</td><td>服务器内部异常</td><td></td></tr>
<tr><td>503</td><td>服务器超载或停机</td><td>表示服务不可用</td><td>如果事先得知接触 需要的时间，可以写入 Retry-After 字段，让浏览器重新请求</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mime概述"><a class="header" href="#mime概述">MIME概述</a></h1>
<blockquote>
<p><em>Multipurpose Internet Mail Extensions or MIME type</em></p>
</blockquote>
<ul>
<li>
<p>多用途网络邮件扩展</p>
</li>
<li>
<p><em>IANA</em>(<em>InternetAssigned NumbersAuthority</em>) 组织 负责 所有官方的MIME类型制定</p>
</li>
<li>
<p><a href="https://www.iana.org/assignments/media-types/media-types.xhtml">所有MIME列表</a></p>
</li>
<li>
<p>浏览器 根据 MIME类型 处理url, 而不是文件的扩展名</p>
</li>
</ul>
<h1 id="mime结构"><a class="header" href="#mime结构">MIME结构</a></h1>
<p><em>type/subtype;parameter=value</em></p>
<ul>
<li>
<p><em>type</em>表示 一般类别</p>
</li>
<li>
<p><em>subtype</em>表示 具体类别</p>
</li>
<li>
<p>参数 常见的有</p>
<p><em>charset=UTF-8</em> 如果不指定这个,则默认采用  *<a href="https://developer.mozilla.org/en-US/docs/Glossary/ASCII">ASCII</a> (<code>US-ASCII</code>)*编码</p>
</li>
<li>
<p>所有参数 大小写敏感</p>
</li>
</ul>
<h1 id="types"><a class="header" href="#types">Types</a></h1>
<ul>
<li>
<p>单部件类别(<em>discrete</em>)</p>
<p>表示一个文件,或者一个媒体</p>
</li>
<li>
<p>多部件类别(<em>multipart</em>)</p>
<p>表示一个文档 有多个部件组成,每个部件有自己的MIME类别,例如邮件中就包含文本,HTML,附件等多种类别</p>
</li>
</ul>
<h2 id="discrete"><a class="header" href="#discrete">discrete</a></h2>
<p><em>application</em></p>
<p>通用的二进制, 一般有  <code>application/octet-stream</code>. <code>application/pdf</code>, <code>application/pkcs8</code>, and <code>application/zip</code>.</p>
<p><em>audio</em></p>
<p>音频数据, <code>audio/mpeg,audio/vorbis</code></p>
<p><em>example</em></p>
<p>保留, 用作占位符,待确定 例如 <em>audio/example</em> <em>example/xxxx</em></p>
<p><em>font</em></p>
<p>字体,<em>font/woff, font/ttf,font/otf</em></p>
<p><em>image</em></p>
<p>图像,image/jpeg , image/png , image/svg+xml</p>
<p><em>model</em></p>
<p>3d模型数据,  <em>model/3mf<code>and</code>model/vml</em></p>
<p><em>text</em></p>
<p>文本, <code>text/plain</code>, <code>text/csv</code>, and <code>text/html</code>.</p>
<p><em>video</em></p>
<p>视频 <em>video/mp4</em></p>
<p><strong>注意</strong> 对于文本文档,不清楚类型 要使用 <em>text/plain</em> 如果是二进制文件不清楚.要使用<em>application/octet-stream</em></p>
<h2 id="multipart-types"><a class="header" href="#multipart-types">Multipart Types</a></h2>
<blockquote>
<p>在邮件这种组合文档中常用,有一个例外,  <code>multipart/form-data , multipart/byteranges</code> ,使用 206发送文档的一部分, <code>Partial Content</code></p>
</blockquote>
<p><code>message</code>  <a href="https://www.iana.org/assignments/media-types/media-types.xhtml#message">List at IANA</a></p>
<ul>
<li>可以表示 转发另一邮件的 内容 <code>message/rfc822</code></li>
<li>或者分离大消息文本为几块 <code>message/partial</code> ,接收者会自动组装</li>
</ul>
<p><code>multipart</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#multipart">List at IANA</a></p>
<p>数据由多个不通的 mimeTpyes的部分组成</p>
<p>Examples include <code>multipart/form-data</code> (for data produced using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><code>FormData</code></a> API) and <code>multipart/byteranges</code> (defined in <a href="https://tools.ietf.org/html/rfc7233">RFC 7233: 5.4.1</a> and used with <a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP">HTTP</a>'s <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206"><code>206</code></a> &quot;Partial Content&quot; response returned when the fetched data is only part of the content, such as is delivered using the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range"><code>Range</code></a> header).</p>
<h1 id="web开发中重要的类型"><a class="header" href="#web开发中重要的类型">Web开发中重要的类型</a></h1>
<p><em>application/octet-stream</em></p>
<p>未知的二进制格式, 浏览器不会执行它, 只会提示下载框</p>
<p><em>text/plain</em></p>
<p>文本类型</p>
<p><em>text/css , text/html, text/javascript</em></p>
<p><em>application/xml or application/xhtml+xml</em></p>
<p><em>multipart/form-data</em></p>
<pre><code>Content-Type: multipart/form-data; boundary=aBoundaryString
(other headers associated with the multipart document as a whole)

--aBoundaryString
Content-Disposition: form-data; name=&quot;myFile&quot;; filename=&quot;img.jpg&quot;
Content-Type: image/jpeg

(data)
--aBoundaryString
Content-Disposition: form-data; name=&quot;myField&quot;

(data)
--aBoundaryString
(more subparts)
--aBoundaryString--
</code></pre>
<h1 id="mime-sniffing"><a class="header" href="#mime-sniffing">MIME sniffing</a></h1>
<p><strong>mime 嗅探</strong></p>
<p>In the absence of a MIME type, or in certain cases where browsers believe they are incorrect, browsers may perform <em>MIME sniffing</em> — guessing the correct MIME type by looking at the bytes of the resource.</p>
<p>Each browser performs MIME sniffing differently and under different circumstances. (For example, Safari will look at the file extension in the URL if the sent MIME type is unsuitable.) There are security concerns as some MIME types represent executable content. Servers can prevent MIME sniffing by sending the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options"><code>X-Content-Type-Options</code></a> header.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">参考</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http头信息解读"><a class="header" href="#http头信息解读">HTTP头信息解读</a></h1>
<blockquote>
<p>HTTP的头域包括通用头、请求头、响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成</p>
</blockquote>
<h2 id="通用头部"><a class="header" href="#通用头部">通用头部</a></h2>
<p>是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。</p>
<h2 id="请求头部"><a class="header" href="#请求头部">请求头部</a></h2>
<p>是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部。</p>
<h2 id="响应头部"><a class="header" href="#响应头部">响应头部</a></h2>
<p>便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互，如Server头部。</p>
<h2 id="实体头部"><a class="header" href="#实体头部">实体头部</a></h2>
<p>指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型，如Content-Type头部。</p>
<h1 id="http通用头"><a class="header" href="#http通用头">HTTP通用头</a></h1>
<blockquote>
<p>通用头域包含请求和响应消息都支持的头域，通用头域包含缓存头部Cache-Control、Pragma及信息性头部Connection、Date、Transfer-Encoding、Update、Via。</p>
</blockquote>
<h2 id="cache-control"><a class="header" href="#cache-control">Cache-Control</a></h2>
<p>　　Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置 Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、 max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下：</p>
<p>　　no-cache：指示请求或响应消息不能缓存，实际上是可以存储在本地缓存区中的，只是在与原始服务器进行新鲜度验证之前，缓存不能将其提供给客户端使用。　</p>
<p>　　no-store：缓存应该尽快从存储器中删除文档的所有痕迹，因为其中可能会包含敏感信息。</p>
<p>　　max-age：缓存无法返回缓存时间长于max-age规定秒的文档，若不超规定秒浏览器将不会发送对应的请求到服务器，数据由缓存直接返回；超过这一时间段才进一步由服务器决定是返回新数据还是仍由缓存提供。若同时还发送了max-stale指令，则使用期可能会超过其过期时间。</p>
<p>　　min-fresh：至少在未来规定秒内文档要保持新鲜，接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的缓存对象。</p>
<p>　　max-stale：指示客户端可以接收过期响应消息，如果指定max-stale消息的值，那么客户端可以接收过期但在指定值之内的响应消息。</p>
<p>　　only-if-cached：只有当缓存中有副本存在时，客户端才会获得一份副本。</p>
<p>　　Public：指示响应可被任何缓存区缓存，可以用缓存内容回应任何用户。</p>
<p>　　Private：指示对于单个用户的整个或部分响应消息，不能被共享缓存处理，只能用缓存内容回应先前请求该内容的那个用户。</p>
<h2 id="pragma"><a class="header" href="#pragma">Pragma</a></h2>
<p>　　Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache- Control:no-cache相同。</p>
<h2 id="connection"><a class="header" href="#connection">Connection</a></h2>
<p>　　Connection表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。</p>
<h2 id="close"><a class="header" href="#close">Close</a></h2>
<p>告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了。</p>
<h2 id="keepalive"><a class="header" href="#keepalive">Keepalive</a></h2>
<p>告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求。</p>
<h2 id="keep-alive"><a class="header" href="#keep-alive">Keep-Alive</a></h2>
<p>如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒），如Keep-Alive：300。</p>
<h2 id="date"><a class="header" href="#date">Date</a></h2>
<p>　　Date头域表示消息发送的时间，服务器响应中要包含这个头部，因为缓存在评估响应的新鲜度时要用到，其时间的描述格式由RFC822定义。例如，Date:Mon, 31 Dec 2001 04:25:57 GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。</p>
<h2 id="transfer-encoding"><a class="header" href="#transfer-encoding">Transfer-Encoding</a></h2>
<p>　　WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked），例如：Transfer-Encoding: chunked</p>
<h2 id="upgrade"><a class="header" href="#upgrade">Upgrade</a></h2>
<p>　　它可以指定另一种可能完全不同的协议，如HTTP/1.1客户端可以向服务器发送一条HTTP/1.0请求，其中包含值为“HTTP/1.1”的Update头部，这样客户端就可以测试一下服务器是否也使用HTTP/1.1了。</p>
<h2 id="via"><a class="header" href="#via">Via</a></h2>
<p>　　列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。</p>
<p>　　当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添加 Via 头部，并填上自己的相关信息，当下一个代理服务器 收到第一个代理服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求的Via头部，并把自己的相关信息加到后面，以此类推，当 OCS 收到最后一个代理服务器的请求时，检查 Via 头部，就知道该请求所经过的路由。例如：Via：1.0 236-81.D07071953.sina.com.cn:80 (squid/2.6.STABLE13)</p>
<h1 id="http请求头"><a class="header" href="#http请求头">HTTP请求头</a></h1>
<blockquote>
<p>请求头用于说明是谁或什么在发送请求、请求源于何处，或者客户端的喜好及能力。服务器可以根据请求头部给出的客户端信息，试着为客户端提供更好的响应。请求头域可能包含下列字段Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If-Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、Proxy-Authorization、Range、Referer、User-Agent。对请求头域的扩展要求通讯双方都支持，如果存在不支持的请求头域，一般将会作为实体头域处理。</p>
</blockquote>
<h2 id="accept"><a class="header" href="#accept">Accept</a></h2>
<p>　　告诉WEB服务器自己接受什么介质类型，<em>/</em> 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。</p>
<h2 id="accept-charset"><a class="header" href="#accept-charset">Accept-Charset</a></h2>
<p>　　浏览器告诉服务器自己能接收的字符集。</p>
<h2 id="accept-encoding"><a class="header" href="#accept-encoding">Accept-Encoding</a></h2>
<p>　　浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）。</p>
<h2 id="accept-language"><a class="header" href="#accept-language">Accept-Language</a></h2>
<p>　　浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</p>
<h2 id="authorization"><a class="header" href="#authorization">Authorization</a></h2>
<p>　　当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。</p>
<h2 id="if-match"><a class="header" href="#if-match">If-Match</a></h2>
<p>　　如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作，获取文档。</p>
<h2 id="if-none-match"><a class="header" href="#if-none-match">If-None-Match</a></h2>
<p>　　如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作，获取文档。</p>
<h2 id="if-modified-since"><a class="header" href="#if-modified-since">If-Modified-Since</a></h2>
<p>　　如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT</p>
<h2 id="if-unmodified-since"><a class="header" href="#if-unmodified-since">If-Unmodified-Since</a></h2>
<p>　　如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。</p>
<h2 id="if-range"><a class="header" href="#if-range">If-Range</a></h2>
<p>　　浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的ETag 或者自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。</p>
<h2 id="range"><a class="header" href="#range">Range</a></h2>
<p>　　浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546</p>
<h2 id="proxy-authenticate"><a class="header" href="#proxy-authenticate">Proxy-Authenticate</a></h2>
<p>　　代理服务器响应浏览器，要求其提供代理身份验证信息。</p>
<h2 id="proxy-authorization"><a class="header" href="#proxy-authorization">Proxy-Authorization</a></h2>
<p>　　浏览器响应代理服务器的身份验证请求，提供自己的身份信息。</p>
<h2 id="host"><a class="header" href="#host">Host</a></h2>
<p>　　客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。如Host：rss.sina.com.cn</p>
<h2 id="referer"><a class="header" href="#referer">Referer</a></h2>
<p>　　浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址/URL，例如：Referer：http://www.ecdoer.com/</p>
<h2 id="user-agent"><a class="header" href="#user-agent">User-Agent</a></h2>
<p>　　浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN;rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14</p>
<h1 id="http响应头"><a class="header" href="#http响应头">HTTP响应头</a></h1>
<blockquote>
<p>响应头向客户端提供一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令。这些头部有助于客户端处理响应，并在将来发起更好的请求。响应头域包含Age、Location、Proxy-Authenticate、Public、Retry- After、Server、Vary、Warning、WWW-Authenticate。对响应头域的扩展要求通讯双方都支持，如果存在不支持的响应头域，一般将会作为实体头域处理。</p>
</blockquote>
<h2 id="age"><a class="header" href="#age">Age</a></h2>
<p>　　当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。</p>
<h2 id="server"><a class="header" href="#server">Server</a></h2>
<p>　　WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix)</p>
<h2 id="accept-ranges"><a class="header" href="#accept-ranges">Accept-Ranges</a></h2>
<p>　　WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。</p>
<h2 id="vary"><a class="header" href="#vary">Vary</a></h2>
<p>　　WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：Content-Encoding: gzip; Vary: Content-Encoding，那么Cache服务器会分析后续请求消息的头部，检查其Accept-Encoding，是否跟先前响应的Vary头部值一致，即是否使用相同的内容编码方法，这样就可以防止Cache服务器用自己Cache 里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding。</p>
<h1 id="http实体头"><a class="header" href="#http实体头">HTTP实体头</a></h1>
<blockquote>
<p>实体头部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。总之，实体头部可以告知接收者它在对什么进行处理。请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括信息性头部Allow、Location，内容头部Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type，缓存头部Etag、Expires、Last-Modified、extension-header。</p>
</blockquote>
<h2 id="allow"><a class="header" href="#allow">Allow</a></h2>
<p>　　服务器支持哪些请求方法（如GET、POST等）。</p>
<h2 id="location"><a class="header" href="#location">Location</a></h2>
<p>　　表示客户应当到哪里去提取文档，用于将接收端定位到资源的位置（URL）上。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</p>
<h2 id="content-base"><a class="header" href="#content-base">Content-Base</a></h2>
<p>　　解析主体中的相对URL时使用的基础URL。</p>
<h2 id="content-encoding"><a class="header" href="#content-encoding">Content-Encoding</a></h2>
<p>　　WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip</p>
<h2 id="content-language"><a class="header" href="#content-language">Content-Language</a></h2>
<p>　　WEB 服务器告诉浏览器理解主体时最适宜使用的自然语言。</p>
<h2 id="content-length"><a class="header" href="#content-length">Content-Length</a></h2>
<p>　　WEB服务器告诉浏览器自己响应的对象的长度或尺寸，例如：Content-Length: 26012</p>
<h2 id="content-location"><a class="header" href="#content-location">Content-Location</a></h2>
<p>　　资源实际所处的位置。</p>
<h2 id="content-md5"><a class="header" href="#content-md5">Content-MD5</a></h2>
<p>　　主体的MD5校验和。</p>
<h2 id="content-range"><a class="header" href="#content-range">Content-Range</a></h2>
<p>　　实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式： Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth。例如，传送头500个字节次字段的形式：Content-Range:bytes0- 499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。</p>
<h2 id="content-type"><a class="header" href="#content-type">Content-Type</a></h2>
<p>　　WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml</p>
<h2 id="etag"><a class="header" href="#etag">Etag</a></h2>
<p>　　就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。</p>
<h2 id="expires"><a class="header" href="#expires">Expires</a></h2>
<p>　　WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT</p>
<h2 id="last-modified"><a class="header" href="#last-modified">Last-Modified</a></h2>
<p>　　WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecmascript-6-简介"><a class="header" href="#ecmascript-6-简介">ECMAScript 6 简介</a></h1>
<p>​	1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织ECMA,希望这种语言能够成为国际标准,ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p>
<p>​	该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p>​	因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。</p>
<h1 id="es6-与-ecmascript-2015-的关系"><a class="header" href="#es6-与-ecmascript-2015-的关系">ES6 与 ECMAScript 2015 的关系</a></h1>
<p>ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？</p>
<p>​	2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。</p>
<p>​	但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。</p>
<p>​	常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。</p>
<p>但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。</p>
<p>​	标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。</p>
<p>​	ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的<code>includes</code>方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。</p>
<p>​	因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。</p>
<h1 id="语法提案的批准流程"><a class="header" href="#语法提案的批准流程">语法提案的批准流程</a></h1>
<ul>
<li>Stage 0 - Strawman（展示阶段）</li>
<li>Stage 1 - Proposal（征求意见阶段）</li>
<li>Stage 2 - Draft（草案阶段）</li>
<li>Stage 3 - Candidate（候选人阶段）</li>
<li>Stage 4 - Finished（定案阶段）</li>
</ul>
<h1 id="ecmascript-的历史"><a class="header" href="#ecmascript-的历史">ECMAScript 的历史</a></h1>
<p>​	ES6 从开始制定到最后发布，整整用了 15 年。</p>
<p>​	前面提到，ECMAScript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ECMAScript 2.0（1998 年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法。</p>
<p>​	2000 年，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6 继承了。因此，ES6 制定的起点其实是 2000 年。</p>
<p>​	为什么 ES4 没有通过呢？因为这个版本太激进了，对 ES3 做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA 的第 39 号技术专家委员会（Technical Committee 39，简称 TC39）负责制订 ECMAScript 标准，成员包括 Microsoft、Mozilla、Google 等大公司。</p>
<p>​	2007 年 10 月，ECMAScript 4.0 版草案发布，本来预计次年 8 月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。</p>
<p>​	2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。</p>
<p>​	2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 委员会的总体考虑是，ES5 与 ES3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是 ES6，第六版发布以后，就指 ES7。TC39 的判断是，ES5 会在 2013 年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。</p>
<p>​	2011 年 6 月，ECMAScript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。</p>
<p>​	2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。</p>
<p>​	2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。</p>
<p>​	2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。从 2000 年算起，这时已经过去了 15 年。</p>
<p>​	目前，各大浏览器对 ES6 的支持可以查看<a href="https://kangax.github.io/compat-table/es6/">kangax.github.io/compat-table/es6/</a>。</p>
<p>Node.js 是 JavaScript 的服务器运行环境（runtime）。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set"><a class="header" href="#set">Set</a></h1>
<p>它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p>
<h2 id="实例化"><a class="header" href="#实例化">实例化</a></h2>
<pre><code class="language-javascript">const s = new Set();

[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));

for (let i of s) {
  console.log(i);
}
// 2 3 5 4
</code></pre>
<h2 id="以数组实例化或其他可迭代的"><a class="header" href="#以数组实例化或其他可迭代的">以数组实例化或其他可迭代的</a></h2>
<pre><code class="language-javascript">// 例一
const set = new Set([1, 2, 3, 4, 4]);
[...set]
// [1, 2, 3, 4]

// 例二
const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5

// 例三
const set = new Set(document.querySelectorAll('div'));
set.size // 56

// 类似于
const set = new Set();
document
 .querySelectorAll('div')
 .forEach(div =&gt; set.add(div));
set.size // 56
</code></pre>
<h2 id="利用set去重"><a class="header" href="#利用set去重">利用set去重</a></h2>
<p>上面代码也展示了一种去除数组重复成员的方法。</p>
<pre><code class="language-javascript">// 去除数组的重复成员
[...new Set(array)]
</code></pre>
<p>上面的方法也可以用于，去除字符串里面的重复字符。</p>
<pre><code class="language-javascript">[...new Set('ababbc')].join('')
// &quot;abc&quot;
</code></pre>
<h2 id="判重"><a class="header" href="#判重">判重</a></h2>
<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>
<pre><code class="language-javascript">let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set {NaN}
</code></pre>
<p>上面代码向 Set 实例添加了两次<code>NaN</code>，但是只会加入一个。这表明，在 Set 内部，两个<code>NaN</code>是相等的。</p>
<p>另外，两个对象总是不相等的。</p>
<pre><code class="language-javascript">let set = new Set();

set.add({});
set.size // 1

set.add({});
set.size // 2
</code></pre>
<p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p>
<h2 id="set的属性和方法"><a class="header" href="#set的属性和方法">set的属性和方法</a></h2>
<h3 id="属性-3"><a class="header" href="#属性-3">属性</a></h3>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
<h3 id="方法-4"><a class="header" href="#方法-4">方法</a></h3>
<ul>
<li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>
<li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<h2 id="遍历"><a class="header" href="#遍历">遍历</a></h2>
<p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li><code>Set.prototype.keys()</code>：返回键名的遍历器</li>
<li><code>Set.prototype.values()</code>：返回键值的遍历器</li>
<li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li>
<li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>
<h3 id="keysvaluesentries"><a class="header" href="#keysvaluesentries"><code>keys()</code>，<code>values()</code>，<code>entries()</code></a></h3>
<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p>
<pre><code class="language-javascript">let set = new Set(['red', 'green', 'blue']);

for (let item of set.keys()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.values()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.entries()) {
  console.log(item);
}
// [&quot;red&quot;, &quot;red&quot;]
// [&quot;green&quot;, &quot;green&quot;]
// [&quot;blue&quot;, &quot;blue&quot;]
</code></pre>
<p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p>
<pre><code class="language-javascript">Set.prototype[Symbol.iterator] === Set.prototype.values
// true
</code></pre>
<p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</p>
<pre><code class="language-javascript">let set = new Set(['red', 'green', 'blue']);

for (let x of set) {
  console.log(x);
}
// red
// green
// blue
</code></pre>
<h3 id="foreach"><a class="header" href="#foreach"><code>forEach()</code></a></h3>
<p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p>
<pre><code class="language-javascript">let set = new Set([1, 4, 9]);
set.forEach((value, key) =&gt; console.log(key + ' : ' + value))
// 1 : 1
// 4 : 4
// 9 : 9
</code></pre>
<p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>
<p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p>
<h2 id="应用"><a class="header" href="#应用">应用</a></h2>
<p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构。</p>
<pre><code class="language-javascript">let set = new Set(['red', 'green', 'blue']);
let arr = [...set];
// ['red', 'green', 'blue']
</code></pre>
<p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>
<pre><code class="language-javascript">let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)];
// [3, 5, 2]
</code></pre>
<p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了。</p>
<pre><code class="language-javascript">let set = new Set([1, 2, 3]);
set = new Set([...set].map(x =&gt; x * 2));
// 返回Set结构：{2, 4, 6}

let set = new Set([1, 2, 3, 4, 5]);
set = new Set([...set].filter(x =&gt; (x % 2) == 0));
// 返回Set结构：{2, 4}
</code></pre>
<p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p>
<pre><code class="language-javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}

// 交集
let intersect = new Set([...a].filter(x =&gt; b.has(x)));
// set {2, 3}

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x =&gt; !b.has(x)));
// Set {1}
</code></pre>
<p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法。</p>
<pre><code class="language-javascript">// 方法一
let set = new Set([1, 2, 3]);
set = new Set([...set].map(val =&gt; val * 2));
// set的值是2, 4, 6

// 方法二
let set = new Set([1, 2, 3]);
set = new Set(Array.from(set, val =&gt; val * 2));
// set的值是2, 4, 6
</code></pre>
<h1 id="weakset"><a class="header" href="#weakset">WeakSet</a></h1>
<p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p>
<pre><code class="language-javascript">const ws = new WeakSet();
ws.add(1)
// TypeError: Invalid value used in weak set
ws.add(Symbol())
// TypeError: invalid value used in weak set
</code></pre>
<p>上面代码试图向 WeakSet 添加一个数值和<code>Symbol</code>值，结果报错，因为 WeakSet 只能放置对象。</p>
<p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为<code>0</code>，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p>
<p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p>
<p>这些特点同样适用于本章后面要介绍的 WeakMap 结构。</p>
<h2 id="语法-3"><a class="header" href="#语法-3">语法</a></h2>
<p>WeakSet 是一个构造函数，可以使用<code>new</code>命令，创建 WeakSet 数据结构。</p>
<pre><code class="language-javascript">const ws = new WeakSet();
</code></pre>
<p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p>
<pre><code class="language-javascript">const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a);
// WeakSet {[1, 2], [3, 4]}
</code></pre>
<p>上面代码中，<code>a</code>是一个数组，它有两个成员，也都是数组。将<code>a</code>作为 WeakSet 构造函数的参数，<code>a</code>的成员会自动成为 WeakSet 的成员。</p>
<p>注意，是<code>a</code>数组的成员成为 WeakSet 的成员，而不是<code>a</code>数组本身。这意味着，数组的成员只能是对象。</p>
<pre><code class="language-javascript">const b = [3, 4];
const ws = new WeakSet(b);
// Uncaught TypeError: Invalid value used in weak set(…)
</code></pre>
<p>上面代码中，数组<code>b</code>的成员不是对象，加入 WeakSet 就会报错。</p>
<h2 id="方法-5"><a class="header" href="#方法-5">方法</a></h2>
<p>WeakSet 结构有以下三个方法。</p>
<ul>
<li><strong>WeakSet.prototype.add(value)</strong>：向 WeakSet 实例添加一个新成员。</li>
<li><strong>WeakSet.prototype.delete(value)</strong>：清除 WeakSet 实例的指定成员。</li>
<li><strong>WeakSet.prototype.has(value)</strong>：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li>
</ul>
<p>下面是一个例子。</p>
<pre><code class="language-javascript">const ws = new WeakSet();
const obj = {};
const foo = {};

ws.add(window);
ws.add(obj);

ws.has(window); // true
ws.has(foo);    // false

ws.delete(window);
ws.has(window);    // false
</code></pre>
<p>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员。</p>
<pre><code class="language-javascript">ws.size // undefined
ws.forEach // undefined

ws.forEach(function(item){ console.log('WeakSet has ' + item)})
// TypeError: undefined is not a function
</code></pre>
<p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。</p>
<p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<h1 id="map"><a class="header" href="#map">Map</a></h1>
<h3 id="含义和基本用法"><a class="header" href="#含义和基本用法">含义和基本用法</a></h3>
<p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<pre><code class="language-javascript">const data = {};
const element = document.getElementById('myDiv');

data[element] = 'metadata';
data['[object HTMLDivElement]'] // &quot;metadata&quot;
</code></pre>
<p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p>
<p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<pre><code class="language-javascript">const m = new Map();
const o = {p: 'Hello World'};

m.set(o, 'content')
m.get(o) // &quot;content&quot;

m.has(o) // true
m.delete(o) // true
m.has(o) // false
</code></pre>
<p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p>
<p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<pre><code class="language-javascript">const map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);

map.size // 2
map.has('name') // true
map.get('name') // &quot;张三&quot;
map.has('title') // true
map.get('title') // &quot;Author&quot;
</code></pre>
<p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p>
<p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p>
<pre><code class="language-javascript">const items = [
  ['name', '张三'],
  ['title', 'Author']
];

const map = new Map();

items.forEach(
  ([key, value]) =&gt; map.set(key, value)
);
</code></pre>
<p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p>
<pre><code class="language-javascript">const set = new Set([
  ['foo', 1],
  ['bar', 2]
]);
const m1 = new Map(set);
m1.get('foo') // 1

const m2 = new Map([['baz', 3]]);
const m3 = new Map(m2);
m3.get('baz') // 3
</code></pre>
<p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作<code>Map</code>构造函数的参数，结果都生成了新的 Map 对象。</p>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>
<pre><code class="language-javascript">const map = new Map();

map
.set(1, 'aaa')
.set(1, 'bbb');

map.get(1) // &quot;bbb&quot;
</code></pre>
<p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p>
<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>
<pre><code class="language-javascript">new Map().get('asfddfsasadf')
// undefined
</code></pre>
<p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>
<pre><code class="language-javascript">const map = new Map();

map.set(['a'], 555);
map.get(['a']) // undefined
</code></pre>
<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>
<p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p>
<pre><code class="language-javascript">const map = new Map();

const k1 = ['a'];
const k2 = ['a'];

map
.set(k1, 111)
.set(k2, 222);

map.get(k1) // 111
map.get(k2) // 222
</code></pre>
<p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 Map 结构中被视为两个键。</p>
<p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p>
<pre><code class="language-javascript">let map = new Map();

map.set(-0, 123);
map.get(+0) // 123

map.set(true, 1);
map.set('true', 2);
map.get(true) // 1

map.set(undefined, 3);
map.set(null, 4);
map.get(undefined) // 3

map.set(NaN, 123);
map.get(NaN) // 123
</code></pre>
<h2 id="属性和方法-1"><a class="header" href="#属性和方法-1">属性和方法</a></h2>
<p><strong>size 属性</strong></p>
<p><code>size</code>属性返回 Map 结构的成员总数。</p>
<pre><code class="language-javascript">const map = new Map();
map.set('foo', true);
map.set('bar', false);

map.size // 2
</code></pre>
<p><strong>Map.prototype.set(key, value)</strong></p>
<p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>
<pre><code class="language-javascript">const m = new Map();

m.set('edition', 6)        // 键是字符串
m.set(262, 'standard')     // 键是数值
m.set(undefined, 'nah')    // 键是 undefined
</code></pre>
<p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p>
<pre><code class="language-javascript">let map = new Map()
  .set(1, 'a')
  .set(2, 'b')
  .set(3, 'c');
</code></pre>
<p><strong>Map.prototype.get(key)</strong></p>
<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>
<pre><code class="language-javascript">const m = new Map();

const hello = function() {console.log('hello');};
m.set(hello, 'Hello ES6!') // 键是函数

m.get(hello)  // Hello ES6!
</code></pre>
<p><strong>Map.prototype.has(key)</strong></p>
<p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>
<pre><code class="language-javascript">const m = new Map();

m.set('edition', 6);
m.set(262, 'standard');
m.set(undefined, 'nah');

m.has('edition')     // true
m.has('years')       // false
m.has(262)           // true
m.has(undefined)     // true
</code></pre>
<p><strong>Map.prototype.delete(key)</strong></p>
<p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>
<pre><code class="language-javascript">const m = new Map();
m.set(undefined, 'nah');
m.has(undefined)     // true

m.delete(undefined)
m.has(undefined)       // false
</code></pre>
<p><strong>Map.prototype.clear()</strong></p>
<p><code>clear</code>方法清除所有成员，没有返回值。</p>
<pre><code class="language-javascript">

let map = new Map();
map.set('foo', true);
map.set('bar', false);

map.size // 2
map.clear()
map.size // 0
</code></pre>
<h3 id="遍历方法"><a class="header" href="#遍历方法">遍历方法</a></h3>
<p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li>
<li><code>Map.prototype.values()</code>：返回键值的遍历器。</li>
<li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li>
<li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li>
</ul>
<p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p>
<pre><code class="language-javascript">const map = new Map([
  ['F', 'no'],
  ['T',  'yes'],
]);

for (let key of map.keys()) {
  console.log(key);
}
// &quot;F&quot;
// &quot;T&quot;

for (let value of map.values()) {
  console.log(value);
}
// &quot;no&quot;
// &quot;yes&quot;

for (let item of map.entries()) {
  console.log(item[0], item[1]);
}
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 或者
for (let [key, value] of map.entries()) {
  console.log(key, value);
}
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 等同于使用map.entries()
for (let [key, value] of map) {
  console.log(key, value);
}
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;
</code></pre>
<p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>
<pre><code class="language-javascript">map[Symbol.iterator] === map.entries
// true
</code></pre>
<p><strong>Map 结构转为数组结构</strong></p>
<pre><code class="language-javascript">const map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

[...map.keys()]
// [1, 2, 3]

[...map.values()]
// ['one', 'two', 'three']

[...map.entries()]
// [[1,'one'], [2, 'two'], [3, 'three']]

[...map]
// [[1,'one'], [2, 'two'], [3, 'three']]
</code></pre>
<p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）。</p>
<pre><code class="language-javascript">const map0 = new Map()
  .set(1, 'a')
  .set(2, 'b')
  .set(3, 'c');

const map1 = new Map(
  [...map0].filter(([k, v]) =&gt; k &lt; 3)
);
// 产生 Map 结构 {1 =&gt; 'a', 2 =&gt; 'b'}

const map2 = new Map(
  [...map0].map(([k, v]) =&gt; [k * 2, '_' + v])
    );
// 产生 Map 结构 {2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'}
</code></pre>
<p>此外，Map 还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p>
<pre><code class="language-javascript">map.forEach(function(value, key, map) {
  console.log(&quot;Key: %s, Value: %s&quot;, key, value);
});
</code></pre>
<p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>
<pre><code class="language-javascript">const reporter = {
  report: function(key, value) {
    console.log(&quot;Key: %s, Value: %s&quot;, key, value);
  }
};

map.forEach(function(value, key, map) {
  this.report(key, value);
}, reporter);
</code></pre>
<p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p>
<h2 id="与其他数据结构的互相转换"><a class="header" href="#与其他数据结构的互相转换">与其他数据结构的互相转换</a></h2>
<p><strong>Map 转为数组</strong></p>
<p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p>
<pre><code class="language-javascript">const myMap = new Map()
  .set(true, 7)
  .set({foo: 3}, ['abc']);
[...myMap]
// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]
</code></pre>
<p><strong>数组 转为 Map</strong></p>
<p>将数组传入 Map 构造函数，就可以转为 Map。</p>
<pre><code class="language-javascript">new Map([
  [true, 7],
  [{foo: 3}, ['abc']]
])
// Map {
//   true =&gt; 7,
//   Object {foo: 3} =&gt; ['abc']
// }
</code></pre>
<p><strong>Map 转为对象</strong></p>
<p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p>
<pre><code class="language-javascript">function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k,v] of strMap) {
    obj[k] = v;
  }
  return obj;
}

const myMap = new Map()
  .set('yes', true)
  .set('no', false);
strMapToObj(myMap)
// { yes: true, no: false }
</code></pre>
<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>
<p><strong>对象转为 Map</strong></p>
<p>对象转为 Map 可以通过<code>Object.entries()</code>。</p>
<pre><code class="language-javascript">let obj = {&quot;a&quot;:1, &quot;b&quot;:2};
let map = new Map(Object.entries(obj));
</code></pre>
<p>此外，也可以自己实现一个转换函数。</p>
<pre><code class="language-javascript">function objToStrMap(obj) {
  let strMap = new Map();
  for (let k of Object.keys(obj)) {
    strMap.set(k, obj[k]);
  }
  return strMap;
}

objToStrMap({yes: true, no: false})
// Map {&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false}
</code></pre>
<p><strong>Map 转为 JSON</strong></p>
<p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p>
<pre><code class="language-javascript">function strMapToJson(strMap) {
  return JSON.stringify(strMapToObj(strMap));
}

let myMap = new Map().set('yes', true).set('no', false);
strMapToJson(myMap)
// '{&quot;yes&quot;:true,&quot;no&quot;:false}'
</code></pre>
<p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p>
<pre><code class="language-javascript">function mapToArrayJson(map) {
  return JSON.stringify([...map]);
}

let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
mapToArrayJson(myMap)
// '[[true,7],[{&quot;foo&quot;:3},[&quot;abc&quot;]]]'
</code></pre>
<p><strong>JSON 转为 Map</strong></p>
<p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p>
<pre><code class="language-javascript">function jsonToStrMap(jsonStr) {
  return objToStrMap(JSON.parse(jsonStr));
}

jsonToStrMap('{&quot;yes&quot;: true, &quot;no&quot;: false}')
// Map {'yes' =&gt; true, 'no' =&gt; false}
</code></pre>
<p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p>
<pre><code class="language-javascript">function jsonToMap(jsonStr) {
  return new Map(JSON.parse(jsonStr));
}

jsonToMap('[[true,7],[{&quot;foo&quot;:3},[&quot;abc&quot;]]]')
// Map {true =&gt; 7, Object {foo: 3} =&gt; ['abc']}
</code></pre>
<h1 id="weakmap"><a class="header" href="#weakmap">WeakMap</a></h1>
<p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p>
<pre><code class="language-javascript">// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap();
const key = {foo: 1};
wm1.set(key, 2);
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);
wm2.get(k2) // &quot;bar&quot;
</code></pre>
<p><code>WeakMap</code>与<code>Map</code>的区别有两点。</p>
<p>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</p>
<pre><code class="language-javascript">const map = new WeakMap();
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key
map.set(null, 2)
// TypeError: Invalid value used as weak map key
</code></pre>
<p>上面代码中，如果将数值<code>1</code>和<code>Symbol</code>值作为 WeakMap 的键名，都会报错。</p>
<p>其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</p>
<p><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。</p>
<pre><code class="language-javascript">const e1 = document.getElementById('foo');
const e2 = document.getElementById('bar');
const arr = [
  [e1, 'foo 元素'],
  [e2, 'bar 元素'],
];
</code></pre>
<p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。</p>
<p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p>
<pre><code class="language-javascript">// 不需要 e1 和 e2 的时候
// 必须手动删除引用
arr [0] = null;
arr [1] = null;
</code></pre>
<p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。</p>
<p>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p>
<pre><code class="language-javascript">const wm = new WeakMap();

const element = document.getElementById('example');

wm.set(element, 'some information');
wm.get(element) // &quot;some information&quot;
</code></pre>
<p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p>
<p>也就是说，上面的 DOM 节点对象的引用计数是<code>1</code>，而不是<code>2</code>。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p>
<p>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>
<p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</p>
<pre><code class="language-javascript">const wm = new WeakMap();
let key = {};
let obj = {foo: 1};

wm.set(key, obj);
obj = null;
wm.get(key)
// Object {foo: 1}
</code></pre>
<p>上面代码中，键值<code>obj</code>是正常引用。所以，即使在 WeakMap 外部消除了<code>obj</code>的引用，WeakMap 内部的引用依然存在。</p>
<h3 id="weakmap-的语法"><a class="header" href="#weakmap-的语法">WeakMap 的语法</a></h3>
<p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持<code>clear</code>方法。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>
<pre><code class="language-javascript">const wm = new WeakMap();

// size、forEach、clear 方法都不存在
wm.size // undefined
wm.forEach // undefined
wm.clear // undefined
</code></pre>
<h3 id="weakmap-的示例"><a class="header" href="#weakmap-的示例">WeakMap 的示例</a></h3>
<p>WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。</p>
<p>贺师俊老师<a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292109104">提示</a>，如果引用所指向的值占用特别多的内存，就可以通过 Node 的<code>process.memoryUsage</code>方法看出来。根据这个思路，网友<a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292451925">vtxf</a>补充了下面的例子。</p>
<p>首先，打开 Node 命令行。</p>
<pre><code class="language-bash">$ node --expose-gc
</code></pre>
<p>上面代码中，<code>--expose-gc</code>参数表示允许手动执行垃圾回收机制。</p>
<p>然后，执行下面的代码。</p>
<pre><code class="language-javascript">// 手动执行一次垃圾回收，保证获取的内存使用状态准确
&gt; global.gc();
undefined

// 查看内存占用的初始状态，heapUsed 为 4M 左右
&gt; process.memoryUsage();
{ rss: 21106688,
  heapTotal: 7376896,
  heapUsed: 4153936,
  external: 9059 }

&gt; let wm = new WeakMap();
undefined

// 新建一个变量 key，指向一个 5*1024*1024 的数组
&gt; let key = new Array(5 * 1024 * 1024);
undefined

// 设置 WeakMap 实例的键名，也指向 key 数组
// 这时，key 数组实际被引用了两次，
// 变量 key 引用一次，WeakMap 的键名引用了第二次
// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1
&gt; wm.set(key, 1);
WeakMap {}

&gt; global.gc();
undefined

// 这时内存占用 heapUsed 增加到 45M 了
&gt; process.memoryUsage();
{ rss: 67538944,
  heapTotal: 7376896,
  heapUsed: 45782816,
  external: 8945 }

// 清除变量 key 对数组的引用，
// 但没有手动清除 WeakMap 实例的键名对数组的引用
&gt; key = null;
null

// 再次执行垃圾回收
&gt; global.gc();
undefined

// 内存占用 heapUsed 变回 4M 左右，
// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收
&gt; process.memoryUsage();
{ rss: 20639744,
  heapTotal: 8425472,
  heapUsed: 3979792,
  external: 8956 }
</code></pre>
<p>上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。</p>
<h3 id="weakmap-的用途"><a class="header" href="#weakmap-的用途">WeakMap 的用途</a></h3>
<p>前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。</p>
<pre><code class="language-javascript">let myWeakmap = new WeakMap();

myWeakmap.set(
  document.getElementById('logo'),
  {timesClicked: 0})
;

document.getElementById('logo').addEventListener('click', function() {
  let logoData = myWeakmap.get(document.getElementById('logo'));
  logoData.timesClicked++;
}, false);
</code></pre>
<p>上面代码中，<code>document.getElementById('logo')</code>是一个 DOM 节点，每当发生<code>click</code>事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>
<p>WeakMap 的另一个用处是部署私有属性。</p>
<pre><code class="language-javascript">const _counter = new WeakMap();
const _action = new WeakMap();

class Countdown {
  constructor(counter, action) {
    _counter.set(this, counter);
    _action.set(this, action);
  }
  dec() {
    let counter = _counter.get(this);
    if (counter &lt; 1) return;
    counter--;
    _counter.set(this, counter);
    if (counter === 0) {
      _action.get(this)();
    }
  }
}

const c = new Countdown(2, () =&gt; console.log('DONE'));

c.dec()
c.dec()
// DONE
</code></pre>
<p>上面代码中，<code>Countdown</code>类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="含义-1"><a class="header" href="#含义-1">含义</a></h1>
<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>
<p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>
<p>前文有一个 Generator 函数，依次读取两个文件。</p>
<pre><code class="language-javascript">const fs = require('fs');

const readFile = function (fileName) {
  return new Promise(function (resolve, reject) {
    fs.readFile(fileName, function(error, data) {
      if (error) return reject(error);
      resolve(data);
    });
  });
};

const gen = function* () {
  const f1 = yield readFile('/etc/fstab');
  const f2 = yield readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
</code></pre>
<p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样。</p>
<pre><code class="language-javascript">const asyncReadFile = async function () {
  const f1 = await readFile('/etc/fstab');
  const f2 = await readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
</code></pre>
<p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>
<p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p>
<ul>
<li>
<p>内置执行器。</p>
<p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p>
<pre><code class="language-javascript">asyncReadFile();
</code></pre>
</li>
<li>
<p>更好的语义。</p>
<p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>
</li>
<li>
<p>更广的适用性</p>
<p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p>
</li>
<li>
<p>返回值是 Promise</p>
<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>
</li>
</ul>
<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>
<h1 id="基本用法-6"><a class="header" href="#基本用法-6">基本用法</a></h1>
<pre><code class="language-javascript">// 函数声明
async function foo() {}

// 函数表达式
const foo = async function () {};

// 对象的方法
let obj = { async foo() {} };
obj.foo().then(...)

// Class 的方法
class Storage {
  constructor() {
    this.cachePromise = caches.open('avatars');
  }

  async getAvatar(name) {
    const cache = await this.cachePromise;
    return cache.match(`/avatars/${name}.jpg`);
  }
}

const storage = new Storage();
storage.getAvatar('jake').then(…);

// 箭头函数
const foo = async () =&gt; {};
</code></pre>
<h1 id="语法-4"><a class="header" href="#语法-4">语法</a></h1>
<h2 id="返回-promise-对象"><a class="header" href="#返回-promise-对象">返回 Promise 对象</a></h2>
<p><code>async</code>函数返回一个 Promise 对象。</p>
<p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p>
<pre><code class="language-javascript">async function f() {
  return 'hello world';
}

f().then(v =&gt; console.log(v))
// &quot;hello world&quot;
</code></pre>
<p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p>
<p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p>
<pre><code class="language-javascript">async function f() {
  throw new Error('出错了');
}

f().then(
  v =&gt; console.log(v),
  e =&gt; console.log(e)
)
// Error: 出错了
</code></pre>
<h2 id="promise-对象的状态变化"><a class="header" href="#promise-对象的状态变化">Promise 对象的状态变化</a></h2>
<p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p>
<pre><code class="language-javascript">async function getTitle(url) {
  let response = await fetch(url);
  let html = await response.text();
  return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];
}
getTitle('https://tc39.github.io/ecma262/').then(console.log)
// &quot;ECMAScript 2017 Language Specification&quot;
</code></pre>
<p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p>
<h2 id="await-命令"><a class="header" href="#await-命令">await 命令</a></h2>
<p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>
<pre><code class="language-javascript">async function f() {
  // 等同于
  // return 123;
  return await 123;
}

f().then(v =&gt; console.log(v))
// 123
</code></pre>
<p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，这时等同于<code>return 123</code>。</p>
<p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p>
<pre><code class="language-javascript">class Sleep {
  constructor(timeout) {
    this.timeout = timeout;
  }
  then(resolve, reject) {
    const startTime = Date.now();
    setTimeout(
      () =&gt; resolve(Date.now() - startTime),
      this.timeout
    );
  }
}

(async () =&gt; {
  const sleepTime = await new Sleep(1000);
  console.log(sleepTime);
})();
// 1000
</code></pre>
<p>上面代码中，<code>await</code>命令后面是一个<code>Sleep</code>对象的实例。这个实例不是 Promise 对象，但是因为定义了<code>then</code>方法，<code>await</code>会将其视为<code>Promise</code>处理。</p>
<p>这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助<code>await</code>命令就可以让程序停顿指定的时间。下面给出了一个简化的<code>sleep</code>实现。</p>
<pre><code class="language-javascript">function sleep(interval) {
  return new Promise(resolve =&gt; {
    setTimeout(resolve, interval);
  })
}

// 用法
async function one2FiveInAsync() {
  for(let i = 1; i &lt;= 5; i++) {
    console.log(i);
    await sleep(1000);
  }
}

one2FiveInAsync();
</code></pre>
<p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p>
<pre><code class="language-javascript">async function f() {
  await Promise.reject('出错了');
}

f()
.then(v =&gt; console.log(v))
.catch(e =&gt; console.log(e))
// 出错了
</code></pre>
<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p>
<pre><code class="language-javascript">async function f() {
  try {
    await Promise.reject('出错了');
  } catch(e) {
  }
  return await Promise.resolve('hello world');
}

f()
.then(v =&gt; console.log(v))
// hello world
</code></pre>
<p>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p>
<pre><code class="language-javascript">async function f() {
  await Promise.reject('出错了')
    .catch(e =&gt; console.log(e));
  return await Promise.resolve('hello world');
}

f()
.then(v =&gt; console.log(v))
// 出错了
// hello world
</code></pre>
<h2 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h2>
<p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p>
<pre><code class="language-javascript">async function f() {
  await new Promise(function (resolve, reject) {
    throw new Error('出错了');
  });
}

f()
.then(v =&gt; console.log(v))
.catch(e =&gt; console.log(e))
// Error：出错了
</code></pre>
<p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p>
<pre><code class="language-javascript">const superagent = require('superagent');
const NUM_RETRIES = 3;

async function test() {
  let i;
  for (i = 0; i &lt; NUM_RETRIES; ++i) {
    try {
      await superagent.get('http://google.com/this-throws-an-error');
      break;
    } catch(err) {}
  }
  console.log(i); // 3
}

test();
</code></pre>
<p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p>
<h2 id="使用注意点"><a class="header" href="#使用注意点">使用注意点</a></h2>
<p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p>
<pre><code class="language-javascript">async function myFunction() {
  try {
    await somethingThatReturnsAPromise();
  } catch (err) {
    console.log(err);
  }
}

// 另一种写法

async function myFunction() {
  await somethingThatReturnsAPromise()
  .catch(function (err) {
    console.log(err);
  });
}
</code></pre>
<p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>
<pre><code class="language-javascript">let foo = await getFoo();
let bar = await getBar();
</code></pre>
<p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p>
<p>async 函数的实现原理</p>
<p>与其他异步处理方法的比较
实例：按顺序完成异步操作</p>
<h1 id="顶层-await"><a class="header" href="#顶层-await">顶层 await</a></h1>
<p>根据语法规格，<code>await</code>命令只能出现在 async 函数内部，否则都会报错。</p>
<pre><code class="language-javascript">// 报错
const data = await fetch('https://api.example.com');
</code></pre>
<p>目前，有一个<a href="https://github.com/tc39/proposal-top-level-await">语法提案</a>，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。这个提案的目的，是借用<code>await</code>解决模块异步加载的问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-9"><a class="header" href="#简介-9">简介</a></h1>
<p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>
<h2 id="语法糖"><a class="header" href="#语法糖">语法糖</a></h2>
<p>语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<h2 id="遍历器"><a class="header" href="#遍历器">遍历器</a></h2>
<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<h2 id="特征"><a class="header" href="#特征">特征</a></h2>
<p>形式上，Generator 函数是一个普通函数，但是有两个特征。</p>
<ul>
<li>
<p>一是，<code>function</code>关键字与函数名之间有一个星号；</p>
</li>
<li>
<p>二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p>
</li>
</ul>
<pre><code class="language-javascript">function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

var hw = helloWorldGenerator();
</code></pre>
<p>​	上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p>
<p>​	然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p>
<p>​	下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p>
<pre><code class="language-javascript">返回value与 done属性
hw.next()
// { value: 'hello', done: false }

hw.next()
// { value: 'world', done: false }

hw.next()
// { value: 'ending', done: true }

hw.next()
// { value: undefined, done: true }
</code></pre>
<p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>
<p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>
<p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p>
<p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p>
<h1 id="yield表达式"><a class="header" href="#yield表达式">yield表达式</a></h1>
<p>由于 Generator 函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。</p>
<h2 id="next方法运行逻辑"><a class="header" href="#next方法运行逻辑">next方法运行逻辑</a></h2>
<ol>
<li>
<p>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</p>
</li>
<li>
<p>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式</p>
</li>
<li>
<p>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</p>
</li>
<li>
<p>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</p>
</li>
</ol>
<h2 id="yield限制"><a class="header" href="#yield限制">yield限制</a></h2>
<ul>
<li>
<p><code>yield</code>表达式只能用在 Generator 函数里面</p>
</li>
<li>
<p><code>yield</code>表达式如果用在另一个表达式之中，必须放在圆括号里面。</p>
</li>
<li>
<p>yield表达式用作函数参数或放在赋值表达式的右边 可以不加括号</p>
</li>
</ul>
<h1 id="与-iterator-接口的关系"><a class="header" href="#与-iterator-接口的关系">与 Iterator 接口的关系</a></h1>
<ol>
<li>
<p>任意一个对象的<code>Symbol.iterator</code>方法，等于该对象的遍历器生成函数</p>
</li>
<li>
<p>调用该函数会返回该对象的一个遍历器对象。</p>
</li>
<li>
<p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有 Iterator 接口。</p>
</li>
</ol>
<pre><code class="language-javascript">var myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};

[...myIterable] // [1, 2, 3]
</code></pre>
<p>上面代码中，Generator 函数赋值给<code>Symbol.iterator</code>属性，从而使得<code>myIterable</code>对象具有了 Iterator 接口，可以被<code>...</code>运算符遍历了。</p>
<p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有<code>Symbol.iterator</code>属性，执行后返回自身。</p>
<pre><code class="language-javascript">function* gen(){
  // some code
}

var g = gen();

g[Symbol.iterator]() === g
// true
</code></pre>
<p>上面代码中，<code>gen</code>是一个 Generator 函数，调用它会生成一个遍历器对象<code>g</code>。它的<code>Symbol.iterator</code>属性，也是一个遍历器对象生成函数，执行后返回它自己。</p>
<h1 id="next-方法的参数"><a class="header" href="#next-方法的参数">next 方法的参数</a></h1>
<p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。</p>
<pre><code class="language-javascript">function* dataConsumer() {
  console.log('Started');
  console.log(`1. ${yield}`);
  console.log(`2. ${yield}`);
  return 'result';
}

let genObj = dataConsumer();
genObj.next();
// Started
genObj.next('a')
// 1. a
genObj.next('b')
// 2. b
</code></pre>
<h1 id="forof-循环"><a class="header" href="#forof-循环">for...of 循环</a></h1>
<p><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</p>
<pre><code class="language-javascript">function* foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

for (let v of foo()) {
  console.log(v);
}
// 1 2 3 4 5
</code></pre>
<p>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</p>
<pre><code class="language-javascript">function* numbers () {
  yield 1
  yield 2
  return 3
  yield 4
}

// 扩展运算符
[...numbers()] // [1, 2]

// Array.from 方法
Array.from(numbers()) // [1, 2]

// 解构赋值
let [x, y] = numbers();
x // 1
y // 2

// for...of 循环
for (let n of numbers()) {
  console.log(n)
}
// 1
// 2
</code></pre>
<h1 id="generatorprototypethrow"><a class="header" href="#generatorprototypethrow">Generator.prototype.throw()</a></h1>
<p>Generator 函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p>
<pre><code class="language-javascript">var g = function* () {
  try {
    yield;
  } catch (e) {
    console.log('内部捕获', e);
  }
};

var i = g();
i.next();

try {
  i.throw('a');
  i.throw('b');
} catch (e) {
  console.log('外部捕获', e);
}
// 内部捕获 a
// 外部捕获 b
</code></pre>
<p>注意，不要混淆遍历器对象的<code>throw</code>方法和全局的<code>throw</code>命令。上面代码的错误，是用遍历器对象的<code>throw</code>方法抛出的，而不是用<code>throw</code>命令抛出的。后者只能被函数体外的<code>catch</code>语句捕获。</p>
<p><code>throw</code>方法抛出的错误要被内部捕获，前提是必须至少执行过一次<code>next</code>方法。</p>
<p>上面代码中，<code>g.throw</code>方法被捕获以后，自动执行了一次<code>next</code>方法，所以会打印<code>b</code>。另外，也可以看到，只要 Generator 函数内部部署了<code>try...catch</code>代码块，那么遍历器的<code>throw</code>方法抛出的错误，不影响下一次遍历。</p>
<h1 id="generatorprototypereturn"><a class="header" href="#generatorprototypereturn">Generator.prototype.return()</a></h1>
<p>Generator 函数返回的遍历器对象，还有一个<code>return</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</p>
<pre><code class="language-javascript">function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

var g = gen();

g.next()        // { value: 1, done: false }
g.return('foo') // { value: &quot;foo&quot;, done: true }
g.next()        // { value: undefined, done: true }
</code></pre>
<p>如果 Generator 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return</code>方法会导致立刻进入<code>finally</code>代码块，执行完以后，整个函数才会结束。</p>
<pre><code class="language-javascript">function* numbers () {
  yield 1;
  try {
    yield 2;
    yield 3;
  } finally {
    yield 4;
    yield 5;
  }
  yield 6;
}
var g = numbers();
g.next() // { value: 1, done: false }
g.next() // { value: 2, done: false }
g.return(7) // { value: 4, done: false }
g.next() // { value: 5, done: false }
g.next() // { value: 7, done: true }
</code></pre>
<p>上面代码中，调用<code>return()</code>方法后，就开始执行<code>finally</code>代码块，不执行<code>try</code>里面剩下的代码了，然后等到<code>finally</code>代码块执行完，再返回<code>return()</code>方法指定的返回值。</p>
<h1 id="nextthrowreturn-的共同点"><a class="header" href="#nextthrowreturn-的共同点">next()、throw()、return() 的共同点</a></h1>
<p><code>next()</code>、<code>throw()</code>、<code>return()</code>这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，</p>
<p><code>next()</code>是将<code>yield</code>表达式替换成一个值。</p>
<pre><code class="language-javascript">const g = function* (x, y) {
  let result = yield x + y;
  return result;
};

const gen = g(1, 2);
gen.next(); // Object {value: 3, done: false}

gen.next(1); // Object {value: 1, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = 1;
</code></pre>
<p><code>throw()</code>是将<code>yield</code>表达式替换成一个<code>throw</code>语句。</p>
<pre><code class="language-javascript">gen.throw(new Error('出错了')); // Uncaught Error: 出错了
// 相当于将 let result = yield x + y
// 替换成 let result = throw(new Error('出错了'));
</code></pre>
<h1 id="yield-表达式"><a class="header" href="#yield-表达式">yield* 表达式</a></h1>
<p>如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。</p>
<pre><code class="language-javascript">function* foo() {
  yield 'a';
  yield 'b';
}

function* bar() {
  yield 'x';
  // 手动遍历 foo()
  for (let i of foo()) {
    console.log(i);
  }
  yield 'y';
}

for (let v of bar()){
  console.log(v);
}
// x
// a
// b
// y
</code></pre>
<p>ES6 提供了<code>yield*</code>表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p>
<pre><code class="language-javascript">function* bar() {
  yield 'x';
  yield* foo();
  yield 'y';
}

// 等同于
function* bar() {
  yield 'x';
  yield 'a';
  yield 'b';
  yield 'y';
}

// 等同于
function* bar() {
  yield 'x';
  for (let v of foo()) {
    yield v;
  }
  yield 'y';
}

for (let v of bar()){
  console.log(v);
}
// &quot;x&quot;
// &quot;a&quot;
// &quot;b&quot;
// &quot;y&quot;
</code></pre>
<p>如果<code>yield*</code>后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p>
<pre><code class="language-javascript">function* gen(){
  yield* [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
}

gen().next() // { value:&quot;a&quot;, done:false }
</code></pre>
<p>上面代码中，<code>yield</code>命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。</p>
<p><strong>实际上，任何数据结构只要有 Iterator 接口，就可以被<code>yield*</code>遍历。</strong></p>
<pre><code class="language-javascript">let read = (function* () {
  yield 'hello';
  yield* 'hello';
})();

read.next().value // &quot;hello&quot;
read.next().value // &quot;h&quot;
</code></pre>
<p>上面代码中，<code>yield</code>表达式返回整个字符串，<code>yield*</code>语句返回单个字符。因为字符串具有 Iterator 接口，所以被<code>yield*</code>遍历。</p>
<p><strong>使用<code>yield*</code>语句遍历完全二叉树</strong></p>
<pre><code class="language-javascript">// 下面是二叉树的构造函数，
// 三个参数分别是左树、当前节点和右树
function Tree(left, label, right) {
  this.left = left;
  this.label = label;
  this.right = right;
}

// 下面是中序（inorder）遍历函数。
// 由于返回的是一个遍历器，所以要用generator函数。
// 函数体内采用递归算法，所以左树和右树要用yield*遍历
function* inorder(t) {
  if (t) {
    yield* inorder(t.left);
    yield t.label;
    yield* inorder(t.right);
  }
}

// 下面生成二叉树
function make(array) {
  // 判断是否为叶节点
  if (array.length == 1) return new Tree(null, array[0], null);
  return new Tree(make(array[0]), array[1], make(array[2]));
}
let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);

// 遍历二叉树
var result = [];
for (let node of inorder(tree)) {
  result.push(node);
}

result
// ['a', 'b', 'c', 'd', 'e', 'f', 'g']
</code></pre>
<h1 id="作为对象属性的-generator-函数"><a class="header" href="#作为对象属性的-generator-函数">作为对象属性的 Generator 函数</a></h1>
<p>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</p>
<pre><code class="language-javascript">let obj = {
  * myGeneratorMethod() {
    ···
  }
};
let obj = {
  myGeneratorMethod: function* () {
    // ···
  }
};
</code></pre>
<h1 id="generator-函数的this"><a class="header" href="#generator-函数的this">Generator 函数的this</a></h1>
<p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的<code>prototype</code>对象上的方法。</p>
<h1 id="含义-2"><a class="header" href="#含义-2">含义</a></h1>
<h2 id="generator-与状态机"><a class="header" href="#generator-与状态机">Generator 与状态机</a></h2>
<p>Generator 是实现状态机的最佳结构。比如，下面的<code>clock</code>函数就是一个状态机。</p>
<pre><code class="language-javascript">var clock = function* () {
  while (true) {
    console.log('Tick!');
    yield;
    console.log('Tock!');
    yield;
  }
};
</code></pre>
<p>上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量<code>ticking</code>，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p>
<p>可以实现一种状态的转换</p>
<h2 id="generator-与协程"><a class="header" href="#generator-与协程">Generator 与协程</a></h2>
<p>不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p>
<p>由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p>
<p>Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p>
<p>如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用<code>yield</code>表达式交换控制权。</p>
<h2 id="generator-与上下文"><a class="header" href="#generator-与上下文">Generator 与上下文</a></h2>
<p>JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。</p>
<p>这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。</p>
<p>Generator 函数不是这样，它执行产生的上下文环境，一旦遇到<code>yield</code>命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行<code>next</code>命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</p>
<pre><code class="language-javascript">function* gen() {
  yield 1;
  return 2;
}

let g = gen();

console.log(
  g.next().value,
  g.next().value,
);
</code></pre>
<p>上面代码中，第一次执行<code>g.next()</code>时，Generator 函数<code>gen</code>的上下文会加入堆栈，即开始运行<code>gen</code>内部的代码。等遇到<code>yield 1</code>时，<code>gen</code>上下文退出堆栈，内部状态冻结。第二次执行<code>g.next()</code>时，<code>gen</code>上下文重新加入堆栈，变成当前的上下文，重新恢复执行。</p>
<h1 id="应用-1"><a class="header" href="#应用-1">应用</a></h1>
<p>Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。</p>
<h2 id="异步操作的同步化表达"><a class="header" href="#异步操作的同步化表达">异步操作的同步化表达</a></h2>
<pre><code class="language-javascript">function* loadUI() {
  showLoadingScreen();
  yield loadUIDataAsynchronously();
  hideLoadingScreen();
}
var loader = loadUI();
// 加载UI
loader.next()

// 卸载UI
loader.next()
</code></pre>
<p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面（<code>showLoadingScreen</code>），并且异步加载数据（<code>loadUIDataAsynchronously</code>）。等到数据加载完成，再一次使用<code>next</code>方法，则会隐藏<code>Loading</code>界面。可以看到，这种写法的好处是所有<code>Loading</code>界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p>
<p>Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。</p>
<pre><code class="language-javascript">function* main() {
  var result = yield request(&quot;http://some.url&quot;);
  var resp = JSON.parse(result);
    console.log(resp.value);
}

function request(url) {
  makeAjaxCall(url, function(response){
    it.next(response);
  });
}

var it = main();
it.next();
</code></pre>
<p>上面代码的<code>main</code>函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个<code>yield</code>，它几乎与同步操作的写法完全一样。注意，<code>makeAjaxCall</code>函数中的<code>next</code>方法，必须加上<code>response</code>参数，因为<code>yield</code>表达式，本身是没有值的，总是等于<code>undefined</code>。</p>
<p>下面是另一个例子，通过 Generator 函数逐行读取文本文件。</p>
<pre><code class="language-javascript">function* numbers() {
  let file = new FileReader(&quot;numbers.txt&quot;);
  try {
    while(!file.eof) {
      yield parseInt(file.readLine(), 10);
    }
  } finally {
    file.close();
  }
}
</code></pre>
<p>上面代码打开文本文件，使用<code>yield</code>表达式可以手动逐行读取文件。</p>
<h2 id="控制流管理"><a class="header" href="#控制流管理">控制流管理</a></h2>
<p>采用 Promise 改写上面的代码。</p>
<pre><code class="language-javascript">Promise.resolve(step1)
  .then(step2)
  .then(step3)
  .then(step4)
  .then(function (value4) {
    // Do something with value4
  }, function (error) {
    // Handle any error from step1 through step4
  })
  .done();
</code></pre>
<p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。</p>
<pre><code class="language-javascript">function* longRunningTask(value1) {
  try {
    var value2 = yield step1(value1);
    var value3 = yield step2(value2);
    var value4 = yield step3(value3);
    var value5 = yield step4(value4);
    // Do something with value4
  } catch (e) {
    // Handle any error from step1 through step4
  }
}
</code></pre>
<p>然后，使用一个函数，按次序自动执行所有步骤。</p>
<pre><code class="language-javascript">scheduler(longRunningTask(initialValue));

function scheduler(task) {
  var taskObj = task.next(task.value);
  // 如果Generator函数未结束，就继续调用
  if (!taskObj.done) {
    task.value = taskObj.value
    scheduler(task);
  }
}
</code></pre>
<p>注意，上面这种做法，只适合同步操作，即所有的<code>task</code>都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。</p>
<h2 id="部署-iterator-接口"><a class="header" href="#部署-iterator-接口">部署 Iterator 接口</a></h2>
<p>利用 Generator 函数，可以在任意对象上部署 Iterator 接口。</p>
<pre><code class="language-javascript">function* iterEntries(obj) {
  let keys = Object.keys(obj);
  for (let i=0; i &lt; keys.length; i++) {
    let key = keys[i];
    yield [key, obj[key]];
  }
}

let myObj = { foo: 3, bar: 7 };

for (let [key, value] of iterEntries(myObj)) {
  console.log(key, value);
}

// foo 3
// bar 7
</code></pre>
<h2 id="作为数据结构"><a class="header" href="#作为数据结构">作为数据结构</a></h2>
<p>Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p>
<pre><code class="language-javascript">function* doStuff() {
  yield fs.readFile.bind(null, 'hello.txt');
  yield fs.readFile.bind(null, 'world.txt');
  yield fs.readFile.bind(null, 'and-such.txt');
}
</code></pre>
<p>上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。</p>
<pre><code class="language-javascript">for (task of doStuff()) {
  // task是一个函数，可以像回调函数那样使用它
}
</code></pre>
<p>实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。</p>
<pre><code class="language-javascript">function doStuff() {
  return [
    fs.readFile.bind(null, 'hello.txt'),
    fs.readFile.bind(null, 'world.txt'),
    fs.readFile.bind(null, 'and-such.txt')
  ];
}
</code></pre>
<p>上面的函数，可以用一模一样的<code>for...of</code>循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。</p>
<h1 id="generator-函数的异步应用"><a class="header" href="#generator-函数的异步应用">Generator 函数的异步应用</a></h1>
<p>异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p>
<h2 id="传统方法"><a class="header" href="#传统方法">传统方法</a></h2>
<p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
<p>Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。</p>
<h2 id="-1"><a class="header" href="#-1"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="let命令"><a class="header" href="#let命令">let命令</a></h1>
<h2 id="语法-5"><a class="header" href="#语法-5">语法</a></h2>
<pre><code>let variable_name
</code></pre>
<h2 id="块级作用域"><a class="header" href="#块级作用域">块级作用域</a></h2>
<ul>
<li>
<p>为什么需要块级作用域?</p>
<p>ES5 只有全局作用域和函数作用域，没有块级作用域</p>
</li>
<li>
<p>只有子作用域可以访问父作用域的变量,其他均不能访问</p>
</li>
<li>
<p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。-- 暂时性死区 (temporal dead zone)</p>
<pre><code class="language-js">这样的typeof会报错
let a = 1
        {
            typeof a
            let a = 1
        }
</code></pre>
</li>
<li>
<p>作用域可以嵌套</p>
<pre><code class="language-javascript">{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};
</code></pre>
</li>
<li>
<p>重复申明</p>
<ul>
<li>类似java的变量作用域,不同点之出在于 不同作用域之间可以重复命名</li>
<li>同一作用域之间 的同名变量不能重复申明</li>
</ul>
</li>
</ul>
<h2 id="块级作用域与函数声明"><a class="header" href="#块级作用域与函数声明">块级作用域与函数声明</a></h2>
<p><strong>不支持在块级作用域中申明函数</strong></p>
<p>​	ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<pre><code class="language-javascript">// 情况一
if (true) {
  function f() {}
}

// 情况二
try {
  function f() {}
} catch(e) {
  // ...
}
</code></pre>
<p><strong>ES6 中 在块级作用域函数声明</strong></p>
<p>​	明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p>
<pre><code class="language-javascript">// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
</code></pre>
<p>​	理论上面的代码在 ES6 浏览器中，都会报错。因为兼容问题,ES6 在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics">附录 B</a>里面规定，浏览器的实现可以不遵守上面的规定，有自己的<a href="http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6">行为方式</a>。</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p>应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<p><strong>变量的申明必须要有 <em>{}</em></strong></p>
<pre><code class="language-javascript">// 第一种写法，报错
if (true) let x = 1;

// 第二种写法，不报错
if (true) {
  let x = 1;
}
</code></pre>
<h1 id="const命令"><a class="header" href="#const命令">const命令</a></h1>
<ul>
<li><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</li>
<li>只是引用不可变, 引用所指向的内容可以变</li>
</ul>
<h2 id="es6中声明变量的六种方法"><a class="header" href="#es6中声明变量的六种方法">ES6中声明变量的六种方法</a></h2>
<ul>
<li>ES5: <code>var</code>命令和<code>function</code>命令</li>
<li>ES6: let const , import,class</li>
</ul>
<h1 id="顶层对象的属性"><a class="header" href="#顶层对象的属性">顶层对象的属性</a></h1>
<p>​	顶层对象，在浏览器环境指的是<code>window</code>对象，在 Node 指的是<code>global</code>对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p>
<pre><code>window.a = 1;
a // 1

a = 2;
window.a // 2
</code></pre>
<p><strong>顶层对象的属性与全局变量挂钩 败笔</strong></p>
<ul>
<li>
<p>没法在编译时就报出变量未声明的错误</p>
<p>只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）</p>
</li>
<li>
<p>程序员很容易不知不觉地就创建了全局变量</p>
</li>
<li>
<p>顶层对象的属性是到处可以读写的，这非常不利于模块化编程</p>
</li>
<li>
<p><code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>
</li>
</ul>
<h2 id="es6对顶层对象的改变"><a class="header" href="#es6对顶层对象的改变">ES6对顶层对象的改变</a></h2>
<ul>
<li>为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性</li>
<li><code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性(从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。)</li>
</ul>
<h2 id="globalthis-对象"><a class="header" href="#globalthis-对象">globalThis 对象</a></h2>
<p><strong>顶层对象不统一的实现</strong></p>
<p>​	JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行,但是，顶层对象在各种实现里面是不统一的。</p>
<ul>
<li>浏览器里面，顶层对象是<code>window</code>，但 Node 和 Web Worker 没有<code>window</code>。</li>
<li>浏览器和 Web Worker 里面，<code>self</code>也指向顶层对象，但是 Node 没有<code>self</code>。</li>
<li>Node 里面，顶层对象是<code>global</code>，但其他环境都不支持。</li>
</ul>
<p><strong>一般使用<em>this</em> 返回顶层对象 但是有局限性</strong></p>
<ul>
<li>全局环境中，<code>this</code>会返回顶层对象。但是，Node 模块和 ES6 模块中，<code>this</code>返回的是当前模块。</li>
<li>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code>。</li>
<li>不管是严格模式，还是普通模式，<code>new Function('return this')()</code>，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</li>
</ul>
<p><strong>很难找到一种方法，可以在所有情况下，都取到顶层对象</strong></p>
<pre><code class="language-javascript">// 方法一
(typeof window !== 'undefined'
   ? window
   : (typeof process === 'object' &amp;&amp;
      typeof require === 'function' &amp;&amp;
      typeof global === 'object')
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
</code></pre>
<p><a href="https://github.com/tc39/proposal-global">ES2020</a> 在语言标准的层面，引入<code>globalThis</code>作为顶层对象。也就是说，任何环境下，<code>globalThis</code>都是存在的，都可以从它拿到顶层对象，指向全局环境下的<code>this</code>。</p>
<p>垫片库<a href="https://github.com/ungap/global-this"><code>global-this</code></a>模拟了这个提案，可以在所有环境拿到<code>globalThis</code>。</p>
<h1 id="变量的解构赋值"><a class="header" href="#变量的解构赋值">变量的解构赋值</a></h1>
<h2 id="数组的解构赋值"><a class="header" href="#数组的解构赋值">数组的解构赋值</a></h2>
<p><strong>什么是结构赋值</strong></p>
<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</p>
<p><strong>案例</strong></p>
<pre><code class="language-javascript">let a = 1;
let b = 2;
let c = 3;

ES6 允许写成下面这样。

let [a, b, c] = [1, 2, 3];

let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // &quot;a&quot;
y // undefined
z // []


</code></pre>
<p><strong>总结</strong></p>
<ul>
<li>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>
</li>
<li>
<p>如果解构不成功，变量的值就等于<code>undefined</code>。</p>
</li>
<li>
<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
</li>
<li>
<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<p>(参见《Generator 函数》一章)</p>
</li>
</ul>
<pre><code>//全都报错,因为不可迭代
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
</code></pre>
<p><strong>默认值</strong></p>
<pre><code class="language-javascript">let [foo = true] = [];
foo // true

let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
</code></pre>
<blockquote>
<p>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</p>
</blockquote>
<p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code></p>
<pre><code class="language-javascript">let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
</code></pre>
<p><strong>惰性求值</strong></p>
<p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>
<pre><code class="language-javascript">function f() {
  console.log('aaa');
}

let [x = f()] = [1];
</code></pre>
<p><strong>引用解构赋值的其他变量</strong></p>
<blockquote>
<p>该变量必须已经声明。</p>
</blockquote>
<pre><code class="language-javascript">let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError: y is not defined
</code></pre>
<h2 id="对象结构赋值"><a class="header" href="#对象结构赋值">对象结构赋值</a></h2>
<p><strong>案例</strong></p>
<pre><code class="language-javascript">let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;
</code></pre>
<p><strong>变量赋值是根据名称来取得</strong></p>
<p>​	的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<p><strong>解构失败,值为undefined</strong></p>
<pre><code class="language-javascript">let {foo} = {bar: 'baz'};
foo // undefined
</code></pre>
<p><strong>已有对象赋值</strong></p>
<pre><code class="language-javascript">// 例一, 将Math对象得 三个方法拿出来赋值
let { log, sin, cos } = Math;

// 例二,将console得 log方法拿出来
const { log } = console;
log('hello') // hello
</code></pre>
<p><strong>对象赋值原理</strong></p>
<pre><code class="language-javascript">let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // &quot;aaa&quot;
foo // error: foo is not defined
</code></pre>
<p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p>
<pre><code class="language-javascript">let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
</code></pre>
<p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code></p>
<p><strong>嵌套解构</strong></p>
<pre><code class="language-javascript">let obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};

let { p: [x, { y }] } = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;
</code></pre>
<pre><code class="language-javascript">let obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};

let { p, p: [x, { y }] } = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;
p // [&quot;Hello&quot;, {y: &quot;World&quot;}]
</code></pre>
<p><strong>个人理解</strong></p>
<p>模式得写法 就是将 原本对象存在值得地方替换成变量即可</p>
<pre><code class="language-javascript">    const node = {
        loc: {
            start: {
                line: 1,
                column: 5
            }
        }
    };

    let {
        
        loc: {
            start: {
                line: x,
                column: y
            }
        },
    
        loc: {
            start: e
        }
    } = node;

    console.log(x,y);
    console.log(e.column,e.line);
</code></pre>
<p>对象中继承的属性 可以解构</p>
<pre><code class="language-javascript">const obj1 = {};
const obj2 = { foo: 'bar' };
Object.setPrototypeOf(obj1, obj2);

const { foo } = obj1;
foo // &quot;bar&quot;
</code></pre>
<p><strong>默认值</strong></p>
<pre><code class="language-javascript">var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5

var {x: y = 3} = {};
y // 3

var {x: y = 3} = {x: 5};
y // 5

var { message: msg = 'Something went wrong' } = {};
msg // &quot;Something went wrong&quot;
</code></pre>
<p>必须是<em>undefined</em></p>
<pre><code class="language-javascript">var {x = 3} = {x: undefined};
x // 3

var {x = 3} = {x: null};
x // null
</code></pre>
<p><strong>对于已经申明过的变量的解构赋值</strong></p>
<pre><code class="language-javascript">// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error
</code></pre>
<p>​	因为这会使解析引擎错误的认为是代码块,正确的赋值方式是使用 <em>()</em> 括号包裹</p>
<p><strong>解构左边没有任何变量名</strong></p>
<p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p>
<pre><code class="language-javascript">({} = [true, false]);
({} = 'abc');
({} = []);
</code></pre>
<p><strong>数组本质是特殊的对象</strong></p>
<p>可以对数组进行对象属性的解构,根据索引 进行模式匹配</p>
<pre><code class="language-javascript">let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
</code></pre>
<h2 id="字符串解构赋值"><a class="header" href="#字符串解构赋值">字符串解构赋值</a></h2>
<p>字符串解构有两种方式</p>
<p><strong>示例</strong></p>
<pre><code class="language-javascript">//字符串被转换成了一个类似数组的对象
const [a, b, c, d, e] = 'hello';
a // &quot;h&quot;
b // &quot;e&quot;
c // &quot;l&quot;
d // &quot;l&quot;
e // &quot;o&quot;
//对象解构赋值
let {length : len} = 'hello';
len // 5

</code></pre>
<h2 id="数值和布尔值的解构赋值"><a class="header" href="#数值和布尔值的解构赋值">数值和布尔值的解构赋值</a></h2>
<p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<pre><code class="language-javascript">let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
</code></pre>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<pre><code class="language-javascript">let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
</code></pre>
<h2 id="函数参数的解构赋值"><a class="header" href="#函数参数的解构赋值">函数参数的解构赋值</a></h2>
<p><strong>一般的参数解构</strong></p>
<pre><code class="language-javascript">function add([x, y]){
  return x + y;
}

add([1, 2]); // 3

[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);
</code></pre>
<p><strong>内建函数的参数解构</strong></p>
<pre><code class="language-javascript">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);
// [ 3, 7 ]
</code></pre>
<p><strong>函数参数的解构也可以使用默认</strong></p>
<pre><code class="language-javascript">//参数串:  {x = 0, y = 0} = {}  表明该函数参数是一个对象, 且默认值为{} , 且会被自动解构成x,y,且解构有默认值
function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
</code></pre>
<p><strong><code>undefined</code>就会触发函数参数的默认值。</strong></p>
<pre><code class="language-javascript">[1, undefined, 3].map((x = 'yes') =&gt; x);
// [ 1, 'yes', 3 ]
</code></pre>
<h2 id="圆括号问题"><a class="header" href="#圆括号问题">圆括号问题</a></h2>
<h3 id="以下三种解构赋值不得使用圆括号"><a class="header" href="#以下三种解构赋值不得使用圆括号">以下三种解构赋值不得使用圆括号。</a></h3>
<ul>
<li>
<p><strong>变量声明语句</strong></p>
<pre><code class="language-javascript">// 全部报错
let [(a)] = [1];

let {x: (c)} = {};
let ({x: c}) = {};
let {(x: c)} = {};
let {(x): c} = {};

let { o: ({ p: p }) } = { o: { p: 2 } };
</code></pre>
</li>
<li>
<p><strong>函数参数</strong></p>
<blockquote>
<p>函数参数也属于变量声明，因此不能带有圆括号。</p>
</blockquote>
</li>
</ul>
<pre><code class="language-javascript">// 报错
function f([(z)]) { return z; }
// 报错
function f([z,(x)]) { return x; }
</code></pre>
<ul>
<li>
<p><strong>赋值语句的模式</strong></p>
<pre><code class="language-javascript">// 全部报错
({ p: a }) = { p: 42 };
([a]) = [5];
</code></pre>
</li>
</ul>
<h3 id="可以使用圆括号的情况"><a class="header" href="#可以使用圆括号的情况">可以使用圆括号的情况</a></h3>
<p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<pre><code class="language-javascript">[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确
</code></pre>
<h2 id="解构的用途"><a class="header" href="#解构的用途">解构的用途</a></h2>
<h3 id="交换变量的值"><a class="header" href="#交换变量的值"><strong>交换变量的值</strong></a></h3>
<pre><code class="language-javascript">[x, y] = [y, x];
</code></pre>
<h3 id="从函数返回多个值"><a class="header" href="#从函数返回多个值"><strong>从函数返回多个值</strong></a></h3>
<pre><code class="language-javascript">// 返回一个数组

function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();
</code></pre>
<h3 id="函数参数的定义"><a class="header" href="#函数参数的定义"><strong>函数参数的定义</strong></a></h3>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<pre><code class="language-javascript">// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
</code></pre>
<h3 id="提取-json-数据"><a class="header" href="#提取-json-数据"><strong>提取 JSON 数据</strong></a></h3>
<pre><code class="language-javascript">let jsonData = {
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]
</code></pre>
<h3 id="函数参数的默认值"><a class="header" href="#函数参数的默认值"><strong>函数参数的默认值</strong></a></h3>
<p>​	指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || 'default foo';</code>这样的语句。</p>
<pre><code class="language-javascript">jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
} = {}) {
  // ... do stuff
};
</code></pre>
<h3 id="遍历-map-结构"><a class="header" href="#遍历-map-结构"><strong>遍历 Map 结构</strong></a></h3>
<p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<pre><code class="language-javascript">const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
  console.log(key + &quot; is &quot; + value);
}
// first is hello
// second is world
</code></pre>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<pre><code class="language-javascript">// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}
</code></pre>
<p><strong>输入模块的指定方法</strong></p>
<pre><code class="language-javascript">const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);
</code></pre>
<p>{% raw %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述"><a class="header" href="#概述">概述</a></h1>
<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 实例的方法
Proxy.revocable()
this 问题
实例：Web 服务的客户端</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-1"><a class="header" href="#概述-1">概述</a></h1>
<h2 id="引入symbol的原因"><a class="header" href="#引入symbol的原因">引入symbol的原因</a></h2>
<p>​	ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>
<h2 id="使用方式"><a class="header" href="#使用方式">使用方式</a></h2>
<p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<pre><code class="language-javascript">let s = Symbol();

typeof s
// &quot;symbol&quot;
</code></pre>
<p>​	<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<pre><code class="language-javascript">let s1 = Symbol('foo');
let s2 = Symbol('bar');

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // &quot;Symbol(foo)&quot;
s2.toString() // &quot;Symbol(bar)&quot;
</code></pre>
<p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。</p>
<pre><code class="language-javascript">const obj = {
  toString() {
    return 'abc';
  }
};
const sym = Symbol(obj);
sym // Symbol(abc)
</code></pre>
<p>，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p>
<pre><code class="language-javascript">// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();

s1 === s2 // false

// 有参数的情况
let s1 = Symbol('foo');
let s2 = Symbol('foo');

s1 === s2 // false
</code></pre>
<p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。</p>
<p>Symbol 值不能与其他类型的值进行运算，会报错。</p>
<pre><code class="language-javascript">let sym = Symbol('My symbol');

&quot;your symbol is &quot; + sym
// TypeError: can't convert symbol to string
`your symbol is ${sym}`
// TypeError: can't convert symbol to string
</code></pre>
<p>但是，Symbol 值可以显式转为字符串。</p>
<pre><code class="language-javascript">let sym = Symbol('My symbol');

String(sym) // 'Symbol(My symbol)'
sym.toString() // 'Symbol(My symbol)'
</code></pre>
<p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>
<pre><code class="language-javascript">let sym = Symbol();
Boolean(sym) // true
!sym  // false

if (sym) {
  // ...
}

Number(sym) // TypeError
sym + 2 // TypeError
</code></pre>
<h2 id="symbolprototypedescription"><a class="header" href="#symbolprototypedescription">Symbol.prototype.description</a></h2>
<p>创建 Symbol 的时候，可以添加一个描述。</p>
<pre><code class="language-javascript">const sym = Symbol('foo');
</code></pre>
<p>上面代码中，<code>sym</code>的描述就是字符串<code>foo</code>。</p>
<p>但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。</p>
<pre><code class="language-javascript">const sym = Symbol('foo');

String(sym) // &quot;Symbol(foo)&quot;
sym.toString() // &quot;Symbol(foo)&quot;
</code></pre>
<p>上面的用法不是很方便。<a href="https://github.com/tc39/proposal-Symbol-description">ES2019</a> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。</p>
<pre><code class="language-javascript">const sym = Symbol('foo');

sym.description // &quot;foo&quot;
</code></pre>
<h1 id="作为属性名的-symbol"><a class="header" href="#作为属性名的-symbol">作为属性名的 Symbol</a></h1>
<p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<pre><code class="language-javascript">let mySymbol = Symbol();

// 第一种写法
let a = {};
a[mySymbol] = 'Hello!';

// 第二种写法
let a = {
  [mySymbol]: 'Hello!'
};

// 第三种写法
let a = {};
Object.defineProperty(a, mySymbol, { value: 'Hello!' });

// 以上写法都得到同样结果
a[mySymbol] // &quot;Hello!&quot;
</code></pre>
<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<pre><code class="language-javascript">const mySymbol = Symbol();
const a = {};

a.mySymbol = 'Hello!';
a[mySymbol] // undefined
a['mySymbol'] // &quot;Hello!&quot;
</code></pre>
<p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。</p>
<p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<pre><code class="language-javascript">let s = Symbol();

let obj = {
  [s]: function (arg) { ... }
};

obj[s](123);
</code></pre>
<p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值。</p>
<p>采用增强的对象写法，上面代码的<code>obj</code>对象可以写得更简洁一些。</p>
<pre><code class="language-javascript">let obj = {
  [s](arg) { ... }
};
</code></pre>
<p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>
<pre><code class="language-javascript">const log = {};

log.levels = {
  DEBUG: Symbol('debug'),
  INFO: Symbol('info'),
  WARN: Symbol('warn')
};
console.log(log.levels.DEBUG, 'debug message');
console.log(log.levels.INFO, 'info message');
</code></pre>
<p>下面是另外一个例子。</p>
<pre><code class="language-javascript">const COLOR_RED    = Symbol();
const COLOR_GREEN  = Symbol();

function getComplement(color) {
  switch (color) {
    case COLOR_RED:
      return COLOR_GREEN;
    case COLOR_GREEN:
      return COLOR_RED;
    default:
      throw new Error('Undefined color');
    }
}
</code></pre>
<p>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按设计的方式工作。</p>
<p>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p>
<h1 id="实例消除魔术字符串"><a class="header" href="#实例消除魔术字符串">实例：消除魔术字符串</a></h1>
<p>​	魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p>
<pre><code class="language-javascript">function getArea(shape, options) {
  let area = 0;

  switch (shape) {
    case 'Triangle': // 魔术字符串
      area = .5 * options.width * options.height;
      break;
    /* ... more code ... */
  }

  return area;
}

getArea('Triangle', { width: 100, height: 100 }); // 魔术字符串
</code></pre>
<p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p>
<p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p>
<pre><code class="language-javascript">const shapeType = {
  triangle: 'Triangle'
};

function getArea(shape, options) {
  let area = 0;
  switch (shape) {
    case shapeType.triangle:
      area = .5 * options.width * options.height;
      break;
  }
  return area;
}

getArea(shapeType.triangle, { width: 100, height: 100 });
</code></pre>
<p>上面代码中，我们把<code>Triangle</code>写成<code>shapeType</code>对象的<code>triangle</code>属性，这样就消除了强耦合。</p>
<p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会跟其他<code>shapeType</code>属性的值冲突即可。因此，这里就很适合改用 Symbol 值。</p>
<pre><code class="language-javascript">const shapeType = {
  triangle: Symbol()
};
</code></pre>
<p>上面代码中，除了将<code>shapeType.triangle</code>的值设为一个 Symbol，其他地方都不用修改。</p>
<h1 id="属性名的遍历"><a class="header" href="#属性名的遍历">属性名的遍历</a></h1>
<p>​	Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p>
<p>但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<pre><code class="language-javascript">const obj = {};
let a = Symbol('a');
let b = Symbol('b');

obj[a] = 'Hello';
obj[b] = 'World';

const objectSymbols = Object.getOwnPropertySymbols(obj);

objectSymbols
// [Symbol(a), Symbol(b)]
</code></pre>
<p>上面代码是<code>Object.getOwnPropertySymbols()</code>方法的示例，可以获取所有 Symbol 属性名。</p>
<p>下面是另一个例子，<code>Object.getOwnPropertySymbols()</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子。</p>
<pre><code class="language-javascript">const obj = {};
const foo = Symbol('foo');

obj[foo] = 'bar';

for (let i in obj) {
  console.log(i); // 无输出
}

Object.getOwnPropertyNames(obj) // []
Object.getOwnPropertySymbols(obj) // [Symbol(foo)]
</code></pre>
<p>上面代码中，使用<code>for...in</code>循环和<code>Object.getOwnPropertyNames()</code>方法都得不到 Symbol 键名，需要使用<code>Object.getOwnPropertySymbols()</code>方法。</p>
<p>另一个新的 API，<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<pre><code class="language-javascript">let obj = {
  [Symbol('my_key')]: 1,
  enum: 2,
  nonEnum: 3
};

Reflect.ownKeys(obj)
//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]
</code></pre>
<p>由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<pre><code class="language-javascript">let size = Symbol('size');

class Collection {
  constructor() {
    this[size] = 0;
  }

  add(item) {
    this[this[size]] = item;
    this[size]++;
  }

  static sizeOf(instance) {
    return instance[size];
  }
}

let x = new Collection();
Collection.sizeOf(x) // 0

x.add('foo');
Collection.sizeOf(x) // 1

Object.keys(x) // ['0']
Object.getOwnPropertyNames(x) // ['0']
Object.getOwnPropertySymbols(x) // [Symbol(size)]
</code></pre>
<p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个 Symbol 值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它。这就造成了一种非私有的内部方法的效果。</p>
<h1 id="symbolforsymbolkeyfor"><a class="header" href="#symbolforsymbolkeyfor">Symbol.for()，Symbol.keyFor()</a></h1>
<p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p>
<pre><code class="language-javascript">let s1 = Symbol.for('foo');
let s2 = Symbol.for('foo');

s1 === s2 // true
</code></pre>
<p>上面代码中，<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p>
<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</p>
<pre><code class="language-javascript">Symbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;)
// true

Symbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;)
// false
</code></pre>
<p>上面代码中，由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p>
<p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p>
<pre><code class="language-javascript">let s1 = Symbol.for(&quot;foo&quot;);
Symbol.keyFor(s1) // &quot;foo&quot;

let s2 = Symbol(&quot;foo&quot;);
Symbol.keyFor(s2) // undefined
</code></pre>
<p>上面代码中，变量<code>s2</code>属于未登记的 Symbol 值，所以返回<code>undefined</code>。</p>
<p>注意，<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。</p>
<pre><code class="language-javascript">function foo() {
  return Symbol.for('bar');
}

const x = foo();
const y = Symbol.for('bar');
console.log(x === y); // true
</code></pre>
<p>上面代码中，<code>Symbol.for('bar')</code>是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行<code>Symbol.for('bar')</code>可以取到这个 Symbol 值。</p>
<p><code>Symbol.for()</code>的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。</p>
<pre><code class="language-javascript">iframe = document.createElement('iframe');
iframe.src = String(window.location);
document.body.appendChild(iframe);

iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo')
// true
</code></pre>
<p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。</p>
<h1 id="实例模块的-singleton-模式"><a class="header" href="#实例模块的-singleton-模式">实例：模块的 Singleton 模式</a></h1>
<p>Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。</p>
<p>对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p>
<p>很容易想到，可以把实例放到顶层对象<code>global</code>。</p>
<pre><code class="language-javascript">// mod.js
function A() {
  this.foo = 'hello';
}

if (!global._foo) {
  global._foo = new A();
}

module.exports = global._foo;
</code></pre>
<p>然后，加载上面的<code>mod.js</code>。</p>
<pre><code class="language-javascript">const a = require('./mod.js');
console.log(a.foo);
</code></pre>
<p>上面代码中，变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例。</p>
<p>但是，这里有一个问题，全局变量<code>global._foo</code>是可写的，任何文件都可以修改。</p>
<pre><code class="language-javascript">global._foo = { foo: 'world' };

const a = require('./mod.js');
console.log(a.foo);
</code></pre>
<p>上面的代码，会使得加载<code>mod.js</code>的脚本都失真。</p>
<p>为了防止这种情况出现，我们就可以使用 Symbol。</p>
<pre><code class="language-javascript">// mod.js
const FOO_KEY = Symbol.for('foo');

function A() {
  this.foo = 'hello';
}

if (!global[FOO_KEY]) {
  global[FOO_KEY] = new A();
}

module.exports = global[FOO_KEY];
</code></pre>
<p>上面代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p>
<pre><code class="language-javascript">global[Symbol.for('foo')] = { foo: 'world' };

const a = require('./mod.js');
</code></pre>
<p>如果键名使用<code>Symbol</code>方法生成，那么外部将无法引用这个值，当然也就无法改写。</p>
<pre><code class="language-javascript">// mod.js
const FOO_KEY = Symbol('foo');

// 后面代码相同 ……
</code></pre>
<p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的<code>FOO_KEY</code>都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。</p>
<h1 id="内置的-symbol-值"><a class="header" href="#内置的-symbol-值">内置的 Symbol 值</a></h1>
<p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p>
<h3 id="symbolhasinstance"><a class="header" href="#symbolhasinstance">Symbol.hasInstance</a></h3>
<p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p>
<pre><code class="language-javascript">class MyClass {
  [Symbol.hasInstance](foo) {
    return foo instanceof Array;
  }
}

[1, 2, 3] instanceof new MyClass() // true
</code></pre>
<p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p>
<pre><code class="language-javascript">class Even {
  static [Symbol.hasInstance](obj) {
    return Number(obj) % 2 === 0;
  }
}

// 等同于
const Even = {
  [Symbol.hasInstance](obj) {
    return Number(obj) % 2 === 0;
  }
};

1 instanceof Even // false
2 instanceof Even // true
12345 instanceof Even // false
</code></pre>
<h3 id="symbolisconcatspreadable"><a class="header" href="#symbolisconcatspreadable">Symbol.isConcatSpreadable</a></h3>
<p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否要展开。是否可以展开</p>
<pre><code class="language-javascript">let arr1 = ['c', 'd'];
['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']
arr1[Symbol.isConcatSpreadable] // undefined

let arr2 = ['c', 'd'];
arr2[Symbol.isConcatSpreadable] = false;
['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']
</code></pre>
<p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p>
<p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p>
<pre><code class="language-javascript">let obj = {length: 2, 0: 'c', 1: 'd'};
['a', 'b'].concat(obj, 'e') // ['a', 'b', obj, 'e']

obj[Symbol.isConcatSpreadable] = true;
['a', 'b'].concat(obj, 'e') // ['a', 'b', 'c', 'd', 'e']
</code></pre>
<p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p>
<pre><code class="language-javascript">class A1 extends Array {
  constructor(args) {
    super(args);
    this[Symbol.isConcatSpreadable] = true;
  }
}
class A2 extends Array {
  constructor(args) {
    super(args);
  }
  get [Symbol.isConcatSpreadable] () {
    return false;
  }
}
let a1 = new A1();
a1[0] = 3;
a1[1] = 4;
let a2 = new A2();
a2[0] = 5;
a2[1] = 6;
[1, 2].concat(a1).concat(a2)
// [1, 2, 3, 4, [5, 6]]
</code></pre>
<p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p>
<p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p>
<h2 id="symbolspecies"><a class="header" href="#symbolspecies">Symbol.species</a></h2>
<p>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p>
<pre><code class="language-javascript">class MyArray extends Array {
}

const a = new MyArray(1, 2, 3);
const b = a.map(x =&gt; x);
const c = a.filter(x =&gt; x &gt; 1);

b instanceof MyArray // true
c instanceof MyArray // true
</code></pre>
<p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，<code>a</code>是<code>MyArray</code>的实例，<code>b</code>和<code>c</code>是<code>a</code>的衍生对象。你可能会认为，<code>b</code>和<code>c</code>都是调用数组方法生成的，所以应该是数组（<code>Array</code>的实例），但实际上它们也是<code>MyArray</code>的实例。</p>
<p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。现在，我们可以为<code>MyArray</code>设置<code>Symbol.species</code>属性。</p>
<pre><code class="language-javascript">class MyArray extends Array {
  static get [Symbol.species]() { return Array; }
}
</code></pre>
<p>上面代码中，由于定义了<code>Symbol.species</code>属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>取值器。默认的<code>Symbol.species</code>属性等同于下面的写法。</p>
<pre><code class="language-javascript">static get [Symbol.species]() {
  return this;
}
</code></pre>
<p>现在，再来看前面的例子。</p>
<pre><code class="language-javascript">class MyArray extends Array {
  static get [Symbol.species]() { return Array; }
}

const a = new MyArray();
const b = a.map(x =&gt; x);

b instanceof MyArray // false
b instanceof Array // true
</code></pre>
<p>上面代码中，<code>a.map(x =&gt; x)</code>生成的衍生对象，就不是<code>MyArray</code>的实例，而直接就是<code>Array</code>的实例。</p>
<p>再看一个例子。</p>
<pre><code class="language-javascript">class T1 extends Promise {
}

class T2 extends Promise {
  static get [Symbol.species]() {
    return Promise;
  }
}

new T1(r =&gt; r()).then(v =&gt; v) instanceof T1 // true
new T2(r =&gt; r()).then(v =&gt; v) instanceof T2 // false
</code></pre>
<p>上面代码中，<code>T2</code>定义了<code>Symbol.species</code>属性，<code>T1</code>没有。结果就导致了创建衍生对象时（<code>then</code>方法），<code>T1</code>调用的是自身的构造方法，而<code>T2</code>调用的是<code>Promise</code>的构造方法。</p>
<p>总之，<code>Symbol.species</code>的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p>
<h2 id="symbolmatch"><a class="header" href="#symbolmatch">Symbol.match</a></h2>
<p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p>
<pre><code class="language-javascript">String.prototype.match(regexp)
// 等同于
regexp[Symbol.match](this)

class MyMatcher {
  [Symbol.match](string) {
    return 'hello world'.indexOf(string);
  }
}

'e'.match(new MyMatcher()) // 1
</code></pre>
<h2 id="symbolreplace"><a class="header" href="#symbolreplace">Symbol.replace</a></h2>
<p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p>
<pre><code class="language-javascript">String.prototype.replace(searchValue, replaceValue)
// 等同于
searchValue[Symbol.replace](this, replaceValue)
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="language-javascript">const x = {};
x[Symbol.replace] = (...s) =&gt; console.log(s);

'Hello'.replace(x, 'World') // [&quot;Hello&quot;, &quot;World&quot;]
</code></pre>
<p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p>
<h2 id="symbolsearch"><a class="header" href="#symbolsearch">Symbol.search</a></h2>
<p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p>
<pre><code class="language-javascript">String.prototype.search(regexp)
// 等同于
regexp[Symbol.search](this)

class MySearch {
  constructor(value) {
    this.value = value;
  }
  [Symbol.search](string) {
    return string.indexOf(this.value);
  }
}
'foobar'.search(new MySearch('foo')) // 0
</code></pre>
<h2 id="symbolsplit"><a class="header" href="#symbolsplit">Symbol.split</a></h2>
<p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p>
<pre><code class="language-javascript">String.prototype.split(separator, limit)
// 等同于
separator[Symbol.split](this, limit)
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="language-javascript">class MySplitter {
  constructor(value) {
    this.value = value;
  }
  [Symbol.split](string) {
    let index = string.indexOf(this.value);
    if (index === -1) {
      return string;
    }
    return [
      string.substr(0, index),
      string.substr(index + this.value.length)
    ];
  }
}

'foobar'.split(new MySplitter('foo'))
// ['', 'bar']

'foobar'.split(new MySplitter('bar'))
// ['foo', '']

'foobar'.split(new MySplitter('baz'))
// 'foobar'
</code></pre>
<p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为，</p>
<h2 id="symboliterator"><a class="header" href="#symboliterator">Symbol.iterator</a></h2>
<p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</p>
<pre><code class="language-javascript">const myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};

[...myIterable] // [1, 2, 3]
</code></pre>
<p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for...of 循环》一章。</p>
<pre><code class="language-javascript">class Collection {
  *[Symbol.iterator]() {
    let i = 0;
    while(this[i] !== undefined) {
      yield this[i];
      ++i;
    }
  }
}

let myCollection = new Collection();
myCollection[0] = 1;
myCollection[1] = 2;

for(let value of myCollection) {
  console.log(value);
}
// 1
// 2
</code></pre>
<h2 id="symboltoprimitive"><a class="header" href="#symboltoprimitive">Symbol.toPrimitive</a></h2>
<p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>
<p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>
<ul>
<li>Number：该场合需要转成数值</li>
<li>String：该场合需要转成字符串</li>
<li>Default：该场合可以转成数值，也可以转成字符串</li>
</ul>
<pre><code class="language-javascript">let obj = {
  [Symbol.toPrimitive](hint) {
    switch (hint) {
      case 'number':
        return 123;
      case 'string':
        return 'str';
      case 'default':
        return 'default';
      default:
        throw new Error();
     }
   }
};

2 * obj // 246
3 + obj // '3default'
obj == 'default' // true
String(obj) // 'str'
</code></pre>
<h2 id="symboltostringtag"><a class="header" href="#symboltostringtag">Symbol.toStringTag</a></h2>
<p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p>
<pre><code class="language-javascript">// 例一
({[Symbol.toStringTag]: 'Foo'}.toString())
// &quot;[object Foo]&quot;

// 例二
class Collection {
  get [Symbol.toStringTag]() {
    return 'xxx';
  }
}
let x = new Collection();
Object.prototype.toString.call(x) // &quot;[object xxx]&quot;
</code></pre>
<p>ES6 新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p>
<ul>
<li><code>JSON[Symbol.toStringTag]</code>：'JSON'</li>
<li><code>Math[Symbol.toStringTag]</code>：'Math'</li>
<li>Module 对象<code>M[Symbol.toStringTag]</code>：'Module'</li>
<li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>：'ArrayBuffer'</li>
<li><code>DataView.prototype[Symbol.toStringTag]</code>：'DataView'</li>
<li><code>Map.prototype[Symbol.toStringTag]</code>：'Map'</li>
<li><code>Promise.prototype[Symbol.toStringTag]</code>：'Promise'</li>
<li><code>Set.prototype[Symbol.toStringTag]</code>：'Set'</li>
<li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>：'Uint8Array'等</li>
<li><code>WeakMap.prototype[Symbol.toStringTag]</code>：'WeakMap'</li>
<li><code>WeakSet.prototype[Symbol.toStringTag]</code>：'WeakSet'</li>
<li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>：'Map Iterator'</li>
<li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>：'Set Iterator'</li>
<li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>：'String Iterator'</li>
<li><code>Symbol.prototype[Symbol.toStringTag]</code>：'Symbol'</li>
<li><code>Generator.prototype[Symbol.toStringTag]</code>：'Generator'</li>
<li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>：'GeneratorFunction'</li>
</ul>
<h2 id="symbolunscopables"><a class="header" href="#symbolunscopables">Symbol.unscopables</a></h2>
<p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p>
<pre><code class="language-javascript">Array.prototype[Symbol.unscopables]
// {
//   copyWithin: true,
//   entries: true,
//   fill: true,
//   find: true,
//   findIndex: true,
//   includes: true,
//   keys: true
// }

Object.keys(Array.prototype[Symbol.unscopables])
// ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'includes', 'keys']
</code></pre>
<p>上面代码说明，数组有 7 个属性，会被<code>with</code>命令排除。</p>
<pre><code class="language-javascript">// 没有 unscopables 时
class MyClass {
  foo() { return 1; }
}

var foo = function () { return 2; };

with (MyClass.prototype) {
  foo(); // 1
}

// 有 unscopables 时
class MyClass {
  foo() { return 1; }
  get [Symbol.unscopables]() {
    return { foo: true };
  }
}

var foo = function () { return 2; };

with (MyClass.prototype) {
  foo(); // 2
}
</code></pre>
<p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数参数的默认值-1"><a class="header" href="#函数参数的默认值-1">函数参数的默认值</a></h1>
<h2 id="es6之前的默认值写法"><a class="header" href="#es6之前的默认值写法">ES6之前的默认值写法</a></h2>
<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>
<pre><code class="language-javascript">function log(x, y) {
  y = y || 'World';
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello World
</code></pre>
<p><strong>ES6之前的赋值缺点</strong></p>
<p>​	上面代码检查函数<code>log</code>的参数<code>y</code>有没有赋值，如果没有，则指定默认值为<code>World</code>。这种写法的缺点在于，如果参数<code>y</code>赋值了，但是对应的布尔值为<code>false</code>，则该赋值不起作用。就像上面代码的最后一行，参数<code>y</code>等于空字符，结果被改为默认值。</p>
<p><strong>上述问题解决办法</strong></p>
<p>为了避免这个问题，通常需要先判断一下参数<code>y</code>是否被赋值，如果没有，再等于默认值。</p>
<pre><code class="language-javascript">if (typeof y === 'undefined') {
  y = 'World';
}
</code></pre>
<h2 id="es6解决办法"><a class="header" href="#es6解决办法">ES6解决办法</a></h2>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre><code class="language-javascript">function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello
</code></pre>
<p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p>
<pre><code class="language-javascript">function foo(x = 5) {
  let x = 1; // error
  const x = 2; // error
}
</code></pre>
<h2 id="默认值惰性求值"><a class="header" href="#默认值惰性求值">默认值惰性求值</a></h2>
<p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<pre><code class="language-javascript">let x = 99;
function foo(p = x + 1) {
  console.log(p);
}

foo() // 100

x = 100;
foo() // 101
</code></pre>
<p>上面代码中，参数<code>p</code>的默认值是<code>x + 1</code>。这时，每次调用函数<code>foo</code>，都会重新计算<code>x + 1</code>，而不是默认<code>p</code>等于 100。</p>
<h2 id="函数默认值与解构默认值结合使用"><a class="header" href="#函数默认值与解构默认值结合使用">函数默认值与解构默认值结合使用</a></h2>
<p>数默认值可以与解构赋值的默认值，结合起来使用。</p>
<pre><code class="language-javascript">function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property 'x' of undefined
</code></pre>
<p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数<code>foo</code>的参数是一个对象时，变量<code>x</code>和<code>y</code>才会通过解构赋值生成。如果函数<code>foo</code>调用时没提供参数，变量<code>x</code>和<code>y</code>就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p>
<pre><code class="language-javascript">function foo({x, y = 5} = {}) {
  console.log(x, y);
}

foo() // undefined 5
</code></pre>
<p>上面代码指定，如果没有提供参数，函数<code>foo</code>的参数默认为一个空对象。</p>
<p>下面是另一个解构赋值默认值的例子。</p>
<pre><code class="language-javascript">function fetch(url, { body = '', method = 'GET', headers = {} }) {
  console.log(method);
}

fetch('http://example.com', {})
// &quot;GET&quot;

fetch('http://example.com')
// 报错
</code></pre>
<p>上面代码中，如果函数<code>fetch</code>的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p>
<pre><code class="language-javascript">function fetch(url, { body = '', method = 'GET', headers = {} } = {}) {
  console.log(method);
}

fetch('http://example.com')
// &quot;GET&quot;
</code></pre>
<p>上面代码中，函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量<code>method</code>才会取到默认值<code>GET</code>。</p>
<p>作为练习，请问下面两种写法有什么差别？</p>
<pre><code class="language-javascript">// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
</code></pre>
<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>
<pre><code class="language-javascript">// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x 和 y 都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
</code></pre>
<h2 id="参数默认值的位置"><a class="header" href="#参数默认值的位置"><strong>参数默认值的位置</strong></a></h2>
<ul>
<li>一般是连续的尾部默认值,这样传值就能省略</li>
<li>如果参数默认值不在中间,就必须传一个  undefined,来触发默认值</li>
</ul>
<h2 id="函数的-length属性"><a class="header" href="#函数的-length属性">函数的 length属性</a></h2>
<ul>
<li>
<p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p>
</li>
<li>
<pre><code class="language-javascript">(function(...args) {}).length // 0
</code></pre>
</li>
</ul>
<h2 id="作用域"><a class="header" href="#作用域">作用域</a></h2>
<p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre><code class="language-javascript">var x = 1;

function f(x, y = x) {
  console.log(y);
}

f(2) // 2
</code></pre>
<p>上面代码中，参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</p>
<p>变量对象跟 函数对象同理</p>
<h2 id="默认值抛出异常"><a class="header" href="#默认值抛出异常">默认值抛出异常</a></h2>
<pre><code class="language-javascript">function throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
</code></pre>
<p><strong>默认值可省略</strong></p>
<p>另外，可以将参数默认值设为<code>undefined</code>，表明这个参数是可以省略的。</p>
<pre><code class="language-javascript">function foo(optional = undefined) { ··· }
</code></pre>
<h1 id="rest-参数"><a class="header" href="#rest-参数">rest 参数</a></h1>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<pre><code class="language-javascript">function add(...values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3) // 10
</code></pre>
<h2 id="示例-3"><a class="header" href="#示例-3">示例</a></h2>
<p>下面是一个 rest 参数代替<code>arguments</code>变量的例子。</p>
<pre><code class="language-javascript">// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) =&gt; numbers.sort();
</code></pre>
<pre><code class="language-javascript">// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) =&gt; numbers.sort();
</code></pre>
<p>​	<code>arguments</code>对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用<code>Array.prototype.slice.call</code>先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组<code>push</code>方法的例子。</p>
<h2 id="rest参数只能是最后一个参数"><a class="header" href="#rest参数只能是最后一个参数">rest参数只能是最后一个参数</a></h2>
<p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<pre><code class="language-javascript">// 报错
function f(a, ...b, c) {
  // ...
}
</code></pre>
<p><strong>函数的<code>length</code>属性，不包括 rest 参数。</strong></p>
<pre><code class="language-javascript">(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1
</code></pre>
<h1 id="严格模式"><a class="header" href="#严格模式">严格模式</a></h1>
<p>从 ES5 开始，函数内部可以设定为严格模式。</p>
<pre><code class="language-javascript">function doSomething(a, b) {
  'use strict';
  // code
}
</code></pre>
<p>​	ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<pre><code class="language-javascript">// 报错
function doSomething(a, b = a) {
  'use strict';
  // code
}

// 报错
const doSomething = function ({a, b}) {
  'use strict';
  // code
};

// 报错
const doSomething = (...a) =&gt; {
  'use strict';
  // code
};

const obj = {
  // 报错
  doSomething({a, b}) {
    'use strict';
    // code
  }
};
</code></pre>
<p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</p>
<pre><code class="language-javascript">// 报错
function doSomething(value = 070) {
  'use strict';
  return value;
}
</code></pre>
<p><strong>解决办法</strong></p>
<p>第一种是设定全局性的严格模式，这是合法的。</p>
<pre><code class="language-javascript">'use strict';

function doSomething(a, b = a) {
  // code
}
</code></pre>
<p>第二种是把函数包在一个无参数的立即执行函数里面。</p>
<pre><code class="language-javascript">const doSomething = (function () {
  'use strict';
  return function(value = 42) {
    return value;
  };
}());
</code></pre>
<h1 id="name-属性"><a class="header" href="#name-属性">name 属性</a></h1>
<p>函数的<code>name</code>属性，返回该函数的函数名。</p>
<pre><code class="language-javascript">function foo() {}
foo.name // &quot;foo&quot;
</code></pre>
<p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 ES6 的<code>name</code>属性会返回实际的函数名。</p>
<pre><code class="language-javascript">var f = function () {};

// ES5
f.name // &quot;&quot;

// ES6
f.name // &quot;f&quot;
</code></pre>
<p><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</p>
<pre><code class="language-javascript">(new Function).name // &quot;anonymous&quot;
</code></pre>
<p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</p>
<pre><code class="language-javascript">function foo() {};
foo.bind({}).name // &quot;bound foo&quot;

(function(){}).bind({}).name // &quot;bound &quot;
</code></pre>
<h1 id="箭头函数"><a class="header" href="#箭头函数">箭头函数</a></h1>
<p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p>
<h2 id="示例-4"><a class="header" href="#示例-4">示例</a></h2>
<pre><code class="language-javascript">var f = v =&gt; v;

// 等同于
var f = function (v) {
  return v;
};
</code></pre>
<h2 id="圆括号代表参数部分"><a class="header" href="#圆括号代表参数部分">圆括号代表参数部分</a></h2>
<pre><code class="language-javascript">var f = () =&gt; 5;
// 等同于
var f = function () { return 5 };

var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};
</code></pre>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p>
<pre><code class="language-javascript">var sum = (num1, num2) =&gt; { return num1 + num2; }
</code></pre>
<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<pre><code class="language-javascript">// 报错
let getTempItem = id =&gt; { id: id, name: &quot;Temp&quot; };

// 不报错
let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });
</code></pre>
<p>下面是一种特殊情况，虽然可以运行，但会得到错误的结果。</p>
<pre><code class="language-javascript">let foo = () =&gt; { a: 1 };
foo() // undefined
</code></pre>
<p>上面代码中，原始意图是返回一个对象<code>{ a: 1 }</code>，但是由于引擎认为大括号是代码块，所以执行了一行语句<code>a: 1</code>。这时，<code>a</code>可以被解释为语句的标签，因此实际执行的语句是<code>1;</code>，然后函数就结束了，没有返回值。</p>
<p>如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。</p>
<pre><code class="language-javascript">let fn = () =&gt; void doesNotReturn();
</code></pre>
<p>箭头函数可以与变量解构结合使用。</p>
<pre><code class="language-javascript">const full = ({ first, last }) =&gt; first + ' ' + last;

// 等同于
function full(person) {
  return person.first + ' ' + person.last;
}
</code></pre>
<p>箭头函数使得表达更加简洁。</p>
<pre><code class="language-javascript">const isEven = n =&gt; n % 2 === 0;
const square = n =&gt; n * n;
</code></pre>
<p>箭头函数的一个用处是简化回调函数。</p>
<pre><code class="language-javascript">// 正常函数写法
[1,2,3].map(function (x) {
  return x * x;
});

// 箭头函数写法
[1,2,3].map(x =&gt; x * x);
</code></pre>
<pre><code class="language-javascript">// 正常函数写法
var result = values.sort(function (a, b) {
  return a - b;
});

// 箭头函数写法
var result = values.sort((a, b) =&gt; a - b);
</code></pre>
<h2 id="使用注意点-1"><a class="header" href="#使用注意点-1">使用注意点</a></h2>
<ul>
<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</li>
</ul>
<h2 id="箭头函数的this关键字"><a class="header" href="#箭头函数的this关键字">箭头函数的this关键字</a></h2>
<p>指向 声明定义时所在的作用域 而不是指向运行时所在的作用域</p>
<pre><code class="language-javascript">function Timer() {
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数
  setInterval(() =&gt; this.s1++, 1000);
  // 普通函数
  setInterval(function () {
    this.s2++;
  }, 1000);
}

var timer = new Timer();

setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);
setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);
// s1: 3
// s2: 0
</code></pre>
<pre><code class="language-javascript">var handler = {
  id: '123456',

  init: function() {
    document.addEventListener('click',
      event =&gt; this.doSomething(event.type), false);
  },

  doSomething: function(type) {
    console.log('Handling ' + type  + ' for ' + this.id);
  }
};
</code></pre>
<p>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<ul>
<li>箭头函数可以让<code>this</code>指向固定化，这种特性很有利于封装回调函数</li>
<li>总是指向外层函数的 对象</li>
<li>对象不构成单独的作用域</li>
</ul>
<h1 id="尾调用优化"><a class="header" href="#尾调用优化">尾调用优化</a></h1>
<h2 id="什么是尾部调用"><a class="header" href="#什么是尾部调用">什么是尾部调用</a></h2>
<p>指某个函数的最后一步是调用另一个函数。</p>
<pre><code class="language-javascript">function f(x){
  return g(x);
}
</code></pre>
<p>以下三种情况，都不属于尾调用。</p>
<pre><code class="language-javascript">// 情况一 存在赋值操作依赖前面的函数栈
function f(x){
  let y = g(x);
  return y;
}

// 情况二 调用后还有操作
function f(x){
  return g(x) + 1;
}

// 情况三
function f(x){
  g(x);
}
等同于
function f(x){
  g(x);
  return undefined;
}
</code></pre>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>
<pre><code class="language-javascript">function f(x) {
  if (x &gt; 0) {
    return m(x)
  }
  return n(x);
}
</code></pre>
<h2 id="尾部调用优化"><a class="header" href="#尾部调用优化">尾部调用优化</a></h2>
<p>​	尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<pre><code class="language-javascript">function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
</code></pre>
<h2 id="尾递归"><a class="header" href="#尾递归">尾递归</a></h2>
<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<pre><code class="language-javascript">function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120
上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n)
</code></pre>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<pre><code class="language-javascript">function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1) // 120
</code></pre>
<p>还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。</p>
<p>非尾递归的 Fibonacci 数列实现如下。</p>
<pre><code class="language-javascript">function Fibonacci (n) {
  if ( n &lt;= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 超时
Fibonacci(500) // 超时
</code></pre>
<p>尾递归优化过的 Fibonacci 数列实现如下。</p>
<pre><code class="language-javascript">function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n &lt;= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
</code></pre>
<h2 id="递归函数改写"><a class="header" href="#递归函数改写">递归函数改写</a></h2>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量<code>total</code>，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算<code>5</code>的阶乘，需要传入两个参数<code>5</code>和<code>1</code>？</p>
<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p>
<pre><code class="language-javascript">function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

function factorial(n) {
  return tailFactorial(n, 1);
}

factorial(5) // 120
</code></pre>
<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>
<pre><code class="language-javascript">function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}

function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

const factorial = currying(tailFactorial, 1);

factorial(5) // 120
</code></pre>
<p>第二种方法就简单多了，就是采用 ES6 的函数默认值。</p>
<pre><code class="language-javascript">function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5) // 120
</code></pre>
<p>递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>
<h2 id="严格模式-1"><a class="header" href="#严格模式-1">严格模式</a></h2>
<p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<ul>
<li><code>func.arguments</code>：返回调用时函数的参数。</li>
<li><code>func.caller</code>：返回调用当前函数的那个函数。</li>
</ul>
<p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<pre><code class="language-javascript">function restricted() {
  'use strict';
  restricted.caller;    // 报错
  restricted.arguments; // 报错
}
restricted();
</code></pre>
<h2 id="尾递归优化实现"><a class="header" href="#尾递归优化实现">尾递归优化实现</a></h2>
<p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>下面是一个正常的递归函数。</p>
<pre><code class="language-javascript">function sum(x, y) {
  if (y &gt; 0) {
    return sum(x + 1, y - 1);
  } else {
    return x;
  }
}

sum(1, 100000)
// Uncaught RangeError: Maximum call stack size exceeded(…)
</code></pre>
<p>上面代码中，<code>sum</code>是一个递归函数，参数<code>x</code>是需要累加的值，参数<code>y</code>控制递归次数。一旦指定<code>sum</code>递归 100000 次，就会报错，提示超出调用栈的最大次数。</p>
<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>
<pre><code class="language-javascript">function trampoline(f) {
  while (f &amp;&amp; f instanceof Function) {
    f = f();
  }
  return f;
}
</code></pre>
<p>上面就是蹦床函数的一个实现，它接受一个函数<code>f</code>作为参数。只要<code>f</code>执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>
<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>
<pre><code class="language-javascript">function sum(x, y) {
  if (y &gt; 0) {
    return sum.bind(null, x + 1, y - 1);
  } else {
    return x;
  }
}
</code></pre>
<p>上面代码中，<code>sum</code>函数的每次执行，都会返回自身的另一个版本。</p>
<p>现在，使用蹦床函数执行<code>sum</code>，就不会发生调用栈溢出。</p>
<pre><code class="language-javascript">trampoline(sum(1, 100000))
// 100001
</code></pre>
<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>
<p>原理是利用手动利用栈去保存变量</p>
<pre><code class="language-javascript">function tco(f) {
  var value;
  var active = false;
  var accumulated = [];

  return function accumulator() {
    accumulated.push(arguments);
    if (!active) {
      active = true;
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift());
      }
      active = false;
      return value;
    }
  };
}

var sum = tco(function(x, y) {
  if (y &gt; 0) {
    return sum(x + 1, y - 1)
  }
  else {
    return x
  }
});

sum(1, 100000)
// 100001
</code></pre>
<p>​	上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<code>sum</code>返回的都是<code>undefined</code>，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>
<h1 id="函数参数的尾逗号"><a class="header" href="#函数参数的尾逗号">函数参数的尾逗号</a></h1>
<ul>
<li>ES2017 <a href="https://github.com/jeffmo/es-trailing-function-commas">允许</a>函数的最后一个参数有尾逗号（trailing comma）。</li>
<li>这是一种语法糖,更加好看</li>
</ul>
<pre><code class="language-javascript">function clownsEverywhere(
  param1,
  param2,
) { /* ... */ }

clownsEverywhere(
  'foo',
  'bar',
);
</code></pre>
<h1 id="functionprototypetostring"><a class="header" href="#functionprototypetostring">Function.prototype.toString()</a></h1>
<p><a href="https://github.com/tc39/Function-prototype-toString-revision">ES2019</a> 对函数实例的<code>toString()</code>方法做出了修改。</p>
<p><code>toString()</code>方法返回函数代码本身，以前会省略注释和空格。</p>
<pre><code class="language-javascript">function /* foo comment */ foo () {}

foo.toString()
// function foo() {}
</code></pre>
<p>上面代码中，函数<code>foo</code>的原始代码包含注释，函数名<code>foo</code>和圆括号之间有空格，但是<code>toString()</code>方法都把它们省略了。</p>
<p>修改后的<code>toString()</code>方法，明确要求返回一模一样的原始代码。</p>
<pre><code class="language-javascript">function /* foo comment */ foo () {}

foo.toString()
// &quot;function /* foo comment */ foo () {}&quot;
</code></pre>
<h1 id="catch-命令的参数省略"><a class="header" href="#catch-命令的参数省略">catch 命令的参数省略</a></h1>
<p>​	JavaScript 语言的<code>try...catch</code>结构，以前明确要求<code>catch</code>命令后面必须跟参数，接受<code>try</code>代码块抛出的错误对象。</p>
<pre><code class="language-javascript">try {
  // ...
} catch (err) {
  // 处理错误
}
</code></pre>
<p>上面代码中，<code>catch</code>命令后面带有参数<code>err</code>。</p>
<p>很多时候，<code>catch</code>代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。<a href="https://github.com/tc39/proposal-optional-catch-binding">ES2019</a> 做出了改变，允许<code>catch</code>语句省略参数。</p>
<pre><code class="language-javascript">try {
  // ...
} catch {
  // ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串的扩展"><a class="header" href="#字符串的扩展">字符串的扩展</a></h1>
<h2 id="字符的unicode的表示法"><a class="header" href="#字符的unicode的表示法">字符的Unicode的表示法</a></h2>
<p>​	ES6 加强了对 Unicode 的支持，允许采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>
<pre><code class="language-javascript">&quot;\u0061&quot;
// &quot;a&quot;
</code></pre>
<p>​	但是，这种表示法只限于码点在<code>\u0000</code>~<code>\uFFFF</code>之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p>
<pre><code class="language-javascript">&quot;\uD842\uDFB7&quot;
// &quot;𠮷&quot;

&quot;\u20BB7&quot;
// &quot; 7&quot;
</code></pre>
<p>​	上面代码表示，如果直接在<code>\u</code>后面跟上超过<code>0xFFFF</code>的数值（比如<code>\u20BB7</code>），JavaScript 会理解成<code>\u20BB+7</code>。由于<code>\u20BB</code>是一个不可打印字符，所以只会显示一个空格，后面跟着一个<code>7</code>。</p>
<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<pre><code class="language-javascript">&quot;\u{20BB7}&quot;
// &quot;𠮷&quot;

&quot;\u{41}\u{42}\u{43}&quot;
// &quot;ABC&quot;

let hello = 123;
hell\u{6F} // 123

'\u{1F680}' === '\uD83D\uDE80'
// true
</code></pre>
<p><strong>JavaScript 共有 6 种方法可以表示一个字符</strong></p>
<pre><code class="language-javascript">'\z' === 'z'  // true 字符
'\172' === 'z' // true ascii
'\x7A' === 'z' // true ascii十六进制
'\u007A' === 'z' // true unicode 
'\u{7A}' === 'z' // true 优化过的unicode
</code></pre>
<h2 id="字符串的遍历"><a class="header" href="#字符串的遍历">字符串的遍历</a></h2>
<pre><code class="language-javascript">for (let codePoint of 'foo') {
  console.log(codePoint)
}
// &quot;f&quot;
// &quot;o&quot;
// &quot;o&quot;
</code></pre>
<p>这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点。</p>
<p>上面代码中，字符串<code>text</code>只有一个字符，但是<code>for</code>循环会认为它包含两个字符（都不可打印），而<code>for...of</code>循环会正确识别出这一个字符。</p>
<h2 id="直接输入u2028u2029"><a class="header" href="#直接输入u2028u2029">直接输入U+2028,U+2029</a></h2>
<p>JavaScript 字符串允许直接输入字符，以及输入字符的转义形式。</p>
<p>“中”的 Unicode 码点是 U+4e2d,你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式<code>\u4e2d</code>，两者是等价的。</p>
<pre><code class="language-javascript">'中' === '\u4e2d' // true
</code></pre>
<p>JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。</p>
<ul>
<li>U+005C：反斜杠（reverse solidus)</li>
<li>U+000D：回车（carriage return）</li>
<li>U+2028：行分隔符（line separator）</li>
<li>U+2029：段分隔符（paragraph separator）</li>
<li>U+000A：换行符（line feed）</li>
</ul>
<p>举例来说，字符串里面不能直接包含反斜杠，一定要转义写成<code>\\</code>或者<code>\u005c</code>。</p>
<p>这个规定本身没有问题，麻烦在于 JSON 格式允许字符串里面直接使用 U+2028（行分隔符）和 U+2029（段分隔符）。这样一来，服务器输出的 JSON 被<code>JSON.parse</code>解析，就有可能直接报错。</p>
<p>JSON 格式已经冻结（RFC 7159），没法修改了。为了消除这个报错，<a href="https://github.com/tc39/proposal-json-superset">ES2019</a> 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。</p>
<pre><code class="language-javascript">const PS = eval(&quot;'\u2029'&quot;);
</code></pre>
<h2 id="jsonstringify改造"><a class="header" href="#jsonstringify改造">Json.stringify改造</a></h2>
<p>​	根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的<code>JSON.stringify()</code>方法有可能返回不符合 UTF-8 标准的字符串。</p>
<p>​	UTF-8 标准规定，<code>0xD800</code>到<code>0xDFFF</code>之间的码点，不能单独使用，必须配对使用。比如，<code>\uD834\uDF06</code>是两个码点，但是必须放在一起配对使用，代表字符<code>𝌆</code>。这是为了表示码点大于<code>0xFFFF</code>的字符的一种变通方法。单独使用<code>\uD834</code>和<code>\uDFO6</code>这两个码点是不合法的，或者颠倒顺序也不行，因为<code>\uDF06\uD834</code>并没有对应的字符。</p>
<p>​	<code>JSON.stringify()</code>的问题在于，它可能返回<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点。</p>
<pre><code class="language-javascript">JSON.stringify('\u{D834}') // &quot;\u{D834}&quot;
</code></pre>
<p>为了确保返回的是合法的 UTF-8 字符，<a href="https://github.com/tc39/proposal-well-formed-stringify">ES2019</a> 改变了<code>JSON.stringify()</code>的行为。如果遇到<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</p>
<pre><code class="language-javascript">JSON.stringify('\u{D834}') // &quot;&quot;\\uD834&quot;&quot;
JSON.stringify('\uDF06\uD834') // &quot;&quot;\\udf06\\ud834&quot;&quot;
</code></pre>
<h2 id="模板字符串"><a class="header" href="#模板字符串">模板字符串</a></h2>
<pre><code class="language-javascript">$('#result').append(`
  There are &lt;b&gt;${basket.count}&lt;/b&gt; items
   in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt;
  are on sale!
`);
</code></pre>
<h3 id="示例-5"><a class="header" href="#示例-5">示例</a></h3>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<pre><code class="language-javascript">// 普通字符串
`In JavaScript '\n' is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
let name = &quot;Bob&quot;, time = &quot;today&quot;;
`Hello ${name}, how are you ${time}?`
</code></pre>
<h3 id="反引号转义"><a class="header" href="#反引号转义">反引号转义</a></h3>
<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
<pre><code class="language-javascript">let greeting = `\`Yo\` World!`;
</code></pre>
<h3 id="保留缩进与换行"><a class="header" href="#保留缩进与换行">保留缩进与换行</a></h3>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p>
<pre><code class="language-javascript">$('#list').html(`
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;
`);
</code></pre>
<p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果你不想要这个换行，可以使用<code>trim</code>方法消除它。</p>
<pre><code class="language-javascript">$('#list').html(`
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;
`.trim());
</code></pre>
<h3 id="变量嵌入"><a class="header" href="#变量嵌入">变量嵌入</a></h3>
<p>模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。</p>
<pre><code class="language-javascript">function authorize(user, action) {
  if (!user.hasPrivilege(action)) {
    throw new Error(
      // 传统写法为
      // 'User '
      // + user.name
      // + ' is not authorized to do '
      // + action
      // + '.'
      `User ${user.name} is not authorized to do ${action}.`);
  }
}
</code></pre>
<p><code>{}</code>放任意表达式</p>
<p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p>
<pre><code class="language-javascript">let x = 1;
let y = 2;

`${x} + ${y} = ${x + y}`
// &quot;1 + 2 = 3&quot;

`${x} + ${y * 2} = ${x + y * 2}`
// &quot;1 + 4 = 5&quot;

let obj = {x: 1, y: 2};
`${obj.x + obj.y}`
// &quot;3&quot;
</code></pre>
<h3 id="调用函数"><a class="header" href="#调用函数">调用函数</a></h3>
<p>模板字符串之中还能调用函数。</p>
<pre><code class="language-javascript">function fn() {
  return &quot;Hello World&quot;;
}

`foo ${fn()} bar`
// foo Hello World bar
如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。

如果模板字符串中的变量没有声明，将报错。
</code></pre>
<h3 id="原始字符串"><a class="header" href="#原始字符串">原始字符串	</a></h3>
<p>由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。</p>
<pre><code class="language-javascript">`Hello ${'World'}`
// &quot;Hello World&quot;
</code></pre>
<h3 id="嵌套"><a class="header" href="#嵌套">嵌套</a></h3>
<p>模板字符串甚至还能嵌套。</p>
<pre><code class="language-javascript">const tmpl = addrs =&gt; `
  &lt;table&gt;
  ${addrs.map(addr =&gt; `
    &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt;
  `).join('')}
  &lt;/table&gt;
`;
</code></pre>
<h3 id="用变量接收模板"><a class="header" href="#用变量接收模板">用变量接收模板</a></h3>
<pre><code class="language-javascript">//定义模板
const tmpl = addrs =&gt; `
  &lt;table&gt;
  ${addrs.map(addr =&gt; `
    &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt;
  `).join('')}
  &lt;/table&gt;
`;
</code></pre>
<pre><code class="language-javascript">//使用模板
const data = [
    { first: '&lt;Jane&gt;', last: 'Bond' },
    { first: 'Lars', last: '&lt;Croft&gt;' },
];

console.log(tmpl(data));
</code></pre>
<p>//模板的变量使用字符串</p>
<pre><code class="language-javascript">let func = (name) =&gt; `Hello ${name}!`;
func('Jack') // &quot;Hello Jack!&quot;
</code></pre>
<h3 id="模板编译"><a class="header" href="#模板编译">模板编译</a></h3>
<h3 id="实例模板编译--"><a class="header" href="#实例模板编译--">实例：模板编译 <a href="https://es6.ruanyifeng.com/#docs/string#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91">§</a> <a href="https://es6.ruanyifeng.com/#docs/string">⇧</a></a></h3>
<h3 id="标签模板"><a class="header" href="#标签模板">标签模板</a></h3>
<pre><code class="language-javascript">alert`hello`
// 等同于
alert(['hello'])
</code></pre>
<p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p>
<pre><code class="language-javascript">let a = 5;
let b = 10;

tag`Hello ${ a + b } world ${ a * b }`;
// 等同于
tag(['Hello ', ' world ', ''], 15, 50);
</code></pre>
<p>标签模板的重要作用 是将参数 与 字符串分离 对用户输入进行过滤</p>
<p>参数访问可以通过arguments 获取</p>
<pre><code class="language-javascript">let total = 30;
let msg = passthru`The total is ${total} (${total*1.05} with tax)`;

function passthru(literals) {
  let result = '';
  let i = 0;

  while (i &lt; literals.length) {
    result += literals[i++];
    if (i &lt; arguments.length) {
      result += arguments[i];
    }
  }

  return result;
}

msg // &quot;The total is 30 (31.5 with tax)&quot;
</code></pre>
<pre><code class="language-javascript">function passthru(literals, ...values) {
  let output = &quot;&quot;;
  let index;
  for (index = 0; index &lt; values.length; index++) {
    output += literals[index] + values[index];
  }

  output += literals[index]
  return output;
}
</code></pre>
<p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p>
<pre><code class="language-javascript">i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`
</code></pre>
<p>获取原始字符串,<code>strings</code>数组是<code>[&quot;First line\nSecond line&quot;]</code>，那么<code>strings.raw</code>数组就是<code>[&quot;First line\\nSecond line&quot;]</code>。</p>
<p>因为在模板字符串中 会对关键字进行转义</p>
<pre><code class="language-javascript">tag`First line\nSecond line`

function tag(strings) {
  console.log(strings.raw[0]);
  // strings.raw[0] 为 &quot;First line\\nSecond line&quot;
  // 打印输出 &quot;First line\nSecond line&quot;
}
</code></pre>
<h3 id="标签模板个人理解"><a class="header" href="#标签模板个人理解">标签模板个人理解</a></h3>
<pre><code>tag`xxx`
会将 字符串, 变量分开传给tag函数
</code></pre>
<h2 id="字符串新增的方法"><a class="header" href="#字符串新增的方法">字符串新增的方法</a></h2>
<h3 id="unicode码获取"><a class="header" href="#unicode码获取">unicode码获取</a></h3>
<p>​	ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>
<p><em>String.fromCharCode(0x20BB7)</em></p>
<p>​	ES6 提供了<code>String.fromCodePoint()</code>方法，可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode()</code>方法的不足。在作用上，正好与下面的<code>codePointAt()</code>方法相反。</p>
<h3 id="stringraw"><a class="header" href="#stringraw"><em>String.raw()</em></a></h3>
<ul>
<li>ES6 还为原生的 String 对象，提供了一个<code>raw()</code>方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</li>
</ul>
<pre><code class="language-javascript">String.raw`Hi\n${2+3}!`
// 实际返回 &quot;Hi\\n5!&quot;，显示的是转义后的结果 &quot;Hi\n5!&quot;

String.raw`Hi\u000A!`;
// 实际返回 &quot;Hi\\u000A!&quot;，显示的是转义后的结果 &quot;Hi\u000A!&quot;

等价

String.raw({ raw: ['foo', 'bar'] }, 1 + 2) // &quot;foo3bar&quot;
</code></pre>
<h3 id="codepointat"><a class="header" href="#codepointat">codePointAt</a></h3>
<p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为<code>2</code>个字节。对于那些需要<code>4</code>个字节储存的字符（Unicode 码点大于<code>0xFFFF</code>的字符），JavaScript 会认为它们是两个字符。</p>
<pre><code class="language-javascript">var s = &quot;𠮷&quot;;

s.length // 2
s.charAt(0) // ''
s.charAt(1) // ''
s.charCodeAt(0) // 55362
s.charCodeAt(1) // 57271
</code></pre>
<p>上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是<code>0x20BB7</code>，UTF-16 编码为<code>0xD842 0xDFB7</code>（十进制为<code>55362 57271</code>），需要<code>4</code>个字节储存。对于这种<code>4</code>个字节的字符，JavaScript 不能正确处理，字符串长度会误判为<code>2</code>，而且<code>charAt()</code>方法无法读取整个字符，<code>charCodeAt()</code>方法只能分别返回前两个字节和后两个字节的值。</p>
<p>ES6 提供了<code>codePointAt()</code>方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p>
<pre><code class="language-javascript">let s = '𠮷a';

s.codePointAt(0).toString(16) // &quot;20bb7&quot;
s.codePointAt(2).toString(16) // &quot;61&quot;
</code></pre>
<p>你可能注意到了，<code>codePointAt()</code>方法的参数，仍然是不正确的。比如，上面代码中，字符<code>a</code>在字符串<code>s</code>的正确位置序号应该是 1，但是必须向<code>codePointAt()</code>方法传入 2。解决这个问题的一个办法是使用<code>for...of</code>循环，因为它会正确识别 32 位的 UTF-16 字符。</p>
<pre><code class="language-javascript">let s = '𠮷a';
for (let ch of s) {
  console.log(ch.codePointAt(0).toString(16));
}
// 20bb7
// 61
</code></pre>
<p>另一种方法也可以，使用扩展运算符（<code>...</code>）进行展开运算。</p>
<pre><code class="language-javascript">let arr = [...'𠮷a']; // arr.length === 2
arr.forEach(
  ch =&gt; console.log(ch.codePointAt(0).toString(16))
);
// 20bb7
// 61
</code></pre>
<pre><code class="language-javascript">function is32Bit(c) {
  return c.codePointAt(0) &gt; 0xFFFF;
}

is32Bit(&quot;𠮷&quot;) // true
is32Bit(&quot;a&quot;) // false
</code></pre>
<p>​</p>
<h3 id="示例方法normalize"><a class="header" href="#示例方法normalize">示例方法:<em>normalize</em></a></h3>
<p>许多欧洲语言有语调符号和重音符号。</p>
<h3 id="实例方法includes-startswith-endswith"><a class="header" href="#实例方法includes-startswith-endswith">实例方法：includes(), startsWith(), endsWith()</a></h3>
<ul>
<li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li>
<li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
<h3 id="实例方法repeat"><a class="header" href="#实例方法repeat">实例方法：repeat()</a></h3>
<p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>
<pre><code class="language-javascript">'x'.repeat(3) // &quot;xxx&quot;
'hello'.repeat(2) // &quot;hellohello&quot;
'na'.repeat(0) // &quot;&quot;
</code></pre>
<p>参数如果是小数，会被取整。</p>
<pre><code class="language-javascript">'na'.repeat(2.9) // &quot;nana&quot;
</code></pre>
<p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p>
<pre><code class="language-javascript">'na'.repeat(Infinity)
// RangeError
'na'.repeat(-1)
// RangeError
</code></pre>
<p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为 0。</p>
<pre><code class="language-javascript">'na'.repeat(-0.9) // &quot;&quot;
</code></pre>
<p>参数<code>NaN</code>等同于 0。</p>
<pre><code class="language-javascript">'na'.repeat(NaN) // &quot;&quot;
</code></pre>
<p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p>
<pre><code class="language-javascript">'na'.repeat('na') // &quot;&quot;
'na'.repeat('3') // &quot;nanana&quot;
</code></pre>
<h3 id="实例方法padstartpadend"><a class="header" href="#实例方法padstartpadend">实例方法：padStart()，padEnd()</a></h3>
<pre><code class="language-javascript">'x'.padStart(5, 'ab') // 'ababx'
'x'.padStart(4, 'ab') // 'abax'

'x'.padEnd(5, 'ab') // 'xabab'
'x'.padEnd(4, 'ab') // 'xaba'
</code></pre>
<p>上面代码中，<code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</p>
<pre><code class="language-javascript">'xxx'.padStart(2, 'ab') // 'xxx'
'xxx'.padEnd(2, 'ab') // 'xxx'
</code></pre>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。</p>
<pre><code class="language-javascript">'abc'.padStart(10, '0123456789')
// '0123456abc'
</code></pre>
<p>如果省略第二个参数，默认使用空格补全长度。</p>
<pre><code class="language-javascript">'x'.padStart(4) // '   x'
'x'.padEnd(4) // 'x   '
</code></pre>
<p><code>padStart()</code>的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p>
<pre><code class="language-javascript">'1'.padStart(10, '0') // &quot;0000000001&quot;
'12'.padStart(10, '0') // &quot;0000000012&quot;
'123456'.padStart(10, '0') // &quot;0000123456&quot;
</code></pre>
<p>另一个用途是提示字符串格式。</p>
<pre><code class="language-javascript">'12'.padStart(10, 'YYYY-MM-DD') // &quot;YYYY-MM-12&quot;
'09-12'.padStart(10, 'YYYY-MM-DD') // &quot;YYYY-09-12&quot;
</code></pre>
<h3 id="实例方法trimstarttrimend"><a class="header" href="#实例方法trimstarttrimend">实例方法：trimStart()，trimEnd()</a></h3>
<pre><code class="language-javascript">const s = '  abc  ';

s.trim() // &quot;abc&quot;
s.trimStart() // &quot;abc  &quot;
s.trimEnd() // &quot;  abc&quot;
</code></pre>
<h1 id="正则扩展"><a class="header" href="#正则扩展">正则扩展</a></h1>
<p><a href="https://es6.ruanyifeng.com/#docs/regex">正则扩展</a></p>
<h2 id="regexp-构造函数httpses6ruanyifengcomdocsregexregexp-构造函数"><a class="header" href="#regexp-构造函数httpses6ruanyifengcomdocsregexregexp-构造函数">[RegExp 构造函数](https://es6.ruanyifeng.com/#docs/regex#RegExp 构造函数)</a></h2>
<pre><code class="language-javascript">var regex = new RegExp(/xyz/i);
// 等价于
var regex = /xyz/i;
#ES6新增第三种构造
var regex = new RegExp(/xyz/, 'i');
#且ig选项会被 i覆盖
new RegExp(/abc/ig, 'i').flags
</code></pre>
<h2 id="字符串的正则方法"><a class="header" href="#字符串的正则方法"><a href="https://es6.ruanyifeng.com/#docs/regex#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AD%A3%E5%88%99%E6%96%B9%E6%B3%95">字符串的正则方法</a></a></h2>
<p>字符串对象共有 4 个方法，可以使用正则表达式</p>
<p><code>match()</code></p>
<p><code>replace()</code></p>
<p><code>search()</code></p>
<p><code>split()</code></p>
<p>ES6 将这 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上。</p>
<ul>
<li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li>
<li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li>
<li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li>
<li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li>
</ul>
<h2 id="u-修饰符httpses6ruanyifengcomdocsregexu-修饰符"><a class="header" href="#u-修饰符httpses6ruanyifengcomdocsregexu-修饰符">[u 修饰符](https://es6.ruanyifeng.com/#docs/regex#u 修饰符)</a></h2>
<p>含义为“Unicode 模式”，用来正确处理大于<code>\uFFFF</code>的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p>
<pre><code class="language-javascript">/^\uD83D/u.test('\uD83D\uDC2A') // false
/^\uD83D/.test('\uD83D\uDC2A') // true
//上面代码中，\uD83D\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。
//但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。
</code></pre>
<p><strong>一旦加上<code>u</code>修饰符号，就会修改下面这些正则表达式的行为。</strong></p>
<ul>
<li><strong>点字符</strong></li>
</ul>
<p>点（<code>.</code>）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于<code>0xFFFF</code>的 Unicode 字符，点字符不能识别，必须加上<code>u</code>修饰符。</p>
<pre><code class="language-javascript">var s = '𠮷';

/^.$/.test(s) // false
/^.$/u.test(s) // true
</code></pre>
<ul>
<li>
<p><strong>Unicode 字符表示法</strong></p>
<p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上<code>u</code>修饰符，才能识别当中的大括号，否则会被解读为量词。</p>
<pre><code class="language-javascript">/\u{61}/.test('a') // false
/\u{61}/u.test('a') // true
/\u{20BB7}/u.test('𠮷') // true
</code></pre>
</li>
<li>
<p><strong>量词</strong></p>
</li>
</ul>
<p>使用<code>u</code>修饰符后，所有量词都会正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p>
<pre><code class="language-javascript">/a{2}/.test('aa') // true
/a{2}/u.test('aa') // true
/𠮷{2}/.test('𠮷𠮷') // false
/𠮷{2}/u.test('𠮷𠮷') // true
</code></pre>
<ul>
<li><strong>预定义模式</strong></li>
</ul>
<p><code>u</code>修饰符也影响到预定义模式，能否正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p>
<pre><code class="language-javascript">/^\S$/.test('𠮷') // false
/^\S$/u.test('𠮷') // true
</code></pre>
<p>上面代码的<code>\S</code>是预定义模式，匹配所有非空白字符。只有加了<code>u</code>修饰符，它才能正确匹配码点大于<code>0xFFFF</code>的 Unicode 字符。</p>
<p>利用这一点，可以写出一个正确返回字符串长度的函数。</p>
<pre><code class="language-javascript">function codePointLength(text) {
  var result = text.match(/[\s\S]/gu);
  return result ? result.length : 0;
}

var s = '𠮷𠮷';

s.length // 4
codePointLength(s) // 2
</code></pre>
<ul>
<li>
<p>i 修饰符</p>
<p>有些 Unicode 字符的编码不同，但是字型很相近，比如，<code>\u004B</code>与<code>\u212A</code>都是大写的<code>K</code></p>
</li>
</ul>
<pre><code class="language-javascript">/[a-z]/i.test('\u212A') // false
/[a-z]/iu.test('\u212A') // true
</code></pre>
<ul>
<li>
<p>转义</p>
<p>没有<code>u</code>修饰符的情况下，正则中没有定义的转义（如逗号的转义<code>\,</code>）无效，而在<code>u</code>模式会报错。</p>
<p>上面代码中，没有<code>u</code>修饰符时，逗号前面的反斜杠是无效的，加了<code>u</code>修饰符就报错。</p>
</li>
</ul>
<p>[RegExp.prototype.unicode 属性](https://es6.ruanyifeng.com/#docs/regex#RegExp.prototype.unicode 属性)</p>
<p>正则实例对象新增<code>unicode</code>属性，表示是否设置了<code>u</code>修饰符。</p>
<h2 id="y-修饰符httpses6ruanyifengcomdocsregexy-修饰符"><a class="header" href="#y-修饰符httpses6ruanyifengcomdocsregexy-修饰符">[y 修饰符](https://es6.ruanyifeng.com/#docs/regex#y 修饰符)</a></h2>
<p>ES6 还为正则表达式添加了<code>y</code>修饰符，叫做“粘连”（sticky）修饰符</p>
<p>​	<code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<pre><code class="language-javascript">var s = 'aaa_aa_a';
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // [&quot;aaa&quot;]
r2.exec(s) // [&quot;aaa&quot;]

r1.exec(s) // [&quot;aa&quot;]
r2.exec(s) // null
</code></pre>
<p>​	上面代码有两个正则表达式，一个使用<code>g</code>修饰符，另一个使用<code>y</code>修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是<code>_aa_a</code>。由于<code>g</code>修饰没有位置要求，所以第二次执行会返回结果，而<code>y</code>修饰符要求匹配必须从头部开始，所以返回<code>null</code>。</p>
<p>如果改一下正则表达式，保证每次都能头部匹配，<code>y</code>修饰符就会返回结果了。</p>
<pre><code class="language-javascript">var s = 'aaa_aa_a';
var r = /a+_/y;

r.exec(s) // [&quot;aaa_&quot;]
r.exec(s) // [&quot;aa_&quot;]
</code></pre>
<p>使用<code>lastIndex</code>属性，可以更好地说明<code>y</code>修饰符。</p>
<pre><code class="language-javascript">const REGEX = /a/g;

// 指定从2号位置（y）开始匹配
REGEX.lastIndex = 2;

// 匹配成功
const match = REGEX.exec('xaya');

// 在3号位置匹配成功
match.index // 3

// 下一次匹配从4号位开始
REGEX.lastIndex // 4

// 4号位开始匹配失败
REGEX.exec('xaya') // null
</code></pre>
<p><strong>y修饰符原理</strong></p>
<ul>
<li>隐含了头部匹配的标志<code>^</code></li>
<li>y修饰符 只会匹配一次,需要手动调用</li>
<li>y修饰符 遇到错误会立即停止</li>
</ul>
<p>[RegExp.prototype.sticky 属性](https://es6.ruanyifeng.com/#docs/regex#RegExp.prototype.sticky 属性)</p>
<p>与<code>y</code>修饰符相匹配，ES6 的正则实例对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>
<h2 id="regexpprototypeflags-属性httpses6ruanyifengcomdocsregexregexpprototypeflags-属性"><a class="header" href="#regexpprototypeflags-属性httpses6ruanyifengcomdocsregexregexpprototypeflags-属性">[RegExp.prototype.flags 属性](https://es6.ruanyifeng.com/#docs/regex#RegExp.prototype.flags 属性)</a></h2>
<p>ES6 为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符。</p>
<pre><code class="language-javascript">// ES5 的 source 属性
// 返回正则表达式的正文
/abc/ig.source
// &quot;abc&quot;

// ES6 的 flags 属性
// 返回正则表达式的修饰符
/abc/ig.flags
// 'gi'
</code></pre>
<h2 id="s-修饰符dotall-模式httpses6ruanyifengcomdocsregexs-修饰符dotall-模式"><a class="header" href="#s-修饰符dotall-模式httpses6ruanyifengcomdocsregexs-修饰符dotall-模式">[s 修饰符：dotAll 模式](https://es6.ruanyifeng.com/#docs/regex#s 修饰符：dotAll 模式)</a></h2>
<p>​	正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用<code>u</code>修饰符解决；另一个是行终止符（line terminator character）。</p>
<p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</p>
<ul>
<li>U+000A 换行符（<code>\n</code>）</li>
<li>U+000D 回车符（<code>\r</code>）</li>
<li>U+2028 行分隔符（line separator）</li>
<li>U+2029 段分隔符（paragraph separator）</li>
</ul>
<pre><code class="language-javascript">//因为`.`不匹配`\n`，所以正则表达式返回`false`。
/foo.bar/.test('foo\nbar')
// false
</code></pre>
<p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</p>
<pre><code class="language-javascript">/foo[^]bar/.test('foo\nbar')
// true
</code></pre>
<p>这种解决方案毕竟不太符合直觉，ES2018 <a href="https://github.com/tc39/proposal-regexp-dotall-flag">引入</a><code>s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p>
<pre><code class="language-javascript">/foo.bar/s.test('foo\nbar') // true
</code></pre>
<p>这被称为<code>dotAll</code>模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个<code>dotAll</code>属性，返回一个布尔值，表示该正则表达式是否处在<code>dotAll</code>模式。</p>
<pre><code class="language-javascript">const re = /foo.bar/s;
// 另一种写法
// const re = new RegExp('foo.bar', 's');

re.test('foo\nbar') // true
re.dotAll // true
re.flags // 's'
</code></pre>
<h2 id="后行断言"><a class="header" href="#后行断言"><a href="https://es6.ruanyifeng.com/#docs/regex#%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80">后行断言</a></a></h2>
<blockquote>
<p>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入<a href="https://github.com/tc39/proposal-regexp-lookbehind">后行断言</a>，V8 引擎 4.9 版（Chrome 62）已经支持。</p>
</blockquote>
<p><strong>先行断言</strong></p>
<pre><code class="language-javascript">/x(?=y)/
/\d+(?!%)/

     搜索顺序是从左到右
</code></pre>
<p><strong>后行断言</strong></p>
<pre><code class="language-javascript">/(?&lt;=\$)\d+/
/(?&lt;!\$)\d+/


</code></pre>
<p><strong>后行断言搜索顺序是从右到左</strong></p>
<pre><code class="language-javascript">/(?&lt;=(\d+)(\d+))$/.exec('1053') // [&quot;&quot;, &quot;1&quot;, &quot;053&quot;]
/^(\d+)(\d+)$/.exec('1053') // [&quot;1053&quot;, &quot;105&quot;, &quot;3&quot;]
</code></pre>
<p>上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是<code>105</code>和<code>3</code>。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是<code>1</code>和<code>053</code>。</p>
<p><strong>后向引用捕获的组顺序也是相反的</strong></p>
<pre><code class="language-javascript">/(?&lt;=(o)d\1)r/.exec('hodor')  // null
/(?&lt;=\1d(o))r/.exec('hodor')  // [&quot;r&quot;, &quot;o&quot;]
</code></pre>
<p>上面代码中，如果后行断言的反斜杠引用（<code>\1</code>）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。</p>
<h2 id="unicode-属性类httpses6ruanyifengcomdocsregexunicode-属性类"><a class="header" href="#unicode-属性类httpses6ruanyifengcomdocsregexunicode-属性类">[Unicode 属性类](https://es6.ruanyifeng.com/#docs/regex#Unicode 属性类)</a></h2>
<p>​	ES2018 <a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes">引入</a>了一种新的类的写法<code>\p{...}</code>和<code>\P{...}</code>，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</p>
<pre><code class="language-javascript">const regexGreekSymbol = /\p{Script=Greek}/u;
regexGreekSymbol.test('π') // true
</code></pre>
<p>上面代码中，<code>\p{Script=Greek}</code>指定匹配一个希腊文字母，所以匹配<code>π</code>成功。</p>
<p>Unicode 属性类要指定属性名和属性值。</p>
<pre><code class="language-javascript">\p{UnicodePropertyName=UnicodePropertyValue}
</code></pre>
<p>对于某些属性，可以只写属性名，或者只写属性值。</p>
<pre><code class="language-javascript">\p{UnicodePropertyName}
\p{UnicodePropertyValue}
</code></pre>
<p><code>\P{…}</code>是<code>\p{…}</code>的反向匹配，即匹配不满足条件的字符。</p>
<p>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。</p>
<pre><code class="language-javascript">const regex = /^\p{Decimal_Number}+$/u;
regex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true
</code></pre>
<p>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。</p>
<p><code>\p{Number}</code>甚至能匹配罗马数字。</p>
<pre><code class="language-javascript">// 匹配所有数字
const regex = /^\p{Number}+$/u;
regex.test('²³¹¼½¾') // true
regex.test('㉛㉜㉝') // true
regex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true
</code></pre>
<p>下面是其他一些例子。</p>
<pre><code class="language-javascript">// 匹配所有空格
\p{White_Space}

// 匹配各种文字的所有字母，等同于 Unicode 版的 \w
[\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]

// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W
[^\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]

// 匹配 Emoji
/\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}|\p{Emoji}\uFE0F/gu

// 匹配所有的箭头字符
const regexArrows = /^\p{Block=Arrows}+$/u;
regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true
</code></pre>
<h2 id="命名-组匹配"><a class="header" href="#命名-组匹配"><a href="https://es6.ruanyifeng.com/#docs/regex#%E5%85%B7%E5%90%8D%E7%BB%84%E5%8C%B9%E9%85%8D">命名 组匹配</a></a></h2>
<p>正则表达式使用圆括号进行组匹配。</p>
<pre><code class="language-javascript">const RE_DATE = /(\d{4})-(\d{2})-(\d{2})/;
</code></pre>
<pre><code class="language-javascript">const RE_DATE = /(\d{4})-(\d{2})-(\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj[1]; // 1999
const month = matchObj[2]; // 12
const day = matchObj[3]; // 31
// or
const [,year,month,day] = RE_DATE.exec('1999-12-31');
</code></pre>
<p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如<code>matchObj[1]</code>）引用，要是组的顺序变了，引用的时候就必须修改序号。</p>
<p>ES2018 引入了<a href="https://github.com/tc39/proposal-regexp-named-groups">具名组匹配</a>（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p>
<pre><code class="language-javascript">const RE_DATE = /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj.groups.year; // 1999
const month = matchObj.groups.month; // 12
const day = matchObj.groups.day; // 31
</code></pre>
<p>​	上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（<code>?&lt;year&gt;</code>），然后就可以在<code>exec</code>方法返回结果的<code>groups</code>属性上引用该组名。同时，数字序号（<code>matchObj[1]</code>）依然有效。</p>
<p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</p>
<pre><code class="language-javascript">const RE_DATE = /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj.groups.year; // 1999
const month = matchObj.groups.month; // 12
const day = matchObj.groups.day; // 31
// or
const {groups:{year,month,day}} = res;
</code></pre>
<p><strong>解构赋值和替换</strong></p>
<pre><code class="language-javascript">let {groups: {one, two}} = /^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u.exec('foo:bar');
one  // foo
two  // bar
</code></pre>
<p>引用具名组</p>
<pre><code class="language-javascript">let re = /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/u;

'2015-01-02'.replace(re, '$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;')
// '02/01/2015'
</code></pre>
<p><code>replace</code>方法的第二个参数也可以是函数，该函数的参数序列如下。</p>
<pre><code class="language-javascript">'2015-01-02'.replace(re, (
   matched, // 整个匹配结果 2015-01-02
   capture1, // 第一个组匹配 2015
   capture2, // 第二个组匹配 01
   capture3, // 第三个组匹配 02
   position, // 匹配开始的位置 0
   S, // 原字符串 2015-01-02
   groups // 具名组构成的一个对象 {year, month, day}
 ) =&gt; {
 let {day, month, year} = groups;
 return `${day}/${month}/${year}`;
});
</code></pre>
<p>​	具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。</p>
<p><strong>引用</strong></p>
<p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用<code>\k&lt;组名&gt;</code>的写法。</p>
<pre><code class="language-javascript">const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/;
RE_TWICE.test('abc!abc') // true
RE_TWICE.test('abc!ab') // false
</code></pre>
<p>数字引用（<code>\1</code>）依然有效。</p>
<pre><code class="language-javascript">const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\1$/;
RE_TWICE.test('abc!abc') // true
RE_TWICE.test('abc!ab') // false
</code></pre>
<pre><code class="language-javascript">const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/;
RE_TWICE.test('abc!abc!abc') // true
RE_TWICE.test('abc!abc!ab') // false
</code></pre>
<h2 id="正则匹配索引"><a class="header" href="#正则匹配索引"><a href="https://es6.ruanyifeng.com/#docs/regex#%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%B4%A2%E5%BC%95">正则匹配索引</a></a></h2>
<p>​	正则匹配结果的开始位置和结束位置，目前获取并不是很方便。正则实例的<code>exec()</code>方法，返回结果有一个<code>index</code>属性，可以获取整个匹配结果的开始位置，但是如果包含组匹配，每个组匹配的开始位置，很难拿到。</p>
<p>​	现在有一个<a href="https://github.com/tc39/proposal-regexp-match-Indices">第三阶段提案</a>，为<code>exec()</code>方法的返回结果加上<code>indices</code>属性，在这个属性上面可以拿到匹配的开始位置和结束位置。</p>
<pre><code class="language-javascript">const text = 'zabbcdef';
const re = /ab/;
const result = re.exec(text);

result.index // 1
result.indices // [ [1, 3] ]
</code></pre>
<p>上面例子中，<code>exec()</code>方法的返回结果<code>result</code>，它的<code>index</code>属性是整个匹配结果（<code>ab</code>）的开始位置，而它的<code>indices</code>属性是一个数组，成员是每个匹配的开始位置和结束位置的数组。由于该例子的正则表达式没有组匹配，所以<code>indices</code>数组只有一个成员，表示整个匹配的开始位置是<code>1</code>，结束位置是<code>3</code>。</p>
<p>注意，开始位置包含在匹配结果之中，但是结束位置不包含在匹配结果之中。比如，匹配结果为<code>ab</code>，分别是原始字符串的第1位和第2位，那么结束位置就是第3位。</p>
<p>如果正则表达式包含组匹配，那么<code>indices</code>属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。</p>
<p>如果正则表达式包含具名组匹配，<code>indices</code>属性数组还会有一个<code>groups</code>属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。</p>
<pre><code class="language-javascript">const text = 'zabbcdef';
const re = /ab+(?&lt;Z&gt;cd)/;
const result = re.exec(text);

result.indices.groups // { Z: [ 4, 6 ] }
</code></pre>
<h2 id="stringprototypematchall"><a class="header" href="#stringprototypematchall"><a href="https://es6.ruanyifeng.com/#docs/regex#String.prototype.matchAll()">String.prototype.matchAll()</a></a></h2>
<p><a href="https://github.com/tc39/proposal-string-matchall">ES2020</a> 增加了<code>String.prototype.matchAll()</code>方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。</p>
<pre><code class="language-javascript">const string = 'test1test2test3';
const regex = /t(e)(st(\d?))/g;

for (const match of string.matchAll(regex)) {
  console.log(match);
}
// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]
// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]
// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]
</code></pre>
<p>上面代码中，由于<code>string.matchAll(regex)</code>返回的是遍历器，所以可以用<code>for...of</code>循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。</p>
<p>遍历器转为数组是非常简单的，使用<code>...</code>运算符和<code>Array.from()</code>方法就可以了。</p>
<pre><code class="language-javascript">// 转为数组的方法一
[...string.matchAll(regex)]

// 转为数组的方法二
Array.from(string.matchAll(regex))
</code></pre>
<h1 id="数值的扩展"><a class="header" href="#数值的扩展">数值的扩展</a></h1>
<h2 id="二进制和八进制表示法"><a class="header" href="#二进制和八进制表示法">二进制和八进制表示法</a></h2>
<p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>
<pre><code class="language-javascript">0b111110111 === 503 // true
0o767 === 503 // true
</code></pre>
<p>从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀<code>0</code>表示，ES6 进一步明确，要使用前缀<code>0o</code>表示。</p>
<pre><code class="language-javascript">// 非严格模式
(function(){
  console.log(0o11 === 011);
})() // true

// 严格模式
(function(){
  'use strict';
  console.log(0o11 === 011);
})() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.
</code></pre>
<p>如果要将<code>0b</code>和<code>0o</code>前缀的字符串数值转为十进制，要使用<code>Number</code>方法。</p>
<pre><code class="language-javascript">Number('0b111')  // 7
Number('0o10')  // 8
</code></pre>
<h2 id="数值函数"><a class="header" href="#数值函数">数值函数</a></h2>
<table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody>
<tr><td>Number.isFinite()</td><td>检查一个数值是否为有限的</td></tr>
<tr><td>Number.isNaN()</td><td>参数类型不是一个数值类型</td></tr>
<tr><td>Number.parseInt()<br />Number.parseFloat()<br />Number.isInteger()</td><td>将全局方法,移植到<code>Number</code>对象上面，行为完全保持不变。</td></tr>
</tbody></table>
<blockquote>
<p>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。</p>
</blockquote>
<pre><code class="language-javascript">(3.0000000000000002) // true
</code></pre>
<p>上面代码中，<code>Number.isInteger</code>的参数明明不是整数，但是会返回<code>true</code>。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个<code>2</code>被丢弃了。</p>
<h2 id="numberepsilon"><a class="header" href="#numberepsilon">Number.EPSILON</a></h2>
<p><strong>精度</strong></p>
<ul>
<li>
<p>ES6 在<code>Number</code>对象上面，新增一个极小的常量<code>Number.EPSILON</code></p>
</li>
<li>
<p>根据规格，它表示 1 与大于 1 的最小浮点数之间的差</p>
</li>
<li>
<p>对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的<code>1.00..001</code>，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。</p>
</li>
</ul>
<p><strong>案例</strong></p>
<p>类似的情况还有，如果一个数值的绝对值小于<code>Number.MIN_VALUE</code>（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，<code>Number.isInteger</code>也会误判。</p>
<pre><code class="language-javascript">Number.isInteger(5E-324) // false
Number.isInteger(5E-325) // true
</code></pre>
<p>上面代码中，<code>5E-325</code>由于值太小，会被自动转为0，因此返回<code>true</code>。</p>
<p>总之，如果对数据精度的要求较高，不建议使用<code>Number.isInteger()</code>判断一个数值是否为整数。</p>
<p><strong>案例2</strong></p>
<hr />
<pre><code class="language-javascript">Number.EPSILON === Math.pow(2, -52)
// true
Number.EPSILON
// 2.220446049250313e-16
Number.EPSILON.toFixed(20)
// &quot;0.00000000000000022204&quot;
</code></pre>
<pre><code class="language-javascript">0.1 + 0.2
// 0.30000000000000004

0.1 + 0.2 - 0.3
// 5.551115123125783e-17

5.551115123125783e-17.toFixed(20)
// '0.00000000000000005551'
</code></pre>
<p>上面代码解释了，为什么比较<code>0.1 + 0.2</code>与<code>0.3</code>得到的结果是<code>false</code>。</p>
<p><code>Number.EPSILON</code>可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即<code>Number.EPSILON * Math.pow(2, 2)</code>），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p>
<p><strong>可以接受的最小误差范围</strong></p>
<pre><code class="language-javascript">function withinErrorMargin (left, right) {
  return Math.abs(left - right) &lt; Number.EPSILON * Math.pow(2, 2);
}

0.1 + 0.2 === 0.3 // false
withinErrorMargin(0.1 + 0.2, 0.3) // true

1.1 + 1.3 === 2.4 // false
withinErrorMargin(1.1 + 1.3, 2.4) // true
</code></pre>
<h2 id="安全整数和-numberissafeinteger"><a class="header" href="#安全整数和-numberissafeinteger">安全整数和 Number.isSafeInteger()</a></h2>
<p>JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>
<pre><code class="language-javascript">Math.pow(2, 53) // 9007199254740992

9007199254740992  // 9007199254740992
9007199254740993  // 9007199254740992

Math.pow(2, 53) === Math.pow(2, 53) + 1
// true
</code></pre>
<p>ES6 引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。</p>
<pre><code class="language-javascript">Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1
// true
Number.MAX_SAFE_INTEGER === 9007199254740991
// true

Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER
// true
Number.MIN_SAFE_INTEGER === -9007199254740991
</code></pre>
<p><code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
<pre><code class="language-javascript">Number.isSafeInteger('a') // false
Number.isSafeInteger(null) // false
Number.isSafeInteger(NaN) // false
Number.isSafeInteger(Infinity) // false
Number.isSafeInteger(-Infinity) // false

Number.isSafeInteger(3) // true
Number.isSafeInteger(1.2) // false
Number.isSafeInteger(9007199254740990) // true
Number.isSafeInteger(9007199254740992) // false

Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false
Number.isSafeInteger(Number.MIN_SAFE_INTEGER) // true
Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // true
Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false
</code></pre>
<p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</p>
<pre><code class="language-javascript">Number.isSafeInteger = function (n) {
  return (typeof n === 'number' &amp;&amp;
    Math.round(n) === n &amp;&amp;
    Number.MIN_SAFE_INTEGER &lt;= n &amp;&amp;
    n &lt;= Number.MAX_SAFE_INTEGER);
}
</code></pre>
<p>​	实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</p>
<h2 id="math-对象的扩展"><a class="header" href="#math-对象的扩展">Math 对象的扩展</a></h2>
<p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p>
<h3 id="mathtrunc"><a class="header" href="#mathtrunc">Math.trunc()</a></h3>
<p>去除一个数的小数部分，返回整数部分</p>
<pre><code class="language-javascript">Math.trunc(4.1) // 4
Math.trunc(4.9) // 4
Math.trunc(-4.1) // -4
Math.trunc(-4.9) // -4
Math.trunc(-0.1234) // -0
</code></pre>
<p>对于非数值，<code>Math.trunc</code>内部使用<code>Number</code>方法将其先转为数值。</p>
<pre><code class="language-javascript">Math.trunc('123.456') // 123
Math.trunc(true) //1
Math.trunc(false) // 0
Math.trunc(null) // 0
</code></pre>
<p>对于空值和无法截取整数的值，返回<code>NaN</code>。</p>
<pre><code class="language-javascript">Math.trunc(NaN);      // NaN
Math.trunc('foo');    // NaN
Math.trunc();         // NaN
Math.trunc(undefined) // NaN
</code></pre>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<pre><code class="language-javascript">Math.trunc = Math.trunc || function(x) {
  return x &lt; 0 ? Math.ceil(x) : Math.floor(x);
};
</code></pre>
<h3 id="mathsign"><a class="header" href="#mathsign">Math.sign()</a></h3>
<p><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回<code>+1</code>；</li>
<li>参数为负数，返回<code>-1</code>；</li>
<li>参数为 0，返回<code>0</code>；</li>
<li>参数为-0，返回<code>-0</code>;</li>
<li>其他值，返回<code>NaN</code>。</li>
</ul>
<p>如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回<code>NaN</code>。</p>
<pre><code class="language-javascript">Math.sign('')  // 0
Math.sign(true)  // +1
Math.sign(false)  // 0
Math.sign(null)  // 0
Math.sign('9')  // +1
Math.sign('foo')  // NaN
Math.sign()  // NaN
Math.sign(undefined)  // NaN
</code></pre>
<pre><code class="language-javascript">Math.sign = Math.sign || function(x) {
  x = +x; // convert to a number
  if (x === 0 || isNaN(x)) {
    return x;
  }
  return x &gt; 0 ? 1 : -1;
};
</code></pre>
<h3 id="mathcbrt"><a class="header" href="#mathcbrt">Math.cbrt()</a></h3>
<p><code>Math.cbrt()</code>方法用于计算一个数的立方根。</p>
<pre><code class="language-javascript">Math.cbrt(-1) // -1
Math.cbrt(0)  // 0
Math.cbrt(1)  // 1
Math.cbrt(2)  // 1.2599210498948732
</code></pre>
<p>对于非数值，<code>Math.cbrt()</code>方法内部也是先使用<code>Number()</code>方法将其转为数值。</p>
<pre><code class="language-javascript">Math.cbrt('8') // 2
Math.cbrt('hello') // NaN
</code></pre>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<pre><code class="language-javascript">Math.cbrt = Math.cbrt || function(x) {
  var y = Math.pow(Math.abs(x), 1/3);
  return x &lt; 0 ? -y : y;
};
</code></pre>
<h3 id="mathclz32"><a class="header" href="#mathclz32">Math.clz32()</a></h3>
<p><code>Math.clz32()</code>方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。</p>
<pre><code class="language-javascript">Math.clz32(0) // 32
Math.clz32(1) // 31
Math.clz32(1000) // 22
Math.clz32(0b01000000000000000000000000000000) // 1
Math.clz32(0b00100000000000000000000000000000) // 2

clz32这个函数名就来自”count leading zero bits in 32-bit binary
</code></pre>
<p>对于小数，<code>Math.clz32</code>方法只考虑整数部分。</p>
<p>对于空值或其他类型的值，<code>Math.clz32</code>方法会将它们先转为数值，然后再计算。</p>
<pre><code class="language-javascript">Math.clz32() // 32
Math.clz32(NaN) // 32
Math.clz32(Infinity) // 32
Math.clz32(null) // 32
Math.clz32('foo') // 32
Math.clz32([]) // 32
Math.clz32({}) // 32
Math.clz32(true) // 31
</code></pre>
<h3 id="mathimul"><a class="header" href="#mathimul">Math.imul()</a></h3>
<p><code>Math.imul</code>方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p>
<pre><code class="language-javascript">Math.imul(2, 4)   // 8
Math.imul(-1, 8)  // -8
Math.imul(-2, -2) // 4
</code></pre>
<p>如果只考虑最后 32 位，大多数情况下，<code>Math.imul(a, b)</code>与<code>a * b</code>的结果是相同的，即该方法等同于<code>(a * b)|0</code>的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，<code>Math.imul</code>方法可以返回正确的低位数值。</p>
<pre><code class="language-javascript">(0x7fffffff * 0x7fffffff)|0 // 0
</code></pre>
<p>上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。<code>Math.imul</code>方法可以返回正确的值 1。</p>
<pre><code class="language-javascript">Math.imul(0x7fffffff, 0x7fffffff) // 1
</code></pre>
<h2 id="指数运算符--"><a class="header" href="#指数运算符--">指数运算符 <a href="https://es6.ruanyifeng.com/#docs/number#%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6">§</a> <a href="https://es6.ruanyifeng.com/#docs/number">⇧</a></a></h2>
<h2 id="bigint-数据类型--"><a class="header" href="#bigint-数据类型--">BigInt 数据类型 <a href="https://es6.ruanyifeng.com/#docs/number#BigInt-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">§</a> <a href="https://es6.ruanyifeng.com/#docs/number">⇧</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="属性的简洁表示法"><a class="header" href="#属性的简洁表示法">属性的简洁表示法</a></h1>
<h2 id="属性名就是变量名-属性值就是变量值"><a class="header" href="#属性名就是变量名-属性值就是变量值">属性名就是变量名, 属性值就是变量值</a></h2>
<p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<pre><code class="language-javascript">const foo = 'bar';
const baz = {foo};
baz // {foo: &quot;bar&quot;}

// 等同于
const baz = {foo: foo};

// x,y既是变量名 也是 属性名
function f(x, y) {
  return {x, y};
}

// 等同于

function f(x, y) {
  return {x: x, y: y};
}

f(1, 2) // Object {x: 1, y: 2}
</code></pre>
<h2 id="方法简写"><a class="header" href="#方法简写">方法简写</a></h2>
<pre><code class="language-javascript">onst o = {
  method() {
    return &quot;Hello!&quot;;
  }
};

// 等同于

const o = {
  method: function() {
    return &quot;Hello!&quot;;
  }
};
</code></pre>
<p>下面是一个实际的例子。</p>
<pre><code class="language-javascript">let birth = '2000/01/01';

const Person = {

  name: '张三',

  //等同于birth: birth
  birth,

  // 等同于hello: function ()...
  hello() { console.log('我的名字是', this.name); }

};
</code></pre>
<h2 id="模块化输出变量"><a class="header" href="#模块化输出变量">模块化输出变量</a></h2>
<p>CommonJS 模块输出一组变量，就非常合适使用简洁写法。</p>
<pre><code class="language-javascript">let ms = {};

function getItem (key) {
  return key in ms ? ms[key] : null;
}

function setItem (key, value) {
  ms[key] = value;
}

function clear () {
  ms = {};
}

module.exports = { getItem, setItem, clear };
// 等同于
module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
};
</code></pre>
<h2 id="属性的赋值器setter和取值器getter"><a class="header" href="#属性的赋值器setter和取值器getter">属性的赋值器（setter）和取值器（getter）</a></h2>
<pre><code class="language-javascript">const cart = {
  _wheels: 4,

  get wheels () {
    return this._wheels;
  },

  set wheels (value) {
    if (value &lt; this._wheels) {
      throw new Error('数值太小了！');
    }
    this._wheels = value;
  }
}
</code></pre>
<h2 id="打印对象"><a class="header" href="#打印对象">打印对象</a></h2>
<pre><code class="language-javascript">let user = {
  name: 'test'
};

let foo = {
  bar: 'baz'
};

console.log(user, foo)
// {name: &quot;test&quot;} {bar: &quot;baz&quot;}
console.log({user, foo})
// {user: {name: &quot;test&quot;}, foo: {bar: &quot;baz&quot;}}
</code></pre>
<p>注意，简写的对象方法不能用作构造函数，会报错。</p>
<pre><code class="language-javascript">const obj = {
  f() {
    this.foo = 'bar';
  }
};

new obj.f() // 报错
</code></pre>
<p>上面代码中，<code>f</code>是一个简写的对象方法，所以<code>obj.f</code>不能当作构造函数使用。</p>
<h1 id="属性名表达式"><a class="header" href="#属性名表达式">属性名表达式</a></h1>
<h2 id="定义对象属性的两种方法"><a class="header" href="#定义对象属性的两种方法">定义对象属性的两种方法</a></h2>
<p>JavaScript 定义对象的属性，有两种方法。</p>
<pre><code class="language-javascript">// 方法一
obj.foo = true;

// 方法二
obj['a' + 'bc'] = 123;
</code></pre>
<p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>
<p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p>
<pre><code class="language-javascript">var obj = {
  foo: true,
  abc: 123
};
</code></pre>
<h2 id="基于变量的属性名定义"><a class="header" href="#基于变量的属性名定义">基于变量的属性名定义</a></h2>
<p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>
<pre><code class="language-javascript">let propKey = 'foo';

let obj = {
  [propKey]: true,
  ['a' + 'bc']: 123
};
</code></pre>
<p>下面是另一个例子。</p>
<pre><code class="language-javascript">let lastWord = 'last word';

const a = {
  'first word': 'hello',
  [lastWord]: 'world'
};

a['first word'] // &quot;hello&quot;
a[lastWord] // &quot;world&quot;
a['last word'] // &quot;world&quot;
</code></pre>
<h2 id="基于变量的方法名定义"><a class="header" href="#基于变量的方法名定义">基于变量的方法名定义</a></h2>
<p>表达式还可以用于定义方法名。</p>
<pre><code class="language-javascript">let obj = {
  ['h' + 'ello']() {
    return 'hi';
  }
};

obj.hello() // hi
</code></pre>
<h2 id="属性名表达式与-简介表示法"><a class="header" href="#属性名表达式与-简介表示法">属性名表达式与 简介表示法</a></h2>
<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p>
<p>因为 简介表示法的 属性名 取决于变量名 ,属性值 取决于变量值</p>
<pre><code class="language-javascript">// 报错
const foo = 'bar';
const bar = 'abc';
const baz = { [foo] };

// 正确
const foo = 'bar';
const baz = { [foo]: 'abc'};
</code></pre>
<h2 id="属性名表达式是一个对象时会自动转成字符串"><a class="header" href="#属性名表达式是一个对象时会自动转成字符串">属性名表达式是一个对象时,会自动转成字符串</a></h2>
<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。</p>
<pre><code class="language-javascript">const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};

myObject // Object {[object Object]: &quot;valueB&quot;}
</code></pre>
<p>上面代码中，<code>[keyA]</code>和<code>[keyB]</code>得到的都是<code>[object Object]</code>，所以<code>[keyB]</code>会把<code>[keyA]</code>覆盖掉，而<code>myObject</code>最后只有一个<code>[object Object]</code>属性。</p>
<h1 id="方法的-name-属性"><a class="header" href="#方法的-name-属性">方法的 name 属性</a></h1>
<h2 id="name属性"><a class="header" href="#name属性">name属性</a></h2>
<p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p>
<pre><code class="language-javascript">const person = {
  sayName() {
    console.log('hello!');
  },
};

person.sayName.name   // &quot;sayName&quot;
</code></pre>
<p>上面代码中，方法的<code>name</code>属性返回函数名（即方法名）。</p>
<h2 id="使用了getter与setter时"><a class="header" href="#使用了getter与setter时">使用了getter与setter时</a></h2>
<p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</p>
<pre><code class="language-javascript">const obj = {
  get foo() {},
  set foo(x) {}
};

obj.foo.name
// TypeError: Cannot read property 'name' of undefined

const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');

descriptor.get.name // &quot;get foo&quot;
descriptor.set.name // &quot;set foo&quot;
</code></pre>
<h2 id="bind创造的函数"><a class="header" href="#bind创造的函数">bind创造的函数</a></h2>
<p>有两种特殊情况：<code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。</p>
<pre><code class="language-javascript">(new Function()).name // &quot;anonymous&quot;

var doSomething = function() {
  // ...
};
doSomething.bind().name // &quot;bound doSomething&quot;
</code></pre>
<h2 id="symbol-值"><a class="header" href="#symbol-值">Symbol 值</a></h2>
<p>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</p>
<pre><code class="language-javascript">const key1 = Symbol('description');
const key2 = Symbol();
let obj = {
  [key1]() {},
  [key2]() {},
};
obj[key1].name // &quot;[description]&quot;
obj[key2].name // &quot;&quot;
</code></pre>
<p>上面代码中，<code>key1</code>对应的 Symbol 值有描述，<code>key2</code>没有。</p>
<h1 id="属性的可枚举性和遍历"><a class="header" href="#属性的可枚举性和遍历">属性的可枚举性和遍历</a></h1>
<h2 id="可枚举性"><a class="header" href="#可枚举性">可枚举性</a></h2>
<p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p>
<pre><code class="language-javascript">let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, 'foo')
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }
</code></pre>
<p>描述对象的<code>enumerable</code>属性，称为“可枚举性”，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p>
<h2 id="属性的枚举"><a class="header" href="#属性的枚举">属性的枚举</a></h2>
<p>描述对象的<code>enumerable</code>属性，称为“可枚举性”，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p>
<p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>
<li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li>
</ul>
<p>这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。其中，只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。</p>
<pre><code class="language-javascript">Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable
// false

Object.getOwnPropertyDescriptor([], 'length').enumerable
// false
</code></pre>
<p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。</p>
<p>另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。</p>
<pre><code class="language-javascript">Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable
// false
</code></pre>
<p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</p>
<h2 id="属性的遍历"><a class="header" href="#属性的遍历">属性的遍历</a></h2>
<p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<p><strong>（1）for...in</strong></p>
<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<p><strong>（2）Object.keys(obj)</strong></p>
<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p>
<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p>
<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<p><strong>（5）Reflect.ownKeys(obj)</strong></p>
<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
<pre><code class="language-javascript">Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
// ['2', '10', 'b', 'a', Symbol()]
</code></pre>
<p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性<code>2</code>和<code>10</code>，其次是字符串属性<code>b</code>和<code>a</code>，最后是 Symbol 属性。</p>
<h1 id="super-关键字"><a class="header" href="#super-关键字">super 关键字</a></h1>
<p>我们知道，<code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。</p>
<pre><code class="language-javascript">const proto = {
  foo: 'hello'
};

const obj = {
  foo: 'world',
  find() {
    return super.foo;
  }
};

Object.setPrototypeOf(obj, proto);
obj.find() // &quot;hello&quot;
</code></pre>
<p>上面代码中，对象<code>obj.find()</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p>
<p>注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p>
<pre><code class="language-javascript">// 报错
const obj = {
  foo: super.foo
}

// 报错
const obj = {
  foo: () =&gt; super.foo
}

// 报错
const obj = {
  foo: function () {
    return super.foo
  }
}
</code></pre>
<p>​	三种<code>super</code>的用法都会报错，因为对于 JavaScript 引擎来说，这里的<code>super</code>都没有用在对象的方法之中。第一种写法是<code>super</code>用在属性里面，第二种和第三种写法是<code>super</code>用在一个函数里面，然后赋值给<code>foo</code>属性。目前，只有<strong>对象方法的简写法</strong>可以让 JavaScript 引擎确认，定义的是对象的方法。</p>
<p>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。</p>
<pre><code class="language-javascript">const proto = {
  x: 'hello',
  foo() {
    console.log(this.x);
  },
};

const obj = {
  x: 'world',
  foo() {
    super.foo();
  }
}

Object.setPrototypeOf(obj, proto);

obj.foo() // &quot;world&quot;
</code></pre>
<p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p>
<h1 id="对象的扩展运算符"><a class="header" href="#对象的扩展运算符">对象的扩展运算符</a></h1>
<h2 id="解构赋值"><a class="header" href="#解构赋值">解构赋值</a></h2>
<p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<pre><code class="language-javascript">let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
</code></pre>
<h3 id="右值是对象且不为空"><a class="header" href="#右值是对象且不为空">右值是对象且不为空</a></h3>
<p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是<code>undefined</code>或<code>null</code>，就会报错，因为它们无法转为对象。</p>
<pre><code class="language-javascript">let { ...z } = null; // 运行时错误
let { ...z } = undefined; // 运行时错误
</code></pre>
<h3 id="扩展运算符必须是最后一个参数"><a class="header" href="#扩展运算符必须是最后一个参数">扩展运算符必须是最后一个参数</a></h3>
<p>解构赋值必须是最后一个参数，否则会报错。</p>
<pre><code class="language-javascript">let { ...x, y, z } = someObject; // 句法错误
let { x, ...y, ...z } = someObject; // 句法错误
</code></pre>
<p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p>
<h3 id="解构赋值的拷贝是浅拷贝"><a class="header" href="#解构赋值的拷贝是浅拷贝">解构赋值的拷贝是浅拷贝</a></h3>
<p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>
<pre><code class="language-javascript">let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2;
x.a.b // 2
</code></pre>
<p>上面代码中，<code>x</code>是解构赋值所在的对象，拷贝了对象<code>obj</code>的<code>a</code>属性。<code>a</code>属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p>
<h3 id="不能复制继承自原型对象的属性"><a class="header" href="#不能复制继承自原型对象的属性">不能复制继承自原型对象的属性</a></h3>
<p>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p>
<p>而单纯的解构赋值可以取到</p>
<pre><code class="language-javascript">let o1 = { a: 1 };
let o2 = { b: 2 };
o2.__proto__ = o1;
let { ...o3 } = o2;
o3 // { b: 2 }
o3.a // undefined
</code></pre>
<p>上面代码中，对象<code>o3</code>复制了<code>o2</code>，但是只复制了<code>o2</code>自身的属性，没有复制它的原型对象<code>o1</code>的属性。</p>
<h3 id="对象扩展运算符后必须跟变量名"><a class="header" href="#对象扩展运算符后必须跟变量名">对象扩展运算符后必须跟变量名</a></h3>
<p>ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量<code>newObj</code>，如果写成下面这样会报错。</p>
<pre><code class="language-javascript">let { x, ...{ y, z } } = o;
// SyntaxError: ... must be followed by an identifier in declaration contexts
</code></pre>
<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p>
<pre><code class="language-javascript">function baseFunction({ a, b }) {
  // ...
}
function wrapperFunction({ x, y, ...restConfig }) {
  // 使用 x 和 y 参数进行操作
  // 其余参数传给原始函数
  return baseFunction(restConfig);
}
</code></pre>
<p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p>
<h2 id="扩展运算符"><a class="header" href="#扩展运算符">扩展运算符</a></h2>
<p>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<pre><code class="language-javascript">let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }
</code></pre>
<h3 id="作用于数组"><a class="header" href="#作用于数组">作用于数组</a></h3>
<p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p>
<pre><code class="language-javascript">let foo = { ...['a', 'b', 'c'] };
foo
// {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;}
</code></pre>
<h3 id="作用于空对象"><a class="header" href="#作用于空对象">作用于空对象</a></h3>
<p>如果扩展运算符后面是一个空对象，则没有任何效果。</p>
<pre><code class="language-javascript">{...{}, a: 1}
// { a: 1 }
</code></pre>
<h3 id="自动转成对象"><a class="header" href="#自动转成对象">自动转成对象</a></h3>
<p>如果扩展运算符后面不是对象，则会自动将其转为对象。</p>
<pre><code class="language-javascript">// 等同于 {...Object(1)}
{...1} // {}
</code></pre>
<p>上面代码中，扩展运算符后面是整数<code>1</code>，会自动转为数值的包装对象<code>Number{1}</code>。由于该对象没有自身属性，所以返回一个空对象。</p>
<p>下面的例子都是类似的道理。</p>
<pre><code class="language-javascript">// 等同于 {...Object(true)}
{...true} // {}

// 等同于 {...Object(undefined)}
{...undefined} // {}

// 等同于 {...Object(null)}
{...null} // {}
</code></pre>
<p><strong>字符串</strong></p>
<p>但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。</p>
<pre><code class="language-javascript">{...'hello'}
// {0: &quot;h&quot;, 1: &quot;e&quot;, 2: &quot;l&quot;, 3: &quot;l&quot;, 4: &quot;o&quot;}
</code></pre>
<p>对象的扩展运算符等同于使用<code>Object.assign()</code>方法。</p>
<pre><code class="language-javascript">let aClone = { ...a };
// 等同于
let aClone = Object.assign({}, a);
</code></pre>
<p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</p>
<pre><code class="language-javascript">// 写法一
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};

// 写法二
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);

// 写法三
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
</code></pre>
<h3 id="合并两个对象"><a class="header" href="#合并两个对象">合并两个对象</a></h3>
<pre><code class="language-javascript">let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);
</code></pre>
<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<pre><code class="language-javascript">let aWithOverrides = { ...a, x: 1, y: 2 };
// 等同于
let aWithOverrides = { ...a, ...{ x: 1, y: 2 } };
// 等同于
let x = 1, y = 2, aWithOverrides = { ...a, x, y };
// 等同于
let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });
</code></pre>
<p>上面代码中，<code>a</code>对象的<code>x</code>属性和<code>y</code>属性，拷贝到新对象后会被覆盖掉。</p>
<p>这用来修改现有对象部分的属性就很方便了。</p>
<pre><code class="language-javascript">let newVersion = {
  ...previousVersion,
  name: 'New Name' // Override the name property
};
</code></pre>
<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>
<pre><code class="language-javascript">let aWithDefaults = { x: 1, y: 2, ...a };
// 等同于
let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);
// 等同于
let aWithDefaults = Object.assign({ x: 1, y: 2 }, a);
</code></pre>
<h3 id="跟表达式"><a class="header" href="#跟表达式">跟表达式</a></h3>
<p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p>
<pre><code class="language-javascript">const obj = {
  ...(x &gt; 1 ? {a: 1} : {}),
  b: 2,
};
</code></pre>
<h3 id="自动执行get函数"><a class="header" href="#自动执行get函数">自动执行get函数</a></h3>
<p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p>
<pre><code class="language-javascript">let a = {
  get x() {
    throw new Error('not throw yet');
  }
}

let aWithXGetter = { ...a }; // 报错
</code></pre>
<p>上面例子中，取值函数<code>get</code>在扩展<code>a</code>对象时会自动执行，导致报错。</p>
<h1 id="链判断运算符"><a class="header" href="#链判断运算符">链判断运算符</a></h1>
<p>编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取<code>message.body.user.firstName</code>，安全的写法是写成下面这样。</p>
<pre><code class="language-javascript">// 错误的写法
const  firstName = message.body.user.firstName;

// 正确的写法
const firstName = (message
  &amp;&amp; message.body
  &amp;&amp; message.body.user
  &amp;&amp; message.body.user.firstName) || 'default';
</code></pre>
<p>上面例子中，<code>firstName</code>属性在对象的第四层，所以需要判断四次，每一层是否有值。</p>
<p>三元运算符<code>?:</code>也常用于判断对象是否存在。</p>
<pre><code class="language-javascript">const fooInput = myForm.querySelector('input[name=foo]')
const fooValue = fooInput ? fooInput.value : undefined
</code></pre>
<p>上面例子中，必须先判断<code>fooInput</code>是否存在，才能读取<code>fooInput.value</code>。</p>
<p>这样的层层判断非常麻烦，因此 <a href="https://github.com/tc39/proposal-optional-chaining">ES2020</a> 引入了“链判断运算符”（optional chaining operator）<code>?.</code>，简化上面的写法。</p>
<h2 id="写法"><a class="header" href="#写法">写法</a></h2>
<pre><code class="language-javascript">const firstName = message?.body?.user?.firstName || 'default';
const fooValue = myForm.querySelector('input[name=foo]')?.value
</code></pre>
<p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。</p>
<p>下面是判断对象方法是否存在，如果存在就立即执行的例子。</p>
<pre><code class="language-javascript">iterator.return?.()
</code></pre>
<p>上面代码中，<code>iterator.return</code>如果有定义，就会调用该方法，否则<code>iterator.return</code>直接返回<code>undefined</code>，不再执行<code>?.</code>后面的部分。</p>
<p>对于那些可能没有实现的方法，这个运算符尤其有用。</p>
<pre><code class="language-javascript">if (myForm.checkValidity?.() === false) {
  // 表单校验失败
  return;
}
</code></pre>
<h2 id="链判断运算符有三种用法"><a class="header" href="#链判断运算符有三种用法">链判断运算符有三种用法。</a></h2>
<ul>
<li><code>obj?.prop</code> // 对象属性</li>
<li><code>obj?.[expr]</code> // 同上</li>
<li><code>func?.(...args)</code> // 函数或对象方法的调用</li>
</ul>
<pre><code class="language-bash">let hex = &quot;#C0FFEE&quot;.match(/#([A-Z]+)/i)?.[1];
</code></pre>
<p>上面例子中，字符串的<code>match()</code>方法，如果没有发现匹配会返回<code>null</code>，如果发现匹配会返回一个数组，<code>?.</code>运算符起到了判断作用。</p>
<p>下面是<code>?.</code>运算符常见形式，以及不使用该运算符时的等价形式。</p>
<pre><code class="language-javascript">a?.b
// 等同于
a == null ? undefined : a.b

a?.[x]
// 等同于
a == null ? undefined : a[x]

a?.b()
// 等同于
a == null ? undefined : a.b()

a?.()
// 等同于
a == null ? undefined : a()
</code></pre>
<p>上面代码中，特别注意后两种形式，如果<code>a?.b()</code>里面的<code>a.b</code>不是函数，不可调用，那么<code>a?.b()</code>是会报错的。<code>a?.()</code>也是如此，如果<code>a</code>不是<code>null</code>或<code>undefined</code>，但也不是函数，那么<code>a?.()</code>会报错。</p>
<h2 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h2>
<p><strong>短路机制</strong></p>
<p><code>?.</code>运算符相当于一种短路机制，只要不满足条件，就不再往下执行。</p>
<pre><code class="language-javascript">a?.[++x]
// 等同于
a == null ? undefined : a[++x]
</code></pre>
<p><strong>delete 运算符</strong></p>
<pre><code class="language-javascript">delete a?.b
// 等同于
a == null ? undefined : delete a.b
</code></pre>
<p>上面代码中，如果<code>a</code>是<code>undefined</code>或<code>null</code>，会直接返回<code>undefined</code>，而不会进行<code>delete</code>运算。</p>
<p><strong>括号的影响</strong></p>
<p>如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。</p>
<pre><code class="language-javascript">(a?.b).c
// 等价于
(a == null ? undefined : a.b).c
</code></pre>
<p>一般来说，使用<code>?.</code>运算符的场合，不应该使用圆括号。</p>
<p><strong>报错场合</strong></p>
<pre><code class="language-javascript">// 构造函数
new a?.()
new a?.b()

// 链判断运算符的右侧有模板字符串
a?.`{b}`
a?.b`{c}`

// 链判断运算符的左侧是 super
super?.()
super?.foo

// 链运算符用于赋值运算符左侧
a?.b = c
</code></pre>
<p><strong>右侧不得为十进制数值</strong></p>
<p>为了保证兼容以前的代码，允许<code>foo?.3:0</code>被解析成<code>foo ? .3 : 0</code>，因此规定如果<code>?.</code>后面紧跟一个十进制数字，那么<code>?.</code>不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。</p>
<h1 id="null-判断运算符"><a class="header" href="#null-判断运算符">Null 判断运算符</a></h1>
<p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值。</p>
<pre><code class="language-javascript">const headerText = response.settings.headerText || 'Hello, world!';
const animationDuration = response.settings.animationDuration || 300;
const showSplashScreen = response.settings.showSplashScreen || true;
</code></pre>
<p>上面的三行代码都通过<code>||</code>运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code>或<code>undefined</code>，默认值就会生效，但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效。</p>
<p>为了避免这种情况，<a href="https://github.com/tc39/proposal-nullish-coalescing">ES2020</a> 引入了一个新的 Null 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值。</p>
<pre><code class="language-javascript">const headerText = response.settings.headerText ?? 'Hello, world!';
const animationDuration = response.settings.animationDuration ?? 300;
const showSplashScreen = response.settings.showSplashScreen ?? true;
</code></pre>
<p>上面代码中，默认值只有在左侧属性值为<code>null</code>或<code>undefined</code>时，才会生效。</p>
<p>这个运算符的一个目的，就是跟链判断运算符<code>?.</code>配合使用，为<code>null</code>或<code>undefined</code>的值设置默认值。</p>
<pre><code class="language-javascript">const animationDuration = response.settings?.animationDuration ?? 300;
</code></pre>
<p>上面代码中，<code>response.settings</code>如果是<code>null</code>或<code>undefined</code>，就会返回默认值300。</p>
<p>这个运算符很适合判断函数参数是否赋值。</p>
<pre><code class="language-javascript">function Component(props) {
  const enable = props.enabled ?? true;
  // …
}
</code></pre>
<p>上面代码判断<code>props</code>参数的<code>enabled</code>属性是否赋值，基本等同于下面的写法。</p>
<pre><code class="language-javascript">function Component(props) {
  const {
    enabled: enable = true,
  } = props;
  // …
}
</code></pre>
<p><code>??</code>有一个运算优先级问题，它与<code>&amp;&amp;</code>和<code>||</code>的优先级孰高孰低。现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。</p>
<pre><code class="language-javascript">// 报错
lhs &amp;&amp; middle ?? rhs
lhs ?? middle &amp;&amp; rhs
lhs || middle ?? rhs
lhs ?? middle || rhs
</code></pre>
<p>上面四个表达式都会报错，必须加入表明优先级的括号。</p>
<pre><code class="language-javascript">(lhs &amp;&amp; middle) ?? rhs;
lhs &amp;&amp; (middle ?? rhs);

(lhs ?? middle) &amp;&amp; rhs;
lhs ?? (middle &amp;&amp; rhs);

(lhs || middle) ?? rhs;
lhs || (middle ?? rhs);

(lhs ?? middle) || rhs;
lhs ?? (middle || rhs);
</code></pre>
<h1 id="对象新增方法"><a class="header" href="#对象新增方法">对象新增方法</a></h1>
<h2 id="objectis"><a class="header" href="#objectis">Object.is()</a></h2>
<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<pre><code class="language-javascript">Object.is('foo', 'foo')
// true
Object.is({}, {})
// false
</code></pre>
<p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p>
<pre><code class="language-javascript">+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</code></pre>
<p>ES5 可以通过下面的代码，部署<code>Object.is</code>。</p>
<pre><code class="language-javascript">Object.defineProperty(Object, 'is', {
  value: function(x, y) {
    if (x === y) {
      // 针对+0 不等于 -0的情况
      return x !== 0 || 1 / x === 1 / y;
    }
    // 针对NaN的情况
    return x !== x &amp;&amp; y !== y;
  },
  configurable: true,
  enumerable: false,
  writable: true
});
</code></pre>
<h2 id="objectassign"><a class="header" href="#objectassign">Object.assign()</a></h2>
<h3 id="基本用法-7"><a class="header" href="#基本用法-7">基本用法</a></h3>
<p><code>Object.assign()</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<pre><code class="language-javascript">const target = { a: 1 };

const source1 = { b: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</code></pre>
<h3 id="多源后覆盖"><a class="header" href="#多源后覆盖">多源后覆盖</a></h3>
<p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<pre><code class="language-javascript">const target = { a: 1, b: 1 };

const source1 = { b: 2, c: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</code></pre>
<h3 id="空值nullundefined"><a class="header" href="#空值nullundefined">空值,null,undefined</a></h3>
<p>如果只有一个参数，<code>Object.assign()</code>会直接返回该参数。</p>
<pre><code class="language-javascript">const obj = {a: 1};
Object.assign(obj) === obj // true
</code></pre>
<p>如果该参数不是对象，则会先转成对象，然后返回。</p>
<pre><code class="language-javascript">typeof Object.assign(2) // &quot;object&quot;
</code></pre>
<p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p>
<pre><code class="language-javascript">Object.assign(undefined) // 报错
Object.assign(null) // 报错
</code></pre>
<h3 id="非对象参数忽略"><a class="header" href="#非对象参数忽略">非对象参数忽略</a></h3>
<p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。</p>
<pre><code class="language-javascript">let obj = {a: 1};
Object.assign(obj, undefined) === obj // true
Object.assign(obj, null) === obj // true
</code></pre>
<p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p>
<pre><code class="language-javascript">const v1 = 'abc';
const v2 = true;
const v3 = 10;

const obj = Object.assign({}, v1, v2, v3);
console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }
</code></pre>
<p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p>
<pre><code class="language-javascript">Object(true) // {[[PrimitiveValue]]: true}
Object(10)  //  {[[PrimitiveValue]]: 10}
Object('abc') // {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;}
</code></pre>
<p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign()</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p>
<h3 id="只拷贝源对象的自身可枚举的属性"><a class="header" href="#只拷贝源对象的自身可枚举的属性">只拷贝源对象的自身可枚举的属性</a></h3>
<p><code>Object.assign()</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p>
<pre><code class="language-javascript">Object.assign({b: 'c'},
  Object.defineProperty({}, 'invisible', {
    enumerable: false,
    value: 'hello'
  })
)
// { b: 'c' }
</code></pre>
<p>上面代码中，<code>Object.assign()</code>要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去。</p>
<p>属性名为 Symbol 值的属性，也会被<code>Object.assign()</code>拷贝。</p>
<pre><code class="language-javascript">Object.assign({ a: 'b' }, { [Symbol('c')]: 'd' })
// { a: 'b', Symbol(c): 'd' }
</code></pre>
<h3 id="注意点"><a class="header" href="#注意点">注意点</a></h3>
<p><strong>浅拷贝</strong></p>
<p><code>Object.assign()</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<p><strong>同名属性的替换</strong></p>
<p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign()</code>的处理方法是替换，而不是添加。</p>
<pre><code class="language-javascript">const target = { a: { b: 'c', d: 'e' } }
const source = { a: { b: 'hello' } }
Object.assign(target, source)
// { a: { b: 'hello' } }
</code></pre>
<p><strong>数组的处理</strong></p>
<p><code>Object.assign()</code>可以用来处理数组，但是会把数组视为对象。</p>
<pre><code class="language-javascript">Object.assign([1, 2, 3], [4, 5])
// [4, 5, 3]
</code></pre>
<p>上面代码中，<code>Object.assign()</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>。</p>
<p><strong>取值函数的处理</strong></p>
<p><code>Object.assign()</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
<pre><code class="language-javascript">const source = {
  get foo() { return 1 }
};
const target = {};

Object.assign(target, source)
// { foo: 1 }
</code></pre>
<h3 id="常见用途"><a class="header" href="#常见用途">常见用途</a></h3>
<p><strong>为对象添加属性</strong></p>
<pre><code class="language-javascript">class Point {
  constructor(x, y) {
    Object.assign(this, {x, y});
  }
}
</code></pre>
<p>上面方法通过<code>Object.assign()</code>方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例。</p>
<p><strong>对象添加方法</strong></p>
<pre><code class="language-javascript">Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};
</code></pre>
<p><strong>克隆对象</strong></p>
<pre><code class="language-javascript">function clone(origin) {
  return Object.assign({}, origin);
}
</code></pre>
<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>
<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>
<pre><code class="language-javascript">function clone(origin) {
  let originProto = Object.getPrototypeOf(origin);
  return Object.assign(Object.create(originProto), origin);
}
</code></pre>
<p><strong>合并多个对象</strong></p>
<p>将多个对象合并到某个对象。</p>
<pre><code class="language-javascript">const merge =
  (target, ...sources) =&gt; Object.assign(target, ...sources);
</code></pre>
<p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>
<pre><code class="language-javascript">const merge =
  (...sources) =&gt; Object.assign({}, ...sources);
</code></pre>
<p><strong>为属性指定默认值</strong></p>
<pre><code class="language-javascript">const DEFAULTS = {
  logLevel: 0,
  outputFormat: 'html'
};

function processContent(options) {
  options = Object.assign({}, DEFAULTS, options);
  console.log(options);
  // ...
}
</code></pre>
<h2 id="objectgetownpropertydescriptors"><a class="header" href="#objectgetownpropertydescriptors">Object.getOwnPropertyDescriptors()</a></h2>
<p>​	ES5 的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<pre><code class="language-javascript">const obj = {
  foo: 123,
  get bar() { return 'abc' }
};

Object.getOwnPropertyDescriptors(obj)
// { foo:
//    { value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true },
//   bar:
//    { get: [Function: get bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true } }
</code></pre>
<p>上面代码中，<code>Object.getOwnPropertyDescriptors()</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p>
<p>该方法的实现非常容易。</p>
<pre><code class="language-javascript">function getOwnPropertyDescriptors(obj) {
  const result = {};
  for (let key of Reflect.ownKeys(obj)) {
    result[key] = Object.getOwnPropertyDescriptor(obj, key);
  }
  return result;
}
</code></pre>
<p>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</p>
<pre><code class="language-javascript">const source = {
  set foo(value) {
    console.log(value);
  }
};

const target1 = {};
Object.assign(target1, source);

Object.getOwnPropertyDescriptor(target1, 'foo')
// { value: undefined,
//   writable: true,
//   enumerable: true,
//   configurable: true }
</code></pre>
<p>上面代码中，<code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了<code>undefined</code>。这是因为<code>Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p>
<p>这时，<code>Object.getOwnPropertyDescriptors()</code>方法配合<code>Object.defineProperties()</code>方法，就可以实现正确拷贝。</p>
<p>.</p>
<pre><code class="language-javascript">const source = {
  set foo(value) {
    console.log(value);
  }
};

const target2 = {};
Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
Object.getOwnPropertyDescriptor(target2, 'foo')
// { get: undefined,
//   set: [Function: set foo],
//   enumerable: true,
//   configurable: true }
</code></pre>
<p>上面代码中，两个对象合并的逻辑可以写成一个函数。</p>
<pre><code class="language-javascript">const shallowMerge = (target, source) =&gt; Object.defineProperties(
  target,
  Object.getOwnPropertyDescriptors(source)
);
</code></pre>
<p><code>Object.getOwnPropertyDescriptors()</code>方法的另一个用处，是配合<code>Object.create()</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p>
<pre><code class="language-javascript">const clone = Object.create(Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj));

// 或者

const shallowClone = (obj) =&gt; Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
</code></pre>
<p>上面代码会克隆对象<code>obj</code>。</p>
<p>另外，<code>Object.getOwnPropertyDescriptors()</code>方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p>
<pre><code class="language-javascript">const obj = {
  __proto__: prot,
  foo: 123,
};
</code></pre>
<p>ES6 规定<code>__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code>__proto__</code>，上面代码就要改成下面这样。</p>
<pre><code class="language-javascript">const obj = Object.create(prot);
obj.foo = 123;

// 或者

const obj = Object.assign(
  Object.create(prot),
  {
    foo: 123,
  }
);
</code></pre>
<p>有了<code>Object.getOwnPropertyDescriptors()</code>，我们就有了另一种写法。</p>
<pre><code class="language-javascript">const obj = Object.create(
  prot,
  Object.getOwnPropertyDescriptors({
    foo: 123,
  })
);
</code></pre>
<p><code>Object.getOwnPropertyDescriptors()</code>也可以用来实现 Mixin（混入）模式。</p>
<pre><code class="language-javascript">let mix = (object) =&gt; ({
  with: (...mixins) =&gt; mixins.reduce(
    (c, mixin) =&gt; Object.create(
      c, Object.getOwnPropertyDescriptors(mixin)
    ), object)
});

// multiple mixins example
let a = {a: 'a'};
let b = {b: 'b'};
let c = {c: 'c'};
let d = mix(c).with(a, b);

d.c // &quot;c&quot;
d.b // &quot;b&quot;
d.a // &quot;a&quot;
</code></pre>
<p>上面代码返回一个新的对象<code>d</code>，代表了对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>的操作。</p>
<p>出于完整性的考虑，<code>Object.getOwnPropertyDescriptors()</code>进入标准以后，以后还会新增<code>Reflect.getOwnPropertyDescriptors()</code>方法。</p>
<h2 id="__proto__属性objectsetprototypeofobjectgetprototypeof"><a class="header" href="#__proto__属性objectsetprototypeofobjectgetprototypeof"><code>__proto__</code>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</a></h2>
<p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 IE11）都部署了这个属性。</p>
<pre><code class="language-javascript">// es5 的写法
const obj = {
  method: function() { ... }
};
obj.__proto__ = someOtherObj;

// es6 的写法
var obj = Object.create(someOtherObj);
obj.method = function() { ... };
</code></pre>
<p>​	该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<p>实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。</p>
<pre><code class="language-javascript">Object.defineProperty(Object.prototype, '__proto__', {
  get() {
    let _thisObj = Object(this);
    return Object.getPrototypeOf(_thisObj);
  },
  set(proto) {
    if (this === undefined || this === null) {
      throw new TypeError();
    }
    if (!isObject(this)) {
      return undefined;
    }
    if (!isObject(proto)) {
      return undefined;
    }
    let status = Reflect.setPrototypeOf(this, proto);
    if (!status) {
      throw new TypeError();
    }
  },
});

function isObject(value) {
  return Object(value) === value;
}
</code></pre>
<p>如果一个对象本身部署了<code>__proto__</code>属性，该属性的值就是对象的原型。</p>
<pre><code class="language-javascript">Object.getPrototypeOf({ __proto__: null })
// null
</code></pre>
<h3 id="objectsetprototypeof"><a class="header" href="#objectsetprototypeof">Object.setPrototypeOf()</a></h3>
<p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>
<pre><code class="language-javascript">// 格式
Object.setPrototypeOf(object, prototype)

// 用法
const o = Object.setPrototypeOf({}, null);
</code></pre>
<p>该方法等同于下面的函数。</p>
<pre><code class="language-javascript">function setPrototypeOf(obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="language-javascript">let proto = {};
let obj = { x: 10 };
Object.setPrototypeOf(obj, proto);

proto.y = 20;
proto.z = 40;

obj.x // 10
obj.y // 20
obj.z // 40
</code></pre>
<p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p>
<pre><code class="language-javascript">Object.setPrototypeOf(1, {}) === 1 // true
Object.setPrototypeOf('foo', {}) === 'foo' // true
Object.setPrototypeOf(true, {}) === true // true
</code></pre>
<p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。</p>
<pre><code class="language-javascript">Object.setPrototypeOf(undefined, {})
// TypeError: Object.setPrototypeOf called on null or undefined

Object.setPrototypeOf(null, {})
// TypeError: Object.setPrototypeOf called on null or undefined
</code></pre>
<h3 id="objectgetprototypeof"><a class="header" href="#objectgetprototypeof">Object.getPrototypeOf()</a></h3>
<p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p>
<pre><code class="language-javascript">Object.getPrototypeOf(obj);
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="language-javascript">function Rectangle() {
  // ...
}

const rec = new Rectangle();

Object.getPrototypeOf(rec) === Rectangle.prototype
// true

Object.setPrototypeOf(rec, Object.prototype);
Object.getPrototypeOf(rec) === Rectangle.prototype
// false
</code></pre>
<p>如果参数不是对象，会被自动转为对象。</p>
<pre><code class="language-javascript">// 等同于 Object.getPrototypeOf(Number(1))
Object.getPrototypeOf(1)
// Number {[[PrimitiveValue]]: 0}

// 等同于 Object.getPrototypeOf(String('foo'))
Object.getPrototypeOf('foo')
// String {length: 0, [[PrimitiveValue]]: &quot;&quot;}

// 等同于 Object.getPrototypeOf(Boolean(true))
Object.getPrototypeOf(true)
// Boolean {[[PrimitiveValue]]: false}

Object.getPrototypeOf(1) === Number.prototype // true
Object.getPrototypeOf('foo') === String.prototype // true
Object.getPrototypeOf(true) === Boolean.prototype // true
</code></pre>
<p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。</p>
<pre><code class="language-javascript">Object.getPrototypeOf(null)
// TypeError: Cannot convert undefined or null to object

Object.getPrototypeOf(undefined)
// TypeError: Cannot convert undefined or null to object
</code></pre>
<h2 id="objectkeysobjectvaluesobjectentries"><a class="header" href="#objectkeysobjectvaluesobjectentries">Object.keys()，Object.values()，Object.entries()</a></h2>
<p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>
<pre><code class="language-javascript">var obj = { foo: 'bar', baz: 42 };
Object.keys(obj)
// [&quot;foo&quot;, &quot;baz&quot;]
</code></pre>
<p>ES2017 <a href="https://github.com/tc39/proposal-object-values-entries">引入</a>了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。</p>
<pre><code class="language-javascript">let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // 'a', 'b', 'c'
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]
}
</code></pre>
<h3 id="objectvalues"><a class="header" href="#objectvalues">Object.values()</a></h3>
<p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<pre><code class="language-javascript">const obj = { foo: 'bar', baz: 42 };
Object.values(obj)
// [&quot;bar&quot;, 42]
</code></pre>
<p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p>
<pre><code class="language-javascript">const obj = { 100: 'a', 2: 'b', 7: 'c' };
Object.values(obj)
// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]
</code></pre>
<p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>。</p>
<p><code>Object.values</code>只返回对象自身的可遍历属性。</p>
<pre><code class="language-javascript">const obj = Object.create({}, {p: {value: 42}});
Object.values(obj) // []
</code></pre>
<p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的，因为<code>p</code>的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性<code>p</code>的值。</p>
<pre><code class="language-javascript">const obj = Object.create({}, {p:
  {
    value: 42,
    enumerable: true
  }
});
Object.values(obj) // [42]
</code></pre>
<p><code>Object.values</code>会过滤属性名为 Symbol 值的属性。</p>
<pre><code class="language-javascript">Object.values({ [Symbol()]: 123, foo: 'abc' });
// ['abc']
</code></pre>
<p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。</p>
<pre><code class="language-javascript">Object.values('foo')
// ['f', 'o', 'o']
</code></pre>
<p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p>
<p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。</p>
<pre><code class="language-javascript">Object.values(42) // []
Object.values(true) // []
</code></pre>
<h3 id="objectentries"><a class="header" href="#objectentries">Object.entries()</a></h3>
<p><code>Object.entries()</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<pre><code class="language-javascript">const obj = { foo: 'bar', baz: 42 };
Object.entries(obj)
// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]
</code></pre>
<p>除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致。</p>
<p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</p>
<pre><code class="language-javascript">Object.entries({ [Symbol()]: 123, foo: 'abc' });
// [ [ 'foo', 'abc' ] ]
</code></pre>
<p>上面代码中，原对象有两个属性，<code>Object.entries</code>只输出属性名非 Symbol 值的属性。将来可能会有<code>Reflect.ownEntries()</code>方法，返回对象自身的所有属性。</p>
<p><code>Object.entries</code>的基本用途是遍历对象的属性。</p>
<pre><code class="language-javascript">let obj = { one: 1, two: 2 };
for (let [k, v] of Object.entries(obj)) {
  console.log(
    `${JSON.stringify(k)}: ${JSON.stringify(v)}`
  );
}
// &quot;one&quot;: 1
// &quot;two&quot;: 2
</code></pre>
<p><code>Object.entries</code>方法的另一个用处是，将对象转为真正的<code>Map</code>结构。</p>
<pre><code class="language-javascript">const obj = { foo: 'bar', baz: 42 };
const map = new Map(Object.entries(obj));
map // Map { foo: &quot;bar&quot;, baz: 42 }
</code></pre>
<p>自己实现<code>Object.entries</code>方法，非常简单。</p>
<pre><code class="language-javascript">// Generator函数的版本
function* entries(obj) {
  for (let key of Object.keys(obj)) {
    yield [key, obj[key]];
  }
}

// 非Generator函数的版本
function entries(obj) {
  let arr = [];
  for (let key of Object.keys(obj)) {
    arr.push([key, obj[key]]);
  }
  return arr;
}
</code></pre>
<h2 id="objectfromentries"><a class="header" href="#objectfromentries">Object.fromEntries()</a></h2>
<p><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</p>
<pre><code class="language-javascript">Object.fromEntries([
  ['foo', 'bar'],
  ['baz', 42]
])
// { foo: &quot;bar&quot;, baz: 42 }
</code></pre>
<p>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。</p>
<pre><code class="language-javascript">// 例一
const entries = new Map([
  ['foo', 'bar'],
  ['baz', 42]
]);

Object.fromEntries(entries)
// { foo: &quot;bar&quot;, baz: 42 }

// 例二
const map = new Map().set('foo', true).set('bar', false);
Object.fromEntries(map)
// { foo: true, bar: false }
</code></pre>
<p>该方法的一个用处是配合<code>URLSearchParams</code>对象，将查询字符串转为对象。</p>
<pre><code class="language-javascript">Object.fromEntries(new URLSearchParams('foo=bar&amp;baz=qux'))
// { foo: &quot;bar&quot;, baz: &quot;qux&quot; }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扩展运算符-1"><a class="header" href="#扩展运算符-1">扩展运算符</a></h1>
<h2 id="含义-3"><a class="header" href="#含义-3">含义</a></h2>
<p>​	扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用<strong>逗号分隔的参数序列。</strong></p>
<pre><code class="language-javascript">console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll('div')]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</code></pre>
<p>该运算符主要用于函数调用。</p>
<pre><code class="language-javascript">function push(array, ...items) {
  array.push(...items);
}

function add(x, y) {
  return x + y;
}

const numbers = [4, 38];
add(...numbers) // 42
</code></pre>
<h2 id="扩展运算符的应用"><a class="header" href="#扩展运算符的应用">扩展运算符的应用</a></h2>
<p><strong>复制数组</strong></p>
<p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p>
<pre><code class="language-javascript">const a1 = [1, 2];
// 写法一
const a2 = [...a1];
// 写法二
const [...a2] = a1;
</code></pre>
<p><strong>合并数组</strong></p>
<pre><code class="language-javascript">const arr1 = ['a', 'b'];
const arr2 = ['c'];
const arr3 = ['d', 'e'];

// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ 'a', 'b', 'c', 'd', 'e' ]

// ES6 的合并数组
[...arr1, ...arr2, ...arr3]
// [ 'a', 'b', 'c', 'd', 'e' ]
</code></pre>
<p><strong>与解构赋值结合</strong></p>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<pre><code class="language-javascript">// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
</code></pre>
<p>下面是另外一些例子。</p>
<pre><code class="language-javascript">const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...rest] = [];
first // undefined
rest  // []

const [first, ...rest] = [&quot;foo&quot;];
first  // &quot;foo&quot;
rest   // []
</code></pre>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<pre><code class="language-javascript">const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
</code></pre>
<p><strong>字符串</strong></p>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<pre><code class="language-javascript">[...'hello']
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
</code></pre>
<p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。</p>
<pre><code class="language-javascript">'x\uD83D\uDE80y'.length // 4
[...'x\uD83D\uDE80y'].length // 3
</code></pre>
<p>上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>
<pre><code class="language-javascript">function length(str) {
  return [...str].length;
}

length('x\uD83D\uDE80y') // 3
</code></pre>
<p>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<pre><code class="language-javascript">let str = 'x\uD83D\uDE80y';

str.split('').reverse().join('')
// 'y\uDE80\uD83Dx'

[...str].reverse().join('')
// 'y\uD83D\uDE80x'
</code></pre>
<p><strong>实现了 Iterator 接口的对象</strong></p>
<p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p>
<pre><code class="language-javascript">let nodeList = document.querySelectorAll('div');
let array = [...nodeList];
</code></pre>
<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个<code>NodeList</code>对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于<code>NodeList</code>对象实现了 Iterator 。</p>
<pre><code class="language-javascript">Number.prototype[Symbol.iterator] = function*() {
  let i = 0;
  let num = this.valueOf();
  while (i &lt; num) {
    yield i++;
  }
}

console.log([...5]) // [0, 1, 2, 3, 4]
</code></pre>
<p>​	上面代码中，先定义了<code>Number</code>对象的遍历器接口，扩展运算符将<code>5</code>自动转成<code>Number</code>实例以后，就会调用这个接口，就会返回自定义的结果。</p>
<p><strong>Map 和 Set 结构，Generator 函数</strong></p>
<p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p>
<pre><code class="language-javascript">let map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

let arr = [...map.keys()]; // [1, 2, 3]
</code></pre>
<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<pre><code class="language-javascript">const go = function*(){
  yield 1;
  yield 2;
  yield 3;
};

[...go()] // [1, 2, 3]
</code></pre>
<p>上面代码中，变量<code>go</code>是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。</p>
<pre><code class="language-javascript">const obj = {a: 1, b: 2};
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
</code></pre>
<h1 id="arrayfrom"><a class="header" href="#arrayfrom">Array.from()</a></h1>
<p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p>
<p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p>
<pre><code class="language-javascript">let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
</code></pre>
<p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。</p>
<pre><code class="language-javascript">// NodeList对象
let ps = document.querySelectorAll('p');
Array.from(ps).filter(p =&gt; {
  return p.textContent.length &gt; 100;
});

// arguments对象
function foo() {
  var args = Array.from(arguments);
  // ...
}
</code></pre>
<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用<code>filter</code>方法。</p>
<p>只要是部署了 Iterator 接口的数据结构，<code>Array.from</code>都能将其转为数组。</p>
<pre><code class="language-javascript">Array.from('hello')
// ['h', 'e', 'l', 'l', 'o']

let namesSet = new Set(['a', 'b'])
Array.from(namesSet) // ['a', 'b']
</code></pre>
<p>如果参数是一个真正的数组，<code>Array.from</code>会返回一个一模一样的新数组。</p>
<pre><code class="language-javascript">Array.from([1, 2, 3])
// [1, 2, 3]
</code></pre>
<p>值得提醒的是，扩展运算符（<code>...</code>）也可以将某些数据结构转为数组。</p>
<pre><code class="language-javascript">// arguments对象
function foo() {
  const args = [...arguments];
}

// NodeList对象
[...document.querySelectorAll('div')]
</code></pre>
<h2 id="扩展运算符与遍历器接口的区别"><a class="header" href="#扩展运算符与遍历器接口的区别"><strong>扩展运算符与遍历器接口的区别</strong></a></h2>
<p>扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。<code>Array.from</code>方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换。</p>
<pre><code class="language-javascript">Array.from({ length: 3 });
// [ undefined, undefined, undefined ]
</code></pre>
<h2 id="第二个-映射器操作"><a class="header" href="#第二个-映射器操作">第二个 映射器操作</a></h2>
<p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<pre><code class="language-javascript">Array.from(arrayLike, x =&gt; x * x);
// 等同于
Array.from(arrayLike).map(x =&gt; x * x);

Array.from([1, 2, 3], (x) =&gt; x * x)
// [1, 4, 9]
</code></pre>
<p>下面的例子是取出一组 DOM 节点的文本内容。</p>
<pre><code class="language-javascript">let spans = document.querySelectorAll('span.name');

// map()
let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);

// Array.from()
let names2 = Array.from(spans, s =&gt; s.textContent)
</code></pre>
<p>下面的例子将数组中布尔值为<code>false</code>的成员转为<code>0</code>。</p>
<pre><code class="language-javascript">Array.from([1, , 2, , 3], (n) =&gt; n || 0)
// [1, 0, 2, 0, 3]
</code></pre>
<p>另一个例子是返回各种数据的类型。</p>
<pre><code class="language-javascript">function typesOf () {
  return Array.from(arguments, value =&gt; typeof value)
}
typesOf(null, [], NaN)
// ['object', 'object', 'number']
</code></pre>
<p>如果<code>map</code>函数里面用到了<code>this</code>关键字，还可以传入<code>Array.from</code>的第三个参数，用来绑定<code>this</code>。</p>
<p><code>Array.from()</code>的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于<code>\uFFFF</code>的 Unicode 字符，算作两个字符的 bug。</p>
<pre><code class="language-javascript">function countSymbols(string) {
  return Array.from(string).length;
}
</code></pre>
<h1 id="arrayof"><a class="header" href="#arrayof">Array.of()</a></h1>
<p><code>Array.of</code>方法用于将一组值，转换为数组。</p>
<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>
<pre><code class="language-javascript">Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
</code></pre>
<pre><code class="language-javascript">Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
</code></pre>
<h1 id="数组实例的-copywithin"><a class="header" href="#数组实例的-copywithin">数组实例的 copyWithin()</a></h1>
<pre><code class="language-javascript">Array.prototype.copyWithin(target, start = 0, end = this.length)
</code></pre>
<p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
<pre><code class="language-javascript">[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]
</code></pre>
<p>上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</p>
<h1 id="数组实例的-find-和-findindex"><a class="header" href="#数组实例的-find-和-findindex">数组实例的 find() 和 findIndex()</a></h1>
<p>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p>
<pre><code class="language-javascript">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)
</code></pre>
<p><code>find</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p>
<pre><code class="language-javascript">function f(v){
  return v &gt; this.age;
}
let person = {name: 'John', age: 20};
[10, 12, 26, 15].find(f, person);    // 26
</code></pre>
<p>上面的代码中，<code>find</code>函数接收了第二个参数<code>person</code>对象，回调函数中的<code>this</code>对象指向<code>person</code>对象。</p>
<p>另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>indexOf</code>方法的不足。</p>
<pre><code class="language-javascript">[NaN].indexOf(NaN)
// -1

[NaN].findIndex(y =&gt; Object.is(NaN, y))
// 0
</code></pre>
<h1 id="数组实例的-fill"><a class="header" href="#数组实例的-fill">数组实例的 fill()</a></h1>
<p><code>fill</code>方法使用给定值，填充一个数组。</p>
<pre><code class="language-javascript">['a', 'b', 'c'].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
</code></pre>
<p>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>
<p><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<pre><code class="language-javascript">['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c']
</code></pre>
<p>上面代码表示，<code>fill</code>方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p>
<p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p>
<pre><code class="language-javascript">let arr = new Array(3).fill({name: &quot;Mike&quot;});
arr[0].name = &quot;Ben&quot;;
arr
// [{name: &quot;Ben&quot;}, {name: &quot;Ben&quot;}, {name: &quot;Ben&quot;}]

let arr = new Array(3).fill([]);
arr[0].push(5);
arr
// [[5], [5], [5]]
</code></pre>
<h1 id="数组实例的-entrieskeys-和-values"><a class="header" href="#数组实例的-entrieskeys-和-values">数组实例的 entries()，keys() 和 values()</a></h1>
<p>ES6 提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
<pre><code class="language-javascript">for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 &quot;a&quot;
// 1 &quot;b&quot;
</code></pre>
<p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>
<pre><code class="language-javascript">let letter = ['a', 'b', 'c'];
let entries = letter.entries();
console.log(entries.next().value); // [0, 'a']
console.log(entries.next().value); // [1, 'b']
console.log(entries.next().value); // [2, 'c']
</code></pre>
<h1 id="数组实例的-includes"><a class="header" href="#数组实例的-includes">数组实例的 includes()</a></h1>
<p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。ES2016 引入了该方法。</p>
<pre><code class="language-javascript">[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
</code></pre>
<p>该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为<code>-4</code>，但数组长度为<code>3</code>），则会重置为从<code>0</code>开始。</p>
<pre><code class="language-javascript">[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
</code></pre>
<p>没有该方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值。</p>
<pre><code class="language-javascript">if (arr.indexOf(el) !== -1) {
  // ...
}
</code></pre>
<p><code>indexOf</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于<code>-1</code>，表达起来不够直观。二是，它内部使用严格相等运算符（<code>===</code>）进行判断，这会导致对<code>NaN</code>的误判。</p>
<pre><code class="language-javascript">[NaN].indexOf(NaN)
// -1
</code></pre>
<p><code>includes</code>使用的是不一样的判断算法，就没有这个问题。</p>
<pre><code class="language-javascript">[NaN].includes(NaN)
// true
</code></pre>
<p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>
<pre><code class="language-javascript">const contains = (() =&gt;
  Array.prototype.includes
    ? (arr, value) =&gt; arr.includes(value)
    : (arr, value) =&gt; arr.some(el =&gt; el === value)
)();
contains(['foo', 'bar'], 'baz'); // =&gt; false
</code></pre>
<p>另外，Map 和 Set 数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>
<ul>
<li>Map 结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>
<li>Set 结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li>
</ul>
<h1 id="数组实例的-flatflatmap"><a class="header" href="#数组实例的-flatflatmap">数组实例的 flat()，flatMap()</a></h1>
<p>数组的成员有时还是数组，<code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p>
<pre><code class="language-javascript">[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]
</code></pre>
<p>上面代码中，原数组的成员里面有一个数组，<code>flat()</code>方法将子数组的成员取出来，添加在原来的位置。</p>
<p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1。</p>
<pre><code class="language-javascript">[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
</code></pre>
<p>上面代码中，<code>flat()</code>的参数为2，表示要“拉平”两层的嵌套数组。</p>
<p>如果不管有多少层嵌套，都要转成一维数组，可以用<code>Infinity</code>关键字作为参数。</p>
<pre><code class="language-javascript">[1, [2, [3]]].flat(Infinity)
// [1, 2, 3]
</code></pre>
<p>如果原数组有空位，<code>flat()</code>方法会跳过空位。</p>
<pre><code class="language-javascript">[1, 2, , 4, 5].flat()
// [1, 2, 4, 5]
</code></pre>
<p><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>Array.prototype.map()</code>），然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组。</p>
<pre><code class="language-javascript">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) =&gt; [x, x * 2])
// [2, 4, 3, 6, 4, 8]
</code></pre>
<p><code>flatMap()</code>只能展开一层数组。</p>
<pre><code class="language-javascript">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()
[1, 2, 3, 4].flatMap(x =&gt; [[x * 2]])
// [[2], [4], [6], [8]]
</code></pre>
<p>上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此<code>flatMap()</code>返回的还是一个嵌套数组。</p>
<p><code>flatMap()</code>方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。</p>
<pre><code class="language-javascript">arr.flatMap(function callback(currentValue[, index[, array]]) {
  // ...
}[, thisArg])
flatMap()`方法还可以有第二个参数，用来绑定遍历函数里面的`this
</code></pre>
<h1 id="数组的空位"><a class="header" href="#数组的空位">数组的空位</a></h1>
<p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p>
<pre><code class="language-javascript">Array(3) // [, , ,]
</code></pre>
<p>上面代码中，<code>Array(3)</code>返回一个具有 3 个空位的数组。</p>
<p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>
<pre><code class="language-javascript">0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false
</code></pre>
<p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。</p>
<p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ul>
<li><code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>
<li><code>map()</code>会跳过空位，但会保留这个值</li>
<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>
</ul>
<pre><code class="language-javascript">// forEach方法
[,'a'].forEach((x,i) =&gt; console.log(i)); // 1

// filter方法
['a',,'b'].filter(x =&gt; true) // ['a','b']

// every方法
[,'a'].every(x =&gt; x==='a') // true

// reduce方法
[1,,2].reduce((x,y) =&gt; x+y) // 3

// some方法
[,'a'].some(x =&gt; x !== 'a') // false

// map方法
[,'a'].map(x =&gt; 1) // [,1]

// join方法
[,'a',undefined,null].join('#') // &quot;#a##&quot;

// toString方法
[,'a',undefined,null].toString() // &quot;,a,,&quot;
</code></pre>
<p>ES6 则是明确将空位转为<code>undefined</code>。</p>
<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>
<pre><code class="language-javascript">Array.from(['a',,'b'])
// [ &quot;a&quot;, undefined, &quot;b&quot; ]
</code></pre>
<p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>
<pre><code class="language-javascript">[...['a',,'b']]
// [ &quot;a&quot;, undefined, &quot;b&quot; ]
</code></pre>
<p><code>copyWithin()</code>会连空位一起拷贝。</p>
<pre><code class="language-javascript">[,'a','b',,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;]
</code></pre>
<p><code>fill()</code>会将空位视为正常的数组位置。</p>
<pre><code class="language-javascript">new Array(3).fill('a') // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]
</code></pre>
<p><code>for...of</code>循环也会遍历空位。</p>
<pre><code class="language-javascript">let arr = [, ,];
for (let i of arr) {
  console.log(1);
}
// 1
// 1
</code></pre>
<p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p>
<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p>
<pre><code class="language-javascript">// entries()
[...[,'a'].entries()] // [[0,undefined], [1,&quot;a&quot;]]

// keys()
[...[,'a'].keys()] // [0,1]

// values()
[...[,'a'].values()] // [undefined,&quot;a&quot;]

// find()
[,'a'].find(x =&gt; true) // undefined

// findIndex()
[,'a'].findIndex(x =&gt; true) // 0
</code></pre>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<h1 id="arrayprototypesort-的排序稳定性"><a class="header" href="#arrayprototypesort-的排序稳定性">Array.prototype.sort() 的排序稳定性</a></h1>
<p>排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。</p>
<p><strong>就是 当key一样时,不要改变 这两个元素的先后顺序</strong></p>
<pre><code class="language-javascript">const arr = [
  'peach',
  'straw',
  'apple',
  'spork'
];

const stableSorting = (s1, s2) =&gt; {
  if (s1[0] &lt; s2[0]) return -1;
  return 1;
};

arr.sort(stableSorting)
// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]
</code></pre>
<p>上面代码对数组<code>arr</code>按照首字母进行排序。排序结果中，<code>straw</code>在<code>spork</code>的前面，跟原始顺序一致，所以排序算法<code>stableSorting</code>是稳定排序。</p>
<pre><code class="language-javascript">const unstableSorting = (s1, s2) =&gt; {
  if (s1[0] &lt;= s2[0]) return -1;
  return 1;
};

arr.sort(unstableSorting)
// [&quot;apple&quot;, &quot;peach&quot;, &quot;spork&quot;, &quot;straw&quot;]
</code></pre>
<p>上面代码中，排序结果是<code>spork</code>在<code>straw</code>前面，跟原始顺序相反，所以排序算法<code>unstableSorting</code>是不稳定的。</p>
<p>常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。</p>
<p>早先的 ECMAScript 没有规定，<code>Array.prototype.sort()</code>的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。<a href="https://github.com/tc39/ecma262/pull/1340">ES2019</a> 明确规定，<code>Array.prototype.sort()</code>的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="步骤-1"><a class="header" href="#步骤-1">步骤</a></h1>
<h2 id="给项目安装ts语言"><a class="header" href="#给项目安装ts语言">给项目安装ts语言</a></h2>
<pre><code class="language-shell"># 先删除package.json 中的 dependencies中的 ts依赖
yarn add --dev typescript
</code></pre>
<h2 id="使用tsc编译"><a class="header" href="#使用tsc编译">使用tsc编译</a></h2>
<pre><code class="language-json">{
  // ...
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;tsc&quot;,
    // ...
  },
  // ...
}
</code></pre>
<p><strong>配置 TypeScript 编译器</strong></p>
<pre><code class="language-shell">yarn run tsc --init
</code></pre>
<p><strong>指定编译源代码路径以及 编译输出路径</strong></p>
<pre><code class="language-json">// tsconfig.json

{
  &quot;compilerOptions&quot;: {
    // ...
    &quot;rootDir&quot;: &quot;src&quot;,
    &quot;outDir&quot;: &quot;build&quot;
    // ...
  },
}
</code></pre>
<p><strong>构建HTML</strong></p>
<pre><code>yarn build
</code></pre>
<h2 id="类型定义"><a class="header" href="#类型定义">类型定义</a></h2>
<p>为了能够显示来自其他包的错误和提示，编译器依赖于声明文件</p>
<p>声明文件提供有关库的所有类型信息</p>
<p>这样，我们的项目就可以用上像 npm 这样的平台提供的三方 JavaScript 库。</p>
<p>获取一个库的声明文件有两种方式：</p>
<p><strong>Bundled</strong> - 该库包含了自己的声明文件。</p>
<p>这样很好，因为我们只需要安装这个库，就可以立即使用它了</p>
<p>要知道一个库是否包含类型，看库中是否有 <code>index.d.ts</code> 文件</p>
<p>有些库会在 <code>package.json</code> 文件的 <code>typings</code> 或 <code>types</code> 属性中指定类型文件。</p>
<p><strong><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a></strong> - DefinitelyTyped 是一个庞大的声明仓库，为没有声明文件的 JavaScript 库提供类型定义。这些类型定义通过众包的方式完成，并由微软和开源贡献者一起管理。例如，React 库并没有自己的声明文件。但我们可以从 DefinitelyTyped 获取它的声明文件。只要执行以下命令。</p>
<pre><code class="language-sh"># yarn
yarn add --dev @types/react

# npm
npm i --save-dev @types/react
</code></pre>
<p><strong>局部声明</strong> 有时，你要使用的包里没有声明文件，在 DefinitelyTyped 上也没有。在这种情况下，我们可以创建一个本地的定义文件。因此，在项目的根目录中创建一个 <code>declarations.d.ts</code> 文件。一个简单的声明可能是这样的：</p>
<pre><code class="language-typescript">declare module 'querystring' {
  export function stringify(val: object): string
  export function parse(val: string): object
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="jsx-简介"><a class="header" href="#jsx-简介">JSX 简介</a></h2>
<pre><code class="language-shell">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;
</code></pre>
<p>这个有趣的标签语法既不是字符串也不是 HTML。</p>
<p>它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。</p>
<h2 id="为什么使用-jsx"><a class="header" href="#为什么使用-jsx">为什么使用 JSX？</a></h2>
<p>React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合,比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。</p>
<p>React 并没有采用将<em>标记与逻辑进行分离到不同文件</em>这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中,来实现<a href="https://en.wikipedia.org/wiki/Separation_of_concerns"><em>关注点分离</em></a></p>
<h2 id="在-jsx-中嵌入表达式"><a class="header" href="#在-jsx-中嵌入表达式">在 JSX 中嵌入表达式</a></h2>
<h3 id="-2"><a class="header" href="#-2"><code>{}</code></a></h3>
<pre><code class="language-jsx">const name = 'Josh Perez';
const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;

ReactDOM.render(
  element,
  document.getElementById('root')
);
</code></pre>
<p>在 JSX 语法中，你可以在大括号内放置任何有效的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions">JavaScript 表达式</a></p>
<h3 id="jsx-也是一个表达式"><a class="header" href="#jsx-也是一个表达式">JSX 也是一个表达式</a></h3>
<p>在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。</p>
<pre><code class="language-javascript">function getGreeting(user) {
  if (user) {
    return &lt;h1&gt;Hello, {formatName(user)}!&lt;/h1&gt;;
  }
  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;
}
</code></pre>
<h2 id="使用-jsx-指定子元素"><a class="header" href="#使用-jsx-指定子元素">使用 JSX 指定子元素</a></h2>
<pre><code class="language-jsx">//闭合标签
const element = &lt;img src={user.avatarUrl} /&gt;;

//嵌套标签
const element = (
  &lt;div&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;h2&gt;Good to see you here.&lt;/h2&gt;
  &lt;/div&gt;
);
</code></pre>
<p><strong>JSX 防止注入攻击</strong></p>
<p>你可以安全地在 JSX 当中插入用户输入内容：</p>
<pre><code class="language-jsx">const title = response.potentiallyMaliciousInput;
// 直接使用是安全的：
const element = &lt;h1&gt;{title}&lt;/h1&gt;;
</code></pre>
<p>React DOM 在渲染所有输入内容之前，默认会进行<a href="https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html">转义</a>。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容</p>
<p>所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS（cross-site-scripting, 跨站脚本）</a>攻击。</p>
<h3 id="-3"><a class="header" href="#-3"></a></h3>
<h2 id="jsx-表示对象"><a class="header" href="#jsx-表示对象">JSX 表示对象</a></h2>
<p>Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。</p>
<pre><code class="language-jsx">const element = (
  &lt;h1 className=&quot;greeting&quot;&gt;
    Hello, world!
  &lt;/h1&gt;
);


const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
</code></pre>
<p><code>React.createElement()</code> 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象：</p>
<pre><code class="language-jsx">// 注意：这是简化过的结构
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world!'
  }
};
</code></pre>
<p>这些对象被称为 “React 元素”。它们描述了你希望在屏幕上看到的内容。React 通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="元素渲染"><a class="header" href="#元素渲染">元素渲染</a></h2>
<p>元素是构成 React 应用的最小砖块。</p>
<p>元素描述了你在屏幕上想看到的内容。</p>
<p>与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。</p>
<h2 id="将一个元素渲染为-dom"><a class="header" href="#将一个元素渲染为-dom">将一个元素渲染为 DOM</a></h2>
<p>假设你的 HTML 文件某处有一个 <code>&lt;div&gt;</code>：</p>
<pre><code class="language-html">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
</code></pre>
<p>我们将其称为“根” DOM 节点，因为该节点内的所有内容都将由 React DOM 管理。</p>
<p>仅使用 React 构建的应用通常只有单一的根 DOM 节点。如果你在将 React 集成进一个已有应用，那么你可以在应用中包含任意多的独立根 DOM 节点。</p>
<p>想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 <a href="https://react.docschina.org/docs/react-dom.html#render"><code>ReactDOM.render()</code></a>：</p>
<p><strong>将一个Reactor元素渲染为 DOM节点</strong> </p>
<pre><code class="language-jsx">const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
ReactDOM.render(element, document.getElementById('root'));
</code></pre>
<h2 id="更新已渲染的元素"><a class="header" href="#更新已渲染的元素">更新已渲染的元素</a></h2>
<p>React 元素是<a href="https://en.wikipedia.org/wiki/Immutable_object">不可变对象</a>。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。</p>
<p>根据我们已有的知识，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 <a href="https://react.docschina.org/docs/react-dom.html#render"><code>ReactDOM.render()</code></a>。</p>
<p>考虑一个计时器的例子：</p>
<pre><code class="language-jsx">function tick() {
  const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
  ReactDOM.render(element, document.getElementById('root'));}

setInterval(tick, 1000);
</code></pre>
<p>在实践中，大多数 React 应用只会调用一次 <a href="https://react.docschina.org/docs/react-dom.html#render"><code>ReactDOM.render()</code></a>。在下一个章节，我们将学习如何将这些代码封装到<a href="https://react.docschina.org/docs/state-and-lifecycle.html">有状态组件</a>中。</p>
<h2 id="react-只更新它需要更新的部分"><a class="header" href="#react-只更新它需要更新的部分">React 只更新它需要更新的部分</a></h2>
<p>React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="组件--props"><a class="header" href="#组件--props">组件 &amp; Props</a></h1>
<p>组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思</p>
<p>组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。</p>
<h2 id="函数组件与-class-组件"><a class="header" href="#函数组件与-class-组件">函数组件与 class 组件</a></h2>
<p><strong>函数组件</strong></p>
<p>定义组件最简单的方式就是编写 JavaScript 函数：</p>
<pre><code class="language-jsx">function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}
</code></pre>
<p>该函数是一个有效的 React 组件</p>
<ul>
<li>因为它接收唯一带有数据的 “props”（代表属性）对象与</li>
<li>并返回一个 React 元素。</li>
</ul>
<p>这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p>
<p><strong>class组件</strong></p>
<pre><code class="language-jsx">class Welcome extends React.Component {
  render() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
}
</code></pre>
<h2 id="渲染组件"><a class="header" href="#渲染组件">渲染组件</a></h2>
<p>之前，我们遇到的 React 元素都只是 DOM 标签：</p>
<pre><code class="language-jsx">const element = &lt;div /&gt;;
</code></pre>
<p>不过，React 元素也可以是用户自定义的组件：</p>
<pre><code class="language-jsx">const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;
</code></pre>
<p>当 React 元素为用户自定义组件时，</p>
<ul>
<li>
<p>它会将 JSX 所接收的属性（attributes）以及</p>
</li>
<li>
<p>子组件（children）转换为单个对象传递给组件，</p>
</li>
</ul>
<p><strong>这个对象被称之为 “props”。</strong></p>
<h2 id="组合组件"><a class="header" href="#组合组件">组合组件</a></h2>
<p>组件可以在其输出中引用其他组件。这就可以让我们用同一组件来抽象出任意层次的细节。按钮，表单，对话框，甚至整个屏幕的内容：在 React 应用程序中，这些通常都会以组件的形式表示。</p>
<h2 id="提取组件"><a class="header" href="#提取组件">提取组件</a></h2>
<p>将组件拆分为更小的组件。</p>
<p>例如，参考如下 <code>Comment</code> 组件：</p>
<pre><code class="language-tsx">function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;div className=&quot;UserInfo&quot;&gt;
        &lt;img className=&quot;Avatar&quot;
          src={props.author.avatarUrl}
          alt={props.author.name}
        /&gt;
        &lt;div className=&quot;UserInfo-name&quot;&gt;
          {props.author.name}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>该组件用于描述一个社交媒体网站上的评论功能，它接收 <code>author</code>（对象），<code>text</code> （字符串）以及 <code>date</code>（日期）作为 props。</p>
<p>该组件由于嵌套的关系，变得难以维护，且很难复用它的各个部分。因此，让我们从中提取一些组件出来。</p>
<p>首先，我们将提取 <code>Avatar</code> 组件：</p>
<pre><code class="language-tsx">function Avatar(props) {
  return (
    &lt;img className=&quot;Avatar&quot;      src={props.user.avatarUrl}      alt={props.user.name}    /&gt;  );
}
</code></pre>
<p><code>Avatar</code> 不需知道它在 <code>Comment</code> 组件内部是如何渲染的。因此，我们给它的 props 起了一个更通用的名字：<code>user</code>，而不是 <code>author</code>。</p>
<p>我们建议从组件自身的角度命名 props，而不是依赖于调用组件的上下文命名。</p>
<pre><code class="language-jsx">function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;div className=&quot;UserInfo&quot;&gt;
        &lt;Avatar user={props.author} /&gt;
        &lt;div className=&quot;UserInfo-name&quot;&gt;
          {props.author.name}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>接下来，我们将提取 <code>UserInfo</code> 组件，该组件在用户名旁渲染 <code>Avatar</code> 组件：</p>
<pre><code class="language-jsx">function UserInfo(props) {
  return (
    &lt;div className=&quot;UserInfo&quot;&gt;
      &lt;Avatar user={props.user} /&gt;
      &lt;div className=&quot;UserInfo-name&quot;&gt;
        {props.user.name}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>进一步简化 <code>Comment</code> 组件：</p>
<pre><code class="language-jsx">function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;UserInfo user={props.author} /&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>最初看上去，提取组件可能是一件繁重的工作，但是，在大型应用中，构建可复用组件库是完全值得的。根据经验来看，如果 UI 中有一部分被多次使用（<code>Button</code>，<code>Panel</code>，<code>Avatar</code>），或者组件本身就足够复杂（<code>App</code>，<code>FeedStory</code>，<code>Comment</code>），那么它就是一个可复用组件的候选项。</p>
<h2 id="props-的只读性"><a class="header" href="#props-的只读性">Props 的只读性</a></h2>
<p>组件无论是使用<a href="https://react.docschina.org/docs/components-and-props.html#function-and-class-components">函数声明还是通过 class 声明</a>，都决不能修改自身的 props。来看下这个 <code>sum</code> 函数：</p>
<pre><code class="language-js">function sum(a, b) {
  return a + b;
}
</code></pre>
<p>下面这个函数则不是纯函数，因为它更改了自己的入参：</p>
<pre><code>function withdraw(account, amount) {
  account.total -= amount;
}
</code></pre>
<p>React 非常灵活，但它也有一个严格的规则：</p>
<p><strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</strong></p>
<p>当然，应用程序的 UI 是动态的，并会伴随着时间的推移而变化。在<a href="https://react.docschina.org/docs/state-and-lifecycle.html">下一章节</a>中，我们将介绍一种新的概念，称之为 “state”。在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="state--生命周期"><a class="header" href="#state--生命周期">State &amp; 生命周期</a></h2>
<p>在<a href="https://react.docschina.org/docs/rendering-elements.html#rendering-an-element-into-the-dom">元素渲染</a>章节中，我们只了解了一种更新 UI 界面的方法。通过调用 <code>ReactDOM.render()</code> 来修改我们想要渲染的元素：</p>
<pre><code class="language-tsx">function tick() {
  const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
  ReactDOM.render(
    element,
    document.getElementById('root')
  );
}

setInterval(tick, 1000);
</code></pre>
<h2 id="将函数组件转换成-class-组件"><a class="header" href="#将函数组件转换成-class-组件">将函数组件转换成 class 组件</a></h2>
<p>通过以下几步将 <code>Clock</code> 的函数组件转成 class 组件：</p>
<ol>
<li>创建一个同名的 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 class</a>，并且继承于 <code>React.Component</code>。</li>
<li>添加一个空的 <code>render()</code> 方法。</li>
<li>将函数体移动到 <code>render()</code> 方法之中。</li>
<li>在 <code>render()</code> 方法中使用 <code>this.props</code> 替换 <code>props</code>。</li>
</ol>
<pre><code class="language-tsx">class Clock extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>每次组件更新时 <code>render</code> 方法都会被调用，但只要在相同的 DOM 节点中渲染 <code>&lt;Clock /&gt;</code> ，就仅有一个 <code>Clock</code> 组件的 class 实例被创建使用。这就使得我们可以使用如 state 或生命周期方法等很多其他特性。</p>
<pre><code class="language-tsx">class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById('root')
);
</code></pre>
<h2 id="将生命周期方法添加到-class-中"><a class="header" href="#将生命周期方法添加到-class-中">将生命周期方法添加到 Class 中</a></h2>
<p>在具有许多组件的应用程序中，当组件被销毁时释放所占用的资源是非常重要的。</p>
<p>当 <code>Clock</code> 组件第一次被渲染到 DOM 中的时候，就为其<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval">设置一个计时器</a>。这在 React 中被称为“挂载（mount）”。</p>
<p>同时，当 DOM 中 <code>Clock</code> 组件被删除的时候，应该<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval">清除计时器</a>。这在 React 中被称为“卸载（unmount）”。</p>
<p>我们可以为 class 组件声明一些特殊的方法，当组件挂载或卸载时就会去执行这些方法：</p>
<pre><code class="language-tsx">class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () =&gt; this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById('root')
);
</code></pre>
<h2 id="正确地使用-state"><a class="header" href="#正确地使用-state">正确地使用 State</a></h2>
<h3 id="不要直接修改-state"><a class="header" href="#不要直接修改-state">不要直接修改 State</a></h3>
<h3 id="state-的更新可能是异步的"><a class="header" href="#state-的更新可能是异步的">State 的更新可能是异步的</a></h3>
<p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用。</p>
<p>因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p>
<p>例如，此代码可能会无法更新计数器：</p>
<pre><code>// Wrong
this.setState({
  counter: this.state.counter + this.props.increment,
});
</code></pre>
<p>要解决这个问题，可以让 <code>setState()</code> 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p>
<pre><code class="language-tsx">// Correct
this.setState((state, props) =&gt; ({
  counter: state.counter + props.increment
}));
</code></pre>
<pre><code class="language-tsx">// Correct
this.setState(function(state, props) {
  return {
    counter: state.counter + props.increment
  };
});
</code></pre>
<p>例如，你的 state 包含几个独立的变量：</p>
<pre><code class="language-tsx">  constructor(props) {
    super(props);
    this.state = {
      posts: [],      comments: []    };
  }
</code></pre>
<p>然后你可以分别调用 <code>setState()</code> 来单独地更新它们：</p>
<pre><code class="language-tsx">  componentDidMount() {
    fetchPosts().then(response =&gt; {
      this.setState({
        posts: response.posts      });
    });

    fetchComments().then(response =&gt; {
      this.setState({
        comments: response.comments      });
    });
  }
</code></pre>
<h2 id="数据是向下流动的"><a class="header" href="#数据是向下流动的">数据是向下流动的</a></h2>
<p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p>
<p>这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。</p>
<p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中：</p>
<pre><code class="language-tsx">&lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
</code></pre>
<p>这对于自定义组件同样适用：</p>
<pre><code class="language-tsx">&lt;FormattedDate date={this.state.date} /&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="事件处理"><a class="header" href="#事件处理">事件处理</a></h1>
<p>React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同：</p>
<ul>
<li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li>
<li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</li>
</ul>
<p>传统的 HTML：</p>
<pre><code class="language-tsx">&lt;button onclick=&quot;activateLasers()&quot;&gt;
  Activate Lasers
&lt;/button&gt;
</code></pre>
<p>在 React 中略微不同：</p>
<pre><code class="language-tsx">&lt;button onClick={activateLasers}&gt;
  Activate Lasers
&lt;/button&gt;
</code></pre>
<p>在 React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。</p>
<p>你必须显式的使用 <code>preventDefault</code> 。例如，传统的 HTML 中阻止链接默认打开一个新页面，你可以这样写：</p>
<pre><code class="language-tsx">&lt;a href=&quot;#&quot; onclick=&quot;console.log('The link was clicked.'); return false&quot;&gt;
  Click me
&lt;/a&gt;
</code></pre>
<p>在 React 中，可能是这样的：</p>
<pre><code class="language-tsx">function ActionLink() {
  function handleClick(e) {    
      e.preventDefault();    
      console.log('The link was clicked.');  
  }
    
  return (
    &lt;a href=&quot;#&quot; onClick={handleClick}&gt;      Click me
    &lt;/a&gt;
  );
}
</code></pre>
<p>在这里，<code>e</code> 是一个合成事件。React 根据 <a href="https://www.w3.org/TR/DOM-Level-3-Events/">W3C 规范</a>来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。如果想了解更多，请查看 <a href="https://react.docschina.org/docs/events.html"><code>SyntheticEvent</code></a> 参考指南。</p>
<p>当你使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 class</a> 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 <code>Toggle</code> 组件会渲染一个让用户切换开关状态的按钮：</p>
<pre><code class="language-tsx">class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // 为了在回调中使用 `this`，这个绑定是必不可少的    this.handleClick = this.handleClick.bind(this);  }

  handleClick() {    this.setState(state =&gt; ({      isToggleOn: !state.isToggleOn    }));  }
  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;        {this.state.isToggleOn ? 'ON' : 'OFF'}
      &lt;/button&gt;
    );
  }
}

ReactDOM.render(
  &lt;Toggle /&gt;,
  document.getElementById('root')
);
</code></pre>
<pre><code class="language-tsx">import {Component} from &quot;react&quot;;
interface ToggleState {
    switch:boolean
}
export class Toggle extends Component&lt;any, ToggleState&gt;{
    constructor(props: any) {
        super(props);
        this.state = {switch:true};
    }
    render() {
        return &lt;button onClick={this.changeState}&gt;
            {this.state.switch?&quot;ON&quot;:&quot;OFF&quot;}
        &lt;/button&gt;;
    }
    changeState = ()=&gt;
        this.setState((state,props)=&gt;{
            return  {switch:!state.switch}
        })
}
</code></pre>
<p>你必须谨慎对待 JSX 回调函数中的 <code>this</code>，在 JavaScript 中，class 的方法默认不会<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">绑定</a> <code>this</code>。如果你忘记绑定 <code>this.handleClick</code> 并把它传入了 <code>onClick</code>，当你调用这个函数的时候 <code>this</code> 的值为 <code>undefined</code>。</p>
<p>这并不是 React 特有的行为；这其实与 <a href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/">JavaScript 函数工作原理</a>有关。通常情况下，如果你没有在方法后面添加 <code>()</code>，例如 <code>onClick={this.handleClick}</code>，你应该为这个方法绑定 <code>this</code>。</p>
<p>如果觉得使用 <code>bind</code> 很麻烦，这里有两种方式可以解决。如果你正在使用实验性的 <a href="https://babeljs.io/docs/plugins/transform-class-properties/">public class fields 语法</a>，你可以使用 class fields 正确的绑定回调函数：</p>
<pre><code>class LoggingButton extends React.Component {
  // 此语法确保 `handleClick` 内的 `this` 已被绑定。  // 注意: 这是 *实验性* 语法。  
  handleClick = () =&gt; {    console.log('this is:', this);  }
  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}
</code></pre>
<p>如果你没有使用 class fields 语法，你可以在回调中使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>：</p>
<pre><code class="language-tsx">class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this);
  }

  render() {
    // 此语法确保 `handleClick` 内的 `this` 已被绑定。    return (      &lt;button onClick={() =&gt; this.handleClick()}&gt;        Click me
      &lt;/button&gt;
    );
  }
}
</code></pre>
<p>此语法问题在于每次渲染 <code>LoggingButton</code> 时都会创建不同的回调函数。</p>
<p>在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。</p>
<h2 id="向事件处理程序传递参数"><a class="header" href="#向事件处理程序传递参数">向事件处理程序传递参数</a></h2>
<p>在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 <code>id</code> 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：</p>
<pre><code class="language-tsx">&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;
&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;

//上述两种方式是等价的，分别通过箭头函数和 Function.prototype.bind 来实现。
</code></pre>
<p>在这两种情况下，React 的事件对象 <code>e</code> 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条件渲染"><a class="header" href="#条件渲染">条件渲染</a></h1>
<p>在 React 中，你可以创建不同的组件来封装各种你需要的行为。然后，依据应用的不同状态，你可以只渲染对应状态下的部分内容。</p>
<p>React 中的条件渲染和 JavaScript 中的一样</p>
<p>观察这两个组件:</p>
<pre><code class="language-tsx">function UserGreeting(props) {
  return &lt;h1&gt;Welcome back!&lt;/h1&gt;;
}

function GuestGreeting(props) {
  return &lt;h1&gt;Please sign up.&lt;/h1&gt;;
}
</code></pre>
<p>再创建一个 <code>Greeting</code> 组件，它会根据用户是否登录来决定显示上面的哪一个组件。</p>
<pre><code class="language-tsx">function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;
  if (isLoggedIn) {    return &lt;UserGreeting /&gt;;  }  return &lt;GuestGreeting /&gt;;}
ReactDOM.render(
  // Try changing to isLoggedIn={true}:
  &lt;Greeting isLoggedIn={false} /&gt;,  document.getElementById('root'));
</code></pre>
<h2 id="元素变量"><a class="header" href="#元素变量">元素变量</a></h2>
<p>你可以使用变量来储存元素。 它可以帮助你有条件地渲染组件的一部分，而其他的渲染部分并不会因此而改变。</p>
<pre><code class="language-tsx">function LoginButton(props) {
  return (
    &lt;button onClick={props.onClick}&gt;
      Login
    &lt;/button&gt;
  );
}

function LogoutButton(props) {
  return (
    &lt;button onClick={props.onClick}&gt;
      Logout
    &lt;/button&gt;
  );
}
</code></pre>
<p>它将根据当前的状态来渲染 <code>&lt;LoginButton /&gt;</code> 或者 <code>&lt;LogoutButton /&gt;</code>。同时它还会渲染上一个示例中的 <code>&lt;Greeting /&gt;</code>。</p>
<pre><code class="language-tsx">class LoginControl extends React.Component {
  constructor(props) {
    super(props);
    this.handleLoginClick = this.handleLoginClick.bind(this);
    this.handleLogoutClick = this.handleLogoutClick.bind(this);
    this.state = {isLoggedIn: false};
  }

  handleLoginClick() {
    this.setState({isLoggedIn: true});
  }

  handleLogoutClick() {
    this.setState({isLoggedIn: false});
  }

  render() {
    const isLoggedIn = this.state.isLoggedIn;
    let button;
    if (isLoggedIn) {      button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;;    } else {      button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;;    }
    return (
      &lt;div&gt;
        &lt;Greeting isLoggedIn={isLoggedIn} /&gt;        {button}      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;LoginControl /&gt;,
  document.getElementById('root')
);
</code></pre>
<p>声明一个变量并使用 <code>if</code> 语句进行条件渲染是不错的方式，但有时你可能会想使用更为简洁的语法。接下来，我们将介绍几种在 JSX 中内联条件渲染的方法。</p>
<h3 id="-4"><a class="header" href="#-4"></a></h3>
<h2 id="与运算符"><a class="header" href="#与运算符">与运算符 &amp;&amp;</a></h2>
<p>通过花括号包裹代码，你可以<a href="https://react.docschina.org/docs/introducing-jsx.html#embedding-expressions-in-jsx">在 JSX 中嵌入任何表达式</a>。这也包括 JavaScript 中的逻辑与 (&amp;&amp;) 运算符。它可以很方便地进行元素的条件渲染。</p>
<pre><code class="language-jsx">function Mailbox(props) {
  const unreadMessages = props.unreadMessages;
  return (
    &lt;div&gt;
      &lt;h1&gt;Hello!&lt;/h1&gt;
      {unreadMessages.length &gt; 0 &amp;&amp;        &lt;h2&gt;          You have {unreadMessages.length} unread messages.        &lt;/h2&gt;      }    &lt;/div&gt;
  );
}

const messages = ['React', 'Re: React', 'Re:Re: React'];
ReactDOM.render(
  &lt;Mailbox unreadMessages={messages} /&gt;,
  document.getElementById('root')
);
</code></pre>
<h2 id="三目运算符"><a class="header" href="#三目运算符">三目运算符</a></h2>
<p>另一种内联条件渲染的方法是使用 JavaScript 中的三目运算符 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator"><code>condition ? true : false</code></a>。</p>
<pre><code class="language-jsx">render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    &lt;div&gt;
      The user is &lt;b&gt;{isLoggedIn ? 'currently' : 'not'}&lt;/b&gt; logged in.    &lt;/div&gt;
  );
}
</code></pre>
<pre><code class="language-jsx">render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    &lt;div&gt;
      {isLoggedIn        ? &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;
        : &lt;LoginButton onClick={this.handleLoginClick} /&gt;      }
    &lt;/div&gt;  );
}
</code></pre>
<h3 id="阻止组件渲染"><a class="header" href="#阻止组件渲染">阻止组件渲染</a></h3>
<p>在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 <code>render</code> 方法直接返回 <code>null</code>，而不进行任何渲染。</p>
<p>下面的示例中，<code>&lt;WarningBanner /&gt;</code> 会根据 prop 中 <code>warn</code> 的值来进行条件渲染。如果 <code>warn</code> 的值是 <code>false</code>，那么组件则不会渲染:</p>
<pre><code class="language-jsx">function WarningBanner(props) {
  if (!props.warn) {    return null;  }
  return (
    &lt;div className=&quot;warning&quot;&gt;
      Warning!
    &lt;/div&gt;
  );
}

class Page extends React.Component {
  constructor(props) {
    super(props);
    this.state = {showWarning: true};
    this.handleToggleClick = this.handleToggleClick.bind(this);
  }

  handleToggleClick() {
    this.setState(state =&gt; ({
      showWarning: !state.showWarning
    }));
  }

  render() {
    return (
      &lt;div&gt;
        &lt;WarningBanner warn={this.state.showWarning} /&gt;        &lt;button onClick={this.handleToggleClick}&gt;
          {this.state.showWarning ? 'Hide' : 'Show'}
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Page /&gt;,
  document.getElementById('root')
);
</code></pre>
<p>在组件的 <code>render</code> 方法中返回 <code>null</code> 并不会影响组件的生命周期。例如，上面这个示例中，<code>componentDidUpdate</code> 依然会被调用。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="列表--key"><a class="header" href="#列表--key">列表 &amp; Key</a></h2>
<h3 id="渲染多个组件"><a class="header" href="#渲染多个组件">渲染多个组件</a></h3>
<p>下面，我们使用 Javascript 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><code>map()</code></a> 方法来遍历 <code>numbers</code> 数组。将数组中的每个元素变成 <code>&lt;li&gt;</code> 标签，最后我们将得到的数组赋值给 <code>listItems</code>：</p>
<pre><code class="language-tsx">const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =&gt;  &lt;li&gt;{number}&lt;/li&gt;);
</code></pre>
<pre><code class="language-tsx">ReactDOM.render(
  &lt;ul&gt;{listItems}&lt;/ul&gt;,  document.getElementById('root')
);
</code></pre>
<h3 id="基础列表组件"><a class="header" href="#基础列表组件">基础列表组件</a></h3>
<p>我们可以把前面的例子重构成一个组件，这个组件接收 <code>numbers</code> 数组作为参数并输出一个元素列表。</p>
<pre><code class="language-tsx">function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =&gt;    &lt;li&gt;{number}&lt;/li&gt;  );  return (
    &lt;ul&gt;{listItems}&lt;/ul&gt;  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  &lt;NumberList numbers={numbers} /&gt;,  document.getElementById('root')
);
</code></pre>
<p>当我们运行这段代码，将会看到一个警告 <code>a key should be provided for list items</code>，意思是当你创建一个元素时，必须包括一个特殊的 <code>key</code> 属性。我们将在下一节讨论这是为什么。</p>
<p>让我们来给每个列表元素分配一个 <code>key</code> 属性来解决上面的那个警告：</p>
<pre><code class="language-tsx">function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =&gt;
    &lt;li key={number.toString()}&gt;      {number}
    &lt;/li&gt;
  );
  return (
    &lt;ul&gt;{listItems}&lt;/ul&gt;
  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  &lt;NumberList numbers={numbers} /&gt;,
  document.getElementById('root')
);
</code></pre>
<h2 id="key"><a class="header" href="#key">key</a></h2>
<p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。</p>
<pre><code class="language-tsx">const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =&gt;
  &lt;li key={number.toString()}&gt;    {number}
  &lt;/li&gt;
);
</code></pre>
<p>如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。可以看看 Robin Pokorny 的<a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318">深度解析使用索引作为 key 的负面影响</a>这一篇文章。如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。</p>
<p>要是你有兴趣了解更多的话，这里有一篇文章<a href="https://react.docschina.org/docs/reconciliation.html#recursing-on-children">深入解析为什么 key 是必须的</a>可以参考。</p>
<h3 id="用-key-提取组件"><a class="header" href="#用-key-提取组件">用 key 提取组件</a></h3>
<p>元素的 key 只有放在就近的数组上下文中才有意义。</p>
<pre><code class="language-tsx">function ListItem(props) {
  const value = props.value;
  return (
    // 错误！你不需要在这里指定 key：    &lt;li key={value.toString()}&gt;      {value}
    &lt;/li&gt;
  );
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =&gt;
    // 错误！元素的 key 应该在这里指定：    &lt;ListItem value={number} /&gt;  );
  return (
    &lt;ul&gt;
      {listItems}
    &lt;/ul&gt;
  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  &lt;NumberList numbers={numbers} /&gt;,
  document.getElementById('root')
);
</code></pre>
<p><strong>例子：正确的使用 key 的方式</strong></p>
<pre><code class="language-tsx">function ListItem(props) {
  // 正确！这里不需要指定 key：  return &lt;li&gt;{props.value}&lt;/li&gt;;}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =&gt;
    // 正确！key 应该在数组的上下文中被指定    &lt;ListItem key={number.toString()}              value={number} /&gt;
  );
  return (
    &lt;ul&gt;
      {listItems}
    &lt;/ul&gt;
  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  &lt;NumberList numbers={numbers} /&gt;,
  document.getElementById('root')
);
</code></pre>
<h3 id="key-只是在兄弟节点之间必须唯一"><a class="header" href="#key-只是在兄弟节点之间必须唯一">key 只是在兄弟节点之间必须唯一</a></h3>
<h3 id="在-jsx-中嵌入-map"><a class="header" href="#在-jsx-中嵌入-map">在 JSX 中嵌入 map()</a></h3>
<p>JSX 允许在大括号中<a href="https://react.docschina.org/docs/introducing-jsx.html#embedding-expressions-in-jsx">嵌入任何表达式</a>，所以我们可以内联 <code>map()</code> 返回的结果：</p>
<pre><code class="language-tsx">function NumberList(props) {
  const numbers = props.numbers;
  return (
    &lt;ul&gt;
      {numbers.map((number) =&gt;        &lt;ListItem key={number.toString()}                  value={number} /&gt;      )}    &lt;/ul&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表单"><a class="header" href="#表单">表单</a></h1>
<p>在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state。例如这个纯 HTML 表单只接受一个名称：</p>
<pre><code class="language-tsx">&lt;form&gt;
  &lt;label&gt;
    名字:
    &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;
  &lt;/label&gt;
  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
&lt;/form&gt;
</code></pre>
<h2 id="受控组件"><a class="header" href="#受控组件">受控组件</a></h2>
<p>在 HTML 中，表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 <a href="https://react.docschina.org/docs/react-component.html#setstate"><code>setState()</code></a>来更新。</p>
<p>我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p>
<pre><code class="language-tsx">class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};
    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {    this.setState({value: event.target.value});  }
  handleSubmit(event) {
    alert('提交的名字: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          名字:
          &lt;input type=&quot;text&quot; value={this.state.value} onChange={this.handleChange} /&gt;        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
      &lt;/form&gt;
    );
  }
}
</code></pre>
<p>由于在表单元素上设置了 <code>value</code> 属性，因此显示的值将始终为 <code>this.state.value</code>，这使得 React 的 state 成为唯一数据源。由于 <code>handlechange</code> 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</p>
<p>对于受控组件来说，输入的值始终由 React 的 state 驱动。你也可以将 value 传递给其他 UI 元素，或者通过其他事件处理函数重置，但这意味着你需要编写更多的代码。</p>
<h2 id="textarea-标签"><a class="header" href="#textarea-标签">textarea 标签</a></h2>
<p>在 HTML 中, <code>&lt;textarea&gt;</code> 元素通过其子元素定义其文本:</p>
<pre><code class="language-jsx">&lt;textarea&gt;
  你好， 这是在 text area 里的文本
&lt;/textarea&gt;
</code></pre>
<pre><code class="language-jsx">class EssayForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {      value: '请撰写一篇关于你喜欢的 DOM 元素的文章.'    };
    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {    this.setState({value: event.target.value});  }
  handleSubmit(event) {
    alert('提交的文章: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          文章:
          &lt;textarea value={this.state.value} onChange={this.handleChange} /&gt;        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
      &lt;/form&gt;
    );
  }
}
</code></pre>
<h2 id="select-标签"><a class="header" href="#select-标签">select 标签</a></h2>
<p>在 HTML 中，<code>&lt;select&gt;</code> 创建下拉列表标签。例如，如下 HTML 创建了水果相关的下拉列表：</p>
<pre><code class="language-jsx">&lt;select&gt;
  &lt;option value=&quot;grapefruit&quot;&gt;葡萄柚&lt;/option&gt;
  &lt;option value=&quot;lime&quot;&gt;酸橙&lt;/option&gt;
  &lt;option selected value=&quot;coconut&quot;&gt;椰子&lt;/option&gt;
  &lt;option value=&quot;mango&quot;&gt;芒果&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<p>请注意，由于 <code>selected</code> 属性的缘故，椰子选项默认被选中。React 并不会使用 <code>selected</code> 属性，而是在根 <code>select</code> 标签上使用 <code>value</code> 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。例如：</p>
<pre><code class="language-jsx">class FlavorForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: 'coconut'};
    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {    this.setState({value: event.target.value});  }
  handleSubmit(event) {
    alert('你喜欢的风味是: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          选择你喜欢的风味:
          &lt;select value={this.state.value} onChange={this.handleChange}&gt;            &lt;option value=&quot;grapefruit&quot;&gt;葡萄柚&lt;/option&gt;
            &lt;option value=&quot;lime&quot;&gt;酸橙&lt;/option&gt;
            &lt;option value=&quot;coconut&quot;&gt;椰子&lt;/option&gt;
            &lt;option value=&quot;mango&quot;&gt;芒果&lt;/option&gt;
          &lt;/select&gt;
        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
      &lt;/form&gt;
    );
  }
}
</code></pre>
<h2 id="文件-input-标签"><a class="header" href="#文件-input-标签">文件 input 标签</a></h2>
<p>在 HTML 中，<code>&lt;input type=&quot;file&quot;&gt;</code> 允许用户从存储设备中选择一个或多个文件，将其上传到服务器，或通过使用 JavaScript 的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications">File API</a> 进行控制。</p>
<pre><code>&lt;input type=&quot;file&quot; /&gt;
</code></pre>
<p>因为它的 value 只读，所以它是 React 中的一个<strong>非受控</strong>组件。将与其他非受控组件<a href="https://react.docschina.org/docs/uncontrolled-components.html#the-file-input-tag">在后续文档中</a>一起讨论。</p>
<p>当需要处理多个 <code>input</code> 元素时，我们可以给每个元素添加 <code>name</code> 属性，并让处理函数根据 <code>event.target.name</code> 的值选择要执行的操作。</p>
<pre><code class="language-jsx">class Reservation extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isGoing: true,
      numberOfGuests: 2
    };

    this.handleInputChange = this.handleInputChange.bind(this);
  }

  handleInputChange(event) {
    const target = event.target;
    const value = target.name === 'isGoing' ? target.checked : target.value;
    const name = target.name;
    this.setState({
      [name]: value    });
  }

  render() {
    return (
      &lt;form&gt;
        &lt;label&gt;
          参与:
          &lt;input
            name=&quot;isGoing&quot;            type=&quot;checkbox&quot;
            checked={this.state.isGoing}
            onChange={this.handleInputChange} /&gt;
        &lt;/label&gt;
        &lt;br /&gt;
        &lt;label&gt;
          来宾人数:
          &lt;input
            name=&quot;numberOfGuests&quot;            type=&quot;number&quot;
            value={this.state.numberOfGuests}
            onChange={this.handleInputChange} /&gt;
        &lt;/label&gt;
      &lt;/form&gt;
    );
  }
}
</code></pre>
<pre><code class="language-jsx">this.setState({
  [name]: value});
</code></pre>
<h2 id="受控输入空值"><a class="header" href="#受控输入空值">受控输入空值</a></h2>
<p>在<a href="https://react.docschina.org/docs/forms.html#controlled-components">受控组件</a>上指定 value 的 prop 会阻止用户更改输入。如果你指定了 <code>value</code>，但输入仍可编辑，则可能是你意外地将<code>value</code> 设置为 <code>undefined</code> 或 <code>null</code>。</p>
<p>下面的代码演示了这一点。（输入最初被锁定，但在短时间延迟后变为可编辑。）</p>
<pre><code class="language-jsx">ReactDOM.render(&lt;input value=&quot;hi&quot; /&gt;, mountNode);

setTimeout(function() {
  ReactDOM.render(&lt;input value={null} /&gt;, mountNode);
}, 1000);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="组合-vs-继承"><a class="header" href="#组合-vs-继承">组合 vs 继承</a></h1>
<h2 id="包含关系"><a class="header" href="#包含关系">包含关系</a></h2>
<p>有些组件无法提前知晓它们子组件的具体内容。在 <code>Sidebar</code>（侧边栏）和 <code>Dialog</code>（对话框）等展现通用容器（box）的组件中特别容易遇到这种情况。</p>
<p>我们建议这些组件使用一个特殊的 <code>children</code> prop 来将他们的子组件传递到渲染结果中：</p>
<pre><code class="language-jsx">function FancyBorder(props) {
  return (
    &lt;div className={'FancyBorder FancyBorder-' + props.color}&gt;
      {props.children}    &lt;/div&gt;
  );
}
</code></pre>
<p>这使得别的组件可以通过 JSX 嵌套，将任意组件作为子组件传递给它们。</p>
<pre><code class="language-jsx">function WelcomeDialog() {
  return (
    &lt;FancyBorder color=&quot;blue&quot;&gt;
      &lt;h1 className=&quot;Dialog-title&quot;&gt;        Welcome      &lt;/h1&gt;      &lt;p className=&quot;Dialog-message&quot;&gt;        Thank you for visiting our spacecraft!      &lt;/p&gt;    &lt;/FancyBorder&gt;
  );
}
</code></pre>
<ol>
<li>
<p><code>&lt;FancyBorder&gt;</code> JSX 标签中的所有内容都会作为一个 <code>children</code> prop 传递给 <code>FancyBorder</code> 组件。</p>
</li>
<li>
<p>因为 <code>FancyBorder</code> 将 <code>{props.children}</code> 渲染在一个 <code>&lt;div&gt;</code> 中，被传递的这些子组件最终都会出现在输出结果中。</p>
</li>
</ol>
<pre><code class="language-jsx">function SplitPane(props) {
  return (
    &lt;div className=&quot;SplitPane&quot;&gt;
      &lt;div className=&quot;SplitPane-left&quot;&gt;
        {props.left}      &lt;/div&gt;
      &lt;div className=&quot;SplitPane-right&quot;&gt;
        {props.right}      &lt;/div&gt;
    &lt;/div&gt;
  );
}

function App() {
  return (
    &lt;SplitPane
      left={
        &lt;Contacts /&gt;      }
      right={
        &lt;Chat /&gt;      } /&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-哲学"><a class="header" href="#react-哲学">React 哲学</a></h1>
<p>React 最棒的部分之一是引导我们思考如何构建一个应用。在这篇文档中，我们将会通过 React 构建一个可搜索的<strong>产品数据表格</strong>来更深刻地领会 React 哲学。</p>
<h2 id="从设计稿开始"><a class="header" href="#从设计稿开始">从设计稿开始</a></h2>
<p>假设我们已经有了一个返回 JSON 的 API，以及设计师提供的组件设计稿。如下所示：</p>
<p>该 JSON API 会返回以下数据：</p>
<pre><code class="language-json">[
  {category: &quot;Sporting Goods&quot;, price: &quot;$49.99&quot;, stocked: true, name: &quot;Football&quot;},
  {category: &quot;Sporting Goods&quot;, price: &quot;$9.99&quot;, stocked: true, name: &quot;Baseball&quot;},
  {category: &quot;Sporting Goods&quot;, price: &quot;$29.99&quot;, stocked: false, name: &quot;Basketball&quot;},
  {category: &quot;Electronics&quot;, price: &quot;$99.99&quot;, stocked: true, name: &quot;iPod Touch&quot;},
  {category: &quot;Electronics&quot;, price: &quot;$399.99&quot;, stocked: false, name: &quot;iPhone 5&quot;},
  {category: &quot;Electronics&quot;, price: &quot;$199.99&quot;, stocked: true, name: &quot;Nexus 7&quot;}
];
</code></pre>
<h2 id="第一步将设计好的-ui-划分为组件层级"><a class="header" href="#第一步将设计好的-ui-划分为组件层级">第一步：将设计好的 UI 划分为组件层级</a></h2>
<p>首先，你需要在设计稿上用方框圈出每一个组件（包括它们的子组件），并且以合适的名称命名</p>
<p>如果你是和设计师一起完成此任务，那么他们可能已经做过类似的工作，所以请和他们进行交流！他们的 Photoshop 的图层名称可能最终就是你编写的 React 组件的名称！</p>
<p>但你如何确定应该将哪些部分划分到一个组件中呢？</p>
<ul>
<li>你可以将组件当作一种函数或者是对象来考虑，根据<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">单一功能原则</a>来判定组件的范围</li>
<li>也就是说，一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。</li>
</ul>
<p>在实践中，因为你经常是在向用户展示 JSON 数据模型，所以如果你的模型设计得恰当</p>
<p>UI（或者说组件结构）便会与数据模型一一对应，这是因为 UI 和数据模型都会倾向于遵守相同的<em>信息结构</em>。</p>
<p>将 UI 分离为组件，其中每个组件需与数据模型的某部分匹配。</p>
<p><img src="reactor/%5Cimages%5Cthinking-in-react-components.png" alt="Component diagram" /></p>
<ol>
<li><strong><code>FilterableProductTable</code> (橙色):</strong> 是整个示例应用的整体</li>
<li><strong><code>SearchBar</code> (蓝色):</strong> 接受所有的<em>用户输入</em></li>
<li><strong><code>ProductTable</code> (绿色):</strong> 展示<em>数据内容</em>并根据<em>用户输入</em>筛选结果</li>
<li><strong><code>ProductCategoryRow</code> (天蓝色):</strong> 为每一个<em>产品类别</em>展示标题</li>
<li><strong><code>ProductRow</code> (红色):</strong> 每一行展示一个<em>产品</em></li>
</ol>
<p>你可能注意到，<code>ProductTable</code> 的表头（包含 “Name” 和 “Price” 的那一部分）并未单独成为一个组件</p>
<p>这仅仅是一种偏好选择，如何处理这一问题也一直存在争论</p>
<p>就这个示例而言，因为表头只起到了渲染<em>数据集合</em>的作用——这与 <code>ProductTable</code> 是一致的，所以我们仍然将其保留为 <code>ProductTable</code> 的一部分</p>
<p>但是，如果表头过于复杂（例如，我们需为其添加排序功能），那么将它作为一个独立的 <code>ProductTableHeader</code> 组件就显得很有必要了。</p>
<p>现在我们已经确定了设计稿中应该包含的组件，接下来我们将把它们描述为更加清晰的层级。设计稿中被其他组件包含的子组件，在层级上应该作为其子节点。</p>
<ul>
<li><code>FilterableProductTable</code>
<ul>
<li><code>SearchBar</code></li>
<li><code>ProductTable</code>
<ul>
<li><code>ProductCategoryRow</code></li>
<li><code>ProductRow</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>分离交互与UI渲染</strong></p>
<p>现在我们已经确定了组件层级，可以编写对应的应用了</p>
<ul>
<li>
<p>最容易的方式，是先用已有的数据模型渲染一个不包含交互功能的 UI</p>
<ol>
<li>
<p>最好将渲染 UI 和添加交互这两个过程分开</p>
</li>
<li>
<p>这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节</p>
</li>
<li>
<p>添加交互功能时则要考虑大量细节，而不需要编写太多代码</p>
</li>
</ol>
</li>
</ul>
<p>所以，将这两个过程分开进行更为合适。我们会在接下来的代码中体会到其中的区别。</p>
<p>在构建应用的静态版本时，我们需要创建一些会重用其他组件的组件，然后通过 <em>props</em> 传入所需的数据</p>
<p><em>props</em> 是父组件向子组件传递数据的方式</p>
<p>即使你已经熟悉了 <em>state</em> 的概念，也<strong>完全不应该使用 state</strong> 构建静态版本</p>
<p>state 代表了随时间会产生变化的数据，应当仅在实现交互时使用。所以构建应用的静态版本时，你不会用到它。</p>
<p><strong>自上而下或者自下而上</strong></p>
<p>你可以自上而下或者自下而上构建应用：自上而下意味着首先编写层级较高的组件（比如 <code>FilterableProductTable</code>），</p>
<p>自下而上意味着从最基本的组件开始编写（比如 <code>ProductRow</code>）。</p>
<p>当你的应用比较简单时，使用自上而下的方式更方便；</p>
<p>对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。</p>
<p>到此为止，你应该已经有了一个可重用的组件库来渲染你的数据模型</p>
<p>由于我们构建的是静态版本，所以这些组件目前只需提供 <code>render()</code> 方法用于渲染</p>
<p>最顶层的组件 <code>FilterableProductTable</code> 通过 props 接受你的数据模型</p>
<p>如果你的数据模型发生了改变，再次调用 <code>ReactDOM.render()</code>，UI 就会相应地被更新</p>
<p>数据模型变化、调用 <code>render()</code> 方法、UI 相应变化，因此很容易看清楚 UI 是如何被更新的，以及是在哪里被更新的。</p>
<p>React <strong>单向数据流</strong>（也叫<em>单向绑定</em>）的思想使得组件模块化，易于快速开发。</p>
<h2 id="第三步确定-ui-state-的最小且完整表示"><a class="header" href="#第三步确定-ui-state-的最小且完整表示">第三步：确定 UI state 的最小（且完整）表示</a></h2>
<p>想要使你的 UI 具备交互功能，需要有触发基础数据模型改变的能力。React 通过实现 <strong>state</strong> 来完成这个任务。</p>
<p>为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据</p>
<p>其中的关键正是 <a href="https://en.wikipedia.org/wiki/Don&#x27;t_repeat_yourself">DRY: <em>Don’t Repeat Yourself</em></a>。只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生</p>
<p><strong>示例</strong></p>
<p>。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。</p>
<p>我们的示例应用拥有如下数据：</p>
<ul>
<li>包含所有产品的原始列表</li>
<li>用户输入的搜索词</li>
<li>复选框是否选中的值</li>
<li>经过搜索筛选的产品列表</li>
</ul>
<p>通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：</p>
<ol>
<li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</li>
<li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li>
<li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</li>
</ol>
<p>包含所有产品的原始列表是经由 props 传入的，所以它不是 state</p>
<p>搜索词和复选框的值应该是 state：因为它们随时间会发生改变且无法由其他数据计算而来</p>
<p>经过搜索筛选的产品列表不是 state，因为它的结果可以由产品的原始列表根据搜索词和复选框的选择计算出来。</p>
<p>综上所述，属于 state 的有：</p>
<ul>
<li>用户输入的搜索词</li>
<li>复选框是否选中的值</li>
</ul>
<h2 id="第四步确定-state-放置的位置"><a class="header" href="#第四步确定-state-放置的位置">第四步：确定 state 放置的位置</a></h2>
<p>我们已经确定了应用所需的 state 的最小集合。接下来，我们需要确定哪个组件能够改变这些 state，或者说<em>拥有</em>这些 state。</p>
<p>注意：React 中的数据流是单向的，并顺着组件层级从上往下传递</p>
<p>对于应用中的每一个 state：</p>
<ul>
<li>找到根据这个 state 进行渲染的所有组件。</li>
<li>找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。</li>
<li>该共同所有者组件或者比它层级更高的组件应该拥有该 state。</li>
<li>如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。</li>
</ul>
<p>根据以上策略重新考虑我们的示例应用：</p>
<ul>
<li><code>ProductTable</code> 需要根据 state 筛选产品列表。<code>SearchBar</code> 需要展示搜索词和复选框的状态。</li>
<li>他们的共同所有者是 <code>FilterableProductTable</code>。</li>
<li>因此，搜索词和复选框的值应该很自然地存放在 <code>FilterableProductTable</code> 组件中。</li>
</ul>
<p>很好，我们已经决定把这些 state 存放在 <code>FilterableProductTable</code> 组件中</p>
<ol>
<li>首先，将实例属性 <code>this.state = {filterText: '', inStockOnly: false}</code> 添加到 <code>FilterableProductTable</code> 的 <code>constructor</code> 中，设置应用的初始 state</li>
<li>接着，将 <code>filterText</code> 和 <code>inStockOnly</code> 作为 props 传入 <code>ProductTable</code> 和 <code>SearchBar</code>；最后，用这些 props 筛选 <code>ProductTable</code> 中的产品信息，并设置 <code>SearchBar</code> 的表单值。</li>
</ol>
<p>你现在可以看到应用的变化了：将 <code>filterText</code> 设置为 <code>&quot;ball&quot;</code> 并刷新应用，你能发现表格中的数据已经更新了。</p>
<h2 id="第五步添加反向数据流"><a class="header" href="#第五步添加反向数据流">第五步：添加反向数据流</a></h2>
<p>到目前为止，我们已经借助自上而下传递的 props 和 state 渲染了一个应用。</p>
<p>现在，我们将尝试让数据反向传递：<strong>处于较低层级的表单组件更新较高层级的 <code>FilterableProductTable</code> 中的 state。</strong></p>
<p><strong>反向绑定</strong></p>
<p>React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递</p>
<p>尽管如此，但这种需要显式声明的方法更有助于人们<strong>理解程序的运作方式</strong>。</p>
<p><strong>单向数据流中的数据固定</strong></p>
<p>如果你在这时尝试在搜索框输入或勾选复选框，React 不会产生任何响应。这是正常的，因为我们之前已经将 <code>input</code> 的值设置为了从 <code>FilterableProductTable</code> 的 <code>state</code> 传递而来的固定值。</p>
<p><strong>使用事件回调函数更新状态</strong></p>
<p>让我们重新梳理一下需要实现的功能：每当用户改变表单的值，我们需要改变 state 来反映用户的当前输入。</p>
<p>由于 state 只能由拥有它们的组件进行更改，<code>FilterableProductTable</code> 必须将一个能够触发 state 改变的回调函数（callback）传递给 <code>SearchBar</code>。我们可以使用输入框的 <code>onChange</code> 事件来监视用户输入的变化，并通知 <code>FilterableProductTable</code> 传递给 <code>SearchBar</code> 的回调函数。然后该回调函数将调用 <code>setState()</code>，从而更新应用。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="refs-and-the-dom"><a class="header" href="#refs-and-the-dom">Refs and the DOM</a></h1>
<p><strong>单向数据流</strong></p>
<p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。</p>
<p>在典型的 React 数据流中，<a href="https://zh-hans.reactjs.org/docs/components-and-props.html">props</a> 是父组件与子组件交互的唯一方式</p>
<p><strong>要修改一个子组件，你需要使用新的 props 来重新渲染它</strong></p>
<p><strong>强制修改子组件</strong></p>
<p>但是，在某些情况下，你需要在典型数据流之外强制修改子组件</p>
<p>被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素</p>
<p>对于这两种情况，React 都提供了解决办法。</p>
<h2 id="何时使用-refs"><a class="header" href="#何时使用-refs">何时使用 Refs</a></h2>
<p>下面是几个适合使用 refs 的情况：</p>
<ul>
<li>管理焦点，文本选择或媒体播放。</li>
<li>触发强制动画。</li>
<li>集成第三方 DOM 库。</li>
</ul>
<p>避免使用 refs 来做任何可以通过声明式实现来完成的事情。 </p>
<p>举个例子，避免在 <code>Dialog</code> 组件里暴露 <code>open()</code> 和 <code>close()</code> 方法，最好传递 <code>isOpen</code> 属性。</p>
<h3 id="勿过度使用-refs"><a class="header" href="#勿过度使用-refs">勿过度使用 Refs</a></h3>
<p>你可能首先会想到使用 refs 在你的 app 中“让事情发生”。如果是这种情况，请花一点时间，认真再考虑一下 state 属性应该被安排在哪个组件层中。通常你会想明白，让更高的组件层级拥有这个 state，是更恰当的。查看 <a href="https://zh-hans.reactjs.org/docs/lifting-state-up.html">状态提升</a> 以获取更多有关示例。</p>
<h3 id="创建-refs"><a class="header" href="#创建-refs">创建 Refs</a></h3>
<p>Refs 是使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。</p>
<pre><code class="language-jsx">class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();  }
  render() {
    return &lt;div ref={this.myRef} /&gt;;  }
}
</code></pre>
<h3 id="访问-refs"><a class="header" href="#访问-refs">访问 Refs</a></h3>
<p>当 ref 被传递给 <code>render</code> 中的元素时，对该节点的引用可以在 ref 的 <code>current</code> 属性中被访问。</p>
<pre><code class="language-jsx">const node = this.myRef.current;
</code></pre>
<p>ref 的值根据节点的类型而有所不同：</p>
<ul>
<li>当 <code>ref</code> 属性用于 HTML 元素时，构造函数中使用 <code>React.createRef()</code> 创建的 <code>ref</code> 接收底层 DOM 元素作为其 <code>current</code> 属性。</li>
<li>当 <code>ref</code> 属性用于自定义 class 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</li>
<li><strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为他们没有实例。</li>
</ul>
<p>以下例子说明了这些差异。</p>
<h4 id="为-dom-元素添加-ref"><a class="header" href="#为-dom-元素添加-ref">为 DOM 元素添加 ref</a></h4>
<p>以下代码使用 <code>ref</code> 去存储 DOM 节点的引用：</p>
<pre><code class="language-jsx">class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    // 创建一个 ref 来存储 textInput 的 DOM 元素
    this.textInput = React.createRef();    this.focusTextInput = this.focusTextInput.bind(this);
  }

  focusTextInput() {
    // 直接使用原生 API 使 text 输入框获得焦点
    // 注意：我们通过 &quot;current&quot; 来访问 DOM 节点
    this.textInput.current.focus();  }

  render() {
    // 告诉 React 我们想把 &lt;input&gt; ref 关联到
    // 构造器里创建的 `textInput` 上
    return (
      &lt;div&gt;
        &lt;input
          type=&quot;text&quot;
          ref={this.textInput} /&gt;        &lt;input
          type=&quot;button&quot;
          value=&quot;Focus the text input&quot;
          onClick={this.focusTextInput}
        /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>React 会在组件挂载时给 <code>current</code> 属性传入 DOM 元素，并在组件卸载时传入 <code>null</code> 值。<code>ref</code> 会在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期钩子触发前更新。</p>
<h4 id="为-class-组件添加-ref"><a class="header" href="#为-class-组件添加-ref">为 class 组件添加 Ref</a></h4>
<p>如果我们想包装上面的 <code>CustomTextInput</code>，来模拟它挂载之后立即被点击的操作，我们可以使用 ref 来获取这个自定义的 input 组件并手动调用它的 <code>focusTextInput</code> 方法：</p>
<pre><code class="language-jsx">class AutoFocusTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();  }

  componentDidMount() {
    this.textInput.current.focusTextInput();  }

  render() {
    return (
      &lt;CustomTextInput ref={this.textInput} /&gt;    );
  }
}
</code></pre>
<p>请注意，这仅在 <code>CustomTextInput</code> 声明为 class 时才有效：</p>
<h4 id="refs-与函数组件"><a class="header" href="#refs-与函数组件">Refs 与函数组件</a></h4>
<p>默认情况下，<strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为它们没有实例：</p>
<pre><code class="language-jsx">function MyFunctionComponent() {  return &lt;input /&gt;;
}

class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();  }
  render() {
    // This will *not* work!
    return (
      &lt;MyFunctionComponent ref={this.textInput} /&gt;    );
  }
}
</code></pre>
<p>如果要在函数组件中使用 <code>ref</code>，你可以使用 <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html"><code>forwardRef</code></a>（可与 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a> 结合使用），或者可以将该组件转化为 class 组件。</p>
<p>不管怎样，你可以<strong>在函数组件内部使用 <code>ref</code> 属性</strong>，只要它指向一个 DOM 元素或 class 组件：</p>
<h3 id="将-dom-refs-暴露给父组件"><a class="header" href="#将-dom-refs-暴露给父组件">将 DOM Refs 暴露给父组件</a></h3>
<p>在极少数情况下，你可能希望在父组件中引用子节点的 DOM 节点。通常不建议这样做，因为它会打破组件的封装，但它偶尔可用于触发焦点或测量子 DOM 节点的大小或位置。</p>
<p>虽然你可以<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#adding-a-ref-to-a-class-component">向子组件添加 ref</a>，但这不是一个理想的解决方案，因为你只能获取组件实例而不是 DOM 节点。并且，它还在函数组件上无效。</p>
<p>如果你使用 16.3 或更高版本的 React, 这种情况下我们推荐使用 <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html">ref 转发</a>。<strong>Ref 转发使组件可以像暴露自己的 ref 一样暴露子组件的 ref</strong>。关于怎样对父组件暴露子组件的 DOM 节点，在 <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components">ref 转发文档</a>中有一个详细的例子。</p>
<p>如果你使用 16.2 或更低版本的 React，或者你需要比 ref 转发更高的灵活性，你可以使用<a href="https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509">这个替代方案</a>将 ref 作为特殊名字的 prop 直接传递。</p>
<p>可能的话，我们不建议暴露 DOM 节点，但有时候它会成为救命稻草。注意这个方案需要你在子组件中增加一些代码。如果你对子组件的实现没有控制权的话，你剩下的选择是使用 <a href="https://zh-hans.reactjs.org/docs/react-dom.html#finddomnode"><code>findDOMNode()</code></a>，但在<a href="https://zh-hans.reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage"><code>严格模式</code></a> 下已被废弃且不推荐使用。</p>
<h3 id="-5"><a class="header" href="#-5"></a></h3>
<h3 id="回调-refs"><a class="header" href="#回调-refs">回调 Refs</a></h3>
<p>React 也支持另一种设置 refs 的方式，称为“回调 refs”。它能助你更精细地控制何时 refs 被设置和解除。</p>
<p>不同于传递 <code>createRef()</code> 创建的 <code>ref</code> 属性，你会传递一个函数。这个函数中接受 React 组件实例或 HTML DOM 元素作为参数，以使它们能在其他地方被存储和访问。</p>
<p>下面的例子描述了一个通用的范例：使用 <code>ref</code> 回调函数，在实例的属性中存储对 DOM 节点的引用。</p>
<pre><code class="language-jsx">class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);

    this.textInput = null;
    this.setTextInputRef = element =&gt; {      this.textInput = element;    };
    this.focusTextInput = () =&gt; {      // 使用原生 DOM API 使 text 输入框获得焦点      if (this.textInput) this.textInput.focus();    };  }

  componentDidMount() {
    // 组件挂载后，让文本框自动获得焦点
    this.focusTextInput();  }

  render() {
    // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React
    // 实例上（比如 this.textInput）
    return (
      &lt;div&gt;
        &lt;input
          type=&quot;text&quot;
          ref={this.setTextInputRef}        /&gt;
        &lt;input
          type=&quot;button&quot;
          value=&quot;Focus the text input&quot;
          onClick={this.focusTextInput}        /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>React 将在组件挂载时，会调用 <code>ref</code> 回调函数并传入 DOM 元素，当卸载时调用它并传入 <code>null</code>。在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 触发前，React 会保证 refs 一定是最新的。</p>
<p>你可以在组件间传递回调形式的 refs，就像你可以传递通过 <code>React.createRef()</code> 创建的对象 refs 一样。</p>
<pre><code class="language-jsx">function CustomTextInput(props) {
  return (
    &lt;div&gt;
      &lt;input ref={props.inputRef} /&gt;    &lt;/div&gt;
  );
}

class Parent extends React.Component {
  render() {
    return (
      &lt;CustomTextInput
        inputRef={el =&gt; this.inputElement = el}      /&gt;
    );
  }
}
</code></pre>
<p>在上面的例子中，<code>Parent</code> 把它的 refs 回调函数当作 <code>inputRef</code> props 传递给了 <code>CustomTextInput</code>，而且 <code>CustomTextInput</code> 把相同的函数作为特殊的 <code>ref</code> 属性传递给了 <code>&lt;input&gt;</code>。结果是，在 <code>Parent</code> 中的 <code>this.inputElement</code> 会被设置为与 <code>CustomTextInput</code> 中的 <code>input</code> 元素相对应的 DOM 节点。</p>
<h3 id="-6"><a class="header" href="#-6"></a></h3>
<h3 id="关于回调-refs-的说明"><a class="header" href="#关于回调-refs-的说明">关于回调 refs 的说明</a></h3>
<p>如果 <code>ref</code> 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 <code>null</code>，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</p>
<h1 id="refs-转发"><a class="header" href="#refs-转发">Refs 转发</a></h1>
<p>Ref 转发是一项将 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">ref</a> 自动地通过组件传递到其一子组件的技巧。对于大多数应用中的组件来说，这通常不是必需的。但其对某些组件，尤其是可重用的组件库是很有用的。最常见的案例如下所述。</p>
<h2 id="转发-refs-到-dom-组件"><a class="header" href="#转发-refs-到-dom-组件">转发 refs 到 DOM 组件</a></h2>
<p>考虑这个渲染原生 DOM 元素 <code>button</code> 的 <code>FancyButton</code> 组件：</p>
<pre><code class="language-jsx">function FancyButton(props) {
  return (
    &lt;button className=&quot;FancyButton&quot;&gt;
      {props.children}
    &lt;/button&gt;
  );
}
</code></pre>
<p><strong>Ref 转发是一个可选特性，其允许某些组件接收 <code>ref</code>，并将其向下传递（换句话说，“转发”它）给子组件。</strong></p>
<p>在下面的示例中，<code>FancyButton</code> 使用 <code>React.forwardRef</code> 来获取传递给它的 <code>ref</code>，然后转发到它渲染的 DOM <code>button</code>：</p>
<pre><code class="language-jsx">const FancyButton = React.forwardRef((props, ref) =&gt; (  &lt;button ref={ref} className=&quot;FancyButton&quot;&gt;    {props.children}
  &lt;/button&gt;
));

// 你可以直接获取 DOM button 的 ref：
const ref = React.createRef();
&lt;FancyButton ref={ref}&gt;Click me!&lt;/FancyButton&gt;;
</code></pre>
<p>这样，使用 <code>FancyButton</code> 的组件可以获取底层 DOM 节点 <code>button</code> 的 ref ，并在必要时访问，就像其直接使用 DOM <code>button</code> 一样。</p>
<ol>
<li>我们通过调用 <code>React.createRef</code> 创建了一个 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">React ref</a> 并将其赋值给 <code>ref</code> 变量。</li>
<li>我们通过指定 <code>ref</code> 为 JSX 属性，将其向下传递给 <code>&lt;FancyButton ref={ref}&gt;</code>。</li>
<li>React 传递 <code>ref</code> 给 <code>forwardRef</code> 内函数 <code>(props, ref) =&gt; ...</code>，作为其第二个参数。</li>
<li>我们向下转发该 <code>ref</code> 参数到 <code>&lt;button ref={ref}&gt;</code>，将其指定为 JSX 属性。</li>
<li>当 ref 挂载完成，<code>ref.current</code> 将指向 <code>&lt;button&gt;</code> DOM 节点。</li>
</ol>
<blockquote>
<p>注意</p>
<p>第二个参数 <code>ref</code> 只在使用 <code>React.forwardRef</code> 定义组件时存在。常规函数和 class 组件不接收 <code>ref</code> 参数，且 props 中也不存在 <code>ref</code>。</p>
<p>Ref 转发不仅限于 DOM 组件，你也可以转发 refs 到 class 组件实例中。</p>
</blockquote>
<h2 id="组件库维护者的注意事项"><a class="header" href="#组件库维护者的注意事项">组件库维护者的注意事项</a></h2>
<p><strong>当你开始在组件库中使用 <code>forwardRef</code> 时，你应当将其视为一个破坏性更改，并发布库的一个新的主版本。</strong> 这是因为你的库可能会有明显不同的行为（例如 refs 被分配给了谁，以及导出了什么类型），并且这样可能会导致依赖旧行为的应用和其他库崩溃。</p>
<p>出于同样的原因，当 <code>React.forwardRef</code> 存在时有条件地使用它也是不推荐的：它改变了你的库的行为，并在升级 React 自身时破坏用户的应用。</p>
<h2 id="在高阶组件中转发-refs"><a class="header" href="#在高阶组件中转发-refs">在高阶组件中转发 refs</a></h2>
<p>这个技巧对<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html">高阶组件</a>（也被称为 HOC）特别有用。让我们从一个输出组件 props 到控制台的 HOC 示例开始：</p>
<p>“logProps” HOC 透传（pass through）所有 <code>props</code> 到其包裹的组件，所以渲染结果将是相同的。例如：我们可以使用该 HOC 记录所有传递到 “fancy button” 组件的 props：</p>
<pre><code class="language-jsx">function logProps(WrappedComponent) {  class LogProps extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('old props:', prevProps);
      console.log('new props:', this.props);
    }

    render() {
      return &lt;WrappedComponent {...this.props} /&gt;;    }
  }

  return LogProps;
}
</code></pre>
<pre><code class="language-jsx">class FancyButton extends React.Component {
  focus() {
    // ...
  }

  // ...
}

// 我们导出 LogProps，而不是 FancyButton。
// 虽然它也会渲染一个 FancyButton。
export default logProps(FancyButton);
</code></pre>
<p>下面的示例有一点需要注意：<strong>refs 将不会透传下去</strong>。<strong>这是因为 <code>ref</code> 不是 prop 属性</strong>。就像 <code>key</code> 一样，其被 React 进行了特殊处理。<strong>如果你对 HOC 添加 ref，该 ref 将引用最外层的容器组件，而不是被包裹的组件</strong>。</p>
<p>这意味着用于我们 <code>FancyButton</code> 组件的 refs 实际上将被挂载到 <code>LogProps</code> 组件：</p>
<pre><code class="language-jsx">import FancyButton from './FancyButton';

const ref = React.createRef();
// 我们导入的 FancyButton 组件是高阶组件（HOC）LogProps。
// 尽管渲染结果将是一样的，
// 但我们的 ref 将指向 LogProps 而不是内部的 FancyButton 组件！
// 这意味着我们不能调用例如 ref.current.focus() 这样的方法
&lt;FancyButton
  label=&quot;Click Me&quot;
  handleClick={handleClick}
  ref={ref}/&gt;;
</code></pre>
<p>幸运的是，我们可以使用 <code>React.forwardRef</code> API 明确地将 refs 转发到内部的 <code>FancyButton</code> 组件。<code>React.forwardRef</code> 接受一个渲染函数，其接收 <code>props</code> 和 <code>ref</code> 参数并返回一个 React 节点。例如：</p>
<pre><code class="language-jsx">function logProps(Component) {
  class LogProps extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('old props:', prevProps);
      console.log('new props:', this.props);
    }

    render() {
      const {forwardedRef, ...rest} = this.props;
      // 将自定义的 prop 属性 “forwardedRef” 定义为 ref
      return &lt;Component ref={forwardedRef} {...rest} /&gt;;    }
  }

  // 注意 React.forwardRef 回调的第二个参数 “ref”。
  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”
  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。
  return React.forwardRef((props, ref) =&gt; {    return &lt;LogProps {...props} forwardedRef={ref} /&gt;;  });}
</code></pre>
<h2 id="在-devtools-中显示自定义名称"><a class="header" href="#在-devtools-中显示自定义名称">在 DevTools 中显示自定义名称</a></h2>
<p><code>React.forwardRef</code> 接受一个渲染函数。React DevTools 使用该函数来决定为 ref 转发组件显示的内容。</p>
<p>例如，以下组件将在 DevTools 中显示为 “<em>ForwardRef</em>”：</p>
<pre><code class="language-jsx">const WrappedComponent = React.forwardRef((props, ref) =&gt; {
  return &lt;LogProps {...props} forwardedRef={ref} /&gt;;
});
</code></pre>
<p>如果你命名了渲染函数，DevTools 也将包含其名称（例如 “<em>ForwardRef(myFunction)</em>”）：</p>
<pre><code class="language-jsx">const WrappedComponent = React.forwardRef(
  function myFunction(props, ref) {
    return &lt;LogProps {...props} forwardedRef={ref} /&gt;;
  }
);
</code></pre>
<p>你甚至可以设置函数的 <code>displayName</code> 属性来包含被包裹组件的名称：.</p>
<pre><code class="language-jsx">function logProps(Component) {
  class LogProps extends React.Component {
    // ...
  }

  function forwardRef(props, ref) {
    return &lt;LogProps {...props} forwardedRef={ref} /&gt;;
  }

  // 在 DevTools 中为该组件提供一个更有用的显示名。
  // 例如 “ForwardRef(logProps(MyComponent))”
  const name = Component.displayName || Component.name;  forwardRef.displayName = `logProps(${name})`;
  return React.forwardRef(forwardRef);
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
